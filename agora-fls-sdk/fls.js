/**
 * RteLivePlayer-v0.0.8-1(2025/3/28 15:40:54) Copyright AgoraInc.
 */

!(function(e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], t)
    : t(
        ((e =
          "undefined" != typeof globalThis ? globalThis : e || self).FLS = {})
      );
})(this, function(e) {
  "use strict";
  function t(e, t) {
    return (
      t.forEach(function(t) {
        t &&
          "string" != typeof t &&
          !Array.isArray(t) &&
          Object.keys(t).forEach(function(i) {
            if ("default" !== i && !(i in e)) {
              var s = Object.getOwnPropertyDescriptor(t, i);
              Object.defineProperty(
                e,
                i,
                s.get
                  ? s
                  : {
                      enumerable: !0,
                      get: function() {
                        return t[i];
                      }
                    }
              );
            }
          });
      }),
      Object.freeze(e)
    );
  }
  var i =
    "undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {};
  function s(e) {
    return e &&
      e.__esModule &&
      Object.prototype.hasOwnProperty.call(e, "default")
      ? e.default
      : e;
  }
  var r = function(e) {
      try {
        return !!e();
      } catch (e) {
        return !0;
      }
    },
    n = !r(function() {
      var e = function() {}.bind();
      return "function" != typeof e || e.hasOwnProperty("prototype");
    }),
    a = n,
    o = Function.prototype,
    c = o.call,
    d = a && o.bind.bind(c, c),
    l = a
      ? d
      : function(e) {
          return function() {
            return c.apply(e, arguments);
          };
        },
    h = l({}.isPrototypeOf),
    u = function(e) {
      return e && e.Math === Math && e;
    },
    p =
      u("object" == typeof globalThis && globalThis) ||
      u("object" == typeof window && window) ||
      u("object" == typeof self && self) ||
      u("object" == typeof i && i) ||
      u("object" == typeof i && i) ||
      (function() {
        return this;
      })() ||
      Function("return this")(),
    f = n,
    E = Function.prototype,
    m = E.apply,
    g = E.call,
    _ =
      ("object" == typeof Reflect && Reflect.apply) ||
      (f
        ? g.bind(m)
        : function() {
            return g.apply(m, arguments);
          }),
    T = l,
    S = T({}.toString),
    v = T("".slice),
    R = function(e) {
      return v(S(e), 8, -1);
    },
    y = R,
    A = l,
    I = function(e) {
      if ("Function" === y(e)) return A(e);
    },
    C = "object" == typeof document && document.all,
    b =
      void 0 === C && void 0 !== C
        ? function(e) {
            return "function" == typeof e || e === C;
          }
        : function(e) {
            return "function" == typeof e;
          },
    O = {},
    D = !r(function() {
      return (
        7 !==
        Object.defineProperty({}, 1, {
          get: function() {
            return 7;
          }
        })[1]
      );
    }),
    w = n,
    L = Function.prototype.call,
    N = w
      ? L.bind(L)
      : function() {
          return L.apply(L, arguments);
        },
    P = {},
    k = {}.propertyIsEnumerable,
    M = Object.getOwnPropertyDescriptor,
    U = M && !k.call({ 1: 2 }, 1);
  P.f = U
    ? function(e) {
        var t = M(this, e);
        return !!t && t.enumerable;
      }
    : k;
  var x,
    F,
    B = function(e, t) {
      return {
        enumerable: !(1 & e),
        configurable: !(2 & e),
        writable: !(4 & e),
        value: t
      };
    },
    V = r,
    G = R,
    j = Object,
    H = l("".split),
    K = V(function() {
      return !j("z").propertyIsEnumerable(0);
    })
      ? function(e) {
          return "String" === G(e) ? H(e, "") : j(e);
        }
      : j,
    W = function(e) {
      return null == e;
    },
    Y = W,
    $ = TypeError,
    q = function(e) {
      if (Y(e)) throw new $("Can't call method on " + e);
      return e;
    },
    X = K,
    z = q,
    J = function(e) {
      return X(z(e));
    },
    Q = b,
    Z = function(e) {
      return "object" == typeof e ? null !== e : Q(e);
    },
    ee = {},
    te = ee,
    ie = p,
    se = b,
    re = function(e) {
      return se(e) ? e : void 0;
    },
    ne = function(e, t) {
      return arguments.length < 2
        ? re(te[e]) || re(ie[e])
        : (te[e] && te[e][t]) || (ie[e] && ie[e][t]);
    },
    ae = p.navigator,
    oe = ae && ae.userAgent,
    ce = oe ? String(oe) : "",
    de = p,
    le = ce,
    he = de.process,
    ue = de.Deno,
    pe = (he && he.versions) || (ue && ue.version),
    fe = pe && pe.v8;
  fe && (F = (x = fe.split("."))[0] > 0 && x[0] < 4 ? 1 : +(x[0] + x[1])),
    !F &&
      le &&
      (!(x = le.match(/Edge\/(\d+)/)) || x[1] >= 74) &&
      (x = le.match(/Chrome\/(\d+)/)) &&
      (F = +x[1]);
  var Ee = F,
    me = Ee,
    ge = r,
    _e = p.String,
    Te =
      !!Object.getOwnPropertySymbols &&
      !ge(function() {
        var e = Symbol("symbol detection");
        return (
          !_e(e) ||
          !(Object(e) instanceof Symbol) ||
          (!Symbol.sham && me && me < 41)
        );
      }),
    Se = Te && !Symbol.sham && "symbol" == typeof Symbol.iterator,
    ve = ne,
    Re = b,
    ye = h,
    Ae = Object,
    Ie = Se
      ? function(e) {
          return "symbol" == typeof e;
        }
      : function(e) {
          var t = ve("Symbol");
          return Re(t) && ye(t.prototype, Ae(e));
        },
    Ce = String,
    be = function(e) {
      try {
        return Ce(e);
      } catch (e) {
        return "Object";
      }
    },
    Oe = b,
    De = be,
    we = TypeError,
    Le = function(e) {
      if (Oe(e)) return e;
      throw new we(De(e) + " is not a function");
    },
    Ne = Le,
    Pe = W,
    ke = function(e, t) {
      var i = e[t];
      return Pe(i) ? void 0 : Ne(i);
    },
    Me = N,
    Ue = b,
    xe = Z,
    Fe = TypeError,
    Be = { exports: {} },
    Ve = p,
    Ge = Object.defineProperty,
    je = p,
    He = function(e, t) {
      try {
        Ge(Ve, e, { value: t, configurable: !0, writable: !0 });
      } catch (i) {
        Ve[e] = t;
      }
      return t;
    },
    Ke = "__core-js_shared__",
    We = (Be.exports = je[Ke] || He(Ke, {}));
  (We.versions || (We.versions = [])).push({
    version: "3.41.0",
    mode: "pure",
    copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  var Ye = Be.exports,
    $e = Ye,
    qe = function(e, t) {
      return $e[e] || ($e[e] = t || {});
    },
    Xe = q,
    ze = Object,
    Je = function(e) {
      return ze(Xe(e));
    },
    Qe = Je,
    Ze = l({}.hasOwnProperty),
    et =
      Object.hasOwn ||
      function(e, t) {
        return Ze(Qe(e), t);
      },
    tt = l,
    it = 0,
    st = Math.random(),
    rt = tt((1).toString),
    nt = function(e) {
      return "Symbol(" + (void 0 === e ? "" : e) + ")_" + rt(++it + st, 36);
    },
    at = qe,
    ot = et,
    ct = nt,
    dt = Te,
    lt = Se,
    ht = p.Symbol,
    ut = at("wks"),
    pt = lt ? ht.for || ht : (ht && ht.withoutSetter) || ct,
    ft = function(e) {
      return (
        ot(ut, e) || (ut[e] = dt && ot(ht, e) ? ht[e] : pt("Symbol." + e)),
        ut[e]
      );
    },
    Et = N,
    mt = Z,
    gt = Ie,
    _t = ke,
    Tt = function(e, t) {
      var i, s;
      if ("string" === t && Ue((i = e.toString)) && !xe((s = Me(i, e))))
        return s;
      if (Ue((i = e.valueOf)) && !xe((s = Me(i, e)))) return s;
      if ("string" !== t && Ue((i = e.toString)) && !xe((s = Me(i, e))))
        return s;
      throw new Fe("Can't convert object to primitive value");
    },
    St = TypeError,
    vt = ft("toPrimitive"),
    Rt = function(e, t) {
      if (!mt(e) || gt(e)) return e;
      var i,
        s = _t(e, vt);
      if (s) {
        if (
          (void 0 === t && (t = "default"), (i = Et(s, e, t)), !mt(i) || gt(i))
        )
          return i;
        throw new St("Can't convert object to primitive value");
      }
      return void 0 === t && (t = "number"), Tt(e, t);
    },
    yt = Ie,
    At = function(e) {
      var t = Rt(e, "string");
      return yt(t) ? t : t + "";
    },
    It = Z,
    Ct = p.document,
    bt = It(Ct) && It(Ct.createElement),
    Ot = function(e) {
      return bt ? Ct.createElement(e) : {};
    },
    Dt = Ot,
    wt =
      !D &&
      !r(function() {
        return (
          7 !==
          Object.defineProperty(Dt("div"), "a", {
            get: function() {
              return 7;
            }
          }).a
        );
      }),
    Lt = D,
    Nt = N,
    Pt = P,
    kt = B,
    Mt = J,
    Ut = At,
    xt = et,
    Ft = wt,
    Bt = Object.getOwnPropertyDescriptor;
  O.f = Lt
    ? Bt
    : function(e, t) {
        if (((e = Mt(e)), (t = Ut(t)), Ft))
          try {
            return Bt(e, t);
          } catch (e) {}
        if (xt(e, t)) return kt(!Nt(Pt.f, e, t), e[t]);
      };
  var Vt = r,
    Gt = b,
    jt = /#|\.prototype\./,
    Ht = function(e, t) {
      var i = Wt[Kt(e)];
      return i === $t || (i !== Yt && (Gt(t) ? Vt(t) : !!t));
    },
    Kt = (Ht.normalize = function(e) {
      return String(e)
        .replace(jt, ".")
        .toLowerCase();
    }),
    Wt = (Ht.data = {}),
    Yt = (Ht.NATIVE = "N"),
    $t = (Ht.POLYFILL = "P"),
    qt = Ht,
    Xt = Le,
    zt = n,
    Jt = I(I.bind),
    Qt = function(e, t) {
      return (
        Xt(e),
        void 0 === t
          ? e
          : zt
          ? Jt(e, t)
          : function() {
              return e.apply(t, arguments);
            }
      );
    },
    Zt = {},
    ei =
      D &&
      r(function() {
        return (
          42 !==
          Object.defineProperty(function() {}, "prototype", {
            value: 42,
            writable: !1
          }).prototype
        );
      }),
    ti = Z,
    ii = String,
    si = TypeError,
    ri = function(e) {
      if (ti(e)) return e;
      throw new si(ii(e) + " is not an object");
    },
    ni = D,
    ai = wt,
    oi = ei,
    ci = ri,
    di = At,
    li = TypeError,
    hi = Object.defineProperty,
    ui = Object.getOwnPropertyDescriptor,
    pi = "enumerable",
    fi = "configurable",
    Ei = "writable";
  Zt.f = ni
    ? oi
      ? function(e, t, i) {
          if (
            (ci(e),
            (t = di(t)),
            ci(i),
            "function" == typeof e &&
              "prototype" === t &&
              "value" in i &&
              Ei in i &&
              !i[Ei])
          ) {
            var s = ui(e, t);
            s &&
              s[Ei] &&
              ((e[t] = i.value),
              (i = {
                configurable: fi in i ? i[fi] : s[fi],
                enumerable: pi in i ? i[pi] : s[pi],
                writable: !1
              }));
          }
          return hi(e, t, i);
        }
      : hi
    : function(e, t, i) {
        if ((ci(e), (t = di(t)), ci(i), ai))
          try {
            return hi(e, t, i);
          } catch (e) {}
        if ("get" in i || "set" in i) throw new li("Accessors not supported");
        return "value" in i && (e[t] = i.value), e;
      };
  var mi = Zt,
    gi = B,
    _i = D
      ? function(e, t, i) {
          return mi.f(e, t, gi(1, i));
        }
      : function(e, t, i) {
          return (e[t] = i), e;
        },
    Ti = p,
    Si = _,
    vi = I,
    Ri = b,
    yi = O.f,
    Ai = qt,
    Ii = ee,
    Ci = Qt,
    bi = _i,
    Oi = et,
    Di = function(e) {
      var t = function(i, s, r) {
        if (this instanceof t) {
          switch (arguments.length) {
            case 0:
              return new e();
            case 1:
              return new e(i);
            case 2:
              return new e(i, s);
          }
          return new e(i, s, r);
        }
        return Si(e, this, arguments);
      };
      return (t.prototype = e.prototype), t;
    },
    wi = function(e, t) {
      var i,
        s,
        r,
        n,
        a,
        o,
        c,
        d,
        l,
        h = e.target,
        u = e.global,
        p = e.stat,
        f = e.proto,
        E = u ? Ti : p ? Ti[h] : Ti[h] && Ti[h].prototype,
        m = u ? Ii : Ii[h] || bi(Ii, h, {})[h],
        g = m.prototype;
      for (n in t)
        (s =
          !(i = Ai(u ? n : h + (p ? "." : "#") + n, e.forced)) &&
          E &&
          Oi(E, n)),
          (o = m[n]),
          s && (c = e.dontCallGetSet ? (l = yi(E, n)) && l.value : E[n]),
          (a = s && c ? c : t[n]),
          (i || f || typeof o != typeof a) &&
            ((d =
              e.bind && s
                ? Ci(a, Ti)
                : e.wrap && s
                ? Di(a)
                : f && Ri(a)
                ? vi(a)
                : a),
            (e.sham || (a && a.sham) || (o && o.sham)) && bi(d, "sham", !0),
            bi(m, n, d),
            f &&
              (Oi(Ii, (r = h + "Prototype")) || bi(Ii, r, {}),
              bi(Ii[r], n, a),
              e.real && g && (i || !g[n]) && bi(g, n, a)));
    },
    Li = {};
  Li[ft("toStringTag")] = "z";
  var Ni = "[object z]" === String(Li),
    Pi = Ni,
    ki = b,
    Mi = R,
    Ui = ft("toStringTag"),
    xi = Object,
    Fi =
      "Arguments" ===
      Mi(
        (function() {
          return arguments;
        })()
      ),
    Bi = Pi
      ? Mi
      : function(e) {
          var t, i, s;
          return void 0 === e
            ? "Undefined"
            : null === e
            ? "Null"
            : "string" ==
              typeof (i = (function(e, t) {
                try {
                  return e[t];
                } catch (e) {}
              })((t = xi(e)), Ui))
            ? i
            : Fi
            ? Mi(t)
            : "Object" === (s = Mi(t)) && ki(t.callee)
            ? "Arguments"
            : s;
        },
    Vi = Bi,
    Gi = String,
    ji = function(e) {
      if ("Symbol" === Vi(e))
        throw new TypeError("Cannot convert a Symbol value to a string");
      return Gi(e);
    },
    Hi = "\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff",
    Ki = q,
    Wi = ji,
    Yi = Hi,
    $i = l("".replace),
    qi = RegExp("^[" + Yi + "]+"),
    Xi = RegExp("(^|[^" + Yi + "])[" + Yi + "]+$"),
    zi = function(e) {
      return function(t) {
        var i = Wi(Ki(t));
        return 1 & e && (i = $i(i, qi, "")), 2 & e && (i = $i(i, Xi, "$1")), i;
      };
    },
    Ji = { start: zi(1), end: zi(2), trim: zi(3) },
    Qi = D,
    Zi = et,
    es = Function.prototype,
    ts = Qi && Object.getOwnPropertyDescriptor,
    is = Zi(es, "name"),
    ss = {
      EXISTS: is,
      PROPER: is && "something" === function() {}.name,
      CONFIGURABLE: is && (!Qi || (Qi && ts(es, "name").configurable))
    },
    rs = ss.PROPER,
    ns = r,
    as = Hi,
    os = Ji.trim;
  wi(
    {
      target: "String",
      proto: !0,
      forced: (function(e) {
        return ns(function() {
          return !!as[e]() || "âÂá " !== "âÂá "[e]() || (rs && as[e].name !== e);
        });
      })("trim")
    },
    {
      trim: function() {
        return os(this);
      }
    }
  );
  var cs = p,
    ds = ee,
    ls = function(e, t) {
      var i = ds[e + "Prototype"],
        s = i && i[t];
      if (s) return s;
      var r = cs[e],
        n = r && r.prototype;
      return n && n[t];
    },
    hs = ls("String", "trim"),
    us = h,
    ps = hs,
    fs = String.prototype,
    Es = function(e) {
      var t = e.trim;
      return "string" == typeof e || e === fs || (us(fs, e) && t === fs.trim)
        ? ps
        : t;
    },
    ms = s(Es),
    gs = nt,
    _s = qe("keys"),
    Ts = function(e) {
      return _s[e] || (_s[e] = gs(e));
    },
    Ss = !r(function() {
      function e() {}
      return (
        (e.prototype.constructor = null),
        Object.getPrototypeOf(new e()) !== e.prototype
      );
    }),
    vs = et,
    Rs = b,
    ys = Je,
    As = Ss,
    Is = Ts("IE_PROTO"),
    Cs = Object,
    bs = Cs.prototype,
    Os = As
      ? Cs.getPrototypeOf
      : function(e) {
          var t = ys(e);
          if (vs(t, Is)) return t[Is];
          var i = t.constructor;
          return Rs(i) && t instanceof i
            ? i.prototype
            : t instanceof Cs
            ? bs
            : null;
        },
    Ds = l,
    ws = Le,
    Ls = Z,
    Ns = function(e) {
      return Ls(e) || null === e;
    },
    Ps = String,
    ks = TypeError,
    Ms = function(e, t, i) {
      try {
        return Ds(ws(Object.getOwnPropertyDescriptor(e, t)[i]));
      } catch (e) {}
    },
    Us = Z,
    xs = q,
    Fs = function(e) {
      if (Ns(e)) return e;
      throw new ks("Can't set " + Ps(e) + " as a prototype");
    },
    Bs =
      Object.setPrototypeOf ||
      ("__proto__" in {}
        ? (function() {
            var e,
              t = !1,
              i = {};
            try {
              (e = Ms(Object.prototype, "__proto__", "set"))(i, []),
                (t = i instanceof Array);
            } catch (e) {}
            return function(i, s) {
              return (
                xs(i), Fs(s), Us(i) ? (t ? e(i, s) : (i.__proto__ = s), i) : i
              );
            };
          })()
        : void 0),
    Vs = {},
    Gs = Math.ceil,
    js = Math.floor,
    Hs =
      Math.trunc ||
      function(e) {
        var t = +e;
        return (t > 0 ? js : Gs)(t);
      },
    Ks = Hs,
    Ws = function(e) {
      var t = +e;
      return t != t || 0 === t ? 0 : Ks(t);
    },
    Ys = Ws,
    $s = Math.max,
    qs = Math.min,
    Xs = function(e, t) {
      var i = Ys(e);
      return i < 0 ? $s(i + t, 0) : qs(i, t);
    },
    zs = Ws,
    Js = Math.min,
    Qs = function(e) {
      var t = zs(e);
      return t > 0 ? Js(t, 9007199254740991) : 0;
    },
    Zs = Qs,
    er = function(e) {
      return Zs(e.length);
    },
    tr = J,
    ir = Xs,
    sr = er,
    rr = function(e) {
      return function(t, i, s) {
        var r = tr(t),
          n = sr(r);
        if (0 === n) return !e && -1;
        var a,
          o = ir(s, n);
        if (e && i != i) {
          for (; n > o; ) if ((a = r[o++]) != a) return !0;
        } else
          for (; n > o; o++)
            if ((e || o in r) && r[o] === i) return e || o || 0;
        return !e && -1;
      };
    },
    nr = { includes: rr(!0), indexOf: rr(!1) },
    ar = {},
    or = et,
    cr = J,
    dr = nr.indexOf,
    lr = ar,
    hr = l([].push),
    ur = function(e, t) {
      var i,
        s = cr(e),
        r = 0,
        n = [];
      for (i in s) !or(lr, i) && or(s, i) && hr(n, i);
      for (; t.length > r; ) or(s, (i = t[r++])) && (~dr(n, i) || hr(n, i));
      return n;
    },
    pr = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ],
    fr = ur,
    Er = pr.concat("length", "prototype");
  Vs.f =
    Object.getOwnPropertyNames ||
    function(e) {
      return fr(e, Er);
    };
  var mr = {};
  mr.f = Object.getOwnPropertySymbols;
  var gr = ne,
    _r = Vs,
    Tr = mr,
    Sr = ri,
    vr = l([].concat),
    Rr =
      gr("Reflect", "ownKeys") ||
      function(e) {
        var t = _r.f(Sr(e)),
          i = Tr.f;
        return i ? vr(t, i(e)) : t;
      },
    yr = et,
    Ar = Rr,
    Ir = O,
    Cr = Zt,
    br = {},
    Or = ur,
    Dr = pr,
    wr =
      Object.keys ||
      function(e) {
        return Or(e, Dr);
      },
    Lr = D,
    Nr = ei,
    Pr = Zt,
    kr = ri,
    Mr = J,
    Ur = wr;
  br.f =
    Lr && !Nr
      ? Object.defineProperties
      : function(e, t) {
          kr(e);
          for (var i, s = Mr(t), r = Ur(t), n = r.length, a = 0; n > a; )
            Pr.f(e, (i = r[a++]), s[i]);
          return e;
        };
  var xr,
    Fr = ne("document", "documentElement"),
    Br = ri,
    Vr = br,
    Gr = pr,
    jr = ar,
    Hr = Fr,
    Kr = Ot,
    Wr = "prototype",
    Yr = "script",
    $r = Ts("IE_PROTO"),
    qr = function() {},
    Xr = function(e) {
      return "<" + Yr + ">" + e + "</" + Yr + ">";
    },
    zr = function(e) {
      e.write(Xr("")), e.close();
      var t = e.parentWindow.Object;
      return (e = null), t;
    },
    Jr = function() {
      try {
        xr = new ActiveXObject("htmlfile");
      } catch (e) {}
      var e, t, i;
      Jr =
        "undefined" != typeof document
          ? document.domain && xr
            ? zr(xr)
            : ((t = Kr("iframe")),
              (i = "java" + Yr + ":"),
              (t.style.display = "none"),
              Hr.appendChild(t),
              (t.src = String(i)),
              (e = t.contentWindow.document).open(),
              e.write(Xr("document.F=Object")),
              e.close(),
              e.F)
          : zr(xr);
      for (var s = Gr.length; s--; ) delete Jr[Wr][Gr[s]];
      return Jr();
    };
  jr[$r] = !0;
  var Qr =
      Object.create ||
      function(e, t) {
        var i;
        return (
          null !== e
            ? ((qr[Wr] = Br(e)), (i = new qr()), (qr[Wr] = null), (i[$r] = e))
            : (i = Jr()),
          void 0 === t ? i : Vr.f(i, t)
        );
      },
    Zr = Z,
    en = _i,
    tn = Error,
    sn = l("".replace),
    rn = String(new tn("zxcasd").stack),
    nn = /\n\s*at [^:]*:[^\n]*/,
    an = nn.test(rn),
    on = B,
    cn = !r(function() {
      var e = new Error("a");
      return (
        !("stack" in e) ||
        (Object.defineProperty(e, "stack", on(1, 7)), 7 !== e.stack)
      );
    }),
    dn = _i,
    ln = function(e, t) {
      if (an && "string" == typeof e && !tn.prepareStackTrace)
        for (; t--; ) e = sn(e, nn, "");
      return e;
    },
    hn = cn,
    un = Error.captureStackTrace,
    pn = {},
    fn = pn,
    En = ft("iterator"),
    mn = Array.prototype,
    gn = function(e) {
      return void 0 !== e && (fn.Array === e || mn[En] === e);
    },
    _n = Bi,
    Tn = ke,
    Sn = W,
    vn = pn,
    Rn = ft("iterator"),
    yn = function(e) {
      if (!Sn(e)) return Tn(e, Rn) || Tn(e, "@@iterator") || vn[_n(e)];
    },
    An = N,
    In = Le,
    Cn = ri,
    bn = be,
    On = yn,
    Dn = TypeError,
    wn = function(e, t) {
      var i = arguments.length < 2 ? On(e) : t;
      if (In(i)) return Cn(An(i, e));
      throw new Dn(bn(e) + " is not iterable");
    },
    Ln = N,
    Nn = ri,
    Pn = ke,
    kn = function(e, t, i) {
      var s, r;
      Nn(e);
      try {
        if (!(s = Pn(e, "return"))) {
          if ("throw" === t) throw i;
          return i;
        }
        s = Ln(s, e);
      } catch (e) {
        (r = !0), (s = e);
      }
      if ("throw" === t) throw i;
      if (r) throw s;
      return Nn(s), i;
    },
    Mn = Qt,
    Un = N,
    xn = ri,
    Fn = be,
    Bn = gn,
    Vn = er,
    Gn = h,
    jn = wn,
    Hn = yn,
    Kn = kn,
    Wn = TypeError,
    Yn = function(e, t) {
      (this.stopped = e), (this.result = t);
    },
    $n = Yn.prototype,
    qn = function(e, t, i) {
      var s,
        r,
        n,
        a,
        o,
        c,
        d,
        l = i && i.that,
        h = !(!i || !i.AS_ENTRIES),
        u = !(!i || !i.IS_RECORD),
        p = !(!i || !i.IS_ITERATOR),
        f = !(!i || !i.INTERRUPTED),
        E = Mn(t, l),
        m = function(e) {
          return s && Kn(s, "normal", e), new Yn(!0, e);
        },
        g = function(e) {
          return h
            ? (xn(e), f ? E(e[0], e[1], m) : E(e[0], e[1]))
            : f
            ? E(e, m)
            : E(e);
        };
      if (u) s = e.iterator;
      else if (p) s = e;
      else {
        if (!(r = Hn(e))) throw new Wn(Fn(e) + " is not iterable");
        if (Bn(r)) {
          for (n = 0, a = Vn(e); a > n; n++)
            if ((o = g(e[n])) && Gn($n, o)) return o;
          return new Yn(!1);
        }
        s = jn(e, r);
      }
      for (c = u ? e.next : s.next; !(d = Un(c, s)).done; ) {
        try {
          o = g(d.value);
        } catch (e) {
          Kn(s, "throw", e);
        }
        if ("object" == typeof o && o && Gn($n, o)) return o;
      }
      return new Yn(!1);
    },
    Xn = ji,
    zn = wi,
    Jn = h,
    Qn = Os,
    Zn = Bs,
    ea = function(e, t, i) {
      for (var s = Ar(t), r = Cr.f, n = Ir.f, a = 0; a < s.length; a++) {
        var o = s[a];
        yr(e, o) || (i && yr(i, o)) || r(e, o, n(t, o));
      }
    },
    ta = Qr,
    ia = _i,
    sa = B,
    ra = function(e, t) {
      Zr(t) && "cause" in t && en(e, "cause", t.cause);
    },
    na = function(e, t, i, s) {
      hn && (un ? un(e, t) : dn(e, "stack", ln(i, s)));
    },
    aa = qn,
    oa = function(e, t) {
      return void 0 === e ? (arguments.length < 2 ? "" : t) : Xn(e);
    },
    ca = ft("toStringTag"),
    da = Error,
    la = [].push,
    ha = function(e, t) {
      var i,
        s = Jn(ua, this);
      Zn
        ? (i = Zn(new da(), s ? Qn(this) : ua))
        : ((i = s ? this : ta(ua)), ia(i, ca, "Error")),
        void 0 !== t && ia(i, "message", oa(t)),
        na(i, ha, i.stack, 1),
        arguments.length > 2 && ra(i, arguments[2]);
      var r = [];
      return aa(e, la, { that: r }), ia(i, "errors", r), i;
    };
  Zn ? Zn(ha, da) : ea(ha, da, { name: !0 });
  var ua = (ha.prototype = ta(da.prototype, {
    constructor: sa(1, ha),
    message: sa(1, ""),
    name: sa(1, "AggregateError")
  }));
  zn({ global: !0, constructor: !0, arity: 2 }, { AggregateError: ha });
  var pa,
    fa,
    Ea,
    ma = b,
    ga = p.WeakMap,
    _a = ma(ga) && /native code/.test(String(ga)),
    Ta = p,
    Sa = Z,
    va = _i,
    Ra = et,
    ya = Ye,
    Aa = Ts,
    Ia = ar,
    Ca = "Object already initialized",
    ba = Ta.TypeError,
    Oa = Ta.WeakMap;
  if (_a || ya.state) {
    var Da = ya.state || (ya.state = new Oa());
    (Da.get = Da.get),
      (Da.has = Da.has),
      (Da.set = Da.set),
      (pa = function(e, t) {
        if (Da.has(e)) throw new ba(Ca);
        return (t.facade = e), Da.set(e, t), t;
      }),
      (fa = function(e) {
        return Da.get(e) || {};
      }),
      (Ea = function(e) {
        return Da.has(e);
      });
  } else {
    var wa = Aa("state");
    (Ia[wa] = !0),
      (pa = function(e, t) {
        if (Ra(e, wa)) throw new ba(Ca);
        return (t.facade = e), va(e, wa, t), t;
      }),
      (fa = function(e) {
        return Ra(e, wa) ? e[wa] : {};
      }),
      (Ea = function(e) {
        return Ra(e, wa);
      });
  }
  var La,
    Na,
    Pa,
    ka = {
      set: pa,
      get: fa,
      has: Ea,
      enforce: function(e) {
        return Ea(e) ? fa(e) : pa(e, {});
      },
      getterFor: function(e) {
        return function(t) {
          var i;
          if (!Sa(t) || (i = fa(t)).type !== e)
            throw new ba("Incompatible receiver, " + e + " required");
          return i;
        };
      }
    },
    Ma = _i,
    Ua = function(e, t, i, s) {
      return s && s.enumerable ? (e[t] = i) : Ma(e, t, i), e;
    },
    xa = r,
    Fa = b,
    Ba = Z,
    Va = Qr,
    Ga = Os,
    ja = Ua,
    Ha = ft("iterator"),
    Ka = !1;
  [].keys &&
    ("next" in (Pa = [].keys())
      ? (Na = Ga(Ga(Pa))) !== Object.prototype && (La = Na)
      : (Ka = !0));
  var Wa =
    !Ba(La) ||
    xa(function() {
      var e = {};
      return La[Ha].call(e) !== e;
    });
  Fa((La = Wa ? {} : Va(La))[Ha]) ||
    ja(La, Ha, function() {
      return this;
    });
  var Ya = { IteratorPrototype: La, BUGGY_SAFARI_ITERATORS: Ka },
    $a = Bi,
    qa = Ni
      ? {}.toString
      : function() {
          return "[object " + $a(this) + "]";
        },
    Xa = Ni,
    za = Zt.f,
    Ja = _i,
    Qa = et,
    Za = qa,
    eo = ft("toStringTag"),
    to = function(e, t, i, s) {
      var r = i ? e : e && e.prototype;
      r &&
        (Qa(r, eo) || za(r, eo, { configurable: !0, value: t }),
        s && !Xa && Ja(r, "toString", Za));
    },
    io = Ya.IteratorPrototype,
    so = Qr,
    ro = B,
    no = to,
    ao = pn,
    oo = function() {
      return this;
    },
    co = function(e, t, i, s) {
      var r = t + " Iterator";
      return (
        (e.prototype = so(io, { next: ro(+!s, i) })),
        no(e, r, !1, !0),
        (ao[r] = oo),
        e
      );
    },
    lo = wi,
    ho = N,
    uo = ss,
    po = co,
    fo = Os,
    Eo = to,
    mo = Ua,
    go = pn,
    _o = Ya,
    To = uo.PROPER,
    So = _o.BUGGY_SAFARI_ITERATORS,
    vo = ft("iterator"),
    Ro = "keys",
    yo = "values",
    Ao = "entries",
    Io = function() {
      return this;
    },
    Co = function(e, t, i, s, r, n, a) {
      po(i, t, s);
      var o,
        c,
        d,
        l = function(e) {
          if (e === r && E) return E;
          if (!So && e && e in p) return p[e];
          switch (e) {
            case Ro:
            case yo:
            case Ao:
              return function() {
                return new i(this, e);
              };
          }
          return function() {
            return new i(this);
          };
        },
        h = t + " Iterator",
        u = !1,
        p = e.prototype,
        f = p[vo] || p["@@iterator"] || (r && p[r]),
        E = (!So && f) || l(r),
        m = ("Array" === t && p.entries) || f;
      if (
        (m &&
          (o = fo(m.call(new e()))) !== Object.prototype &&
          o.next &&
          (Eo(o, h, !0, !0), (go[h] = Io)),
        To &&
          r === yo &&
          f &&
          f.name !== yo &&
          ((u = !0),
          (E = function() {
            return ho(f, this);
          })),
        r)
      )
        if (((c = { values: l(yo), keys: n ? E : l(Ro), entries: l(Ao) }), a))
          for (d in c) (So || u || !(d in p)) && mo(p, d, c[d]);
        else lo({ target: t, proto: !0, forced: So || u }, c);
      return a && p[vo] !== E && mo(p, vo, E, { name: r }), (go[t] = E), c;
    },
    bo = function(e, t) {
      return { value: e, done: t };
    },
    Oo = J,
    Do = pn,
    wo = ka;
  Zt.f;
  var Lo = Co,
    No = bo,
    Po = "Array Iterator",
    ko = wo.set,
    Mo = wo.getterFor(Po);
  Lo(
    Array,
    "Array",
    function(e, t) {
      ko(this, { type: Po, target: Oo(e), index: 0, kind: t });
    },
    function() {
      var e = Mo(this),
        t = e.target,
        i = e.index++;
      if (!t || i >= t.length) return (e.target = null), No(void 0, !0);
      switch (e.kind) {
        case "keys":
          return No(i, !1);
        case "values":
          return No(t[i], !1);
      }
      return No([i, t[i]], !1);
    },
    "values"
  ),
    (Do.Arguments = Do.Array);
  var Uo = p,
    xo = ce,
    Fo = R,
    Bo = function(e) {
      return xo.slice(0, e.length) === e;
    },
    Vo = Bo("Bun/")
      ? "BUN"
      : Bo("Cloudflare-Workers")
      ? "CLOUDFLARE"
      : Bo("Deno/")
      ? "DENO"
      : Bo("Node.js/")
      ? "NODE"
      : Uo.Bun && "string" == typeof Bun.version
      ? "BUN"
      : Uo.Deno && "object" == typeof Deno.version
      ? "DENO"
      : "process" === Fo(Uo.process)
      ? "NODE"
      : Uo.window && Uo.document
      ? "BROWSER"
      : "REST",
    Go = "NODE" === Vo,
    jo = Zt,
    Ho = function(e, t, i) {
      return jo.f(e, t, i);
    },
    Ko = ne,
    Wo = Ho,
    Yo = D,
    $o = ft("species"),
    qo = h,
    Xo = TypeError,
    zo = function(e, t) {
      if (qo(t, e)) return e;
      throw new Xo("Incorrect invocation");
    },
    Jo = b,
    Qo = Ye,
    Zo = l(Function.toString);
  Jo(Qo.inspectSource) ||
    (Qo.inspectSource = function(e) {
      return Zo(e);
    });
  var ec = Qo.inspectSource,
    tc = l,
    ic = r,
    sc = b,
    rc = Bi,
    nc = ec,
    ac = function() {},
    oc = ne("Reflect", "construct"),
    cc = /^\s*(?:class|function)\b/,
    dc = tc(cc.exec),
    lc = !cc.test(ac),
    hc = function(e) {
      if (!sc(e)) return !1;
      try {
        return oc(ac, [], e), !0;
      } catch (e) {
        return !1;
      }
    },
    uc = function(e) {
      if (!sc(e)) return !1;
      switch (rc(e)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return !1;
      }
      try {
        return lc || !!dc(cc, nc(e));
      } catch (e) {
        return !0;
      }
    };
  uc.sham = !0;
  var pc,
    fc,
    Ec,
    mc,
    gc =
      !oc ||
      ic(function() {
        var e;
        return (
          hc(hc.call) ||
          !hc(Object) ||
          !hc(function() {
            e = !0;
          }) ||
          e
        );
      })
        ? uc
        : hc,
    _c = gc,
    Tc = be,
    Sc = TypeError,
    vc = ri,
    Rc = function(e) {
      if (_c(e)) return e;
      throw new Sc(Tc(e) + " is not a constructor");
    },
    yc = W,
    Ac = ft("species"),
    Ic = function(e, t) {
      var i,
        s = vc(e).constructor;
      return void 0 === s || yc((i = vc(s)[Ac])) ? t : Rc(i);
    },
    Cc = l([].slice),
    bc = TypeError,
    Oc = function(e, t) {
      if (e < t) throw new bc("Not enough arguments");
      return e;
    },
    Dc = /(?:ipad|iphone|ipod).*applewebkit/i.test(ce),
    wc = p,
    Lc = _,
    Nc = Qt,
    Pc = b,
    kc = et,
    Mc = r,
    Uc = Fr,
    xc = Cc,
    Fc = Ot,
    Bc = Oc,
    Vc = Dc,
    Gc = Go,
    jc = wc.setImmediate,
    Hc = wc.clearImmediate,
    Kc = wc.process,
    Wc = wc.Dispatch,
    Yc = wc.Function,
    $c = wc.MessageChannel,
    qc = wc.String,
    Xc = 0,
    zc = {},
    Jc = "onreadystatechange";
  Mc(function() {
    pc = wc.location;
  });
  var Qc = function(e) {
      if (kc(zc, e)) {
        var t = zc[e];
        delete zc[e], t();
      }
    },
    Zc = function(e) {
      return function() {
        Qc(e);
      };
    },
    ed = function(e) {
      Qc(e.data);
    },
    td = function(e) {
      wc.postMessage(qc(e), pc.protocol + "//" + pc.host);
    };
  (jc && Hc) ||
    ((jc = function(e) {
      Bc(arguments.length, 1);
      var t = Pc(e) ? e : Yc(e),
        i = xc(arguments, 1);
      return (
        (zc[++Xc] = function() {
          Lc(t, void 0, i);
        }),
        fc(Xc),
        Xc
      );
    }),
    (Hc = function(e) {
      delete zc[e];
    }),
    Gc
      ? (fc = function(e) {
          Kc.nextTick(Zc(e));
        })
      : Wc && Wc.now
      ? (fc = function(e) {
          Wc.now(Zc(e));
        })
      : $c && !Vc
      ? ((mc = (Ec = new $c()).port2),
        (Ec.port1.onmessage = ed),
        (fc = Nc(mc.postMessage, mc)))
      : wc.addEventListener &&
        Pc(wc.postMessage) &&
        !wc.importScripts &&
        pc &&
        "file:" !== pc.protocol &&
        !Mc(td)
      ? ((fc = td), wc.addEventListener("message", ed, !1))
      : (fc =
          Jc in Fc("script")
            ? function(e) {
                Uc.appendChild(Fc("script"))[Jc] = function() {
                  Uc.removeChild(this), Qc(e);
                };
              }
            : function(e) {
                setTimeout(Zc(e), 0);
              }));
  var id = { set: jc, clear: Hc },
    sd = p,
    rd = D,
    nd = Object.getOwnPropertyDescriptor,
    ad = function(e) {
      if (!rd) return sd[e];
      var t = nd(sd, e);
      return t && t.value;
    },
    od = function() {
      (this.head = null), (this.tail = null);
    };
  od.prototype = {
    add: function(e) {
      var t = { item: e, next: null },
        i = this.tail;
      i ? (i.next = t) : (this.head = t), (this.tail = t);
    },
    get: function() {
      var e = this.head;
      if (e) return null === (this.head = e.next) && (this.tail = null), e.item;
    }
  };
  var cd,
    dd,
    ld,
    hd,
    ud,
    pd = od,
    fd = /ipad|iphone|ipod/i.test(ce) && "undefined" != typeof Pebble,
    Ed = /web0s(?!.*chrome)/i.test(ce),
    md = p,
    gd = ad,
    _d = Qt,
    Td = id.set,
    Sd = pd,
    vd = Dc,
    Rd = fd,
    yd = Ed,
    Ad = Go,
    Id = md.MutationObserver || md.WebKitMutationObserver,
    Cd = md.document,
    bd = md.process,
    Od = md.Promise,
    Dd = gd("queueMicrotask");
  if (!Dd) {
    var wd = new Sd(),
      Ld = function() {
        var e, t;
        for (Ad && (e = bd.domain) && e.exit(); (t = wd.get()); )
          try {
            t();
          } catch (e) {
            throw (wd.head && cd(), e);
          }
        e && e.enter();
      };
    vd || Ad || yd || !Id || !Cd
      ? !Rd && Od && Od.resolve
        ? (((hd = Od.resolve(void 0)).constructor = Od),
          (ud = _d(hd.then, hd)),
          (cd = function() {
            ud(Ld);
          }))
        : Ad
        ? (cd = function() {
            bd.nextTick(Ld);
          })
        : ((Td = _d(Td, md)),
          (cd = function() {
            Td(Ld);
          }))
      : ((dd = !0),
        (ld = Cd.createTextNode("")),
        new Id(Ld).observe(ld, { characterData: !0 }),
        (cd = function() {
          ld.data = dd = !dd;
        })),
      (Dd = function(e) {
        wd.head || cd(), wd.add(e);
      });
  }
  var Nd = Dd,
    Pd = function(e) {
      try {
        return { error: !1, value: e() };
      } catch (e) {
        return { error: !0, value: e };
      }
    },
    kd = p.Promise,
    Md = p,
    Ud = kd,
    xd = b,
    Fd = qt,
    Bd = ec,
    Vd = ft,
    Gd = Vo,
    jd = Ee,
    Hd = Ud && Ud.prototype,
    Kd = Vd("species"),
    Wd = !1,
    Yd = xd(Md.PromiseRejectionEvent),
    $d = Fd("Promise", function() {
      var e = Bd(Ud),
        t = e !== String(Ud);
      if (!t && 66 === jd) return !0;
      if (!Hd.catch || !Hd.finally) return !0;
      if (!jd || jd < 51 || !/native code/.test(e)) {
        var i = new Ud(function(e) {
            e(1);
          }),
          s = function(e) {
            e(
              function() {},
              function() {}
            );
          };
        if (
          (((i.constructor = {})[Kd] = s),
          !(Wd = i.then(function() {}) instanceof s))
        )
          return !0;
      }
      return !(t || ("BROWSER" !== Gd && "DENO" !== Gd) || Yd);
    }),
    qd = { CONSTRUCTOR: $d, REJECTION_EVENT: Yd, SUBCLASSING: Wd },
    Xd = {},
    zd = Le,
    Jd = TypeError,
    Qd = function(e) {
      var t, i;
      (this.promise = new e(function(e, s) {
        if (void 0 !== t || void 0 !== i)
          throw new Jd("Bad Promise constructor");
        (t = e), (i = s);
      })),
        (this.resolve = zd(t)),
        (this.reject = zd(i));
    };
  Xd.f = function(e) {
    return new Qd(e);
  };
  var Zd,
    el,
    tl = wi,
    il = Go,
    sl = p,
    rl = N,
    nl = Ua,
    al = to,
    ol = function(e) {
      var t = Ko(e);
      Yo &&
        t &&
        !t[$o] &&
        Wo(t, $o, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
    },
    cl = Le,
    dl = b,
    ll = Z,
    hl = zo,
    ul = Ic,
    pl = id.set,
    fl = Nd,
    El = function(e, t) {
      try {
        1 === arguments.length ? console.error(e) : console.error(e, t);
      } catch (e) {}
    },
    ml = Pd,
    gl = pd,
    _l = ka,
    Tl = kd,
    Sl = qd,
    vl = Xd,
    Rl = "Promise",
    yl = Sl.CONSTRUCTOR,
    Al = Sl.REJECTION_EVENT,
    Il = _l.getterFor(Rl),
    Cl = _l.set,
    bl = Tl && Tl.prototype,
    Ol = Tl,
    Dl = bl,
    wl = sl.TypeError,
    Ll = sl.document,
    Nl = sl.process,
    Pl = vl.f,
    kl = Pl,
    Ml = !!(Ll && Ll.createEvent && sl.dispatchEvent),
    Ul = "unhandledrejection",
    xl = function(e) {
      var t;
      return !(!ll(e) || !dl((t = e.then))) && t;
    },
    Fl = function(e, t) {
      var i,
        s,
        r,
        n = t.value,
        a = 1 === t.state,
        o = a ? e.ok : e.fail,
        c = e.resolve,
        d = e.reject,
        l = e.domain;
      try {
        o
          ? (a || (2 === t.rejection && Hl(t), (t.rejection = 1)),
            !0 === o
              ? (i = n)
              : (l && l.enter(), (i = o(n)), l && (l.exit(), (r = !0))),
            i === e.promise
              ? d(new wl("Promise-chain cycle"))
              : (s = xl(i))
              ? rl(s, i, c, d)
              : c(i))
          : d(n);
      } catch (e) {
        l && !r && l.exit(), d(e);
      }
    },
    Bl = function(e, t) {
      e.notified ||
        ((e.notified = !0),
        fl(function() {
          for (var i, s = e.reactions; (i = s.get()); ) Fl(i, e);
          (e.notified = !1), t && !e.rejection && Gl(e);
        }));
    },
    Vl = function(e, t, i) {
      var s, r;
      Ml
        ? (((s = Ll.createEvent("Event")).promise = t),
          (s.reason = i),
          s.initEvent(e, !1, !0),
          sl.dispatchEvent(s))
        : (s = { promise: t, reason: i }),
        !Al && (r = sl["on" + e])
          ? r(s)
          : e === Ul && El("Unhandled promise rejection", i);
    },
    Gl = function(e) {
      rl(pl, sl, function() {
        var t,
          i = e.facade,
          s = e.value;
        if (
          jl(e) &&
          ((t = ml(function() {
            il ? Nl.emit("unhandledRejection", s, i) : Vl(Ul, i, s);
          })),
          (e.rejection = il || jl(e) ? 2 : 1),
          t.error)
        )
          throw t.value;
      });
    },
    jl = function(e) {
      return 1 !== e.rejection && !e.parent;
    },
    Hl = function(e) {
      rl(pl, sl, function() {
        var t = e.facade;
        il
          ? Nl.emit("rejectionHandled", t)
          : Vl("rejectionhandled", t, e.value);
      });
    },
    Kl = function(e, t, i) {
      return function(s) {
        e(t, s, i);
      };
    },
    Wl = function(e, t, i) {
      e.done ||
        ((e.done = !0), i && (e = i), (e.value = t), (e.state = 2), Bl(e, !0));
    },
    Yl = function(e, t, i) {
      if (!e.done) {
        (e.done = !0), i && (e = i);
        try {
          if (e.facade === t) throw new wl("Promise can't be resolved itself");
          var s = xl(t);
          s
            ? fl(function() {
                var i = { done: !1 };
                try {
                  rl(s, t, Kl(Yl, i, e), Kl(Wl, i, e));
                } catch (t) {
                  Wl(i, t, e);
                }
              })
            : ((e.value = t), (e.state = 1), Bl(e, !1));
        } catch (t) {
          Wl({ done: !1 }, t, e);
        }
      }
    };
  yl &&
    ((Dl = (Ol = function(e) {
      hl(this, Dl), cl(e), rl(Zd, this);
      var t = Il(this);
      try {
        e(Kl(Yl, t), Kl(Wl, t));
      } catch (e) {
        Wl(t, e);
      }
    }).prototype),
    ((Zd = function(e) {
      Cl(this, {
        type: Rl,
        done: !1,
        notified: !1,
        parent: !1,
        reactions: new gl(),
        rejection: !1,
        state: 0,
        value: null
      });
    }).prototype = nl(Dl, "then", function(e, t) {
      var i = Il(this),
        s = Pl(ul(this, Ol));
      return (
        (i.parent = !0),
        (s.ok = !dl(e) || e),
        (s.fail = dl(t) && t),
        (s.domain = il ? Nl.domain : void 0),
        0 === i.state
          ? i.reactions.add(s)
          : fl(function() {
              Fl(s, i);
            }),
        s.promise
      );
    })),
    (el = function() {
      var e = new Zd(),
        t = Il(e);
      (this.promise = e), (this.resolve = Kl(Yl, t)), (this.reject = Kl(Wl, t));
    }),
    (vl.f = Pl = function(e) {
      return e === Ol || undefined === e ? new el(e) : kl(e);
    })),
    tl({ global: !0, constructor: !0, wrap: !0, forced: yl }, { Promise: Ol }),
    al(Ol, Rl, !1, !0),
    ol(Rl);
  var $l = ft("iterator"),
    ql = !1;
  try {
    var Xl = 0,
      zl = {
        next: function() {
          return { done: !!Xl++ };
        },
        return: function() {
          ql = !0;
        }
      };
    (zl[$l] = function() {
      return this;
    }),
      Array.from(zl, function() {
        throw 2;
      });
  } catch (e) {}
  var Jl = kd,
    Ql = function(e, t) {
      try {
        if (!t && !ql) return !1;
      } catch (e) {
        return !1;
      }
      var i = !1;
      try {
        var s = {};
        (s[$l] = function() {
          return {
            next: function() {
              return { done: (i = !0) };
            }
          };
        }),
          e(s);
      } catch (e) {}
      return i;
    },
    Zl =
      qd.CONSTRUCTOR ||
      !Ql(function(e) {
        Jl.all(e).then(void 0, function() {});
      }),
    eh = N,
    th = Le,
    ih = Xd,
    sh = Pd,
    rh = qn;
  wi(
    { target: "Promise", stat: !0, forced: Zl },
    {
      all: function(e) {
        var t = this,
          i = ih.f(t),
          s = i.resolve,
          r = i.reject,
          n = sh(function() {
            var i = th(t.resolve),
              n = [],
              a = 0,
              o = 1;
            rh(e, function(e) {
              var c = a++,
                d = !1;
              o++,
                eh(i, t, e).then(function(e) {
                  d || ((d = !0), (n[c] = e), --o || s(n));
                }, r);
            }),
              --o || s(n);
          });
        return n.error && r(n.value), i.promise;
      }
    }
  );
  var nh = wi,
    ah = qd.CONSTRUCTOR;
  kd && kd.prototype,
    nh(
      { target: "Promise", proto: !0, forced: ah, real: !0 },
      {
        catch: function(e) {
          return this.then(void 0, e);
        }
      }
    );
  var oh = N,
    ch = Le,
    dh = Xd,
    lh = Pd,
    hh = qn;
  wi(
    { target: "Promise", stat: !0, forced: Zl },
    {
      race: function(e) {
        var t = this,
          i = dh.f(t),
          s = i.reject,
          r = lh(function() {
            var r = ch(t.resolve);
            hh(e, function(e) {
              oh(r, t, e).then(i.resolve, s);
            });
          });
        return r.error && s(r.value), i.promise;
      }
    }
  );
  var uh = Xd;
  wi(
    { target: "Promise", stat: !0, forced: qd.CONSTRUCTOR },
    {
      reject: function(e) {
        var t = uh.f(this);
        return (0, t.reject)(e), t.promise;
      }
    }
  );
  var ph = ri,
    fh = Z,
    Eh = Xd,
    mh = function(e, t) {
      if ((ph(e), fh(t) && t.constructor === e)) return t;
      var i = Eh.f(e);
      return (0, i.resolve)(t), i.promise;
    },
    gh = wi,
    _h = kd,
    Th = qd.CONSTRUCTOR,
    Sh = mh,
    vh = ne("Promise"),
    Rh = !Th;
  gh(
    { target: "Promise", stat: !0, forced: true },
    {
      resolve: function(e) {
        return Sh(Rh && this === vh ? _h : this, e);
      }
    }
  );
  var yh = N,
    Ah = Le,
    Ih = Xd,
    Ch = Pd,
    bh = qn;
  wi(
    { target: "Promise", stat: !0, forced: Zl },
    {
      allSettled: function(e) {
        var t = this,
          i = Ih.f(t),
          s = i.resolve,
          r = i.reject,
          n = Ch(function() {
            var i = Ah(t.resolve),
              r = [],
              n = 0,
              a = 1;
            bh(e, function(e) {
              var o = n++,
                c = !1;
              a++,
                yh(i, t, e).then(
                  function(e) {
                    c ||
                      ((c = !0),
                      (r[o] = { status: "fulfilled", value: e }),
                      --a || s(r));
                  },
                  function(e) {
                    c ||
                      ((c = !0),
                      (r[o] = { status: "rejected", reason: e }),
                      --a || s(r));
                  }
                );
            }),
              --a || s(r);
          });
        return n.error && r(n.value), i.promise;
      }
    }
  );
  var Oh = N,
    Dh = Le,
    wh = ne,
    Lh = Xd,
    Nh = Pd,
    Ph = qn,
    kh = "No one promise resolved";
  wi(
    { target: "Promise", stat: !0, forced: Zl },
    {
      any: function(e) {
        var t = this,
          i = wh("AggregateError"),
          s = Lh.f(t),
          r = s.resolve,
          n = s.reject,
          a = Nh(function() {
            var s = Dh(t.resolve),
              a = [],
              o = 0,
              c = 1,
              d = !1;
            Ph(e, function(e) {
              var l = o++,
                h = !1;
              c++,
                Oh(s, t, e).then(
                  function(e) {
                    h || d || ((d = !0), r(e));
                  },
                  function(e) {
                    h || d || ((h = !0), (a[l] = e), --c || n(new i(a, kh)));
                  }
                );
            }),
              --c || n(new i(a, kh));
          });
        return a.error && n(a.value), s.promise;
      }
    }
  );
  var Mh = wi,
    Uh = _,
    xh = Cc,
    Fh = Xd,
    Bh = Le,
    Vh = Pd,
    Gh = p.Promise,
    jh = !1;
  Mh(
    {
      target: "Promise",
      stat: !0,
      forced:
        !Gh ||
        !Gh.try ||
        Vh(function() {
          Gh.try(function(e) {
            jh = 8 === e;
          }, 8);
        }).error ||
        !jh
    },
    {
      try: function(e) {
        var t = arguments.length > 1 ? xh(arguments, 1) : [],
          i = Fh.f(this),
          s = Vh(function() {
            return Uh(Bh(e), void 0, t);
          });
        return (s.error ? i.reject : i.resolve)(s.value), i.promise;
      }
    }
  );
  var Hh = Xd;
  wi(
    { target: "Promise", stat: !0 },
    {
      withResolvers: function() {
        var e = Hh.f(this);
        return { promise: e.promise, resolve: e.resolve, reject: e.reject };
      }
    }
  );
  var Kh = wi,
    Wh = kd,
    Yh = r,
    $h = ne,
    qh = b,
    Xh = Ic,
    zh = mh,
    Jh = Wh && Wh.prototype;
  Kh(
    {
      target: "Promise",
      proto: !0,
      real: !0,
      forced:
        !!Wh &&
        Yh(function() {
          Jh.finally.call({ then: function() {} }, function() {});
        })
    },
    {
      finally: function(e) {
        var t = Xh(this, $h("Promise")),
          i = qh(e);
        return this.then(
          i
            ? function(i) {
                return zh(t, e()).then(function() {
                  return i;
                });
              }
            : e,
          i
            ? function(i) {
                return zh(t, e()).then(function() {
                  throw i;
                });
              }
            : e
        );
      }
    }
  );
  var Qh = l,
    Zh = Ws,
    eu = ji,
    tu = q,
    iu = Qh("".charAt),
    su = Qh("".charCodeAt),
    ru = Qh("".slice),
    nu = function(e) {
      return function(t, i) {
        var s,
          r,
          n = eu(tu(t)),
          a = Zh(i),
          o = n.length;
        return a < 0 || a >= o
          ? e
            ? ""
            : void 0
          : (s = su(n, a)) < 55296 ||
            s > 56319 ||
            a + 1 === o ||
            (r = su(n, a + 1)) < 56320 ||
            r > 57343
          ? e
            ? iu(n, a)
            : s
          : e
          ? ru(n, a, a + 2)
          : r - 56320 + ((s - 55296) << 10) + 65536;
      };
    },
    au = { codeAt: nu(!1), charAt: nu(!0) },
    ou = au.charAt,
    cu = ji,
    du = ka,
    lu = Co,
    hu = bo,
    uu = "String Iterator",
    pu = du.set,
    fu = du.getterFor(uu);
  lu(
    String,
    "String",
    function(e) {
      pu(this, { type: uu, string: cu(e), index: 0 });
    },
    function() {
      var e,
        t = fu(this),
        i = t.string,
        s = t.index;
      return s >= i.length
        ? hu(void 0, !0)
        : ((e = ou(i, s)), (t.index += e.length), hu(e, !1));
    }
  );
  var Eu = ee.Promise,
    mu = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    },
    gu = p,
    _u = to,
    Tu = pn;
  for (var Su in mu) _u(gu[Su], Su), (Tu[Su] = Tu.Array);
  var vu = Eu,
    Ru = s(vu),
    yu = { exports: {} },
    Au = wi,
    Iu = D,
    Cu = Zt.f;
  Au(
    {
      target: "Object",
      stat: !0,
      forced: Object.defineProperty !== Cu,
      sham: !Iu
    },
    { defineProperty: Cu }
  );
  var bu = ee.Object,
    Ou = (yu.exports = function(e, t, i) {
      return bu.defineProperty(e, t, i);
    });
  bu.defineProperty.sham && (Ou.sham = !0);
  var Du = s(yu.exports),
    wu = R,
    Lu =
      Array.isArray ||
      function(e) {
        return "Array" === wu(e);
      },
    Nu = TypeError,
    Pu = D,
    ku = Zt,
    Mu = B,
    Uu = function(e, t, i) {
      Pu ? ku.f(e, t, Mu(0, i)) : (e[t] = i);
    },
    xu = Lu,
    Fu = gc,
    Bu = Z,
    Vu = ft("species"),
    Gu = Array,
    ju = function(e) {
      var t;
      return (
        xu(e) &&
          ((t = e.constructor),
          ((Fu(t) && (t === Gu || xu(t.prototype))) ||
            (Bu(t) && null === (t = t[Vu]))) &&
            (t = void 0)),
        void 0 === t ? Gu : t
      );
    },
    Hu = function(e, t) {
      return new (ju(e))(0 === t ? 0 : t);
    },
    Ku = r,
    Wu = Ee,
    Yu = ft("species"),
    $u = wi,
    qu = r,
    Xu = Lu,
    zu = Z,
    Ju = Je,
    Qu = er,
    Zu = function(e) {
      if (e > 9007199254740991) throw Nu("Maximum allowed index exceeded");
      return e;
    },
    ep = Uu,
    tp = Hu,
    ip = function(e) {
      return (
        Wu >= 51 ||
        !Ku(function() {
          var t = [];
          return (
            ((t.constructor = {})[Yu] = function() {
              return { foo: 1 };
            }),
            1 !== t[e](Boolean).foo
          );
        })
      );
    },
    sp = Ee,
    rp = ft("isConcatSpreadable"),
    np =
      sp >= 51 ||
      !qu(function() {
        var e = [];
        return (e[rp] = !1), e.concat()[0] !== e;
      }),
    ap = function(e) {
      if (!zu(e)) return !1;
      var t = e[rp];
      return void 0 !== t ? !!t : Xu(e);
    };
  $u(
    { target: "Array", proto: !0, arity: 1, forced: !np || !ip("concat") },
    {
      concat: function(e) {
        var t,
          i,
          s,
          r,
          n,
          a = Ju(this),
          o = tp(a, 0),
          c = 0;
        for (t = -1, s = arguments.length; t < s; t++)
          if (ap((n = -1 === t ? a : arguments[t])))
            for (r = Qu(n), Zu(c + r), i = 0; i < r; i++, c++)
              i in n && ep(o, c, n[i]);
          else Zu(c + 1), ep(o, c++, n);
        return (o.length = c), o;
      }
    }
  );
  var op = {},
    cp = R,
    dp = J,
    lp = Vs.f,
    hp = Cc,
    up =
      "object" == typeof window && window && Object.getOwnPropertyNames
        ? Object.getOwnPropertyNames(window)
        : [];
  op.f = function(e) {
    return up && "Window" === cp(e)
      ? (function(e) {
          try {
            return lp(e);
          } catch (e) {
            return hp(up);
          }
        })(e)
      : lp(dp(e));
  };
  var pp = {},
    fp = ft;
  pp.f = fp;
  var Ep = ee,
    mp = et,
    gp = pp,
    _p = Zt.f,
    Tp = function(e) {
      var t = Ep.Symbol || (Ep.Symbol = {});
      mp(t, e) || _p(t, e, { value: gp.f(e) });
    },
    Sp = N,
    vp = ne,
    Rp = ft,
    yp = Ua,
    Ap = function() {
      var e = vp("Symbol"),
        t = e && e.prototype,
        i = t && t.valueOf,
        s = Rp("toPrimitive");
      t &&
        !t[s] &&
        yp(
          t,
          s,
          function(e) {
            return Sp(i, this);
          },
          { arity: 1 }
        );
    },
    Ip = Qt,
    Cp = K,
    bp = Je,
    Op = er,
    Dp = Hu,
    wp = l([].push),
    Lp = function(e) {
      var t = 1 === e,
        i = 2 === e,
        s = 3 === e,
        r = 4 === e,
        n = 6 === e,
        a = 7 === e,
        o = 5 === e || n;
      return function(c, d, l, h) {
        for (
          var u,
            p,
            f = bp(c),
            E = Cp(f),
            m = Op(E),
            g = Ip(d, l),
            _ = 0,
            T = h || Dp,
            S = t ? T(c, m) : i || a ? T(c, 0) : void 0;
          m > _;
          _++
        )
          if ((o || _ in E) && ((p = g((u = E[_]), _, f)), e))
            if (t) S[_] = p;
            else if (p)
              switch (e) {
                case 3:
                  return !0;
                case 5:
                  return u;
                case 6:
                  return _;
                case 2:
                  wp(S, u);
              }
            else
              switch (e) {
                case 4:
                  return !1;
                case 7:
                  wp(S, u);
              }
        return n ? -1 : s || r ? r : S;
      };
    },
    Np = {
      forEach: Lp(0),
      map: Lp(1),
      filter: Lp(2),
      some: Lp(3),
      every: Lp(4),
      find: Lp(5),
      findIndex: Lp(6),
      filterReject: Lp(7)
    },
    Pp = wi,
    kp = p,
    Mp = N,
    Up = l,
    xp = D,
    Fp = Te,
    Bp = r,
    Vp = et,
    Gp = h,
    jp = ri,
    Hp = J,
    Kp = At,
    Wp = ji,
    Yp = B,
    $p = Qr,
    qp = wr,
    Xp = Vs,
    zp = op,
    Jp = mr,
    Qp = O,
    Zp = Zt,
    ef = br,
    tf = P,
    sf = Ua,
    rf = Ho,
    nf = qe,
    af = ar,
    of = nt,
    cf = ft,
    df = pp,
    lf = Tp,
    hf = Ap,
    uf = to,
    pf = ka,
    ff = Np.forEach,
    Ef = Ts("hidden"),
    mf = "Symbol",
    gf = "prototype",
    _f = pf.set,
    Tf = pf.getterFor(mf),
    Sf = Object[gf],
    vf = kp.Symbol,
    Rf = vf && vf[gf],
    yf = kp.RangeError,
    Af = kp.TypeError,
    If = kp.QObject,
    Cf = Qp.f,
    bf = Zp.f,
    Of = zp.f,
    Df = tf.f,
    wf = Up([].push),
    Lf = nf("symbols"),
    Nf = nf("op-symbols"),
    Pf = nf("wks"),
    kf = !If || !If[gf] || !If[gf].findChild,
    Mf = function(e, t, i) {
      var s = Cf(Sf, t);
      s && delete Sf[t], bf(e, t, i), s && e !== Sf && bf(Sf, t, s);
    },
    Uf =
      xp &&
      Bp(function() {
        return (
          7 !==
          $p(
            bf({}, "a", {
              get: function() {
                return bf(this, "a", { value: 7 }).a;
              }
            })
          ).a
        );
      })
        ? Mf
        : bf,
    xf = function(e, t) {
      var i = (Lf[e] = $p(Rf));
      return (
        _f(i, { type: mf, tag: e, description: t }),
        xp || (i.description = t),
        i
      );
    },
    Ff = function(e, t, i) {
      e === Sf && Ff(Nf, t, i), jp(e);
      var s = Kp(t);
      return (
        jp(i),
        Vp(Lf, s)
          ? (i.enumerable
              ? (Vp(e, Ef) && e[Ef][s] && (e[Ef][s] = !1),
                (i = $p(i, { enumerable: Yp(0, !1) })))
              : (Vp(e, Ef) || bf(e, Ef, Yp(1, $p(null))), (e[Ef][s] = !0)),
            Uf(e, s, i))
          : bf(e, s, i)
      );
    },
    Bf = function(e, t) {
      jp(e);
      var i = Hp(t),
        s = qp(i).concat(Hf(i));
      return (
        ff(s, function(t) {
          (xp && !Mp(Vf, i, t)) || Ff(e, t, i[t]);
        }),
        e
      );
    },
    Vf = function(e) {
      var t = Kp(e),
        i = Mp(Df, this, t);
      return (
        !(this === Sf && Vp(Lf, t) && !Vp(Nf, t)) &&
        (!(i || !Vp(this, t) || !Vp(Lf, t) || (Vp(this, Ef) && this[Ef][t])) ||
          i)
      );
    },
    Gf = function(e, t) {
      var i = Hp(e),
        s = Kp(t);
      if (i !== Sf || !Vp(Lf, s) || Vp(Nf, s)) {
        var r = Cf(i, s);
        return (
          !r || !Vp(Lf, s) || (Vp(i, Ef) && i[Ef][s]) || (r.enumerable = !0), r
        );
      }
    },
    jf = function(e) {
      var t = Of(Hp(e)),
        i = [];
      return (
        ff(t, function(e) {
          Vp(Lf, e) || Vp(af, e) || wf(i, e);
        }),
        i
      );
    },
    Hf = function(e) {
      var t = e === Sf,
        i = Of(t ? Nf : Hp(e)),
        s = [];
      return (
        ff(i, function(e) {
          !Vp(Lf, e) || (t && !Vp(Sf, e)) || wf(s, Lf[e]);
        }),
        s
      );
    };
  Fp ||
    ((vf = function() {
      if (Gp(Rf, this)) throw new Af("Symbol is not a constructor");
      var e =
          arguments.length && void 0 !== arguments[0]
            ? Wp(arguments[0])
            : void 0,
        t = of(e),
        i = function(e) {
          var s = void 0 === this ? kp : this;
          s === Sf && Mp(i, Nf, e),
            Vp(s, Ef) && Vp(s[Ef], t) && (s[Ef][t] = !1);
          var r = Yp(1, e);
          try {
            Uf(s, t, r);
          } catch (e) {
            if (!(e instanceof yf)) throw e;
            Mf(s, t, r);
          }
        };
      return xp && kf && Uf(Sf, t, { configurable: !0, set: i }), xf(t, e);
    }),
    sf((Rf = vf[gf]), "toString", function() {
      return Tf(this).tag;
    }),
    sf(vf, "withoutSetter", function(e) {
      return xf(of(e), e);
    }),
    (tf.f = Vf),
    (Zp.f = Ff),
    (ef.f = Bf),
    (Qp.f = Gf),
    (Xp.f = zp.f = jf),
    (Jp.f = Hf),
    (df.f = function(e) {
      return xf(cf(e), e);
    }),
    xp &&
      rf(Rf, "description", {
        configurable: !0,
        get: function() {
          return Tf(this).description;
        }
      })),
    Pp(
      { global: !0, constructor: !0, wrap: !0, forced: !Fp, sham: !Fp },
      { Symbol: vf }
    ),
    ff(qp(Pf), function(e) {
      lf(e);
    }),
    Pp(
      { target: mf, stat: !0, forced: !Fp },
      {
        useSetter: function() {
          kf = !0;
        },
        useSimple: function() {
          kf = !1;
        }
      }
    ),
    Pp(
      { target: "Object", stat: !0, forced: !Fp, sham: !xp },
      {
        create: function(e, t) {
          return void 0 === t ? $p(e) : Bf($p(e), t);
        },
        defineProperty: Ff,
        defineProperties: Bf,
        getOwnPropertyDescriptor: Gf
      }
    ),
    Pp(
      { target: "Object", stat: !0, forced: !Fp },
      { getOwnPropertyNames: jf }
    ),
    hf(),
    uf(vf, mf),
    (af[Ef] = !0);
  var Kf = Te && !!Symbol.for && !!Symbol.keyFor,
    Wf = wi,
    Yf = ne,
    $f = et,
    qf = ji,
    Xf = qe,
    zf = Kf,
    Jf = Xf("string-to-symbol-registry"),
    Qf = Xf("symbol-to-string-registry");
  Wf(
    { target: "Symbol", stat: !0, forced: !zf },
    {
      for: function(e) {
        var t = qf(e);
        if ($f(Jf, t)) return Jf[t];
        var i = Yf("Symbol")(t);
        return (Jf[t] = i), (Qf[i] = t), i;
      }
    }
  );
  var Zf = wi,
    eE = et,
    tE = Ie,
    iE = be,
    sE = Kf,
    rE = qe("symbol-to-string-registry");
  Zf(
    { target: "Symbol", stat: !0, forced: !sE },
    {
      keyFor: function(e) {
        if (!tE(e)) throw new TypeError(iE(e) + " is not a symbol");
        if (eE(rE, e)) return rE[e];
      }
    }
  );
  var nE = Lu,
    aE = b,
    oE = R,
    cE = ji,
    dE = l([].push),
    lE = wi,
    hE = ne,
    uE = _,
    pE = N,
    fE = l,
    EE = r,
    mE = b,
    gE = Ie,
    _E = Cc,
    TE = function(e) {
      if (aE(e)) return e;
      if (nE(e)) {
        for (var t = e.length, i = [], s = 0; s < t; s++) {
          var r = e[s];
          "string" == typeof r
            ? dE(i, r)
            : ("number" != typeof r &&
                "Number" !== oE(r) &&
                "String" !== oE(r)) ||
              dE(i, cE(r));
        }
        var n = i.length,
          a = !0;
        return function(e, t) {
          if (a) return (a = !1), t;
          if (nE(this)) return t;
          for (var s = 0; s < n; s++) if (i[s] === e) return t;
        };
      }
    },
    SE = Te,
    vE = String,
    RE = hE("JSON", "stringify"),
    yE = fE(/./.exec),
    AE = fE("".charAt),
    IE = fE("".charCodeAt),
    CE = fE("".replace),
    bE = fE((1).toString),
    OE = /[\uD800-\uDFFF]/g,
    DE = /^[\uD800-\uDBFF]$/,
    wE = /^[\uDC00-\uDFFF]$/,
    LE =
      !SE ||
      EE(function() {
        var e = hE("Symbol")("stringify detection");
        return (
          "[null]" !== RE([e]) ||
          "{}" !== RE({ a: e }) ||
          "{}" !== RE(Object(e))
        );
      }),
    NE = EE(function() {
      return (
        '"\\udf06\\ud834"' !== RE("\udf06\ud834") ||
        '"\\udead"' !== RE("\udead")
      );
    }),
    PE = function(e, t) {
      var i = _E(arguments),
        s = TE(t);
      if (mE(s) || (void 0 !== e && !gE(e)))
        return (
          (i[1] = function(e, t) {
            if ((mE(s) && (t = pE(s, this, vE(e), t)), !gE(t))) return t;
          }),
          uE(RE, null, i)
        );
    },
    kE = function(e, t, i) {
      var s = AE(i, t - 1),
        r = AE(i, t + 1);
      return (yE(DE, e) && !yE(wE, r)) || (yE(wE, e) && !yE(DE, s))
        ? "\\u" + bE(IE(e, 0), 16)
        : e;
    };
  RE &&
    lE(
      { target: "JSON", stat: !0, arity: 3, forced: LE || NE },
      {
        stringify: function(e, t, i) {
          var s = _E(arguments),
            r = uE(LE ? PE : RE, null, s);
          return NE && "string" == typeof r ? CE(r, OE, kE) : r;
        }
      }
    );
  var ME = mr,
    UE = Je;
  wi(
    {
      target: "Object",
      stat: !0,
      forced:
        !Te ||
        r(function() {
          ME.f(1);
        })
    },
    {
      getOwnPropertySymbols: function(e) {
        var t = ME.f;
        return t ? t(UE(e)) : [];
      }
    }
  ),
    Tp("asyncIterator"),
    Tp("hasInstance"),
    Tp("isConcatSpreadable"),
    Tp("iterator"),
    Tp("match"),
    Tp("matchAll"),
    Tp("replace"),
    Tp("search"),
    Tp("species"),
    Tp("split");
  var xE = Ap;
  Tp("toPrimitive"), xE();
  var FE = ne,
    BE = to;
  Tp("toStringTag"),
    BE(FE("Symbol"), "Symbol"),
    Tp("unscopables"),
    to(p.JSON, "JSON", !0);
  var VE = ee.Symbol,
    GE = ft,
    jE = Zt.f,
    HE = GE("metadata"),
    KE = Function.prototype;
  void 0 === KE[HE] && jE(KE, HE, { value: null }),
    Tp("asyncDispose"),
    Tp("dispose"),
    Tp("metadata");
  var WE = VE,
    YE = l,
    $E = ne("Symbol"),
    qE = $E.keyFor,
    XE = YE($E.prototype.valueOf),
    zE =
      $E.isRegisteredSymbol ||
      function(e) {
        try {
          return void 0 !== qE(XE(e));
        } catch (e) {
          return !1;
        }
      };
  wi({ target: "Symbol", stat: !0 }, { isRegisteredSymbol: zE });
  for (
    var JE = qe,
      QE = ne,
      ZE = l,
      em = Ie,
      tm = ft,
      im = QE("Symbol"),
      sm = im.isWellKnownSymbol,
      rm = QE("Object", "getOwnPropertyNames"),
      nm = ZE(im.prototype.valueOf),
      am = JE("wks"),
      om = 0,
      cm = rm(im),
      dm = cm.length;
    om < dm;
    om++
  )
    try {
      var lm = cm[om];
      em(im[lm]) && tm(lm);
    } catch (e) {}
  var hm = function(e) {
    if (sm && sm(e)) return !0;
    try {
      for (var t = nm(e), i = 0, s = rm(am), r = s.length; i < r; i++)
        if (am[s[i]] == t) return !0;
    } catch (e) {}
    return !1;
  };
  wi({ target: "Symbol", stat: !0, forced: !0 }, { isWellKnownSymbol: hm }),
    Tp("customMatcher"),
    Tp("observable"),
    wi(
      { target: "Symbol", stat: !0, name: "isRegisteredSymbol" },
      { isRegistered: zE }
    ),
    wi(
      { target: "Symbol", stat: !0, name: "isWellKnownSymbol", forced: !0 },
      { isWellKnown: hm }
    ),
    Tp("matcher"),
    Tp("metadataKey"),
    Tp("patternMatch"),
    Tp("replaceAll");
  var um = s(WE),
    pm = s(pp.f("iterator"));
  function fm(e) {
    return (
      (fm =
        "function" == typeof um && "symbol" == typeof pm
          ? function(e) {
              return typeof e;
            }
          : function(e) {
              return e &&
                "function" == typeof um &&
                e.constructor === um &&
                e !== um.prototype
                ? "symbol"
                : typeof e;
            }),
      fm(e)
    );
  }
  var Em = s(pp.f("toPrimitive"));
  function mm(e) {
    var t = (function(e, t) {
      if ("object" !== fm(e) || null === e) return e;
      var i = e[Em];
      if (void 0 !== i) {
        var s = i.call(e, t || "default");
        if ("object" !== fm(s)) return s;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t ? String : Number)(e);
    })(e, "string");
    return "symbol" === fm(t) ? t : String(t);
  }
  function gm(e, t, i) {
    return (
      (t = mm(t)) in e
        ? Du(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 })
        : (e[t] = i),
      e
    );
  }
  let _m = class {
    constructor() {
      (this._events = new Map()), (this.addListener = this.on);
    }
    getListeners(e) {
      const t = this._events.get(e);
      return Array.isArray(t) ? t.map(e => e.listener) : [];
    }
    on(e, t) {
      let i = this._events.get(e);
      Array.isArray(i) || ((i = []), this._events.set(e, i)),
        -1 === this._indexOfListener(i, t) && i.push({ listener: t, once: !1 });
    }
    once(e, t) {
      let i = this._events.get(e);
      Array.isArray(i) || ((i = []), this._events.set(e, i)),
        -1 === this._indexOfListener(i, t) && i.push({ listener: t, once: !0 });
    }
    off(e, t) {
      const i = this._events.get(e);
      if (!Array.isArray(i)) return;
      if (!t) return this.removeAllListeners(e);
      const s = this._indexOfListener(i, t);
      -1 !== s && i.splice(s, 1),
        0 === this._events.size && this._events.delete(e);
    }
    removeAllListeners(e) {
      if (!e) return this._events.clear();
      this._events.delete(e);
    }
    emit(e) {
      for (
        var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1;
        s < t;
        s++
      )
        i[s - 1] = arguments[s];
      const r = this._events.get(e);
      Array.isArray(r) &&
        r.forEach(t => {
          t.once && this.off(e, t.listener), t.listener.apply(this, i || []);
        });
    }
    safeEmit(e) {
      for (
        var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1;
        s < t;
        s++
      )
        i[s - 1] = arguments[s];
      const r = this._events.get(e);
      Array.isArray(r) &&
        r.forEach(t => {
          t.once && this.off(e, t.listener);
          try {
            t.listener.apply(this, i || []);
          } catch (t) {
            console.error(
              "safeEmit event:"
                .concat(e, " error ")
                .concat(null == t ? void 0 : t.toString())
            );
          }
        });
    }
    _indexOfListener(e, t) {
      return e.findIndex(e => e.listener === t);
    }
  };
  const Tm =
      Number.isFinite ||
      function(e) {
        return "number" == typeof e && isFinite(e);
      },
    Sm =
      Number.isSafeInteger ||
      function(e) {
        return "number" == typeof e && Math.abs(e) <= vm;
      },
    vm = Number.MAX_SAFE_INTEGER || 9007199254740991;
  let Rm = (function(e) {
      return (
        (e.NETWORK_ERROR = "networkError"),
        (e.MEDIA_ERROR = "mediaError"),
        (e.KEY_SYSTEM_ERROR = "keySystemError"),
        (e.MUX_ERROR = "muxError"),
        (e.OTHER_ERROR = "otherError"),
        e
      );
    })({}),
    ym = (function(e) {
      return (
        (e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys"),
        (e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess"),
        (e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession"),
        (e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense"),
        (e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed"),
        (e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED =
          "keySystemServerCertificateRequestFailed"),
        (e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED =
          "keySystemServerCertificateUpdateFailed"),
        (e.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed"),
        (e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED =
          "keySystemStatusOutputRestricted"),
        (e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError"),
        (e.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR =
          "keySystemDestroyMediaKeysError"),
        (e.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR =
          "keySystemDestroyCloseSessionError"),
        (e.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR =
          "keySystemDestroyRemoveSessionError"),
        (e.MANIFEST_LOAD_ERROR = "manifestLoadError"),
        (e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut"),
        (e.MANIFEST_PARSING_ERROR = "manifestParsingError"),
        (e.MANIFEST_INCOMPATIBLE_CODECS_ERROR =
          "manifestIncompatibleCodecsError"),
        (e.LEVEL_EMPTY_ERROR = "levelEmptyError"),
        (e.LEVEL_LOAD_ERROR = "levelLoadError"),
        (e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut"),
        (e.LEVEL_PARSING_ERROR = "levelParsingError"),
        (e.LEVEL_SWITCH_ERROR = "levelSwitchError"),
        (e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError"),
        (e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut"),
        (e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError"),
        (e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut"),
        (e.FRAG_LOAD_ERROR = "fragLoadError"),
        (e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut"),
        (e.FRAG_DECRYPT_ERROR = "fragDecryptError"),
        (e.FRAG_PARSING_ERROR = "fragParsingError"),
        (e.FRAG_GAP = "fragGap"),
        (e.REMUX_ALLOC_ERROR = "remuxAllocError"),
        (e.KEY_LOAD_ERROR = "keyLoadError"),
        (e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut"),
        (e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError"),
        (e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError"),
        (e.BUFFER_APPEND_ERROR = "bufferAppendError"),
        (e.BUFFER_APPENDING_ERROR = "bufferAppendingError"),
        (e.BUFFER_STALLED_ERROR = "bufferStalledError"),
        (e.BUFFER_FULL_ERROR = "bufferFullError"),
        (e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole"),
        (e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall"),
        (e.ASSET_LIST_LOAD_ERROR = "assetListLoadError"),
        (e.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout"),
        (e.ASSET_LIST_PARSING_ERROR = "assetListParsingError"),
        (e.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError"),
        (e.INTERNAL_EXCEPTION = "internalException"),
        (e.INTERNAL_ABORTED = "aborted"),
        (e.ATTACH_MEDIA_ERROR = "attachMediaError"),
        (e.UNKNOWN = "unknown"),
        e
      );
    })({}),
    Am = (function(e) {
      return (
        (e.MEDIA_ATTACHING = "hlsMediaAttaching"),
        (e.MEDIA_ATTACHED = "hlsMediaAttached"),
        (e.MEDIA_DETACHING = "hlsMediaDetaching"),
        (e.MEDIA_DETACHED = "hlsMediaDetached"),
        (e.MEDIA_ENDED = "hlsMediaEnded"),
        (e.STALL_RESOLVED = "hlsStallResolved"),
        (e.BUFFER_RESET = "hlsBufferReset"),
        (e.BUFFER_CODECS = "hlsBufferCodecs"),
        (e.BUFFER_CREATED = "hlsBufferCreated"),
        (e.BUFFER_APPENDING = "hlsBufferAppending"),
        (e.BUFFER_APPENDED = "hlsBufferAppended"),
        (e.BUFFER_EOS = "hlsBufferEos"),
        (e.BUFFERED_TO_END = "hlsBufferedToEnd"),
        (e.BUFFER_FLUSHING = "hlsBufferFlushing"),
        (e.BUFFER_FLUSHED = "hlsBufferFlushed"),
        (e.MANIFEST_LOADING = "hlsManifestLoading"),
        (e.MANIFEST_LOADED = "hlsManifestLoaded"),
        (e.MANIFEST_PARSED = "hlsManifestParsed"),
        (e.LEVEL_SWITCHING = "hlsLevelSwitching"),
        (e.LEVEL_SWITCHED = "hlsLevelSwitched"),
        (e.LEVEL_LOADING = "hlsLevelLoading"),
        (e.LEVEL_LOADED = "hlsLevelLoaded"),
        (e.LEVEL_UPDATED = "hlsLevelUpdated"),
        (e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated"),
        (e.LEVELS_UPDATED = "hlsLevelsUpdated"),
        (e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated"),
        (e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching"),
        (e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched"),
        (e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading"),
        (e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded"),
        (e.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated"),
        (e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated"),
        (e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared"),
        (e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch"),
        (e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading"),
        (e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded"),
        (e.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated"),
        (e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed"),
        (e.CUES_PARSED = "hlsCuesParsed"),
        (e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound"),
        (e.INIT_PTS_FOUND = "hlsInitPtsFound"),
        (e.FRAG_LOADING = "hlsFragLoading"),
        (e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted"),
        (e.FRAG_LOADED = "hlsFragLoaded"),
        (e.FRAG_DECRYPTED = "hlsFragDecrypted"),
        (e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment"),
        (e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata"),
        (e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata"),
        (e.FRAG_PARSED = "hlsFragParsed"),
        (e.FRAG_BUFFERED = "hlsFragBuffered"),
        (e.FRAG_CHANGED = "hlsFragChanged"),
        (e.FPS_DROP = "hlsFpsDrop"),
        (e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping"),
        (e.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated"),
        (e.ERROR = "hlsError"),
        (e.DESTROYING = "hlsDestroying"),
        (e.KEY_LOADING = "hlsKeyLoading"),
        (e.KEY_LOADED = "hlsKeyLoaded"),
        (e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached"),
        (e.BACK_BUFFER_REACHED = "hlsBackBufferReached"),
        (e.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded"),
        (e.ASSET_LIST_LOADING = "hlsAssetListLoading"),
        (e.ASSET_LIST_LOADED = "hlsAssetListLoaded"),
        (e.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated"),
        (e.INTERSTITIALS_BUFFERED_TO_BOUNDARY =
          "hlsInterstitialsBufferedToBoundary"),
        (e.INTERSTITIAL_ASSET_PLAYER_CREATED =
          "hlsInterstitialAssetPlayerCreated"),
        (e.INTERSTITIAL_STARTED = "hlsInterstitialStarted"),
        (e.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted"),
        (e.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded"),
        (e.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError"),
        (e.INTERSTITIAL_ENDED = "hlsInterstitialEnded"),
        (e.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed"),
        (e.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached"),
        (e.EVENT_CUE_ENTER = "hlsEventCueEnter"),
        e
      );
    })({});
  var Im = {
      MANIFEST: "manifest",
      LEVEL: "level",
      AUDIO_TRACK: "audioTrack",
      SUBTITLE_TRACK: "subtitleTrack"
    },
    Cm = { MAIN: "main", AUDIO: "audio", SUBTITLE: "subtitle" };
  class bm {
    constructor(e, t = 0, i = 0) {
      (this.halfLife = void 0),
        (this.alpha_ = void 0),
        (this.estimate_ = void 0),
        (this.totalWeight_ = void 0),
        (this.halfLife = e),
        (this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0),
        (this.estimate_ = t),
        (this.totalWeight_ = i);
    }
    sample(e, t) {
      const i = Math.pow(this.alpha_, e);
      (this.estimate_ = t * (1 - i) + i * this.estimate_),
        (this.totalWeight_ += e);
    }
    getTotalWeight() {
      return this.totalWeight_;
    }
    getEstimate() {
      if (this.alpha_) {
        const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
        if (e) return this.estimate_ / e;
      }
      return this.estimate_;
    }
  }
  class Om {
    constructor(e, t, i, s = 100) {
      (this.defaultEstimate_ = void 0),
        (this.minWeight_ = void 0),
        (this.minDelayMs_ = void 0),
        (this.slow_ = void 0),
        (this.fast_ = void 0),
        (this.defaultTTFB_ = void 0),
        (this.ttfb_ = void 0),
        (this.defaultEstimate_ = i),
        (this.minWeight_ = 0.001),
        (this.minDelayMs_ = 50),
        (this.slow_ = new bm(e)),
        (this.fast_ = new bm(t)),
        (this.defaultTTFB_ = s),
        (this.ttfb_ = new bm(e));
    }
    update(e, t) {
      const { slow_: i, fast_: s, ttfb_: r } = this;
      i.halfLife !== e &&
        (this.slow_ = new bm(e, i.getEstimate(), i.getTotalWeight())),
        s.halfLife !== t &&
          (this.fast_ = new bm(t, s.getEstimate(), s.getTotalWeight())),
        r.halfLife !== e &&
          (this.ttfb_ = new bm(e, r.getEstimate(), r.getTotalWeight()));
    }
    sample(e, t) {
      const i = (e = Math.max(e, this.minDelayMs_)) / 1e3,
        s = (8 * t) / i;
      this.fast_.sample(i, s), this.slow_.sample(i, s);
    }
    sampleTTFB(e) {
      const t = e / 1e3,
        i = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
      this.ttfb_.sample(i, Math.max(e, 5));
    }
    canEstimate() {
      return this.fast_.getTotalWeight() >= this.minWeight_;
    }
    getEstimate() {
      return this.canEstimate()
        ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate())
        : this.defaultEstimate_;
    }
    getEstimateTTFB() {
      return this.ttfb_.getTotalWeight() >= this.minWeight_
        ? this.ttfb_.getEstimate()
        : this.defaultTTFB_;
    }
    get defaultEstimate() {
      return this.defaultEstimate_;
    }
    destroy() {}
  }
  function Dm(e, t, i) {
    return (
      (t = (function(e) {
        var t = (function(e, t) {
          if ("object" != typeof e || !e) return e;
          var i = e[Symbol.toPrimitive];
          if (void 0 !== i) {
            var s = i.call(e, t);
            if ("object" != typeof s) return s;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t ? String : Number)(e);
        })(e, "string");
        return "symbol" == typeof t ? t : t + "";
      })(t)) in e
        ? Object.defineProperty(e, t, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
          })
        : (e[t] = i),
      e
    );
  }
  function wm() {
    return (
      (wm = Object.assign
        ? Object.assign.bind()
        : function(e) {
            for (var t = 1; t < arguments.length; t++) {
              var i = arguments[t];
              for (var s in i) ({}.hasOwnProperty.call(i, s) && (e[s] = i[s]));
            }
            return e;
          }),
      wm.apply(null, arguments)
    );
  }
  function Lm(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function Nm(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? Lm(Object(i), !0).forEach(function(t) {
            Dm(e, t, i[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
        : Lm(Object(i)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
          });
    }
    return e;
  }
  class Pm {
    constructor(e, t) {
      (this.trace = void 0),
        (this.debug = void 0),
        (this.log = void 0),
        (this.warn = void 0),
        (this.info = void 0),
        (this.error = void 0);
      const i = `[${e}]:`;
      (this.trace = km),
        (this.debug = t.debug.bind(null, i)),
        (this.log = t.log.bind(null, i)),
        (this.warn = t.warn.bind(null, i)),
        (this.info = t.info.bind(null, i)),
        (this.error = t.error.bind(null, i));
    }
  }
  const km = function() {},
    Mm = { trace: km, debug: km, log: km, warn: km, info: km, error: km };
  function Um() {
    return wm({}, Mm);
  }
  function xm(e, t, i) {
    return t[e]
      ? t[e].bind(t)
      : (function(e, t) {
          const i = self.console[e];
          return i
            ? i.bind(self.console, `${t ? "[" + t + "] " : ""}[${e}] >`)
            : km;
        })(e, i);
  }
  const Fm = Um();
  const Bm = Fm;
  function Vm(e = !0) {
    if ("undefined" == typeof self) return;
    return (
      ((e || !self.MediaSource) && self.ManagedMediaSource) ||
      self.MediaSource ||
      self.WebKitMediaSource
    );
  }
  function Gm(e, t) {
    const i = Object.keys(e),
      s = Object.keys(t),
      r = i.length,
      n = s.length;
    return !r || !n || (r === n && !i.some(e => -1 === s.indexOf(e)));
  }
  function jm(e, t = !1) {
    if ("undefined" != typeof TextDecoder) {
      const i = new TextDecoder("utf-8").decode(e);
      if (t) {
        const e = i.indexOf("\0");
        return -1 !== e ? i.substring(0, e) : i;
      }
      return i.replace(/\0/g, "");
    }
    const i = e.length;
    let s,
      r,
      n,
      a = "",
      o = 0;
    for (; o < i; ) {
      if (((s = e[o++]), 0 === s && t)) return a;
      if (0 !== s && 3 !== s)
        switch (s >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            a += String.fromCharCode(s);
            break;
          case 12:
          case 13:
            (r = e[o++]),
              (a += String.fromCharCode(((31 & s) << 6) | (63 & r)));
            break;
          case 14:
            (r = e[o++]),
              (n = e[o++]),
              (a += String.fromCharCode(
                ((15 & s) << 12) | ((63 & r) << 6) | ((63 & n) << 0)
              ));
        }
    }
    return a;
  }
  const Hm = {
    hexDump: function(e) {
      let t = "";
      for (let i = 0; i < e.length; i++) {
        let s = e[i].toString(16);
        s.length < 2 && (s = "0" + s), (t += s);
      }
      return t;
    }
  };
  function Km(e) {
    return e &&
      e.__esModule &&
      Object.prototype.hasOwnProperty.call(e, "default")
      ? e.default
      : e;
  }
  var Wm,
    Ym = { exports: {} };
  var $m =
    (Wm ||
      ((Wm = 1),
      (function(e, t) {
        var i, s, r, n, a;
        (i = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/),
          (s = /^(?=([^\/?#]*))\1([^]*)$/),
          (r = /(?:\/|^)\.(?=\/)/g),
          (n = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g),
          (a = {
            buildAbsoluteURL: function(e, t, i) {
              if (((i = i || {}), (e = e.trim()), !(t = t.trim()))) {
                if (!i.alwaysNormalize) return e;
                var r = a.parseURL(e);
                if (!r) throw new Error("Error trying to parse base URL.");
                return (
                  (r.path = a.normalizePath(r.path)), a.buildURLFromParts(r)
                );
              }
              var n = a.parseURL(t);
              if (!n) throw new Error("Error trying to parse relative URL.");
              if (n.scheme)
                return i.alwaysNormalize
                  ? ((n.path = a.normalizePath(n.path)), a.buildURLFromParts(n))
                  : t;
              var o = a.parseURL(e);
              if (!o) throw new Error("Error trying to parse base URL.");
              if (!o.netLoc && o.path && "/" !== o.path[0]) {
                var c = s.exec(o.path);
                (o.netLoc = c[1]), (o.path = c[2]);
              }
              o.netLoc && !o.path && (o.path = "/");
              var d = {
                scheme: o.scheme,
                netLoc: n.netLoc,
                path: null,
                params: n.params,
                query: n.query,
                fragment: n.fragment
              };
              if (!n.netLoc && ((d.netLoc = o.netLoc), "/" !== n.path[0]))
                if (n.path) {
                  var l = o.path,
                    h = l.substring(0, l.lastIndexOf("/") + 1) + n.path;
                  d.path = a.normalizePath(h);
                } else
                  (d.path = o.path),
                    n.params ||
                      ((d.params = o.params), n.query || (d.query = o.query));
              return (
                null === d.path &&
                  (d.path = i.alwaysNormalize
                    ? a.normalizePath(n.path)
                    : n.path),
                a.buildURLFromParts(d)
              );
            },
            parseURL: function(e) {
              var t = i.exec(e);
              return t
                ? {
                    scheme: t[1] || "",
                    netLoc: t[2] || "",
                    path: t[3] || "",
                    params: t[4] || "",
                    query: t[5] || "",
                    fragment: t[6] || ""
                  }
                : null;
            },
            normalizePath: function(e) {
              for (
                e = e
                  .split("")
                  .reverse()
                  .join("")
                  .replace(r, "");
                e.length !== (e = e.replace(n, "")).length;

              );
              return e
                .split("")
                .reverse()
                .join("");
            },
            buildURLFromParts: function(e) {
              return (
                e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
              );
            }
          }),
          (e.exports = a);
      })(Ym)),
    Ym.exports);
  class qm {
    constructor() {
      (this.aborted = !1),
        (this.loaded = 0),
        (this.retry = 0),
        (this.total = 0),
        (this.chunkCount = 0),
        (this.bwEstimate = 0),
        (this.loading = { start: 0, first: 0, end: 0 }),
        (this.parsing = { start: 0, end: 0 }),
        (this.buffering = { start: 0, first: 0, end: 0 });
    }
  }
  var Xm = { AUDIO: "audio", VIDEO: "video", AUDIOVIDEO: "audiovideo" };
  class zm {
    constructor(e) {
      (this._byteRange = null),
        (this._url = null),
        (this._stats = null),
        (this._streams = null),
        (this.base = void 0),
        (this.relurl = void 0),
        "string" == typeof e && (e = { url: e }),
        (this.base = e),
        (function(e, t) {
          const i = eg(e, t);
          i && ((i.enumerable = !0), Object.defineProperty(e, t, i));
        })(this, "stats");
    }
    setByteRange(e, t) {
      const i = e.split("@", 2);
      let s;
      (s =
        1 === i.length
          ? (null == t ? void 0 : t.byteRangeEndOffset) || 0
          : parseInt(i[1])),
        (this._byteRange = [s, parseInt(i[0]) + s]);
    }
    get baseurl() {
      return this.base.url;
    }
    get byteRange() {
      return null === this._byteRange ? [] : this._byteRange;
    }
    get byteRangeStartOffset() {
      return this.byteRange[0];
    }
    get byteRangeEndOffset() {
      return this.byteRange[1];
    }
    get elementaryStreams() {
      return (
        null === this._streams &&
          (this._streams = {
            [Xm.AUDIO]: null,
            [Xm.VIDEO]: null,
            [Xm.AUDIOVIDEO]: null
          }),
        this._streams
      );
    }
    set elementaryStreams(e) {
      this._streams = e;
    }
    get hasStats() {
      return null !== this._stats;
    }
    get hasStreams() {
      return null !== this._streams;
    }
    get stats() {
      return null === this._stats && (this._stats = new qm()), this._stats;
    }
    set stats(e) {
      this._stats = e;
    }
    get url() {
      return (
        !this._url &&
          this.baseurl &&
          this.relurl &&
          (this._url = $m.buildAbsoluteURL(this.baseurl, this.relurl, {
            alwaysNormalize: !0
          })),
        this._url || ""
      );
    }
    set url(e) {
      this._url = e;
    }
    clearElementaryStreamInfo() {
      const { elementaryStreams: e } = this;
      (e[Xm.AUDIO] = null), (e[Xm.VIDEO] = null), (e[Xm.AUDIOVIDEO] = null);
    }
  }
  function Jm(e) {
    return "initSegment" !== e.sn;
  }
  class Qm extends zm {
    constructor(e, t) {
      super(t),
        (this._decryptdata = null),
        (this._programDateTime = null),
        (this._ref = null),
        (this._bitrate = void 0),
        (this.rawProgramDateTime = null),
        (this.tagList = []),
        (this.duration = 0),
        (this.sn = 0),
        (this.levelkeys = void 0),
        (this.type = void 0),
        (this.loader = null),
        (this.keyLoader = null),
        (this.level = -1),
        (this.cc = 0),
        (this.startPTS = void 0),
        (this.endPTS = void 0),
        (this.startDTS = void 0),
        (this.endDTS = void 0),
        (this.start = 0),
        (this.playlistOffset = 0),
        (this.deltaPTS = void 0),
        (this.maxStartPTS = void 0),
        (this.minEndPTS = void 0),
        (this.data = void 0),
        (this.bitrateTest = !1),
        (this.title = null),
        (this.initSegment = null),
        (this.endList = void 0),
        (this.gap = void 0),
        (this.urlId = 0),
        (this.type = e);
    }
    get byteLength() {
      if (this.hasStats) {
        const e = this.stats.total;
        if (e) return e;
      }
      if (this.byteRange) {
        const e = this.byteRange[0],
          t = this.byteRange[1];
        if (Tm(e) && Tm(t)) return t - e;
      }
      return null;
    }
    get bitrate() {
      return this.byteLength
        ? (8 * this.byteLength) / this.duration
        : this._bitrate
        ? this._bitrate
        : null;
    }
    set bitrate(e) {
      this._bitrate = e;
    }
    get decryptdata() {
      const { levelkeys: e } = this;
      if (!e && !this._decryptdata) return null;
      if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
        const e = this.levelkeys.identity;
        if (e) this._decryptdata = e.getDecryptData(this.sn);
        else {
          const e = Object.keys(this.levelkeys);
          if (1 === e.length)
            return (this._decryptdata = this.levelkeys[e[0]].getDecryptData(
              this.sn
            ));
        }
      }
      return this._decryptdata;
    }
    get end() {
      return this.start + this.duration;
    }
    get endProgramDateTime() {
      if (null === this.programDateTime) return null;
      const e = Tm(this.duration) ? this.duration : 0;
      return this.programDateTime + 1e3 * e;
    }
    get encrypted() {
      var e;
      if (null != (e = this._decryptdata) && e.encrypted) return !0;
      if (this.levelkeys) {
        const e = Object.keys(this.levelkeys),
          t = e.length;
        if (t > 1 || (1 === t && this.levelkeys[e[0]].encrypted)) return !0;
      }
      return !1;
    }
    get programDateTime() {
      return (
        null === this._programDateTime &&
          this.rawProgramDateTime &&
          (this.programDateTime = Date.parse(this.rawProgramDateTime)),
        this._programDateTime
      );
    }
    set programDateTime(e) {
      Tm(e)
        ? (this._programDateTime = e)
        : (this._programDateTime = this.rawProgramDateTime = null);
    }
    get ref() {
      return Jm(this)
        ? (this._ref ||
            (this._ref = {
              base: this.base,
              start: this.start,
              duration: this.duration,
              sn: this.sn,
              programDateTime: this.programDateTime
            }),
          this._ref)
        : null;
    }
    addStart(e) {
      this.setStart(this.start + e);
    }
    setStart(e) {
      (this.start = e), this._ref && (this._ref.start = e);
    }
    setDuration(e) {
      (this.duration = e), this._ref && (this._ref.duration = e);
    }
    setKeyFormat(e) {
      if (this.levelkeys) {
        const t = this.levelkeys[e];
        t &&
          !this._decryptdata &&
          (this._decryptdata = t.getDecryptData(this.sn));
      }
    }
    abortRequests() {
      var e, t;
      null == (e = this.loader) || e.abort(),
        null == (t = this.keyLoader) || t.abort();
    }
    setElementaryStreamInfo(e, t, i, s, r, n = !1) {
      const { elementaryStreams: a } = this,
        o = a[e];
      o
        ? ((o.startPTS = Math.min(o.startPTS, t)),
          (o.endPTS = Math.max(o.endPTS, i)),
          (o.startDTS = Math.min(o.startDTS, s)),
          (o.endDTS = Math.max(o.endDTS, r)))
        : (a[e] = {
            startPTS: t,
            endPTS: i,
            startDTS: s,
            endDTS: r,
            partial: n
          });
    }
  }
  class Zm extends zm {
    constructor(e, t, i, s, r) {
      super(i),
        (this.fragOffset = 0),
        (this.duration = 0),
        (this.gap = !1),
        (this.independent = !1),
        (this.relurl = void 0),
        (this.fragment = void 0),
        (this.index = void 0),
        (this.duration = e.decimalFloatingPoint("DURATION")),
        (this.gap = e.bool("GAP")),
        (this.independent = e.bool("INDEPENDENT")),
        (this.relurl = e.enumeratedString("URI")),
        (this.fragment = t),
        (this.index = s);
      const n = e.enumeratedString("BYTERANGE");
      n && this.setByteRange(n, r),
        r && (this.fragOffset = r.fragOffset + r.duration);
    }
    get start() {
      return this.fragment.start + this.fragOffset;
    }
    get end() {
      return this.start + this.duration;
    }
    get loaded() {
      const { elementaryStreams: e } = this;
      return !!(e.audio || e.video || e.audiovideo);
    }
  }
  function eg(e, t) {
    const i = Object.getPrototypeOf(e);
    if (i) {
      const e = Object.getOwnPropertyDescriptor(i, t);
      return e || eg(i, t);
    }
  }
  const tg = Math.pow(2, 32) - 1,
    ig = [].push,
    sg = { video: 1, audio: 2, id3: 3, text: 4 };
  function rg(e) {
    return String.fromCharCode.apply(null, e);
  }
  function ng(e, t) {
    const i = (e[t] << 8) | e[t + 1];
    return i < 0 ? 65536 + i : i;
  }
  function ag(e, t) {
    const i = cg(e, t);
    return i < 0 ? 4294967296 + i : i;
  }
  function og(e, t) {
    let i = ag(e, t);
    return (i *= Math.pow(2, 32)), (i += ag(e, t + 4)), i;
  }
  function cg(e, t) {
    return (e[t] << 24) | (e[t + 1] << 16) | (e[t + 2] << 8) | e[t + 3];
  }
  function dg(e, t, i) {
    (e[t] = i >> 24),
      (e[t + 1] = (i >> 16) & 255),
      (e[t + 2] = (i >> 8) & 255),
      (e[t + 3] = 255 & i);
  }
  function lg(e, t) {
    const i = [];
    if (!t.length) return i;
    const s = e.byteLength;
    for (let r = 0; r < s; ) {
      const n = ag(e, r),
        a = n > 1 ? r + n : s;
      if (rg(e.subarray(r + 4, r + 8)) === t[0])
        if (1 === t.length) i.push(e.subarray(r + 8, a));
        else {
          const s = lg(e.subarray(r + 8, a), t.slice(1));
          s.length && ig.apply(i, s);
        }
      r = a;
    }
    return i;
  }
  function hg(e) {
    const t = [],
      i = e[0];
    let s = 8;
    const r = ag(e, s);
    s += 4;
    let n = 0,
      a = 0;
    0 === i
      ? ((n = ag(e, s)), (a = ag(e, s + 4)), (s += 8))
      : ((n = og(e, s)), (a = og(e, s + 8)), (s += 16)),
      (s += 2);
    let o = e.length + a;
    const c = ng(e, s);
    s += 2;
    for (let i = 0; i < c; i++) {
      let i = s;
      const n = ag(e, i);
      i += 4;
      const a = 2147483647 & n;
      if (1 === (2147483648 & n) >>> 31)
        return (
          Bm.warn("SIDX has hierarchical references (not supported)"), null
        );
      const c = ag(e, i);
      (i += 4),
        t.push({
          referenceSize: a,
          subsegmentDuration: c,
          info: { duration: c / r, start: o, end: o + a - 1 }
        }),
        (o += a),
        (i += 4),
        (s = i);
    }
    return {
      earliestPresentationTime: n,
      timescale: r,
      version: i,
      referencesCount: c,
      references: t
    };
  }
  function ug(e) {
    const t = [],
      i = lg(e, ["moov", "trak"]);
    for (let e = 0; e < i.length; e++) {
      const s = i[e],
        r = lg(s, ["tkhd"])[0];
      if (r) {
        let e = r[0];
        const i = ag(r, 0 === e ? 12 : 20),
          n = lg(s, ["mdia", "mdhd"])[0];
        if (n) {
          e = n[0];
          const r = ag(n, 0 === e ? 12 : 20),
            a = lg(s, ["mdia", "hdlr"])[0];
          if (a) {
            const e = rg(a.subarray(8, 12)),
              n = { soun: Xm.AUDIO, vide: Xm.VIDEO }[e],
              o = pg(lg(s, ["mdia", "minf", "stbl", "stsd"])[0]);
            n
              ? ((t[i] = { timescale: r, type: n, stsd: o }),
                (t[n] = Nm({ timescale: r, id: i }, o)))
              : (t[i] = { timescale: r, type: e, stsd: o });
          }
        }
      }
    }
    return (
      lg(e, ["moov", "mvex", "trex"]).forEach(e => {
        const i = ag(e, 4),
          s = t[i];
        s && (s.default = { duration: ag(e, 12), flags: ag(e, 20) });
      }),
      t
    );
  }
  function pg(e) {
    const t = e.subarray(8),
      i = t.subarray(86),
      s = rg(t.subarray(4, 8));
    let r,
      n = s;
    const a = "enca" === s || "encv" === s;
    if (a) {
      const e = lg(t, [s])[0];
      lg(e.subarray("enca" === s ? 28 : 78), ["sinf"]).forEach(e => {
        const t = lg(e, ["schm"])[0];
        if (t) {
          const i = rg(t.subarray(4, 8));
          if ("cbcs" === i || "cenc" === i) {
            const t = lg(e, ["frma"])[0];
            t && (n = rg(t));
          }
        }
      });
    }
    const o = n;
    switch (n) {
      case "avc1":
      case "avc2":
      case "avc3":
      case "avc4": {
        const e = lg(i, ["avcC"])[0];
        (n += "." + mg(e[1]) + mg(e[2]) + mg(e[3])),
          (r = fg("avc1" === o ? "dva1" : "dvav", i));
        break;
      }
      case "mp4a": {
        const e = lg(t, [s])[0],
          i = lg(e.subarray(28), ["esds"])[0];
        if (i && i.length > 7) {
          let e = 4;
          if (3 !== i[e++]) break;
          (e = Eg(i, e)), (e += 2);
          const t = i[e++];
          if ((128 & t && (e += 2), 64 & t && (e += i[e++]), 4 !== i[e++]))
            break;
          e = Eg(i, e);
          const s = i[e++];
          if (64 !== s) break;
          if (((n += "." + mg(s)), (e += 12), 5 !== i[e++])) break;
          e = Eg(i, e);
          const r = i[e++];
          let a = (248 & r) >> 3;
          31 === a && (a += 1 + ((7 & r) << 3) + ((224 & i[e]) >> 5)),
            (n += "." + a);
        }
        break;
      }
      case "hvc1":
      case "hev1": {
        const e = lg(i, ["hvcC"]);
        if (e) {
          const t = e[0],
            i = t[1],
            s = ["", "A", "B", "C"][i >> 6],
            r = 31 & i,
            a = ag(t, 2),
            o = (32 & i) >> 5 ? "H" : "L",
            c = t[12],
            d = t.subarray(6, 12);
          (n += "." + s + r),
            (n += "." + a.toString(16).toUpperCase()),
            (n += "." + o + c);
          let l = "";
          for (let e = d.length; e--; ) {
            const t = d[e];
            if (t || l) {
              l = "." + t.toString(16).toUpperCase() + l;
            }
          }
          n += l;
        }
        r = fg("hev1" == o ? "dvhe" : "dvh1", i);
        break;
      }
      case "dvh1":
      case "dvhe":
      case "dvav":
      case "dva1":
      case "dav1":
        n = fg(n, i) || n;
        break;
      case "vp09": {
        const e = lg(i, ["vpcC"])[0],
          t = e[4],
          s = e[5],
          r = (e[6] >> 4) & 15;
        n += "." + gg(t) + "." + gg(s) + "." + gg(r);
        break;
      }
      case "av01": {
        const e = lg(i, ["av1C"])[0],
          t = e[1] >>> 5,
          s = 31 & e[1],
          a = e[2] >>> 7 ? "H" : "M",
          o = (64 & e[2]) >> 6,
          c = (32 & e[2]) >> 5,
          d = 2 === t && o ? (c ? 12 : 10) : o ? 10 : 8,
          l = (16 & e[2]) >> 4,
          h = (8 & e[2]) >> 3,
          u = (4 & e[2]) >> 2,
          p = 3 & e[2],
          f = 1,
          E = 1,
          m = 1,
          g = 0;
        (n +=
          "." +
          t +
          "." +
          gg(s) +
          a +
          "." +
          gg(d) +
          "." +
          l +
          "." +
          h +
          u +
          p +
          "." +
          gg(f) +
          "." +
          gg(E) +
          "." +
          gg(m) +
          "." +
          g),
          (r = fg("dav1", i));
        break;
      }
    }
    return { codec: n, encrypted: a, supplemental: r };
  }
  function fg(e, t) {
    const i = lg(t, ["dvvC"]),
      s = i.length ? i[0] : lg(t, ["dvcC"])[0];
    if (s) {
      const t = (s[2] >> 1) & 127,
        i = ((s[2] << 5) & 32) | ((s[3] >> 3) & 31);
      return e + "." + gg(t) + "." + gg(i);
    }
  }
  function Eg(e, t) {
    const i = t + 5;
    for (; 128 & e[t++] && t < i; );
    return t;
  }
  function mg(e) {
    return ("0" + e.toString(16).toUpperCase()).slice(-2);
  }
  function gg(e) {
    return (e < 10 ? "0" : "") + e;
  }
  function _g(e) {
    const t = lg(e, ["schm"])[0];
    if (t) {
      const i = rg(t.subarray(4, 8));
      if ("cbcs" === i || "cenc" === i) return lg(e, ["schi", "tenc"])[0];
    }
    return null;
  }
  function Tg(e) {
    const t = ag(e, 0);
    let i = 8;
    1 & t && (i += 4), 4 & t && (i += 4);
    let s = 0;
    const r = ag(e, 4);
    for (let n = 0; n < r; n++) {
      if (256 & t) {
        (s += ag(e, i)), (i += 4);
      }
      512 & t && (i += 4), 1024 & t && (i += 4), 2048 & t && (i += 4);
    }
    return s;
  }
  function Sg(e, t) {
    const i = new Uint8Array(e.length + t.length);
    return i.set(e), i.set(t, e.length), i;
  }
  function vg(e, t) {
    const i = [],
      s = t.samples,
      r = t.timescale,
      n = t.id;
    let a = !1;
    return (
      lg(s, ["moof"]).map(o => {
        const c = o.byteOffset - 8;
        lg(o, ["traf"]).map(o => {
          const d = lg(o, ["tfdt"]).map(e => {
            const t = e[0];
            let i = ag(e, 4);
            return 1 === t && ((i *= Math.pow(2, 32)), (i += ag(e, 8))), i / r;
          })[0];
          return (
            void 0 !== d && (e = d),
            lg(o, ["tfhd"]).map(d => {
              const l = ag(d, 4),
                h = 16777215 & ag(d, 0);
              let u = 0;
              const p = 0 != (16 & h);
              let f = 0;
              const E = 0 != (32 & h);
              let m = 8;
              l === n &&
                (0 != (1 & h) && (m += 8),
                0 != (2 & h) && (m += 4),
                0 != (8 & h) && ((u = ag(d, m)), (m += 4)),
                p && ((f = ag(d, m)), (m += 4)),
                E && (m += 4),
                "video" === t.type && (a = Rg(t.codec)),
                lg(o, ["trun"]).map(n => {
                  const o = n[0],
                    d = 16777215 & ag(n, 0),
                    l = 0 != (1 & d);
                  let h = 0;
                  const p = 0 != (4 & d),
                    E = 0 != (256 & d);
                  let m = 0;
                  const g = 0 != (512 & d);
                  let _ = 0;
                  const T = 0 != (1024 & d),
                    S = 0 != (2048 & d);
                  let v = 0;
                  const R = ag(n, 4);
                  let y = 8;
                  l && ((h = ag(n, y)), (y += 4)), p && (y += 4);
                  let A = h + c;
                  for (let c = 0; c < R; c++) {
                    if (
                      (E ? ((m = ag(n, y)), (y += 4)) : (m = u),
                      g ? ((_ = ag(n, y)), (y += 4)) : (_ = f),
                      T && (y += 4),
                      S && ((v = 0 === o ? ag(n, y) : cg(n, y)), (y += 4)),
                      t.type === Xm.VIDEO)
                    ) {
                      let t = 0;
                      for (; t < _; ) {
                        const n = ag(s, A);
                        if (((A += 4), yg(a, s[A]))) {
                          Ag(s.subarray(A, A + n), a ? 2 : 1, e + v / r, i);
                        }
                        (A += n), (t += n + 4);
                      }
                    }
                    e += m / r;
                  }
                }));
            })
          );
        });
      }),
      i
    );
  }
  function Rg(e) {
    if (!e) return !1;
    const t = e.substring(0, 4);
    return "hvc1" === t || "hev1" === t || "dvh1" === t || "dvhe" === t;
  }
  function yg(e, t) {
    if (e) {
      const e = (t >> 1) & 63;
      return 39 === e || 40 === e;
    }
    return 6 === (31 & t);
  }
  function Ag(e, t, i, s) {
    const r = Ig(e);
    let n = 0;
    n += t;
    let a = 0,
      o = 0,
      c = 0;
    for (; n < r.length; ) {
      a = 0;
      do {
        if (n >= r.length) break;
        (c = r[n++]), (a += c);
      } while (255 === c);
      o = 0;
      do {
        if (n >= r.length) break;
        (c = r[n++]), (o += c);
      } while (255 === c);
      const e = r.length - n;
      let t = n;
      if (o < e) n += o;
      else if (o > e) {
        Bm.error(
          `Malformed SEI payload. ${o} is too small, only ${e} bytes left to parse.`
        );
        break;
      }
      if (4 === a) {
        if (181 === r[t++]) {
          const e = ng(r, t);
          if (((t += 2), 49 === e)) {
            const e = ag(r, t);
            if (((t += 4), 1195456820 === e)) {
              const e = r[t++];
              if (3 === e) {
                const n = r[t++],
                  o = 64 & n,
                  c = o ? 2 + 3 * (31 & n) : 0,
                  d = new Uint8Array(c);
                if (o) {
                  d[0] = n;
                  for (let e = 1; e < c; e++) d[e] = r[t++];
                }
                s.push({ type: e, payloadType: a, pts: i, bytes: d });
              }
            }
          }
        }
      } else if (5 === a && o > 16) {
        const e = [];
        for (let i = 0; i < 16; i++) {
          const s = r[t++].toString(16);
          e.push(1 == s.length ? "0" + s : s),
            (3 !== i && 5 !== i && 7 !== i && 9 !== i) || e.push("-");
        }
        const n = o - 16,
          c = new Uint8Array(n);
        for (let e = 0; e < n; e++) c[e] = r[t++];
        s.push({
          payloadType: a,
          pts: i,
          uuid: e.join(""),
          userData: jm(c),
          userDataBytes: c
        });
      }
    }
  }
  function Ig(e) {
    const t = e.byteLength,
      i = [];
    let s = 1;
    for (; s < t - 2; )
      0 === e[s] && 0 === e[s + 1] && 3 === e[s + 2]
        ? (i.push(s + 2), (s += 2))
        : s++;
    if (0 === i.length) return e;
    const r = t - i.length,
      n = new Uint8Array(r);
    let a = 0;
    for (s = 0; s < r; a++, s++) a === i[0] && (a++, i.shift()), (n[s] = e[a]);
    return n;
  }
  function Cg(e, t, i) {
    if (16 !== e.byteLength) throw new RangeError("Invalid system id");
    let s, r, n;
    (s = 0), (r = new Uint8Array()), (n = new Uint8Array());
    const a = new Uint8Array(4);
    return (
      i &&
        i.byteLength > 0 &&
        new DataView(a.buffer).setUint32(0, i.byteLength, !1),
      (function(e, ...t) {
        const i = t.length;
        let s = 8,
          r = i;
        for (; r--; ) s += t[r].byteLength;
        const n = new Uint8Array(s);
        for (
          n[0] = (s >> 24) & 255,
            n[1] = (s >> 16) & 255,
            n[2] = (s >> 8) & 255,
            n[3] = 255 & s,
            n.set(e, 4),
            r = 0,
            s = 8;
          r < i;
          r++
        )
          n.set(t[r], s), (s += t[r].byteLength);
        return n;
      })(
        [112, 115, 115, 104],
        new Uint8Array([0, 0, 0, 0]),
        e,
        n,
        r,
        a,
        i || new Uint8Array()
      )
    );
  }
  function bg(e) {
    const t = e.getUint32(0),
      i = e.byteOffset,
      s = e.byteLength;
    if (s < t) return { offset: i, size: s };
    if (1886614376 !== e.getUint32(4)) return { offset: i, size: t };
    const r = e.getUint32(8) >>> 24;
    if (0 !== r && 1 !== r) return { offset: i, size: t };
    const n = e.buffer,
      a = Hm.hexDump(new Uint8Array(n, i + 12, 16)),
      o = e.getUint32(28);
    let c = null,
      d = null;
    if (0 === r) {
      if (t - 32 < o || o < 22) return { offset: i, size: t };
      d = new Uint8Array(n, i + 32, o);
    } else if (1 === r) {
      if (!o || s < i + 32 + 16 * o + 16) return { offset: i, size: t };
      c = [];
      for (let e = 0; e < o; e++)
        c.push(new Uint8Array(n, i + 32 + 16 * e, 16));
    }
    return { version: r, systemId: a, kids: c, data: d, offset: i, size: t };
  }
  const Og = () => /\(Windows.+Firefox\//i.test(navigator.userAgent),
    Dg = {
      audio: {
        a3ds: 1,
        "ac-3": 0.95,
        "ac-4": 1,
        alac: 0.9,
        alaw: 1,
        dra1: 1,
        "dts+": 1,
        "dts-": 1,
        dtsc: 1,
        dtse: 1,
        dtsh: 1,
        "ec-3": 0.9,
        enca: 1,
        fLaC: 0.9,
        flac: 0.9,
        FLAC: 0.9,
        g719: 1,
        g726: 1,
        m4ae: 1,
        mha1: 1,
        mha2: 1,
        mhm1: 1,
        mhm2: 1,
        mlpa: 1,
        mp4a: 1,
        "raw ": 1,
        Opus: 1,
        opus: 1,
        samr: 1,
        sawb: 1,
        sawp: 1,
        sevc: 1,
        sqcp: 1,
        ssmv: 1,
        twos: 1,
        ulaw: 1
      },
      video: {
        avc1: 1,
        avc2: 1,
        avc3: 1,
        avc4: 1,
        avcp: 1,
        av01: 0.8,
        dav1: 0.8,
        drac: 1,
        dva1: 1,
        dvav: 1,
        dvh1: 0.7,
        dvhe: 0.7,
        encv: 1,
        hev1: 0.75,
        hvc1: 0.75,
        mjp2: 1,
        mp4v: 1,
        mvc1: 1,
        mvc2: 1,
        mvc3: 1,
        mvc4: 1,
        resv: 1,
        rv60: 1,
        s263: 1,
        svc1: 1,
        svc2: 1,
        "vc-1": 1,
        vp08: 1,
        vp09: 0.9
      },
      text: { stpp: 1, wvtt: 1 }
    };
  function wg(e, t) {
    const i = Dg[t];
    return !!i && !!i[e.slice(0, 4)];
  }
  function Lg(e, t, i = !0) {
    return !e.split(",").some(e => !Ng(e, t, i));
  }
  function Ng(e, t, i = !0) {
    var s;
    const r = Vm(i);
    return null != (s = null == r ? void 0 : r.isTypeSupported(Pg(e, t))) && s;
  }
  function Pg(e, t) {
    return `${t}/mp4;codecs=${e}`;
  }
  function kg(e) {
    if (e) {
      const t = e.substring(0, 4);
      return Dg.video[t];
    }
    return 2;
  }
  function Mg(e) {
    const t = Og();
    return e.split(",").reduce((e, i) => {
      const s = t && Rg(i) ? 9 : Dg.video[i];
      return s ? (2 * s + e) / (e ? 3 : 2) : (Dg.audio[i] + e) / (e ? 2 : 1);
    }, 0);
  }
  const Ug = {};
  const xg = /flac|opus|mp4a\.40\.34/i;
  function Fg(e, t = !0) {
    return e.replace(xg, e =>
      (function(e, t = !0) {
        if (Ug[e]) return Ug[e];
        const i = {
          flac: ["flac", "fLaC", "FLAC"],
          opus: ["opus", "Opus"],
          "mp4a.40.34": ["mp3"]
        }[e];
        for (let r = 0; r < i.length; r++) {
          var s;
          if (Ng(i[r], "audio", t)) return (Ug[e] = i[r]), i[r];
          if (
            "mp3" === i[r] &&
            null != (s = Vm(t)) &&
            s.isTypeSupported("audio/mpeg")
          )
            return "";
        }
        return e;
      })(e.toLowerCase(), t)
    );
  }
  function Bg(e, t) {
    if (
      e &&
      (e.length > 4 ||
        -1 !== ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(e))
    )
      return e;
    if (t) {
      const i = t.split(",");
      if (i.length > 1) {
        if (e)
          for (let t = i.length; t--; )
            if (i[t].substring(0, 4) === e.substring(0, 4)) return i[t];
        return i[0];
      }
    }
    return t || e;
  }
  function Vg(e) {
    if (e.startsWith("av01.")) {
      const t = e.split("."),
        i = ["0", "111", "01", "01", "01", "0"];
      for (let e = t.length; e > 4 && e < 10; e++) t[e] = i[e - 4];
      return t.join(".");
    }
    return e;
  }
  function Gg(e) {
    const t = Vm(e) || { isTypeSupported: () => !1 };
    return {
      mpeg: t.isTypeSupported("audio/mpeg"),
      mp3: t.isTypeSupported('audio/mp4; codecs="mp3"'),
      ac3: t.isTypeSupported('audio/mp4; codecs="ac-3"')
    };
  }
  function jg(e) {
    return e.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
  }
  const Hg = {
    supported: !0,
    configurations: [],
    decodingInfoResults: [{ supported: !0, powerEfficient: !0, smooth: !0 }]
  };
  function Kg(e, t) {
    return {
      supported: !1,
      configurations: t,
      decodingInfoResults: [{ supported: !1, smooth: !1, powerEfficient: !1 }],
      error: e
    };
  }
  const Wg = {};
  function Yg(e, t, i, s, r, n) {
    const a = e.audioCodec ? e.audioGroups : null,
      o = null == n ? void 0 : n.audioCodec,
      c = null == n ? void 0 : n.channels,
      d = c ? parseInt(c) : o ? 1 / 0 : 2;
    let l = null;
    if (null != a && a.length)
      try {
        l =
          1 === a.length && a[0]
            ? t.groups[a[0]].channels
            : a.reduce(
                (e, i) => {
                  if (i) {
                    const s = t.groups[i];
                    if (!s) throw new Error(`Audio track group ${i} not found`);
                    Object.keys(s.channels).forEach(t => {
                      e[t] = (e[t] || 0) + s.channels[t];
                    });
                  }
                  return e;
                },
                { 2: 0 }
              );
      } catch (e) {
        return !0;
      }
    return (
      (void 0 !== e.videoCodec &&
        ((e.width > 1920 && e.height > 1088) ||
          (e.height > 1920 && e.width > 1088) ||
          e.frameRate > Math.max(s, 30) ||
          ("SDR" !== e.videoRange && e.videoRange !== i) ||
          e.bitrate > Math.max(r, 8e6))) ||
      (!!l && Tm(d) && Object.keys(l).some(e => parseInt(e) > d))
    );
  }
  function $g(e, t, i) {
    const s = e.videoCodec,
      r = e.audioCodec;
    if ((!s && !r) || !i) return Promise.resolve(Hg);
    const n = [];
    if (s) {
      const t = {
          width: e.width,
          height: e.height,
          bitrate: Math.ceil(Math.max(0.9 * e.bitrate, e.averageBitrate)),
          framerate: e.frameRate || 30
        },
        i = e.videoRange;
      "SDR" !== i && (t.transferFunction = i.toLowerCase());
      const r = s.split(","),
        a = navigator.userAgent;
      if (r.some(e => Rg(e)) && Og())
        return Promise.resolve(
          Kg(
            new Error(
              `Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent sting: (${a})`
            ),
            n
          )
        );
      n.push.apply(
        n,
        r.map(e => ({
          type: "media-source",
          video: Nm(Nm({}, t), {}, { contentType: Pg(Vg(e), "video") })
        }))
      );
    }
    return (
      r &&
        e.audioGroups &&
        e.audioGroups.forEach(e => {
          var i;
          e &&
            (null == (i = t.groups[e]) ||
              i.tracks.forEach(t => {
                if (t.groupId === e) {
                  const e = t.channels || "",
                    i = parseFloat(e);
                  Tm(i) &&
                    i > 2 &&
                    n.push.apply(
                      n,
                      r
                        .split(",")
                        .map(e => ({
                          type: "media-source",
                          audio: {
                            contentType: Pg(e, "audio"),
                            channels: "" + i
                          }
                        }))
                    );
                }
              }));
        }),
      Promise.all(
        n.map(e => {
          const t = (function(e) {
            const { audio: t, video: i } = e,
              s = i || t;
            if (s) {
              const e = jg(s.contentType);
              if (i)
                return `r${i.height}x${i.width}f${Math.ceil(
                  i.framerate
                )}${i.transferFunction || "sd"}_${e}_${Math.ceil(
                  i.bitrate / 1e5
                )}`;
              if (t)
                return `c${t.channels}${t.spatialRendering ? "s" : "n"}_${e}`;
            }
            return "";
          })(e);
          return Wg[t] || (Wg[t] = i.decodingInfo(e));
        })
      )
        .then(e => ({
          supported: !e.some(e => !e.supported),
          configurations: n,
          decodingInfoResults: e
        }))
        .catch(e => ({
          supported: !1,
          configurations: n,
          decodingInfoResults: [],
          error: e
        }))
    );
  }
  const qg = ["NONE", "TYPE-0", "TYPE-1", null];
  const Xg = ["SDR", "PQ", "HLG"];
  var zg = { No: "", Yes: "YES", v2: "v2" };
  function Jg(e) {
    const { canSkipUntil: t, canSkipDateRanges: i, age: s } = e;
    return t && s < t / 2 ? (i ? zg.v2 : zg.Yes) : zg.No;
  }
  class Qg {
    constructor(e, t, i) {
      (this.msn = void 0),
        (this.part = void 0),
        (this.skip = void 0),
        (this.msn = e),
        (this.part = t),
        (this.skip = i);
    }
    addDirectives(e) {
      const t = new self.URL(e);
      return (
        void 0 !== this.msn &&
          t.searchParams.set("_HLS_msn", this.msn.toString()),
        void 0 !== this.part &&
          t.searchParams.set("_HLS_part", this.part.toString()),
        this.skip && t.searchParams.set("_HLS_skip", this.skip),
        t.href
      );
    }
  }
  class Zg {
    constructor(e) {
      if (
        ((this._attrs = void 0),
        (this.audioCodec = void 0),
        (this.bitrate = void 0),
        (this.codecSet = void 0),
        (this.url = void 0),
        (this.frameRate = void 0),
        (this.height = void 0),
        (this.id = void 0),
        (this.name = void 0),
        (this.supplemental = void 0),
        (this.videoCodec = void 0),
        (this.width = void 0),
        (this.details = void 0),
        (this.fragmentError = 0),
        (this.loadError = 0),
        (this.loaded = void 0),
        (this.realBitrate = 0),
        (this.supportedPromise = void 0),
        (this.supportedResult = void 0),
        (this._avgBitrate = 0),
        (this._audioGroups = void 0),
        (this._subtitleGroups = void 0),
        (this._urlId = 0),
        (this.url = [e.url]),
        (this._attrs = [e.attrs]),
        (this.bitrate = e.bitrate),
        e.details && (this.details = e.details),
        (this.id = e.id || 0),
        (this.name = e.name),
        (this.width = e.width || 0),
        (this.height = e.height || 0),
        (this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0)),
        (this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH")),
        (this.audioCodec = e.audioCodec),
        (this.videoCodec = e.videoCodec),
        (this.codecSet = [e.videoCodec, e.audioCodec]
          .filter(e => !!e)
          .map(e => e.substring(0, 4))
          .join(",")),
        "supplemental" in e)
      ) {
        var t;
        this.supplemental = e.supplemental;
        const i = null == (t = e.supplemental) ? void 0 : t.videoCodec;
        i && i !== e.videoCodec && (this.codecSet += `,${i.substring(0, 4)}`);
      }
      this.addGroupId("audio", e.attrs.AUDIO),
        this.addGroupId("text", e.attrs.SUBTITLES);
    }
    get maxBitrate() {
      return Math.max(this.realBitrate, this.bitrate);
    }
    get averageBitrate() {
      return this._avgBitrate || this.realBitrate || this.bitrate;
    }
    get attrs() {
      return this._attrs[0];
    }
    get codecs() {
      return this.attrs.CODECS || "";
    }
    get pathwayId() {
      return this.attrs["PATHWAY-ID"] || ".";
    }
    get videoRange() {
      return this.attrs["VIDEO-RANGE"] || "SDR";
    }
    get score() {
      return this.attrs.optionalFloat("SCORE", 0);
    }
    get uri() {
      return this.url[0] || "";
    }
    hasAudioGroup(e) {
      return e_(this._audioGroups, e);
    }
    hasSubtitleGroup(e) {
      return e_(this._subtitleGroups, e);
    }
    get audioGroups() {
      return this._audioGroups;
    }
    get subtitleGroups() {
      return this._subtitleGroups;
    }
    addGroupId(e, t) {
      if (t)
        if ("audio" === e) {
          let e = this._audioGroups;
          e || (e = this._audioGroups = []), -1 === e.indexOf(t) && e.push(t);
        } else if ("text" === e) {
          let e = this._subtitleGroups;
          e || (e = this._subtitleGroups = []),
            -1 === e.indexOf(t) && e.push(t);
        }
    }
    get urlId() {
      return 0;
    }
    set urlId(e) {}
    get audioGroupIds() {
      return this.audioGroups ? [this.audioGroupId] : void 0;
    }
    get textGroupIds() {
      return this.subtitleGroups ? [this.textGroupId] : void 0;
    }
    get audioGroupId() {
      var e;
      return null == (e = this.audioGroups) ? void 0 : e[0];
    }
    get textGroupId() {
      var e;
      return null == (e = this.subtitleGroups) ? void 0 : e[0];
    }
    addFallback() {}
  }
  function e_(e, t) {
    return !(!t || !e) && -1 !== e.indexOf(t);
  }
  function t_(e, t) {
    let i = !1,
      s = [];
    if ((e && ((i = "SDR" !== e), (s = [e])), t)) {
      s = t.allowedVideoRanges || Xg.slice(0);
      const e = "SDR" !== s.join("") && !t.videoCodec;
      (i =
        void 0 !== t.preferHDR
          ? t.preferHDR
          : e &&
            (function() {
              if ("function" == typeof matchMedia) {
                const e = matchMedia("(dynamic-range: high)"),
                  t = matchMedia("bad query");
                if (e.media !== t.media) return !0 === e.matches;
              }
              return !1;
            })()),
        i || (s = ["SDR"]);
    }
    return { preferHDR: i, allowedVideoRanges: s };
  }
  const i_ = (e, t) =>
    JSON.stringify(
      e,
      (e => {
        const t = new WeakSet();
        return (i, s) => {
          if ((e && (s = e(i, s)), "object" == typeof s && null !== s)) {
            if (t.has(s)) return;
            t.add(s);
          }
          return s;
        };
      })(t)
    );
  function s_(e, t) {
    Bm.log(`[abr] start candidates with "${e}" ignored because ${t}`);
  }
  function r_(e) {
    return e.reduce(
      (e, t) => {
        let i = e.groups[t.groupId];
        i ||
          (i = e.groups[t.groupId] = {
            tracks: [],
            channels: { 2: 0 },
            hasDefault: !1,
            hasAutoSelect: !1
          }),
          i.tracks.push(t);
        const s = t.channels || "2";
        return (
          (i.channels[s] = (i.channels[s] || 0) + 1),
          (i.hasDefault = i.hasDefault || t.default),
          (i.hasAutoSelect = i.hasAutoSelect || t.autoselect),
          i.hasDefault && (e.hasDefaultAudio = !0),
          i.hasAutoSelect && (e.hasAutoSelectAudio = !0),
          e
        );
      },
      { hasDefaultAudio: !1, hasAutoSelectAudio: !1, groups: {} }
    );
  }
  function n_(e) {
    if (!e) return e;
    const {
      lang: t,
      assocLang: i,
      characteristics: s,
      channels: r,
      audioCodec: n
    } = e;
    return {
      lang: t,
      assocLang: i,
      characteristics: s,
      channels: r,
      audioCodec: n
    };
  }
  function a_(e, t, i) {
    if ("attrs" in e) {
      const i = t.indexOf(e);
      if (-1 !== i) return i;
    }
    for (let s = 0; s < t.length; s++) {
      if (o_(e, t[s], i)) return s;
    }
    return -1;
  }
  function o_(e, t, i) {
    const { groupId: s, name: r, lang: n, assocLang: a, default: o } = e,
      c = e.forced;
    return (
      (void 0 === s || t.groupId === s) &&
      (void 0 === r || t.name === r) &&
      (void 0 === n ||
        (function(e, t = "--") {
          if (e.length === t.length) return e === t;
          return e.startsWith(t) || t.startsWith(e);
        })(n, t.lang)) &&
      (void 0 === n || t.assocLang === a) &&
      (void 0 === o || t.default === o) &&
      (void 0 === c || t.forced === c) &&
      (!("characteristics" in e) ||
        (function(e, t = "") {
          const i = e.split(","),
            s = t.split(",");
          return i.length === s.length && !i.some(e => -1 === s.indexOf(e));
        })(e.characteristics || "", t.characteristics)) &&
      (void 0 === i || i(e, t))
    );
  }
  function c_(e, t) {
    const { audioCodec: i, channels: s } = e;
    return !(
      (void 0 !== i &&
        (t.audioCodec || "").substring(0, 4) !== i.substring(0, 4)) ||
      (void 0 !== s && s !== (t.channels || "2"))
    );
  }
  function d_(e, t, i) {
    for (let s = t; s > -1; s--) if (i(e[s])) return s;
    for (let s = t + 1; s < e.length; s++) if (i(e[s])) return s;
    return -1;
  }
  function l_(e, t) {
    var i;
    return !!e && e !== (null == (i = t.loadLevelObj) ? void 0 : i.uri);
  }
  const h_ = {
    search: function(e, t) {
      let i = 0,
        s = e.length - 1,
        r = null,
        n = null;
      for (; i <= s; ) {
        (r = ((i + s) / 2) | 0), (n = e[r]);
        const a = t(n);
        if (a > 0) i = r + 1;
        else {
          if (!(a < 0)) return n;
          s = r - 1;
        }
      }
      return null;
    }
  };
  function u_(e, t, i = 0, s = 0, r = 0.005) {
    let n = null;
    if (e) {
      n = t[1 + e.sn - t[0].sn] || null;
      const s = e.endDTS - i;
      s > 0 && s < 15e-7 && (i += 15e-7),
        n &&
          e.level !== n.level &&
          n.end <= e.end &&
          (n = t[2 + e.sn - t[0].sn] || null);
    } else 0 === i && 0 === t[0].start && (n = t[0]);
    if (
      n &&
      (((!e || e.level === n.level) && 0 === p_(i, s, n)) ||
        (function(e, t, i) {
          if (t && 0 === t.start && t.level < e.level && (t.endPTS || 0) > 0) {
            const s = t.tagList.reduce(
              (e, t) => ("INF" === t[0] && (e += parseFloat(t[1])), e),
              i
            );
            return e.start <= s;
          }
          return !1;
        })(n, e, Math.min(r, s)))
    )
      return n;
    const a = h_.search(t, p_.bind(null, i, s));
    return !a || (a === e && n) ? n : a;
  }
  function p_(e = 0, t = 0, i) {
    if (i.start <= e && i.start + i.duration > e) return 0;
    const s = Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
    return i.start + i.duration - s <= e
      ? 1
      : i.start - s > e && i.start
      ? -1
      : 0;
  }
  function f_(e, t, i) {
    const s = 1e3 * Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
    return (i.endProgramDateTime || 0) - s > e;
  }
  function E_(e, t) {
    return h_.search(e, e => (e.cc < t ? 1 : e.cc > t ? -1 : 0));
  }
  function m_(e) {
    switch (e.details) {
      case ym.FRAG_LOAD_TIMEOUT:
      case ym.KEY_LOAD_TIMEOUT:
      case ym.LEVEL_LOAD_TIMEOUT:
      case ym.MANIFEST_LOAD_TIMEOUT:
        return !0;
    }
    return !1;
  }
  function g_(e, t) {
    const i = m_(t);
    return e.default[(i ? "timeout" : "error") + "Retry"];
  }
  function __(e, t) {
    const i = "linear" === e.backoff ? 1 : Math.pow(2, t);
    return Math.min(i * e.retryDelayMs, e.maxRetryDelayMs);
  }
  function T_(e) {
    return Nm(Nm({}, e), { errorRetry: null, timeoutRetry: null });
  }
  function S_(e, t, i, s) {
    if (!e) return !1;
    const r = null == s ? void 0 : s.code,
      n =
        t < e.maxNumRetry &&
        ((function(e) {
          return (
            (0 === e && !1 === navigator.onLine) ||
            (!!e && (e < 400 || e > 499))
          );
        })(r) ||
          !!i);
    return e.shouldRetry ? e.shouldRetry(e, t, i, s, n) : n;
  }
  var v_ = {
      DoNothing: 0,
      SendEndCallback: 1,
      SendAlternateToPenaltyBox: 2,
      RemoveAlternatePermanently: 3,
      InsertDiscontinuity: 4,
      RetryRequest: 5
    },
    R_ = {
      None: 0,
      MoveAllAlternatesMatchingHost: 1,
      MoveAllAlternatesMatchingHDCP: 2,
      SwitchToSDR: 4
    };
  function y_(e) {
    const t = { action: v_.DoNothing, flags: R_.None };
    return e && (t.resolved = !0), t;
  }
  var A_ = "NOT_LOADED",
    I_ = "APPENDING",
    C_ = "PARTIAL",
    b_ = "OK";
  class O_ {
    constructor(e) {
      (this.activePartLists = Object.create(null)),
        (this.endListFragments = Object.create(null)),
        (this.fragments = Object.create(null)),
        (this.timeRanges = Object.create(null)),
        (this.bufferPadding = 0.2),
        (this.hls = void 0),
        (this.hasGaps = !1),
        (this.hls = e),
        this._registerListeners();
    }
    _registerListeners() {
      const { hls: e } = this;
      e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Am.BUFFER_APPENDED, this.onBufferAppended, this),
        e.on(Am.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(Am.FRAG_LOADED, this.onFragLoaded, this);
    }
    _unregisterListeners() {
      const { hls: e } = this;
      e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Am.BUFFER_APPENDED, this.onBufferAppended, this),
        e.off(Am.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(Am.FRAG_LOADED, this.onFragLoaded, this);
    }
    destroy() {
      this._unregisterListeners(),
        (this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null);
    }
    getAppendedFrag(e, t) {
      const i = this.activePartLists[t];
      if (i)
        for (let t = i.length; t--; ) {
          const s = i[t];
          if (!s) break;
          const r = s.end;
          if (s.start <= e && null !== r && e <= r) return s;
        }
      return this.getBufferedFrag(e, t);
    }
    getBufferedFrag(e, t) {
      return this.getFragAtPos(e, t, !0);
    }
    getFragAtPos(e, t, i) {
      const { fragments: s } = this,
        r = Object.keys(s);
      for (let n = r.length; n--; ) {
        const a = s[r[n]];
        if ((null == a ? void 0 : a.body.type) === t && (!i || a.buffered)) {
          const t = a.body;
          if (t.start <= e && e <= t.end) return t;
        }
      }
      return null;
    }
    detectEvictedFragments(e, t, i, s, r) {
      this.timeRanges && (this.timeRanges[e] = t);
      const n = (null == s ? void 0 : s.fragment.sn) || -1;
      Object.keys(this.fragments).forEach(s => {
        const a = this.fragments[s];
        if (!a) return;
        if (n >= a.body.sn) return;
        if (!a.buffered && (!a.loaded || r))
          return void (a.body.type === i && this.removeFragment(a.body));
        const o = a.range[e];
        o &&
          (0 !== o.time.length
            ? o.time.some(e => {
                const i = !this.isTimeBuffered(e.startPTS, e.endPTS, t);
                return i && this.removeFragment(a.body), i;
              })
            : this.removeFragment(a.body));
      });
    }
    detectPartialFragments(e) {
      const t = this.timeRanges;
      if (!t || "initSegment" === e.frag.sn) return;
      const i = e.frag,
        s = w_(i),
        r = this.fragments[s];
      if (!r || (r.buffered && i.gap)) return;
      const n = !i.relurl;
      if (
        (Object.keys(t).forEach(s => {
          const a = i.elementaryStreams[s];
          if (!a) return;
          const o = t[s],
            c = n || !0 === a.partial;
          r.range[s] = this.getBufferedTimes(i, e.part, c, o);
        }),
        (r.loaded = null),
        Object.keys(r.range).length)
      ) {
        r.buffered = !0;
        (r.body.endList = i.endList || r.body.endList) &&
          (this.endListFragments[r.body.type] = r),
          D_(r) || this.removeParts(i.sn - 1, i.type);
      } else this.removeFragment(r.body);
    }
    removeParts(e, t) {
      const i = this.activePartLists[t];
      i && (this.activePartLists[t] = i.filter(t => t.fragment.sn >= e));
    }
    fragBuffered(e, t) {
      const i = w_(e);
      let s = this.fragments[i];
      !s &&
        t &&
        ((s = this.fragments[i] = {
          body: e,
          appendedPTS: null,
          loaded: null,
          buffered: !1,
          range: Object.create(null)
        }),
        e.gap && (this.hasGaps = !0)),
        s && ((s.loaded = null), (s.buffered = !0));
    }
    getBufferedTimes(e, t, i, s) {
      const r = { time: [], partial: i },
        n = e.start,
        a = e.end,
        o = e.minEndPTS || a,
        c = e.maxStartPTS || n;
      for (let e = 0; e < s.length; e++) {
        const t = s.start(e) - this.bufferPadding,
          i = s.end(e) + this.bufferPadding;
        if (c >= t && o <= i) {
          r.time.push({
            startPTS: Math.max(n, s.start(e)),
            endPTS: Math.min(a, s.end(e))
          });
          break;
        }
        if (n < i && a > t) {
          const t = Math.max(n, s.start(e)),
            i = Math.min(a, s.end(e));
          i > t && ((r.partial = !0), r.time.push({ startPTS: t, endPTS: i }));
        } else if (a <= t) break;
      }
      return r;
    }
    getPartialFragment(e) {
      let t,
        i,
        s,
        r = null,
        n = 0;
      const { bufferPadding: a, fragments: o } = this;
      return (
        Object.keys(o).forEach(c => {
          const d = o[c];
          d &&
            D_(d) &&
            ((i = d.body.start - a),
            (s = d.body.end + a),
            e >= i &&
              e <= s &&
              ((t = Math.min(e - i, s - e)),
              n <= t && ((r = d.body), (n = t))));
        }),
        r
      );
    }
    isEndListAppended(e) {
      const t = this.endListFragments[e];
      return void 0 !== t && (t.buffered || D_(t));
    }
    getState(e) {
      const t = w_(e),
        i = this.fragments[t];
      return i ? (i.buffered ? (D_(i) ? C_ : b_) : I_) : A_;
    }
    isTimeBuffered(e, t, i) {
      let s, r;
      for (let n = 0; n < i.length; n++) {
        if (
          ((s = i.start(n) - this.bufferPadding),
          (r = i.end(n) + this.bufferPadding),
          e >= s && t <= r)
        )
          return !0;
        if (t <= s) return !1;
      }
      return !1;
    }
    onManifestLoading() {
      this.removeAllFragments();
    }
    onFragLoaded(e, t) {
      if ("initSegment" === t.frag.sn || t.frag.bitrateTest) return;
      const i = t.frag,
        s = t.part ? null : t,
        r = w_(i);
      this.fragments[r] = {
        body: i,
        appendedPTS: null,
        loaded: s,
        buffered: !1,
        range: Object.create(null)
      };
    }
    onBufferAppended(e, t) {
      const { frag: i, part: s, timeRanges: r, type: n } = t;
      if ("initSegment" === i.sn) return;
      const a = i.type;
      if (s) {
        let e = this.activePartLists[a];
        e || (this.activePartLists[a] = e = []), e.push(s);
      }
      this.timeRanges = r;
      const o = r[n];
      this.detectEvictedFragments(n, o, a, s);
    }
    onFragBuffered(e, t) {
      this.detectPartialFragments(t);
    }
    hasFragment(e) {
      const t = w_(e);
      return !!this.fragments[t];
    }
    hasFragments(e) {
      const { fragments: t } = this,
        i = Object.keys(t);
      if (!e) return i.length > 0;
      for (let s = i.length; s--; ) {
        const r = t[i[s]];
        if ((null == r ? void 0 : r.body.type) === e) return !0;
      }
      return !1;
    }
    hasParts(e) {
      var t;
      return !(null == (t = this.activePartLists[e]) || !t.length);
    }
    removeFragmentsInRange(e, t, i, s, r) {
      (s && !this.hasGaps) ||
        Object.keys(this.fragments).forEach(n => {
          const a = this.fragments[n];
          if (!a) return;
          const o = a.body;
          o.type !== i ||
            (s && !o.gap) ||
            (o.start < t &&
              o.end > e &&
              (a.buffered || r) &&
              this.removeFragment(o));
        });
    }
    removeFragment(e) {
      const t = w_(e);
      e.clearElementaryStreamInfo();
      const i = this.activePartLists[e.type];
      if (i) {
        const t = e.sn;
        this.activePartLists[e.type] = i.filter(e => e.fragment.sn !== t);
      }
      delete this.fragments[t],
        e.endList && delete this.endListFragments[e.type];
    }
    removeAllFragments() {
      var e, t;
      (this.fragments = Object.create(null)),
        (this.endListFragments = Object.create(null)),
        (this.activePartLists = Object.create(null)),
        (this.hasGaps = !1);
      const i =
        null == (e = this.hls) || null == (t = e.latestLevelDetails)
          ? void 0
          : t.partList;
      i && i.forEach(e => e.clearElementaryStreamInfo());
    }
  }
  function D_(e) {
    var t, i, s;
    return (
      e.buffered &&
      (e.body.gap ||
        (null == (t = e.range.video) ? void 0 : t.partial) ||
        (null == (i = e.range.audio) ? void 0 : i.partial) ||
        (null == (s = e.range.audiovideo) ? void 0 : s.partial))
    );
  }
  function w_(e) {
    return `${e.type}_${e.level}_${e.sn}`;
  }
  var L_ = { cbc: 0, ctr: 1 };
  class N_ {
    constructor(e, t, i) {
      (this.subtle = void 0),
        (this.aesIV = void 0),
        (this.aesMode = void 0),
        (this.subtle = e),
        (this.aesIV = t),
        (this.aesMode = i);
    }
    decrypt(e, t) {
      switch (this.aesMode) {
        case L_.cbc:
          return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t, e);
        case L_.ctr:
          return this.subtle.decrypt(
            { name: "AES-CTR", counter: this.aesIV, length: 64 },
            t,
            e
          );
        default:
          throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
      }
    }
  }
  class P_ {
    constructor() {
      (this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]),
        (this.subMix = [
          new Uint32Array(256),
          new Uint32Array(256),
          new Uint32Array(256),
          new Uint32Array(256)
        ]),
        (this.invSubMix = [
          new Uint32Array(256),
          new Uint32Array(256),
          new Uint32Array(256),
          new Uint32Array(256)
        ]),
        (this.sBox = new Uint32Array(256)),
        (this.invSBox = new Uint32Array(256)),
        (this.key = new Uint32Array(0)),
        (this.ksRows = 0),
        (this.keySize = 0),
        (this.keySchedule = void 0),
        (this.invKeySchedule = void 0),
        this.initTable();
    }
    uint8ArrayToUint32Array_(e) {
      const t = new DataView(e),
        i = new Uint32Array(4);
      for (let e = 0; e < 4; e++) i[e] = t.getUint32(4 * e);
      return i;
    }
    initTable() {
      const e = this.sBox,
        t = this.invSBox,
        i = this.subMix,
        s = i[0],
        r = i[1],
        n = i[2],
        a = i[3],
        o = this.invSubMix,
        c = o[0],
        d = o[1],
        l = o[2],
        h = o[3],
        u = new Uint32Array(256);
      let p = 0,
        f = 0,
        E = 0;
      for (E = 0; E < 256; E++) u[E] = E < 128 ? E << 1 : (E << 1) ^ 283;
      for (E = 0; E < 256; E++) {
        let i = f ^ (f << 1) ^ (f << 2) ^ (f << 3) ^ (f << 4);
        (i = (i >>> 8) ^ (255 & i) ^ 99), (e[p] = i), (t[i] = p);
        const o = u[p],
          E = u[o],
          m = u[E];
        let g = (257 * u[i]) ^ (16843008 * i);
        (s[p] = (g << 24) | (g >>> 8)),
          (r[p] = (g << 16) | (g >>> 16)),
          (n[p] = (g << 8) | (g >>> 24)),
          (a[p] = g),
          (g = (16843009 * m) ^ (65537 * E) ^ (257 * o) ^ (16843008 * p)),
          (c[i] = (g << 24) | (g >>> 8)),
          (d[i] = (g << 16) | (g >>> 16)),
          (l[i] = (g << 8) | (g >>> 24)),
          (h[i] = g),
          p ? ((p = o ^ u[u[u[m ^ o]]]), (f ^= u[u[f]])) : (p = f = 1);
      }
    }
    expandKey(e) {
      const t = this.uint8ArrayToUint32Array_(e);
      let i = !0,
        s = 0;
      for (; s < t.length && i; ) (i = t[s] === this.key[s]), s++;
      if (i) return;
      this.key = t;
      const r = (this.keySize = t.length);
      if (4 !== r && 6 !== r && 8 !== r)
        throw new Error("Invalid aes key size=" + r);
      const n = (this.ksRows = 4 * (r + 6 + 1));
      let a, o;
      const c = (this.keySchedule = new Uint32Array(n)),
        d = (this.invKeySchedule = new Uint32Array(n)),
        l = this.sBox,
        h = this.rcon,
        u = this.invSubMix,
        p = u[0],
        f = u[1],
        E = u[2],
        m = u[3];
      let g, _;
      for (a = 0; a < n; a++)
        a < r
          ? (g = c[a] = t[a])
          : ((_ = g),
            a % r == 0
              ? ((_ = (_ << 8) | (_ >>> 24)),
                (_ =
                  (l[_ >>> 24] << 24) |
                  (l[(_ >>> 16) & 255] << 16) |
                  (l[(_ >>> 8) & 255] << 8) |
                  l[255 & _]),
                (_ ^= h[(a / r) | 0] << 24))
              : r > 6 &&
                a % r == 4 &&
                (_ =
                  (l[_ >>> 24] << 24) |
                  (l[(_ >>> 16) & 255] << 16) |
                  (l[(_ >>> 8) & 255] << 8) |
                  l[255 & _]),
            (c[a] = g = (c[a - r] ^ _) >>> 0));
      for (o = 0; o < n; o++)
        (a = n - o),
          (_ = 3 & o ? c[a] : c[a - 4]),
          (d[o] =
            o < 4 || a <= 4
              ? _
              : p[l[_ >>> 24]] ^
                f[l[(_ >>> 16) & 255]] ^
                E[l[(_ >>> 8) & 255]] ^
                m[l[255 & _]]),
          (d[o] = d[o] >>> 0);
    }
    networkToHostOrderSwap(e) {
      return (
        (e << 24) | ((65280 & e) << 8) | ((16711680 & e) >> 8) | (e >>> 24)
      );
    }
    decrypt(e, t, i) {
      const s = this.keySize + 6,
        r = this.invKeySchedule,
        n = this.invSBox,
        a = this.invSubMix,
        o = a[0],
        c = a[1],
        d = a[2],
        l = a[3],
        h = this.uint8ArrayToUint32Array_(i);
      let u = h[0],
        p = h[1],
        f = h[2],
        E = h[3];
      const m = new Int32Array(e),
        g = new Int32Array(m.length);
      let _, T, S, v, R, y, A, I, C, b, O, D, w, L;
      const N = this.networkToHostOrderSwap;
      for (; t < m.length; ) {
        for (
          C = N(m[t]),
            b = N(m[t + 1]),
            O = N(m[t + 2]),
            D = N(m[t + 3]),
            R = C ^ r[0],
            y = D ^ r[1],
            A = O ^ r[2],
            I = b ^ r[3],
            w = 4,
            L = 1;
          L < s;
          L++
        )
          (_ =
            o[R >>> 24] ^
            c[(y >> 16) & 255] ^
            d[(A >> 8) & 255] ^
            l[255 & I] ^
            r[w]),
            (T =
              o[y >>> 24] ^
              c[(A >> 16) & 255] ^
              d[(I >> 8) & 255] ^
              l[255 & R] ^
              r[w + 1]),
            (S =
              o[A >>> 24] ^
              c[(I >> 16) & 255] ^
              d[(R >> 8) & 255] ^
              l[255 & y] ^
              r[w + 2]),
            (v =
              o[I >>> 24] ^
              c[(R >> 16) & 255] ^
              d[(y >> 8) & 255] ^
              l[255 & A] ^
              r[w + 3]),
            (R = _),
            (y = T),
            (A = S),
            (I = v),
            (w += 4);
        (_ =
          (n[R >>> 24] << 24) ^
          (n[(y >> 16) & 255] << 16) ^
          (n[(A >> 8) & 255] << 8) ^
          n[255 & I] ^
          r[w]),
          (T =
            (n[y >>> 24] << 24) ^
            (n[(A >> 16) & 255] << 16) ^
            (n[(I >> 8) & 255] << 8) ^
            n[255 & R] ^
            r[w + 1]),
          (S =
            (n[A >>> 24] << 24) ^
            (n[(I >> 16) & 255] << 16) ^
            (n[(R >> 8) & 255] << 8) ^
            n[255 & y] ^
            r[w + 2]),
          (v =
            (n[I >>> 24] << 24) ^
            (n[(R >> 16) & 255] << 16) ^
            (n[(y >> 8) & 255] << 8) ^
            n[255 & A] ^
            r[w + 3]),
          (g[t] = N(_ ^ u)),
          (g[t + 1] = N(v ^ p)),
          (g[t + 2] = N(S ^ f)),
          (g[t + 3] = N(T ^ E)),
          (u = C),
          (p = b),
          (f = O),
          (E = D),
          (t += 4);
      }
      return g.buffer;
    }
  }
  class k_ {
    constructor(e, t, i) {
      (this.subtle = void 0),
        (this.key = void 0),
        (this.aesMode = void 0),
        (this.subtle = e),
        (this.key = t),
        (this.aesMode = i);
    }
    expandKey() {
      const e = (function(e) {
        switch (e) {
          case L_.cbc:
            return "AES-CBC";
          case L_.ctr:
            return "AES-CTR";
          default:
            throw new Error(`[FastAESKey] invalid aes mode ${e}`);
        }
      })(this.aesMode);
      return this.subtle.importKey("raw", this.key, { name: e }, !1, [
        "encrypt",
        "decrypt"
      ]);
    }
  }
  class M_ {
    constructor(e, { removePKCS7Padding: t = !0 } = {}) {
      if (
        ((this.logEnabled = !0),
        (this.removePKCS7Padding = void 0),
        (this.subtle = null),
        (this.softwareDecrypter = null),
        (this.key = null),
        (this.fastAesKey = null),
        (this.remainderData = null),
        (this.currentIV = null),
        (this.currentResult = null),
        (this.useSoftware = void 0),
        (this.enableSoftwareAES = void 0),
        (this.enableSoftwareAES = e.enableSoftwareAES),
        (this.removePKCS7Padding = t),
        t)
      )
        try {
          const e = self.crypto;
          e && (this.subtle = e.subtle || e.webkitSubtle);
        } catch (e) {}
      this.useSoftware = !this.subtle;
    }
    destroy() {
      (this.subtle = null),
        (this.softwareDecrypter = null),
        (this.key = null),
        (this.fastAesKey = null),
        (this.remainderData = null),
        (this.currentIV = null),
        (this.currentResult = null);
    }
    isSync() {
      return this.useSoftware;
    }
    flush() {
      const { currentResult: e, remainderData: t } = this;
      if (!e || t) return this.reset(), null;
      const i = new Uint8Array(e);
      return (
        this.reset(),
        this.removePKCS7Padding
          ? (function(e) {
              const t = e.byteLength,
                i = t && new DataView(e.buffer).getUint8(t - 1);
              return i ? e.slice(0, t - i) : e;
            })(i)
          : i
      );
    }
    reset() {
      (this.currentResult = null),
        (this.currentIV = null),
        (this.remainderData = null),
        this.softwareDecrypter && (this.softwareDecrypter = null);
    }
    decrypt(e, t, i, s) {
      return this.useSoftware
        ? new Promise((r, n) => {
            const a = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
            this.softwareDecrypt(a, t, i, s);
            const o = this.flush();
            o
              ? r(o.buffer)
              : n(new Error("[softwareDecrypt] Failed to decrypt data"));
          })
        : this.webCryptoDecrypt(new Uint8Array(e), t, i, s);
    }
    softwareDecrypt(e, t, i, s) {
      const { currentIV: r, currentResult: n, remainderData: a } = this;
      if (s !== L_.cbc || 16 !== t.byteLength)
        return Bm.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
      this.logOnce("JS AES decrypt"),
        a && ((e = Sg(a, e)), (this.remainderData = null));
      const o = this.getValidChunk(e);
      if (!o.length) return null;
      r && (i = r);
      let c = this.softwareDecrypter;
      c || (c = this.softwareDecrypter = new P_()), c.expandKey(t);
      const d = n;
      return (
        (this.currentResult = c.decrypt(o.buffer, 0, i)),
        (this.currentIV = o.slice(-16).buffer),
        d || null
      );
    }
    webCryptoDecrypt(e, t, i, s) {
      if (this.key !== t || !this.fastAesKey) {
        if (!this.subtle)
          return Promise.resolve(this.onWebCryptoError(e, t, i, s));
        (this.key = t), (this.fastAesKey = new k_(this.subtle, t, s));
      }
      return this.fastAesKey
        .expandKey()
        .then(t => {
          if (!this.subtle)
            return Promise.reject(new Error("web crypto not initialized"));
          this.logOnce("WebCrypto AES decrypt");
          return new N_(this.subtle, new Uint8Array(i), s).decrypt(e.buffer, t);
        })
        .catch(
          r => (
            Bm.warn(
              `[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`
            ),
            this.onWebCryptoError(e, t, i, s)
          )
        );
    }
    onWebCryptoError(e, t, i, s) {
      const r = this.enableSoftwareAES;
      if (r) {
        (this.useSoftware = !0),
          (this.logEnabled = !0),
          this.softwareDecrypt(e, t, i, s);
        const r = this.flush();
        if (r) return r.buffer;
      }
      throw new Error(
        "WebCrypto" +
          (r ? " and softwareDecrypt" : "") +
          ": failed to decrypt data"
      );
    }
    getValidChunk(e) {
      let t = e;
      const i = e.length - (e.length % 16);
      return (
        i !== e.length &&
          ((t = e.slice(0, i)), (this.remainderData = e.slice(i))),
        t
      );
    }
    logOnce(e) {
      this.logEnabled && (Bm.log(`[decrypter]: ${e}`), (this.logEnabled = !1));
    }
  }
  const U_ = Math.pow(2, 17);
  class x_ {
    constructor(e) {
      (this.config = void 0),
        (this.loader = null),
        (this.partLoadTimeout = -1),
        (this.config = e);
    }
    destroy() {
      this.loader && (this.loader.destroy(), (this.loader = null));
    }
    abort() {
      this.loader && this.loader.abort();
    }
    load(e, t) {
      const i = e.url;
      if (!i)
        return Promise.reject(
          new V_({
            type: Rm.NETWORK_ERROR,
            details: ym.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            error: new Error(
              "Fragment does not have a " + (i ? "part list" : "url")
            ),
            networkDetails: null
          })
        );
      this.abort();
      const s = this.config,
        r = s.fLoader,
        n = s.loader;
      return new Promise((a, o) => {
        if ((this.loader && this.loader.destroy(), e.gap)) {
          if (e.tagList.some(e => "GAP" === e[0])) return void o(B_(e));
          e.gap = !1;
        }
        const c = (this.loader = r ? new r(s) : new n(s)),
          d = F_(e);
        e.loader = c;
        const l = T_(s.fragLoadPolicy.default),
          h = {
            loadPolicy: l,
            timeout: l.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0,
            highWaterMark: "initSegment" === e.sn ? 1 / 0 : U_
          };
        e.stats = c.stats;
        const u = {
          onSuccess: (t, i, s, r) => {
            this.resetLoader(e, c);
            let n = t.data;
            s.resetIV &&
              e.decryptdata &&
              ((e.decryptdata.iv = new Uint8Array(n.slice(0, 16))),
              (n = n.slice(16))),
              a({ frag: e, part: null, payload: n, networkDetails: r });
          },
          onError: (t, s, r, n) => {
            this.resetLoader(e, c),
              o(
                new V_({
                  type: Rm.NETWORK_ERROR,
                  details: ym.FRAG_LOAD_ERROR,
                  fatal: !1,
                  frag: e,
                  response: Nm({ url: i, data: void 0 }, t),
                  error: new Error(`HTTP Error ${t.code} ${t.text}`),
                  networkDetails: r,
                  stats: n
                })
              );
          },
          onAbort: (t, i, s) => {
            this.resetLoader(e, c),
              o(
                new V_({
                  type: Rm.NETWORK_ERROR,
                  details: ym.INTERNAL_ABORTED,
                  fatal: !1,
                  frag: e,
                  error: new Error("Aborted"),
                  networkDetails: s,
                  stats: t
                })
              );
          },
          onTimeout: (t, i, s) => {
            this.resetLoader(e, c),
              o(
                new V_({
                  type: Rm.NETWORK_ERROR,
                  details: ym.FRAG_LOAD_TIMEOUT,
                  fatal: !1,
                  frag: e,
                  error: new Error(`Timeout after ${h.timeout}ms`),
                  networkDetails: s,
                  stats: t
                })
              );
          }
        };
        t &&
          (u.onProgress = (i, s, r, n) =>
            t({ frag: e, part: null, payload: r, networkDetails: n })),
          c.load(d, h, u);
      });
    }
    loadPart(e, t, i) {
      this.abort();
      const s = this.config,
        r = s.fLoader,
        n = s.loader;
      return new Promise((a, o) => {
        if ((this.loader && this.loader.destroy(), e.gap || t.gap))
          return void o(B_(e, t));
        const c = (this.loader = r ? new r(s) : new n(s)),
          d = F_(e, t);
        e.loader = c;
        const l = T_(s.fragLoadPolicy.default),
          h = {
            loadPolicy: l,
            timeout: l.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0,
            highWaterMark: U_
          };
        (t.stats = c.stats),
          c.load(d, h, {
            onSuccess: (s, r, n, o) => {
              this.resetLoader(e, c), this.updateStatsFromPart(e, t);
              const d = {
                frag: e,
                part: t,
                payload: s.data,
                networkDetails: o
              };
              i(d), a(d);
            },
            onError: (i, s, r, n) => {
              this.resetLoader(e, c),
                o(
                  new V_({
                    type: Rm.NETWORK_ERROR,
                    details: ym.FRAG_LOAD_ERROR,
                    fatal: !1,
                    frag: e,
                    part: t,
                    response: Nm({ url: d.url, data: void 0 }, i),
                    error: new Error(`HTTP Error ${i.code} ${i.text}`),
                    networkDetails: r,
                    stats: n
                  })
                );
            },
            onAbort: (i, s, r) => {
              (e.stats.aborted = t.stats.aborted),
                this.resetLoader(e, c),
                o(
                  new V_({
                    type: Rm.NETWORK_ERROR,
                    details: ym.INTERNAL_ABORTED,
                    fatal: !1,
                    frag: e,
                    part: t,
                    error: new Error("Aborted"),
                    networkDetails: r,
                    stats: i
                  })
                );
            },
            onTimeout: (i, s, r) => {
              this.resetLoader(e, c),
                o(
                  new V_({
                    type: Rm.NETWORK_ERROR,
                    details: ym.FRAG_LOAD_TIMEOUT,
                    fatal: !1,
                    frag: e,
                    part: t,
                    error: new Error(`Timeout after ${h.timeout}ms`),
                    networkDetails: r,
                    stats: i
                  })
                );
            }
          });
      });
    }
    updateStatsFromPart(e, t) {
      const i = e.stats,
        s = t.stats,
        r = s.total;
      if (((i.loaded += s.loaded), r)) {
        const s = Math.round(e.duration / t.duration),
          n = Math.min(Math.round(i.loaded / r), s),
          a = (s - n) * Math.round(i.loaded / n);
        i.total = i.loaded + a;
      } else i.total = Math.max(i.loaded, i.total);
      const n = i.loading,
        a = s.loading;
      n.start
        ? (n.first += a.first - a.start)
        : ((n.start = a.start), (n.first = a.first)),
        (n.end = a.end);
    }
    resetLoader(e, t) {
      (e.loader = null),
        this.loader === t &&
          (self.clearTimeout(this.partLoadTimeout), (this.loader = null)),
        t.destroy();
    }
  }
  function F_(e, t = null) {
    const i = t || e,
      s = {
        frag: e,
        part: t,
        responseType: "arraybuffer",
        url: i.url,
        headers: {},
        rangeStart: 0,
        rangeEnd: 0
      },
      r = i.byteRangeStartOffset,
      n = i.byteRangeEndOffset;
    if (Tm(r) && Tm(n)) {
      var a;
      let t = r,
        i = n;
      if (
        "initSegment" === e.sn &&
        (function(e) {
          return "AES-128" === e || "AES-256" === e;
        })(null == (a = e.decryptdata) ? void 0 : a.method)
      ) {
        const e = n - r;
        e % 16 && (i = n + (16 - (e % 16))),
          0 !== r && ((s.resetIV = !0), (t = r - 16));
      }
      (s.rangeStart = t), (s.rangeEnd = i);
    }
    return s;
  }
  function B_(e, t) {
    const i = new Error(`GAP ${e.gap ? "tag" : "attribute"} found`),
      s = {
        type: Rm.MEDIA_ERROR,
        details: ym.FRAG_GAP,
        fatal: !1,
        frag: e,
        error: i,
        networkDetails: null
      };
    return t && (s.part = t), ((t || e).stats.aborted = !0), new V_(s);
  }
  class V_ extends Error {
    constructor(e) {
      super(e.error.message), (this.data = void 0), (this.data = e);
    }
  }
  class G_ extends Pm {
    constructor(e, t) {
      super(e, t),
        (this._boundTick = void 0),
        (this._tickTimer = null),
        (this._tickInterval = null),
        (this._tickCallCount = 0),
        (this._boundTick = this.tick.bind(this));
    }
    destroy() {
      this.onHandlerDestroying(), this.onHandlerDestroyed();
    }
    onHandlerDestroying() {
      this.clearNextTick(), this.clearInterval();
    }
    onHandlerDestroyed() {}
    hasInterval() {
      return !!this._tickInterval;
    }
    hasNextTick() {
      return !!this._tickTimer;
    }
    setInterval(e) {
      return (
        !this._tickInterval &&
        ((this._tickCallCount = 0),
        (this._tickInterval = self.setInterval(this._boundTick, e)),
        !0)
      );
    }
    clearInterval() {
      return (
        !!this._tickInterval &&
        (self.clearInterval(this._tickInterval),
        (this._tickInterval = null),
        !0)
      );
    }
    clearNextTick() {
      return (
        !!this._tickTimer &&
        (self.clearTimeout(this._tickTimer), (this._tickTimer = null), !0)
      );
    }
    tick() {
      this._tickCallCount++,
        1 === this._tickCallCount &&
          (this.doTick(),
          this._tickCallCount > 1 && this.tickImmediate(),
          (this._tickCallCount = 0));
    }
    tickImmediate() {
      this.clearNextTick(),
        (this._tickTimer = self.setTimeout(this._boundTick, 0));
    }
    doTick() {}
  }
  class j_ {
    constructor(e, t, i, s = 0, r = -1, n = !1) {
      (this.level = void 0),
        (this.sn = void 0),
        (this.part = void 0),
        (this.id = void 0),
        (this.size = void 0),
        (this.partial = void 0),
        (this.transmuxing = {
          start: 0,
          executeStart: 0,
          executeEnd: 0,
          end: 0
        }),
        (this.buffering = {
          audio: { start: 0, executeStart: 0, executeEnd: 0, end: 0 },
          video: { start: 0, executeStart: 0, executeEnd: 0, end: 0 },
          audiovideo: { start: 0, executeStart: 0, executeEnd: 0, end: 0 }
        }),
        (this.level = e),
        (this.sn = t),
        (this.id = i),
        (this.size = s),
        (this.part = r),
        (this.partial = n);
    }
  }
  const H_ = { length: 0, start: () => 0, end: () => 0 };
  class K_ {
    static isBuffered(e, t) {
      if (e) {
        const i = K_.getBuffered(e);
        for (let e = i.length; e--; )
          if (t >= i.start(e) && t <= i.end(e)) return !0;
      }
      return !1;
    }
    static bufferedRanges(e) {
      if (e) {
        const t = K_.getBuffered(e);
        return K_.timeRangesToArray(t);
      }
      return [];
    }
    static timeRangesToArray(e) {
      const t = [];
      for (let i = 0; i < e.length; i++)
        t.push({ start: e.start(i), end: e.end(i) });
      return t;
    }
    static bufferInfo(e, t, i) {
      if (e) {
        const s = K_.bufferedRanges(e);
        if (s.length) return K_.bufferedInfo(s, t, i);
      }
      return { len: 0, start: t, end: t, bufferedIndex: -1 };
    }
    static bufferedInfo(e, t, i) {
      (t = Math.max(0, t)),
        e.length > 1 && e.sort((e, t) => e.start - t.start || t.end - e.end);
      let s = -1,
        r = [];
      if (i)
        for (let n = 0; n < e.length; n++) {
          t >= e[n].start && t <= e[n].end && (s = n);
          const a = r.length;
          if (a) {
            const t = r[a - 1].end;
            e[n].start - t < i
              ? e[n].end > t && (r[a - 1].end = e[n].end)
              : r.push(e[n]);
          } else r.push(e[n]);
        }
      else r = e;
      let n,
        a = 0,
        o = t,
        c = t;
      for (let e = 0; e < r.length; e++) {
        const d = r[e].start,
          l = r[e].end;
        if ((-1 === s && t >= d && t <= l && (s = e), t + i >= d && t < l))
          (o = d), (c = l), (a = c - t);
        else if (t + i < d) {
          n = d;
          break;
        }
      }
      return {
        len: a,
        start: o || 0,
        end: c || 0,
        nextStart: n,
        buffered: e,
        bufferedIndex: s
      };
    }
    static getBuffered(e) {
      try {
        return e.buffered || H_;
      } catch (e) {
        return Bm.log("failed to get media.buffered", e), H_;
      }
    }
  }
  const W_ = /\{\$([a-zA-Z0-9-_]+)\}/g;
  function Y_(e) {
    return W_.test(e);
  }
  function $_(e, t) {
    if (null !== e.variableList || e.hasVariableRefs) {
      const i = e.variableList;
      return t.replace(W_, t => {
        const s = t.substring(2, t.length - 1),
          r = null == i ? void 0 : i[s];
        return void 0 === r
          ? (e.playlistParsingError ||
              (e.playlistParsingError = new Error(
                `Missing preceding EXT-X-DEFINE tag for Variable Reference: "${s}"`
              )),
            t)
          : r;
      });
    }
    return t;
  }
  function q_(e, t, i) {
    let s,
      r,
      n = e.variableList;
    if ((n || (e.variableList = n = {}), "QUERYPARAM" in t)) {
      s = t.QUERYPARAM;
      try {
        const e = new self.URL(i).searchParams;
        if (!e.has(s))
          throw new Error(
            `"${s}" does not match any query parameter in URI: "${i}"`
          );
        r = e.get(s);
      } catch (t) {
        e.playlistParsingError ||
          (e.playlistParsingError = new Error(
            `EXT-X-DEFINE QUERYPARAM: ${t.message}`
          ));
      }
    } else (s = t.NAME), (r = t.VALUE);
    s in n
      ? e.playlistParsingError ||
        (e.playlistParsingError = new Error(
          `EXT-X-DEFINE duplicate Variable Name declarations: "${s}"`
        ))
      : (n[s] = r || "");
  }
  function X_(e, t, i) {
    const s = t.IMPORT;
    if (i && s in i) {
      let t = e.variableList;
      t || (e.variableList = t = {}), (t[s] = i[s]);
    } else e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${s}"`));
  }
  const z_ = /^(\d+)x(\d+)$/,
    J_ = /(.+?)=(".*?"|.*?)(?:,|$)/g;
  class Q_ {
    constructor(e, t) {
      "string" == typeof e && (e = Q_.parseAttrList(e, t)), wm(this, e);
    }
    get clientAttrs() {
      return Object.keys(this).filter(e => "X-" === e.substring(0, 2));
    }
    decimalInteger(e) {
      const t = parseInt(this[e], 10);
      return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
    }
    hexadecimalInteger(e) {
      if (this[e]) {
        let t = (this[e] || "0x").slice(2);
        t = (1 & t.length ? "0" : "") + t;
        const i = new Uint8Array(t.length / 2);
        for (let e = 0; e < t.length / 2; e++)
          i[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16);
        return i;
      }
      return null;
    }
    hexadecimalIntegerAsNumber(e) {
      const t = parseInt(this[e], 16);
      return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
    }
    decimalFloatingPoint(e) {
      return parseFloat(this[e]);
    }
    optionalFloat(e, t) {
      const i = this[e];
      return i ? parseFloat(i) : t;
    }
    enumeratedString(e) {
      return this[e];
    }
    enumeratedStringList(e, t) {
      const i = this[e];
      return (i ? i.split(/[ ,]+/) : []).reduce(
        (e, t) => ((e[t.toLowerCase()] = !0), e),
        t
      );
    }
    bool(e) {
      return "YES" === this[e];
    }
    decimalResolution(e) {
      const t = z_.exec(this[e]);
      if (null !== t)
        return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) };
    }
    static parseAttrList(e, t) {
      let i;
      const s = {};
      for (J_.lastIndex = 0; null !== (i = J_.exec(e)); ) {
        const r = i[1].trim();
        let n = i[2];
        const a = 0 === n.indexOf('"') && n.lastIndexOf('"') === n.length - 1;
        let o = !1;
        if (a) n = n.slice(1, -1);
        else
          switch (r) {
            case "IV":
            case "SCTE35-CMD":
            case "SCTE35-IN":
            case "SCTE35-OUT":
              o = !0;
          }
        if (t && (a || o)) n = $_(t, n);
        else if (!o && !a)
          switch (r) {
            case "CLOSED-CAPTIONS":
              if ("NONE" === n) break;
            case "ALLOWED-CPC":
            case "CLASS":
            case "ASSOC-LANGUAGE":
            case "AUDIO":
            case "BYTERANGE":
            case "CHANNELS":
            case "CHARACTERISTICS":
            case "CODECS":
            case "DATA-ID":
            case "END-DATE":
            case "GROUP-ID":
            case "ID":
            case "IMPORT":
            case "INSTREAM-ID":
            case "KEYFORMAT":
            case "KEYFORMATVERSIONS":
            case "LANGUAGE":
            case "NAME":
            case "PATHWAY-ID":
            case "QUERYPARAM":
            case "RECENTLY-REMOVED-DATERANGES":
            case "SERVER-URI":
            case "STABLE-RENDITION-ID":
            case "STABLE-VARIANT-ID":
            case "START-DATE":
            case "SUBTITLES":
            case "SUPPLEMENTAL-CODECS":
            case "URI":
            case "VALUE":
            case "VIDEO":
            case "X-ASSET-LIST":
            case "X-ASSET-URI":
              Bm.warn(`${e}: attribute ${r} is missing quotes`);
          }
        s[r] = n;
      }
      return s;
    }
  }
  function Z_(e) {
    return "SCTE35-OUT" === e || "SCTE35-IN" === e || "SCTE35-CMD" === e;
  }
  class eT {
    constructor(e, t, i = 0) {
      var s;
      if (
        ((this.attr = void 0),
        (this.tagAnchor = void 0),
        (this.tagOrder = void 0),
        (this._startDate = void 0),
        (this._endDate = void 0),
        (this._dateAtEnd = void 0),
        (this._cue = void 0),
        (this._badValueForSameId = void 0),
        (this.tagAnchor = (null == t ? void 0 : t.tagAnchor) || null),
        (this.tagOrder = null != (s = null == t ? void 0 : t.tagOrder) ? s : i),
        t)
      ) {
        const i = t.attr;
        for (const t in i)
          if (Object.prototype.hasOwnProperty.call(e, t) && e[t] !== i[t]) {
            Bm.warn(
              `DATERANGE tag attribute: "${t}" does not match for tags with ID: "${e.ID}"`
            ),
              (this._badValueForSameId = t);
            break;
          }
        e = wm(new Q_({}), i, e);
      }
      if (
        ((this.attr = e),
        t
          ? ((this._startDate = t._startDate),
            (this._cue = t._cue),
            (this._endDate = t._endDate),
            (this._dateAtEnd = t._dateAtEnd))
          : (this._startDate = new Date(e["START-DATE"])),
        "END-DATE" in this.attr)
      ) {
        const e =
          (null == t ? void 0 : t.endDate) || new Date(this.attr["END-DATE"]);
        Tm(e.getTime()) && (this._endDate = e);
      }
    }
    get id() {
      return this.attr.ID;
    }
    get class() {
      return this.attr.CLASS;
    }
    get cue() {
      const e = this._cue;
      return void 0 === e
        ? (this._cue = this.attr.enumeratedStringList(
            this.attr.CUE ? "CUE" : "X-CUE",
            { pre: !1, post: !1, once: !1 }
          ))
        : e;
    }
    get startTime() {
      const { tagAnchor: e } = this;
      return null === e || null === e.programDateTime
        ? (Bm.warn(
            `Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`
          ),
          NaN)
        : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;
    }
    get startDate() {
      return this._startDate;
    }
    get endDate() {
      const e = this._endDate || this._dateAtEnd;
      if (e) return e;
      const t = this.duration;
      return null !== t
        ? (this._dateAtEnd = new Date(this._startDate.getTime() + 1e3 * t))
        : null;
    }
    get duration() {
      if ("DURATION" in this.attr) {
        const e = this.attr.decimalFloatingPoint("DURATION");
        if (Tm(e)) return e;
      } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
      return null;
    }
    get plannedDuration() {
      return "PLANNED-DURATION" in this.attr
        ? this.attr.decimalFloatingPoint("PLANNED-DURATION")
        : null;
    }
    get endOnNext() {
      return this.attr.bool("END-ON-NEXT");
    }
    get isInterstitial() {
      return "com.apple.hls.interstitial" === this.class;
    }
    get isValid() {
      return (
        !!this.id &&
        !this._badValueForSameId &&
        Tm(this.startDate.getTime()) &&
        (null === this.duration || this.duration >= 0) &&
        (!this.endOnNext || !!this.class) &&
        (!this.attr.CUE ||
          (!this.cue.pre && !this.cue.post) ||
          this.cue.pre !== this.cue.post) &&
        (!this.isInterstitial ||
          "X-ASSET-URI" in this.attr ||
          "X-ASSET-LIST" in this.attr)
      );
    }
  }
  class tT {
    constructor(e) {
      (this.PTSKnown = !1),
        (this.alignedSliding = !1),
        (this.averagetargetduration = void 0),
        (this.endCC = 0),
        (this.endSN = 0),
        (this.fragments = void 0),
        (this.fragmentHint = void 0),
        (this.partList = null),
        (this.dateRanges = void 0),
        (this.dateRangeTagCount = 0),
        (this.live = !0),
        (this.requestScheduled = -1),
        (this.ageHeader = 0),
        (this.advancedDateTime = void 0),
        (this.updated = !0),
        (this.advanced = !0),
        (this.misses = 0),
        (this.startCC = 0),
        (this.startSN = 0),
        (this.startTimeOffset = null),
        (this.targetduration = 0),
        (this.totalduration = 0),
        (this.type = null),
        (this.url = void 0),
        (this.m3u8 = ""),
        (this.version = null),
        (this.canBlockReload = !1),
        (this.canSkipUntil = 0),
        (this.canSkipDateRanges = !1),
        (this.skippedSegments = 0),
        (this.recentlyRemovedDateranges = void 0),
        (this.partHoldBack = 0),
        (this.holdBack = 0),
        (this.partTarget = 0),
        (this.preloadHint = void 0),
        (this.renditionReports = void 0),
        (this.tuneInGoal = 0),
        (this.deltaUpdateFailed = void 0),
        (this.driftStartTime = 0),
        (this.driftEndTime = 0),
        (this.driftStart = 0),
        (this.driftEnd = 0),
        (this.encryptedFragments = void 0),
        (this.playlistParsingError = null),
        (this.variableList = null),
        (this.hasVariableRefs = !1),
        (this.appliedTimelineOffset = void 0),
        (this.fragments = []),
        (this.encryptedFragments = []),
        (this.dateRanges = {}),
        (this.url = e);
    }
    reloaded(e) {
      if (!e) return (this.advanced = !0), void (this.updated = !0);
      const t = this.lastPartSn - e.lastPartSn,
        i = this.lastPartIndex - e.lastPartIndex;
      (this.updated = this.endSN !== e.endSN || !!i || !!t || !this.live),
        (this.advanced = this.endSN > e.endSN || t > 0 || (0 === t && i > 0)),
        this.updated || this.advanced
          ? (this.misses = Math.floor(0.6 * e.misses))
          : (this.misses = e.misses + 1);
    }
    get hasProgramDateTime() {
      return (
        !!this.fragments.length &&
        Tm(this.fragments[this.fragments.length - 1].programDateTime)
      );
    }
    get levelTargetDuration() {
      return this.averagetargetduration || this.targetduration || 10;
    }
    get drift() {
      const e = this.driftEndTime - this.driftStartTime;
      if (e > 0) {
        return (1e3 * (this.driftEnd - this.driftStart)) / e;
      }
      return 1;
    }
    get edge() {
      return this.partEnd || this.fragmentEnd;
    }
    get partEnd() {
      var e;
      return null != (e = this.partList) && e.length
        ? this.partList[this.partList.length - 1].end
        : this.fragmentEnd;
    }
    get fragmentEnd() {
      var e;
      return null != (e = this.fragments) && e.length
        ? this.fragments[this.fragments.length - 1].end
        : 0;
    }
    get fragmentStart() {
      var e;
      return null != (e = this.fragments) && e.length
        ? this.fragments[0].start
        : 0;
    }
    get age() {
      return this.advancedDateTime
        ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3
        : 0;
    }
    get lastPartIndex() {
      var e;
      return null != (e = this.partList) && e.length
        ? this.partList[this.partList.length - 1].index
        : -1;
    }
    get maxPartIndex() {
      const e = this.partList;
      if (e) {
        const t = this.lastPartIndex;
        if (-1 !== t) {
          for (let i = e.length; i--; ) if (e[i].index > t) return e[i].index;
          return t;
        }
      }
      return 0;
    }
    get lastPartSn() {
      var e;
      return null != (e = this.partList) && e.length
        ? this.partList[this.partList.length - 1].fragment.sn
        : this.endSN;
    }
    get expired() {
      if (this.live && this.age && this.misses < 3) {
        const e = this.partEnd - this.fragmentStart;
        return (
          this.age > Math.max(e, this.totalduration) + this.levelTargetDuration
        );
      }
      return !1;
    }
  }
  function iT(e) {
    return "AES-128" === e || "AES-256" === e || "AES-256-CTR" === e;
  }
  function sT(e) {
    switch (e) {
      case "AES-128":
      case "AES-256":
        return L_.cbc;
      case "AES-256-CTR":
        return L_.ctr;
      default:
        throw new Error(`invalid full segment method ${e}`);
    }
  }
  function rT(e) {
    return Uint8Array.from(atob(e), e => e.charCodeAt(0));
  }
  function nT(e) {
    return Uint8Array.from(unescape(encodeURIComponent(e)), e =>
      e.charCodeAt(0)
    );
  }
  function aT(e) {
    const t = e.split(":");
    let i = null;
    if ("data" === t[0] && 2 === t.length) {
      const e = t[1].split(";"),
        s = e[e.length - 1].split(",");
      if (2 === s.length) {
        const t = "base64" === s[0],
          r = s[1];
        t
          ? (e.splice(-1, 1), (i = rT(r)))
          : (i = (function(e) {
              const t = nT(e).subarray(0, 16),
                i = new Uint8Array(16);
              return i.set(t, 16 - t.length), i;
            })(r));
      }
    }
    return i;
  }
  const oT = "undefined" != typeof self ? self : void 0;
  var cT = {
      CLEARKEY: "org.w3.clearkey",
      FAIRPLAY: "com.apple.fps",
      PLAYREADY: "com.microsoft.playready",
      WIDEVINE: "com.widevine.alpha"
    },
    dT = {
      CLEARKEY: "org.w3.clearkey",
      FAIRPLAY: "com.apple.streamingkeydelivery",
      PLAYREADY: "com.microsoft.playready",
      WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
    };
  function lT(e) {
    switch (e) {
      case dT.FAIRPLAY:
        return cT.FAIRPLAY;
      case dT.PLAYREADY:
        return cT.PLAYREADY;
      case dT.WIDEVINE:
        return cT.WIDEVINE;
      case dT.CLEARKEY:
        return cT.CLEARKEY;
    }
  }
  var hT = {
    CENC: "1077efecc0b24d02ace33c1e52e2fb4b",
    CLEARKEY: "e2719d58a985b3c9781ab030af78d30e",
    PLAYREADY: "9a04f07998404286ab92e65be0885f95",
    WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
  };
  function uT(e) {
    return e === hT.WIDEVINE
      ? cT.WIDEVINE
      : e === hT.PLAYREADY
      ? cT.PLAYREADY
      : e === hT.CENC || e === hT.CLEARKEY
      ? cT.CLEARKEY
      : void 0;
  }
  function pT(e) {
    switch (e) {
      case cT.FAIRPLAY:
        return dT.FAIRPLAY;
      case cT.PLAYREADY:
        return dT.PLAYREADY;
      case cT.WIDEVINE:
        return dT.WIDEVINE;
      case cT.CLEARKEY:
        return dT.CLEARKEY;
    }
  }
  function fT(e) {
    const { drmSystems: t, widevineLicenseUrl: i } = e,
      s = t
        ? [cT.FAIRPLAY, cT.WIDEVINE, cT.PLAYREADY, cT.CLEARKEY].filter(
            e => !!t[e]
          )
        : [];
    return !s[cT.WIDEVINE] && i && s.push(cT.WIDEVINE), s;
  }
  const ET =
    null != oT && null != (mT = oT.navigator) && mT.requestMediaKeySystemAccess
      ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator)
      : null;
  var mT;
  function gT(e) {
    const t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2),
      i = String.fromCharCode.apply(null, Array.from(t)),
      s = i.substring(i.indexOf("<"), i.length),
      r = new DOMParser()
        .parseFromString(s, "text/xml")
        .getElementsByTagName("KID")[0];
    if (r) {
      const e = r.childNodes[0]
        ? r.childNodes[0].nodeValue
        : r.getAttribute("VALUE");
      if (e) {
        const t = rT(e).subarray(0, 16);
        return (
          (function(e) {
            const t = function(e, t, i) {
              const s = e[t];
              (e[t] = e[i]), (e[i] = s);
            };
            t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7);
          })(t),
          t
        );
      }
    }
    return null;
  }
  let _T = {};
  class TT {
    static clearKeyUriToKeyIdMap() {
      _T = {};
    }
    constructor(e, t, i, s = [1], r = null) {
      (this.uri = void 0),
        (this.method = void 0),
        (this.keyFormat = void 0),
        (this.keyFormatVersions = void 0),
        (this.encrypted = void 0),
        (this.isCommonEncryption = void 0),
        (this.iv = null),
        (this.key = null),
        (this.keyId = null),
        (this.pssh = null),
        (this.method = e),
        (this.uri = t),
        (this.keyFormat = i),
        (this.keyFormatVersions = s),
        (this.iv = r),
        (this.encrypted = !!e && "NONE" !== e),
        (this.isCommonEncryption = this.encrypted && !iT(e));
    }
    isSupported() {
      if (this.method) {
        if (iT(this.method) || "NONE" === this.method) return !0;
        if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method;
        switch (this.keyFormat) {
          case dT.FAIRPLAY:
          case dT.WIDEVINE:
          case dT.PLAYREADY:
          case dT.CLEARKEY:
            return (
              -1 !==
              [
                "ISO-23001-7",
                "SAMPLE-AES",
                "SAMPLE-AES-CENC",
                "SAMPLE-AES-CTR"
              ].indexOf(this.method)
            );
        }
      }
      return !1;
    }
    getDecryptData(e) {
      if (!this.encrypted || !this.uri) return null;
      if (iT(this.method) && this.uri && !this.iv) {
        "number" != typeof e &&
          (Bm.warn(
            `missing IV for initialization segment with method="${this.method}" - compliance issue`
          ),
          (e = 0));
        const t = (function(e) {
          const t = new Uint8Array(16);
          for (let i = 12; i < 16; i++) t[i] = (e >> (8 * (15 - i))) & 255;
          return t;
        })(e);
        return new TT(
          this.method,
          this.uri,
          "identity",
          this.keyFormatVersions,
          t
        );
      }
      const t = aT(this.uri);
      if (t)
        switch (this.keyFormat) {
          case dT.WIDEVINE:
            (this.pssh = t),
              t.length >= 22 &&
                (this.keyId = t.subarray(t.length - 22, t.length - 6));
            break;
          case dT.PLAYREADY: {
            const e = new Uint8Array([
              154,
              4,
              240,
              121,
              152,
              64,
              66,
              134,
              171,
              146,
              230,
              91,
              224,
              136,
              95,
              149
            ]);
            (this.pssh = Cg(e, 0, t)), (this.keyId = gT(t));
            break;
          }
          default: {
            let e = t.subarray(0, 16);
            if (16 !== e.length) {
              const t = new Uint8Array(16);
              t.set(e, 16 - e.length), (e = t);
            }
            this.keyId = e;
            break;
          }
        }
      if (!this.keyId || 16 !== this.keyId.byteLength) {
        let e = _T[this.uri];
        if (!e) {
          const t = Object.keys(_T).length % Number.MAX_SAFE_INTEGER;
          e = new Uint8Array(16);
          new DataView(e.buffer, 12, 4).setUint32(0, t), (_T[this.uri] = e);
        }
        this.keyId = e;
      }
      return this;
    }
  }
  const ST = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
    vT = /#EXT-X-MEDIA:(.*)/g,
    RT = /^#EXT(?:INF|-X-TARGETDURATION):/m,
    yT = new RegExp(
      [
        /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
        /(?!#) *(\S[^\r\n]*)/.source,
        /#.*/.source
      ].join("|"),
      "g"
    ),
    AT = new RegExp(
      [
        /#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/
          .source,
        /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/
          .source,
        /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source,
        /(#)([^:]*):(.*)/.source,
        /(#)(.*)(?:.*)\r?\n?/.source
      ].join("|")
    );
  class IT {
    static findGroup(e, t) {
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (s.id === t) return s;
      }
    }
    static resolve(e, t) {
      return $m.buildAbsoluteURL(t, e, { alwaysNormalize: !0 });
    }
    static isMediaPlaylist(e) {
      return RT.test(e);
    }
    static parseMasterPlaylist(e, t) {
      const i = {
          contentSteering: null,
          levels: [],
          playlistParsingError: null,
          sessionData: null,
          sessionKeys: null,
          startTimeOffset: null,
          variableList: null,
          hasVariableRefs: Y_(e)
        },
        s = [];
      let r;
      for (ST.lastIndex = 0; null != (r = ST.exec(e)); )
        if (r[1]) {
          var n;
          const e = new Q_(r[1], i),
            a = $_(i, r[2]),
            o = {
              attrs: e,
              bitrate:
                e.decimalInteger("BANDWIDTH") ||
                e.decimalInteger("AVERAGE-BANDWIDTH"),
              name: e.NAME,
              url: IT.resolve(a, t)
            },
            c = e.decimalResolution("RESOLUTION");
          c && ((o.width = c.width), (o.height = c.height)), wT(e.CODECS, o);
          const d = e["SUPPLEMENTAL-CODECS"];
          d && ((o.supplemental = {}), wT(d, o.supplemental)),
            (null != (n = o.unknownCodecs) && n.length) || s.push(o),
            i.levels.push(o);
        } else if (r[3]) {
          const e = r[3],
            s = r[4];
          switch (e) {
            case "SESSION-DATA": {
              const e = new Q_(s, i),
                t = e["DATA-ID"];
              t &&
                (null === i.sessionData && (i.sessionData = {}),
                (i.sessionData[t] = e));
              break;
            }
            case "SESSION-KEY": {
              const e = OT(s, t, i);
              e.encrypted && e.isSupported()
                ? (null === i.sessionKeys && (i.sessionKeys = []),
                  i.sessionKeys.push(e))
                : Bm.warn(
                    `[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${s}"`
                  );
              break;
            }
            case "DEFINE":
              q_(i, new Q_(s, i), t);
              break;
            case "CONTENT-STEERING": {
              const e = new Q_(s, i);
              i.contentSteering = {
                uri: IT.resolve(e["SERVER-URI"], t),
                pathwayId: e["PATHWAY-ID"] || "."
              };
              break;
            }
            case "START":
              i.startTimeOffset = DT(s);
          }
        }
      const a = s.length > 0 && s.length < i.levels.length;
      return (
        (i.levels = a ? s : i.levels),
        0 === i.levels.length &&
          (i.playlistParsingError = new Error("no levels found in manifest")),
        i
      );
    }
    static parseMasterPlaylistMedia(e, t, i) {
      let s;
      const r = {},
        n = i.levels,
        a = {
          AUDIO: n.map(e => ({ id: e.attrs.AUDIO, audioCodec: e.audioCodec })),
          SUBTITLES: n.map(e => ({
            id: e.attrs.SUBTITLES,
            textCodec: e.textCodec
          })),
          "CLOSED-CAPTIONS": []
        };
      let o = 0;
      for (vT.lastIndex = 0; null !== (s = vT.exec(e)); ) {
        const e = new Q_(s[1], i),
          n = e.TYPE;
        if (n) {
          const i = a[n],
            s = r[n] || [];
          r[n] = s;
          const c = e.LANGUAGE,
            d = e["ASSOC-LANGUAGE"],
            l = e.CHANNELS,
            h = e.CHARACTERISTICS,
            u = e["INSTREAM-ID"],
            p = {
              attrs: e,
              bitrate: 0,
              id: o++,
              groupId: e["GROUP-ID"] || "",
              name: e.NAME || c || "",
              type: n,
              default: e.bool("DEFAULT"),
              autoselect: e.bool("AUTOSELECT"),
              forced: e.bool("FORCED"),
              lang: c,
              url: e.URI ? IT.resolve(e.URI, t) : ""
            };
          if (
            (d && (p.assocLang = d),
            l && (p.channels = l),
            h && (p.characteristics = h),
            u && (p.instreamId = u),
            null != i && i.length)
          ) {
            const e = IT.findGroup(i, p.groupId) || i[0];
            LT(p, e, "audioCodec"), LT(p, e, "textCodec");
          }
          s.push(p);
        }
      }
      return r;
    }
    static parseLevelPlaylist(e, t, i, s, r, n) {
      var a;
      const o = { url: t },
        c = new tT(t),
        d = c.fragments,
        l = [];
      let h,
        u,
        p,
        f,
        E = null,
        m = 0,
        g = 0,
        _ = 0,
        T = 0,
        S = 0,
        v = null,
        R = new Qm(s, o),
        y = -1,
        A = !1,
        I = null;
      if (
        ((yT.lastIndex = 0),
        (c.m3u8 = e),
        (c.hasVariableRefs = Y_(e)),
        "#EXTM3U" !== (null == (a = yT.exec(e)) ? void 0 : a[0]))
      )
        return (
          (c.playlistParsingError = new Error(
            "Missing format identifier #EXTM3U"
          )),
          c
        );
      for (; null !== (h = yT.exec(e)); ) {
        A &&
          ((A = !1),
          (R = new Qm(s, o)),
          (R.playlistOffset = _),
          (R.start = _),
          (R.sn = m),
          (R.cc = T),
          S && (R.bitrate = S),
          (R.level = i),
          E &&
            ((R.initSegment = E),
            E.rawProgramDateTime &&
              ((R.rawProgramDateTime = E.rawProgramDateTime),
              (E.rawProgramDateTime = null)),
            I && (R.setByteRange(I), (I = null))));
        const e = h[1];
        if (e) {
          R.duration = parseFloat(e);
          const t = (" " + h[2]).slice(1);
          (R.title = t || null), R.tagList.push(t ? ["INF", e, t] : ["INF", e]);
        } else if (h[3]) {
          if (Tm(R.duration)) {
            (R.playlistOffset = _),
              (R.start = _),
              p && kT(R, p, c),
              (R.sn = m),
              (R.level = i),
              (R.cc = T),
              d.push(R);
            const e = (" " + h[3]).slice(1);
            (R.relurl = $_(c, e)),
              NT(R, v, l),
              (v = R),
              (_ += R.duration),
              m++,
              (g = 0),
              (A = !0);
          }
        } else {
          if (((h = h[0].match(AT)), !h)) {
            Bm.warn("No matches on slow regex match for level playlist!");
            continue;
          }
          for (u = 1; u < h.length && void 0 === h[u]; u++);
          const e = (" " + h[u]).slice(1),
            r = (" " + h[u + 1]).slice(1),
            a = h[u + 2] ? (" " + h[u + 2]).slice(1) : null;
          switch (e) {
            case "BYTERANGE":
              v ? R.setByteRange(r, v) : R.setByteRange(r);
              break;
            case "PROGRAM-DATE-TIME":
              (R.rawProgramDateTime = r),
                R.tagList.push(["PROGRAM-DATE-TIME", r]),
                -1 === y && (y = d.length);
              break;
            case "PLAYLIST-TYPE":
              c.type && MT(c, e, h), (c.type = r.toUpperCase());
              break;
            case "MEDIA-SEQUENCE":
              0 !== c.startSN ? MT(c, e, h) : d.length > 0 && UT(c, e, h),
                (m = c.startSN = parseInt(r));
              break;
            case "SKIP": {
              c.skippedSegments && MT(c, e, h);
              const t = new Q_(r, c),
                i = t.decimalInteger("SKIPPED-SEGMENTS");
              if (Tm(i)) {
                c.skippedSegments += i;
                for (let e = i; e--; ) d.push(null);
                m += i;
              }
              const s = t.enumeratedString("RECENTLY-REMOVED-DATERANGES");
              s &&
                (c.recentlyRemovedDateranges = (
                  c.recentlyRemovedDateranges || []
                ).concat(s.split("\t")));
              break;
            }
            case "TARGETDURATION":
              0 !== c.targetduration && MT(c, e, h),
                (c.targetduration = Math.max(parseInt(r), 1));
              break;
            case "VERSION":
              null !== c.version && MT(c, e, h), (c.version = parseInt(r));
              break;
            case "INDEPENDENT-SEGMENTS":
              break;
            case "ENDLIST":
              c.live || MT(c, e, h), (c.live = !1);
              break;
            case "#":
              (r || a) && R.tagList.push(a ? [r, a] : [r]);
              break;
            case "DISCONTINUITY":
              T++, R.tagList.push(["DIS"]);
              break;
            case "GAP":
              (R.gap = !0), R.tagList.push([e]);
              break;
            case "BITRATE":
              R.tagList.push([e, r]),
                (S = 1e3 * parseInt(r)),
                Tm(S) ? (R.bitrate = S) : (S = 0);
              break;
            case "DATERANGE": {
              const e = new Q_(r, c),
                t = new eT(e, c.dateRanges[e.ID], c.dateRangeTagCount);
              c.dateRangeTagCount++,
                t.isValid || c.skippedSegments
                  ? (c.dateRanges[t.id] = t)
                  : Bm.warn(`Ignoring invalid DATERANGE tag: "${r}"`),
                R.tagList.push(["EXT-X-DATERANGE", r]);
              break;
            }
            case "DEFINE":
              {
                const e = new Q_(r, c);
                "IMPORT" in e ? X_(c, e, n) : q_(c, e, t);
              }
              break;
            case "DISCONTINUITY-SEQUENCE":
              0 !== c.startCC ? MT(c, e, h) : d.length > 0 && UT(c, e, h),
                (c.startCC = T = parseInt(r));
              break;
            case "KEY": {
              const e = OT(r, t, c);
              if (e.isSupported()) {
                if ("NONE" === e.method) {
                  p = void 0;
                  break;
                }
                p || (p = {}),
                  p[e.keyFormat] && (p = wm({}, p)),
                  (p[e.keyFormat] = e);
              } else Bm.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${r}"`);
              break;
            }
            case "START":
              c.startTimeOffset = DT(r);
              break;
            case "MAP": {
              const e = new Q_(r, c);
              if (R.duration) {
                const t = new Qm(s, o);
                PT(t, e, i, p),
                  (E = t),
                  (R.initSegment = E),
                  E.rawProgramDateTime &&
                    !R.rawProgramDateTime &&
                    (R.rawProgramDateTime = E.rawProgramDateTime);
              } else {
                const t = R.byteRangeEndOffset;
                if (t) {
                  const e = R.byteRangeStartOffset;
                  I = `${t - e}@${e}`;
                } else I = null;
                PT(R, e, i, p), (E = R), (A = !0);
              }
              E.cc = T;
              break;
            }
            case "SERVER-CONTROL":
              f && MT(c, e, h),
                (f = new Q_(r)),
                (c.canBlockReload = f.bool("CAN-BLOCK-RELOAD")),
                (c.canSkipUntil = f.optionalFloat("CAN-SKIP-UNTIL", 0)),
                (c.canSkipDateRanges =
                  c.canSkipUntil > 0 && f.bool("CAN-SKIP-DATERANGES")),
                (c.partHoldBack = f.optionalFloat("PART-HOLD-BACK", 0)),
                (c.holdBack = f.optionalFloat("HOLD-BACK", 0));
              break;
            case "PART-INF": {
              c.partTarget && MT(c, e, h);
              const t = new Q_(r);
              c.partTarget = t.decimalFloatingPoint("PART-TARGET");
              break;
            }
            case "PART": {
              let e = c.partList;
              e || (e = c.partList = []);
              const t = g > 0 ? e[e.length - 1] : void 0,
                i = g++,
                s = new Q_(r, c),
                n = new Zm(s, R, o, i, t);
              e.push(n), (R.duration += n.duration);
              break;
            }
            case "PRELOAD-HINT": {
              const e = new Q_(r, c);
              c.preloadHint = e;
              break;
            }
            case "RENDITION-REPORT": {
              const e = new Q_(r, c);
              (c.renditionReports = c.renditionReports || []),
                c.renditionReports.push(e);
              break;
            }
            default:
              Bm.warn(`line parsed but not handled: ${h}`);
          }
        }
      }
      v && !v.relurl
        ? (d.pop(), (_ -= v.duration), c.partList && (c.fragmentHint = v))
        : c.partList &&
          (NT(R, v, l), (R.cc = T), (c.fragmentHint = R), p && kT(R, p, c)),
        c.targetduration ||
          (c.playlistParsingError = new Error(
            "#EXT-X-TARGETDURATION is required"
          ));
      const C = d.length,
        b = d[0],
        O = d[C - 1];
      if (((_ += c.skippedSegments * c.targetduration), _ > 0 && C && O)) {
        c.averagetargetduration = _ / C;
        const e = O.sn;
        (c.endSN = "initSegment" !== e ? e : 0),
          c.live || (O.endList = !0),
          b && void 0 === c.startCC && (c.startCC = b.cc),
          y > 0 &&
            (!(function(e, t) {
              let i = e[t];
              for (let s = t; s--; ) {
                const t = e[s];
                if (!t) return;
                (t.programDateTime = i.programDateTime - 1e3 * t.duration),
                  (i = t);
              }
            })(d, y),
            b && l.unshift(b));
      } else (c.endSN = 0), (c.startCC = 0);
      return (
        c.fragmentHint && (_ += c.fragmentHint.duration),
        (c.totalduration = _),
        l.length && c.dateRangeTagCount && b && CT(l, c),
        (c.endCC = T),
        c
      );
    }
  }
  function CT(e, t) {
    const i = e.length,
      s = e[i - 1],
      r = t.live ? 1 / 0 : t.totalduration,
      n = Object.keys(t.dateRanges);
    for (let a = n.length; a--; ) {
      const o = t.dateRanges[n[a]],
        c = o.startDate.getTime();
      o.tagAnchor = s.ref;
      for (let s = i; s--; ) {
        const i = bT(t, c, e, s, r);
        if (-1 !== i) {
          o.tagAnchor = t.fragments[i].ref;
          break;
        }
      }
    }
  }
  function bT(e, t, i, s, r) {
    const n = i[s];
    if (n) {
      const o = n.programDateTime;
      if (t >= o || 0 === s) {
        var a;
        if (
          t <=
          o +
            1e3 * (((null == (a = i[s + 1]) ? void 0 : a.start) || r) - n.start)
        ) {
          const r = i[s].sn - e.startSN,
            n = e.fragments;
          if (n.length > i.length) {
            for (
              let a = (i[s + 1] || n[n.length - 1]).sn - e.startSN;
              a > r;
              a--
            ) {
              const e = n[a].programDateTime;
              if (t >= e && t < e + 1e3 * n[a].duration) return a;
            }
          }
          return r;
        }
      }
    }
    return -1;
  }
  function OT(e, t, i) {
    var s, r;
    const n = new Q_(e, i),
      a = null != (s = n.METHOD) ? s : "",
      o = n.URI,
      c = n.hexadecimalInteger("IV"),
      d = n.KEYFORMATVERSIONS,
      l = null != (r = n.KEYFORMAT) ? r : "identity";
    o && n.IV && !c && Bm.error(`Invalid IV: ${n.IV}`);
    const h = o ? IT.resolve(o, t) : "",
      u = (d || "1")
        .split("/")
        .map(Number)
        .filter(Number.isFinite);
    return new TT(a, h, l, u, c);
  }
  function DT(e) {
    const t = new Q_(e).decimalFloatingPoint("TIME-OFFSET");
    return Tm(t) ? t : null;
  }
  function wT(e, t) {
    let i = (e || "").split(/[ ,]+/).filter(e => e);
    ["video", "audio", "text"].forEach(e => {
      const s = i.filter(t => wg(t, e));
      s.length &&
        ((t[`${e}Codec`] = s.map(e => e.split("/")[0]).join(",")),
        (i = i.filter(e => -1 === s.indexOf(e))));
    }),
      (t.unknownCodecs = i);
  }
  function LT(e, t, i) {
    const s = t[i];
    s && (e[i] = s);
  }
  function NT(e, t, i) {
    e.rawProgramDateTime
      ? i.push(e)
      : null != t &&
        t.programDateTime &&
        (e.programDateTime = t.endProgramDateTime);
  }
  function PT(e, t, i, s) {
    (e.relurl = t.URI),
      t.BYTERANGE && e.setByteRange(t.BYTERANGE),
      (e.level = i),
      (e.sn = "initSegment"),
      s && (e.levelkeys = s),
      (e.initSegment = null);
  }
  function kT(e, t, i) {
    e.levelkeys = t;
    const { encryptedFragments: s } = i;
    (s.length && s[s.length - 1].levelkeys === t) ||
      !Object.keys(t).some(e => t[e].isCommonEncryption) ||
      s.push(e);
  }
  function MT(e, t, i) {
    e.playlistParsingError = new Error(
      `#EXT-X-${t} must not appear more than once (${i[0]})`
    );
  }
  function UT(e, t, i) {
    e.playlistParsingError = new Error(
      `#EXT-X-${t} must appear before the first Media Segment (${i[0]})`
    );
  }
  function xT(e, t) {
    const i = t.startPTS;
    if (Tm(i)) {
      let s,
        r = 0;
      t.sn > e.sn ? ((r = i - e.start), (s = e)) : ((r = e.start - i), (s = t)),
        s.duration !== r && s.setDuration(r);
    } else if (t.sn > e.sn) {
      e.cc === t.cc && e.minEndPTS
        ? t.setStart(e.start + (e.minEndPTS - e.start))
        : t.setStart(e.start + e.duration);
    } else t.setStart(Math.max(e.start - t.duration, 0));
  }
  function FT(e, t, i, s, r, n) {
    s - i <= 0 &&
      (Bm.warn("Fragment should have a positive duration", t),
      (s = i + t.duration),
      (n = r + t.duration));
    let a = i,
      o = s;
    const c = t.startPTS,
      d = t.endPTS;
    if (Tm(c)) {
      const e = Math.abs(c - i);
      Tm(t.deltaPTS)
        ? (t.deltaPTS = Math.max(e, t.deltaPTS))
        : (t.deltaPTS = e),
        (a = Math.max(i, c)),
        (i = Math.min(i, c)),
        (r = Math.min(r, t.startDTS)),
        (o = Math.min(s, d)),
        (s = Math.max(s, d)),
        (n = Math.max(n, t.endDTS));
    }
    const l = i - t.start;
    0 !== t.start && t.setStart(i),
      t.setDuration(s - t.start),
      (t.startPTS = i),
      (t.maxStartPTS = a),
      (t.startDTS = r),
      (t.endPTS = s),
      (t.minEndPTS = o),
      (t.endDTS = n);
    const h = t.sn;
    if (!e || h < e.startSN || h > e.endSN) return 0;
    let u;
    const p = h - e.startSN,
      f = e.fragments;
    for (f[p] = t, u = p; u > 0; u--) xT(f[u], f[u - 1]);
    for (u = p; u < f.length - 1; u++) xT(f[u], f[u + 1]);
    return (
      e.fragmentHint && xT(f[f.length - 1], e.fragmentHint),
      (e.PTSKnown = e.alignedSliding = !0),
      l
    );
  }
  function BT(e, t) {
    if (e === t) return;
    let i = null;
    const s = e.fragments;
    for (let e = s.length - 1; e >= 0; e--) {
      const t = s[e].initSegment;
      if (t) {
        i = t;
        break;
      }
    }
    let r;
    e.fragmentHint && delete e.fragmentHint.endPTS,
      (function(e, t, i) {
        const s = t.skippedSegments,
          r = Math.max(e.startSN, t.startSN) - t.startSN,
          n =
            (e.fragmentHint ? 1 : 0) +
            (s ? t.endSN : Math.min(e.endSN, t.endSN)) -
            t.startSN,
          a = t.startSN - e.startSN,
          o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments,
          c = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments;
        for (let d = r; d <= n; d++) {
          const r = c[a + d];
          let n = o[d];
          if ((s && !n && r && (n = t.fragments[d] = r), r && n)) {
            if ((i(r, n, d, o), r.url && r.url !== n.url))
              return void (t.playlistParsingError = VT(
                `media sequence mismatch ${n.sn}:`,
                e,
                t,
                r,
                n
              ));
            if (r.cc !== n.cc)
              return void (t.playlistParsingError = VT(
                `discontinuity sequence mismatch (${r.cc}!=${n.cc})`,
                e,
                t,
                r,
                n
              ));
          }
        }
      })(e, t, (e, s, n, a) => {
        if (t.skippedSegments && s.cc !== e.cc) {
          const t = e.cc - s.cc;
          for (let e = n; e < a.length; e++) a[e].cc += t;
        }
        Tm(e.startPTS) &&
          Tm(e.endPTS) &&
          (s.setStart((s.startPTS = e.startPTS)),
          (s.startDTS = e.startDTS),
          (s.maxStartPTS = e.maxStartPTS),
          (s.endPTS = e.endPTS),
          (s.endDTS = e.endDTS),
          (s.minEndPTS = e.minEndPTS),
          s.setDuration(e.endPTS - e.startPTS),
          s.duration && (r = s),
          (t.PTSKnown = t.alignedSliding = !0)),
          e.hasStreams && (s.elementaryStreams = e.elementaryStreams),
          (s.loader = e.loader),
          e.hasStats && (s.stats = e.stats),
          e.initSegment &&
            ((s.initSegment = e.initSegment), (i = e.initSegment));
      });
    const n = t.fragments,
      a = t.fragmentHint ? n.concat(t.fragmentHint) : n;
    if (
      (i &&
        a.forEach(e => {
          var t;
          !e ||
            (e.initSegment &&
              e.initSegment.relurl !== (null == (t = i) ? void 0 : t.relurl)) ||
            (e.initSegment = i);
        }),
      t.skippedSegments)
    )
      if (((t.deltaUpdateFailed = n.some(e => !e)), t.deltaUpdateFailed)) {
        Bm.warn(
          "[level-helper] Previous playlist missing segments skipped in delta playlist"
        );
        for (let e = t.skippedSegments; e--; ) n.shift();
        t.startSN = n[0].sn;
      } else {
        (t.endCC = n[n.length - 1].cc),
          t.canSkipDateRanges &&
            (t.dateRanges = (function(e, t) {
              const { dateRanges: i, recentlyRemovedDateranges: s } = t,
                r = wm({}, e);
              s &&
                s.forEach(e => {
                  delete r[e];
                });
              const n = Object.keys(r).length;
              n &&
                Object.keys(i).forEach(e => {
                  const t = r[e],
                    s = new eT(i[e].attr, t);
                  s.isValid
                    ? ((r[e] = s), t || (s.tagOrder += n))
                    : Bm.warn(
                        `Ignoring invalid Playlist Delta Update DATERANGE tag: "${i_(
                          i[e].attr
                        )}"`
                      );
                });
              return r;
            })(e.dateRanges, t));
        const i = e.fragments.filter(e => e.rawProgramDateTime);
        if (e.hasProgramDateTime && !t.hasProgramDateTime)
          for (let e = 1; e < a.length; e++)
            null === a[e].programDateTime && NT(a[e], a[e - 1], i);
        CT(i, t);
      }
    !(function(e, t, i) {
      if (e && t) {
        let s = 0;
        for (let r = 0, n = e.length; r <= n; r++) {
          const n = e[r],
            a = t[r + s];
          n && a && n.index === a.index && n.fragment.sn === a.fragment.sn
            ? i(n, a)
            : s--;
        }
      }
    })(e.partList, t.partList, (e, t) => {
      (t.elementaryStreams = e.elementaryStreams), (t.stats = e.stats);
    }),
      r ? FT(t, r, r.startPTS, r.endPTS, r.startDTS, r.endDTS) : GT(e, t),
      n.length && (t.totalduration = t.edge - n[0].start),
      (t.driftStartTime = e.driftStartTime),
      (t.driftStart = e.driftStart);
    const o = t.advancedDateTime;
    if (t.advanced && o) {
      const e = t.edge;
      t.driftStart || ((t.driftStartTime = o), (t.driftStart = e)),
        (t.driftEndTime = o),
        (t.driftEnd = e);
    } else (t.driftEndTime = e.driftEndTime), (t.driftEnd = e.driftEnd), (t.advancedDateTime = e.advancedDateTime);
    -1 === t.requestScheduled && (t.requestScheduled = e.requestScheduled);
  }
  function VT(e, t, i, s, r) {
    return new Error(
      `${e} ${r.url}\nPlaylist starting @${t.startSN}\n${t.m3u8}\n\nPlaylist starting @${i.startSN}\n${i.m3u8}`
    );
  }
  function GT(e, t, i = !0) {
    const s = t.startSN + t.skippedSegments - e.startSN,
      r = e.fragments,
      n = s >= 0;
    let a = 0;
    if (n && s < r.length) a = r[s].start;
    else if (n && t.startSN === e.endSN + 1) a = e.fragmentEnd;
    else if (n && i) a = e.fragmentStart + s * t.levelTargetDuration;
    else {
      if (t.skippedSegments || 0 !== t.fragmentStart) return;
      a = e.fragmentStart;
    }
    jT(t, a);
  }
  function jT(e, t) {
    if (t) {
      const i = e.fragments;
      for (let s = e.skippedSegments; s < i.length; s++) i[s].addStart(t);
      e.fragmentHint && e.fragmentHint.addStart(t);
    }
  }
  function HT(e, t = 1 / 0) {
    let i = 1e3 * e.targetduration;
    if (e.updated) {
      const s = e.fragments,
        r = 4;
      if (s.length && i * r > t) {
        const e = 1e3 * s[s.length - 1].duration;
        e < i && (i = e);
      }
    } else i /= 2;
    return Math.round(i);
  }
  function KT(e, t, i) {
    return e ? WT(e.partList, t, i) : null;
  }
  function WT(e, t, i) {
    if (e)
      for (let s = e.length; s--; ) {
        const r = e[s];
        if (r.index === i && r.fragment.sn === t) return r;
      }
    return null;
  }
  function YT(e) {
    e.forEach((e, t) => {
      var i;
      null == (i = e.details) ||
        i.fragments.forEach(e => {
          (e.level = t), e.initSegment && (e.initSegment.level = t);
        });
    });
  }
  function $T(e, t) {
    for (let s = 0, r = e.length; s < r; s++) {
      var i;
      if ((null == (i = e[s]) ? void 0 : i.cc) === t) return e[s];
    }
    return null;
  }
  function qT(e, t) {
    if (e) {
      const i = e.start + t;
      (e.start = e.startPTS = i), (e.endPTS = i + e.duration);
    }
  }
  function XT(e, t) {
    const i = t.fragments;
    for (let t = 0, s = i.length; t < s; t++) qT(i[t], e);
    t.fragmentHint && qT(t.fragmentHint, e), (t.alignedSliding = !0);
  }
  function zT(e, t) {
    if (
      !(function(e, t) {
        return !!(e && t.startCC < e.endCC && t.endCC > e.startCC);
      })(t, e)
    )
      return;
    const i = Math.min(t.endCC, e.endCC),
      s = $T(t.fragments, i),
      r = $T(e.fragments, i);
    if (!s || !r) return;
    Bm.log(`Aligning playlist at start of dicontinuity sequence ${i}`);
    XT(s.start - r.start, e);
  }
  function JT(e, t) {
    if (!e.hasProgramDateTime || !t.hasProgramDateTime) return;
    const i = e.fragments,
      s = t.fragments;
    if (!i.length || !s.length) return;
    let r, n;
    const a = Math.min(t.endCC, e.endCC);
    t.startCC < a && e.startCC < a && ((r = $T(s, a)), (n = $T(i, a))),
      (r && n) ||
        ((r = s[Math.floor(s.length / 2)]),
        (n = $T(i, r.cc) || i[Math.floor(i.length / 2)]));
    const o = r.programDateTime,
      c = n.programDateTime;
    if (!o || !c) return;
    XT((c - o) / 1e3 - (n.start - r.start), e);
  }
  const QT = function(e) {
      let t = "";
      const i = e.length;
      for (let s = 0; s < i; s++)
        t += `[${e.start(s).toFixed(3)}-${e.end(s).toFixed(3)}]`;
      return t;
    },
    ZT = {
      STOPPED: "STOPPED",
      IDLE: "IDLE",
      KEY_LOADING: "KEY_LOADING",
      FRAG_LOADING: "FRAG_LOADING",
      FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
      WAITING_TRACK: "WAITING_TRACK",
      PARSING: "PARSING",
      PARSED: "PARSED",
      ENDED: "ENDED",
      ERROR: "ERROR",
      WAITING_INIT_PTS: "WAITING_INIT_PTS",
      WAITING_LEVEL: "WAITING_LEVEL"
    };
  class eS extends G_ {
    constructor(e, t, i, s, r) {
      super(s, e.logger),
        (this.hls = void 0),
        (this.fragPrevious = null),
        (this.fragCurrent = null),
        (this.fragmentTracker = void 0),
        (this.transmuxer = null),
        (this._state = ZT.STOPPED),
        (this.playlistType = void 0),
        (this.media = null),
        (this.mediaBuffer = null),
        (this.config = void 0),
        (this.bitrateTest = !1),
        (this.lastCurrentTime = 0),
        (this.nextLoadPosition = 0),
        (this.startPosition = 0),
        (this.startTimeOffset = null),
        (this.retryDate = 0),
        (this.levels = null),
        (this.fragmentLoader = void 0),
        (this.keyLoader = void 0),
        (this.levelLastLoaded = null),
        (this.startFragRequested = !1),
        (this.decrypter = void 0),
        (this.initPTS = []),
        (this.buffering = !0),
        (this.loadingParts = !1),
        (this.loopSn = void 0),
        (this.onMediaSeeking = () => {
          const {
              config: e,
              fragCurrent: t,
              media: i,
              mediaBuffer: s,
              state: r
            } = this,
            n = i ? i.currentTime : 0,
            a = K_.bufferInfo(s || i, n, e.maxBufferHole);
          if (
            (this.log(
              `media seeking to ${Tm(n) ? n.toFixed(3) : n}, state: ${r}`
            ),
            this.state === ZT.ENDED)
          )
            this.resetLoadingState();
          else if (t) {
            const i = e.maxFragLookUpTolerance,
              s = t.start - i,
              r = t.start + t.duration + i;
            if (!a.len || r < a.start || s > a.end) {
              const e = n > r;
              (n < s || e) &&
                (e &&
                  t.loader &&
                  (this.log(
                    "seeking outside of buffer while fragment load in progress, cancel fragment load"
                  ),
                  t.abortRequests(),
                  this.resetLoadingState()),
                (this.fragPrevious = null));
            }
          }
          if (i) {
            this.fragmentTracker.removeFragmentsInRange(
              n,
              1 / 0,
              this.playlistType,
              !0
            );
            if (
              (n > this.lastCurrentTime && (this.lastCurrentTime = n),
              !this.loadingParts)
            ) {
              const e = Math.max(a.end, n),
                t = this.shouldLoadParts(this.getLevelDetails(), e);
              t &&
                (this.log(
                  `LL-Part loading ON after seeking to ${n.toFixed(
                    2
                  )} with buffer @${e.toFixed(2)}`
                ),
                (this.loadingParts = t));
            }
          }
          this.hls.hasEnoughToStart ||
            a.len ||
            (this.log(
              `setting startPosition to ${n} because of seek before start`
            ),
            (this.nextLoadPosition = this.startPosition = n)),
            this.tickImmediate();
        }),
        (this.onMediaEnded = () => {
          this.log("setting startPosition to 0 because media ended"),
            (this.startPosition = this.lastCurrentTime = 0);
        }),
        (this.playlistType = r),
        (this.hls = e),
        (this.fragmentLoader = new x_(e.config)),
        (this.keyLoader = i),
        (this.fragmentTracker = t),
        (this.config = e.config),
        (this.decrypter = new M_(e.config));
    }
    registerListeners() {
      const { hls: e } = this;
      e.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(Am.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const { hls: e } = this;
      e.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(Am.ERROR, this.onError, this);
    }
    doTick() {
      this.onTickEnd();
    }
    onTickEnd() {}
    startLoad(e) {}
    stopLoad() {
      if (this.state === ZT.STOPPED) return;
      this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
      const e = this.fragCurrent;
      null != e &&
        e.loader &&
        (e.abortRequests(), this.fragmentTracker.removeFragment(e)),
        this.resetTransmuxer(),
        (this.fragCurrent = null),
        (this.fragPrevious = null),
        this.clearInterval(),
        this.clearNextTick(),
        (this.state = ZT.STOPPED);
    }
    get startPositionValue() {
      const { nextLoadPosition: e, startPosition: t } = this;
      return -1 === t && e ? e : t;
    }
    get bufferingEnabled() {
      return this.buffering;
    }
    pauseBuffering() {
      this.buffering = !1;
    }
    resumeBuffering() {
      this.buffering = !0;
    }
    get inFlightFrag() {
      return { frag: this.fragCurrent, state: this.state };
    }
    _streamEnded(e, t) {
      if (t.live || !this.media) return !1;
      const i = e.end || 0,
        s = this.config.timelineOffset || 0;
      if (i <= s) return !1;
      const r = e.nextStart;
      if (r && r > s && r < t.edge) return !1;
      if (this.media.currentTime < e.start) return !1;
      const n = t.partList;
      if (null != n && n.length) {
        const e = n[n.length - 1];
        return K_.isBuffered(this.media, e.start + e.duration / 2);
      }
      const a = t.fragments[t.fragments.length - 1].type;
      return this.fragmentTracker.isEndListAppended(a);
    }
    getLevelDetails() {
      var e;
      if (this.levels && null !== this.levelLastLoaded)
        return null == (e = this.levelLastLoaded) ? void 0 : e.details;
    }
    get timelineOffset() {
      const e = this.config.timelineOffset;
      var t;
      return e
        ? (null == (t = this.getLevelDetails())
            ? void 0
            : t.appliedTimelineOffset) || e
        : 0;
    }
    onMediaAttached(e, t) {
      const i = (this.media = this.mediaBuffer = t.media);
      i.removeEventListener("seeking", this.onMediaSeeking),
        i.removeEventListener("ended", this.onMediaEnded),
        i.addEventListener("seeking", this.onMediaSeeking),
        i.addEventListener("ended", this.onMediaEnded);
      const s = this.config;
      this.levels &&
        s.autoStartLoad &&
        this.state === ZT.STOPPED &&
        this.startLoad(s.startPosition);
    }
    onMediaDetaching(e, t) {
      const i = !!t.transferMedia,
        s = this.media;
      if (null !== s) {
        if (
          (s.ended &&
            (this.log("MSE detaching and video ended, reset startPosition"),
            (this.startPosition = this.lastCurrentTime = 0)),
          s.removeEventListener("seeking", this.onMediaSeeking),
          s.removeEventListener("ended", this.onMediaEnded),
          this.keyLoader && !i && this.keyLoader.detach(),
          (this.media = this.mediaBuffer = null),
          (this.loopSn = void 0),
          i)
        )
          return this.resetLoadingState(), void this.resetTransmuxer();
        (this.loadingParts = !1),
          this.fragmentTracker.removeAllFragments(),
          this.stopLoad();
      }
    }
    onManifestLoading() {
      (this.initPTS = []),
        (this.levels = this.levelLastLoaded = this.fragCurrent = null),
        (this.lastCurrentTime = this.startPosition = 0),
        (this.startFragRequested = !1);
    }
    onError(e, t) {}
    onManifestLoaded(e, t) {
      this.startTimeOffset = t.startTimeOffset;
    }
    onHandlerDestroying() {
      this.stopLoad(),
        this.transmuxer &&
          (this.transmuxer.destroy(), (this.transmuxer = null)),
        super.onHandlerDestroying(),
        (this.hls = this.onMediaSeeking = this.onMediaEnded = null);
    }
    onHandlerDestroyed() {
      (this.state = ZT.STOPPED),
        this.fragmentLoader && this.fragmentLoader.destroy(),
        this.keyLoader && this.keyLoader.destroy(),
        this.decrypter && this.decrypter.destroy(),
        (this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null),
        super.onHandlerDestroyed();
    }
    loadFragment(e, t, i) {
      (this.startFragRequested = !0), this._loadFragForPlayback(e, t, i);
    }
    _loadFragForPlayback(e, t, i) {
      this._doFragLoad(e, t, i, e => {
        const t = e.frag;
        if (this.fragContextChanged(t))
          return (
            this.warn(
              `${t.type} sn: ${t.sn}${
                e.part ? " part: " + e.part.index : ""
              } of ${this.fragInfo(
                t,
                !1,
                e.part
              )}) was dropped during download.`
            ),
            void this.fragmentTracker.removeFragment(t)
          );
        t.stats.chunkCount++, this._handleFragmentLoadProgress(e);
      })
        .then(e => {
          if (!e) return;
          const t = this.state,
            i = e.frag;
          this.fragContextChanged(i)
            ? (t === ZT.FRAG_LOADING ||
                (!this.fragCurrent && t === ZT.PARSING)) &&
              (this.fragmentTracker.removeFragment(i), (this.state = ZT.IDLE))
            : ("payload" in e &&
                (this.log(
                  `Loaded ${i.type} sn: ${i.sn} of ${this.playlistLabel()} ${
                    i.level
                  }`
                ),
                this.hls.trigger(Am.FRAG_LOADED, e)),
              this._handleFragmentLoadComplete(e));
        })
        .catch(t => {
          this.state !== ZT.STOPPED &&
            this.state !== ZT.ERROR &&
            (this.warn(`Frag error: ${(null == t ? void 0 : t.message) || t}`),
            this.resetFragmentLoading(e));
        });
    }
    clearTrackerIfNeeded(e) {
      var t;
      const { fragmentTracker: i } = this;
      if (i.getState(e) === I_) {
        const t = e.type,
          s = this.getFwdBufferInfo(this.mediaBuffer, t),
          r = Math.max(e.duration, s ? s.len : this.config.maxBufferLength),
          n = this.backtrackFragment;
        (1 === (n ? e.sn - n.sn : 0) ||
          this.reduceMaxBufferLength(r, e.duration)) &&
          i.removeFragment(e);
      } else 0 === (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) ? i.removeAllFragments() : i.hasParts(e.type) && (i.detectPartialFragments({ frag: e, part: null, stats: e.stats, id: e.type }), i.getState(e) === C_ && i.removeFragment(e));
    }
    checkLiveUpdate(e) {
      if (e.updated && !e.live) {
        const t = e.fragments[e.fragments.length - 1];
        this.fragmentTracker.detectPartialFragments({
          frag: t,
          part: null,
          stats: t.stats,
          id: t.type
        });
      }
      e.fragments[0] || (e.deltaUpdateFailed = !0);
    }
    waitForLive(e) {
      const t = e.details;
      return (
        (null == t ? void 0 : t.live) &&
        "EVENT" !== t.type &&
        (this.levelLastLoaded !== e || t.expired)
      );
    }
    flushMainBuffer(e, t, i = null) {
      if (!(e - t)) return;
      const s = { startOffset: e, endOffset: t, type: i };
      this.hls.trigger(Am.BUFFER_FLUSHING, s);
    }
    _loadInitSegment(e, t) {
      this._doFragLoad(e, t)
        .then(e => {
          const t = null == e ? void 0 : e.frag;
          if (!t || this.fragContextChanged(t) || !this.levels)
            throw new Error("init load aborted");
          return e;
        })
        .then(e => {
          const { hls: t } = this,
            { frag: i, payload: s } = e,
            r = i.decryptdata;
          if (
            s &&
            s.byteLength > 0 &&
            null != r &&
            r.key &&
            r.iv &&
            iT(r.method)
          ) {
            const n = self.performance.now();
            return this.decrypter
              .decrypt(
                new Uint8Array(s),
                r.key.buffer,
                r.iv.buffer,
                sT(r.method)
              )
              .catch(e => {
                throw (t.trigger(Am.ERROR, {
                  type: Rm.MEDIA_ERROR,
                  details: ym.FRAG_DECRYPT_ERROR,
                  fatal: !1,
                  error: e,
                  reason: e.message,
                  frag: i
                }),
                e);
              })
              .then(s => {
                const r = self.performance.now();
                return (
                  t.trigger(Am.FRAG_DECRYPTED, {
                    frag: i,
                    payload: s,
                    stats: { tstart: n, tdecrypt: r }
                  }),
                  (e.payload = s),
                  this.completeInitSegmentLoad(e)
                );
              });
          }
          return this.completeInitSegmentLoad(e);
        })
        .catch(t => {
          this.state !== ZT.STOPPED &&
            this.state !== ZT.ERROR &&
            (this.warn(t), this.resetFragmentLoading(e));
        });
    }
    completeInitSegmentLoad(e) {
      const { levels: t } = this;
      if (!t) throw new Error("init load aborted, missing levels");
      const i = e.frag.stats;
      this.state !== ZT.STOPPED && (this.state = ZT.IDLE),
        (e.frag.data = new Uint8Array(e.payload)),
        (i.parsing.start = i.buffering.start = self.performance.now()),
        (i.parsing.end = i.buffering.end = self.performance.now()),
        this.tick();
    }
    fragContextChanged(e) {
      const { fragCurrent: t } = this;
      return !e || !t || e.sn !== t.sn || e.level !== t.level;
    }
    fragBufferedComplete(e, t) {
      const i = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (
        (this.log(
          `Buffered ${e.type} sn: ${e.sn}${
            t ? " part: " + t.index : ""
          } of ${this.fragInfo(e, !1, t)} > buffer:${
            i ? QT(K_.getBuffered(i)) : "(detached)"
          })`
        ),
        Jm(e))
      ) {
        var s;
        if (e.type !== Cm.SUBTITLE) {
          const t = e.elementaryStreams;
          if (!Object.keys(t).some(e => !!t[e]))
            return void (this.state = ZT.IDLE);
        }
        const t = null == (s = this.levels) ? void 0 : s[e.level];
        null != t &&
          t.fragmentError &&
          (this.log(
            `Resetting level fragment error count of ${t.fragmentError} on frag buffered`
          ),
          (t.fragmentError = 0));
      }
      this.state = ZT.IDLE;
    }
    _handleFragmentLoadComplete(e) {
      const { transmuxer: t } = this;
      if (!t) return;
      const { frag: i, part: s, partsLoaded: r } = e,
        n = !r || 0 === r.length || r.some(e => !e),
        a = new j_(
          i.level,
          i.sn,
          i.stats.chunkCount + 1,
          0,
          s ? s.index : -1,
          !n
        );
      t.flush(a);
    }
    _handleFragmentLoadProgress(e) {}
    _doFragLoad(e, t, i = null, s) {
      var r;
      this.fragCurrent = e;
      const n = null == t ? void 0 : t.details;
      if (!this.levels || !n)
        throw new Error(
          `frag load aborted, missing level${n ? "" : " detail"}s`
        );
      let a = null;
      !e.encrypted || (null != (r = e.decryptdata) && r.key)
        ? !e.encrypted &&
          n.encryptedFragments.length &&
          this.keyLoader.loadClear(e, n.encryptedFragments)
        : (this.log(
            `Loading key for ${e.sn} of [${n.startSN}-${
              n.endSN
            }], ${this.playlistLabel()} ${e.level}`
          ),
          (this.state = ZT.KEY_LOADING),
          (this.fragCurrent = e),
          (a = this.keyLoader.load(e).then(e => {
            if (!this.fragContextChanged(e.frag))
              return (
                this.hls.trigger(Am.KEY_LOADED, e),
                this.state === ZT.KEY_LOADING && (this.state = ZT.IDLE),
                e
              );
          })),
          this.hls.trigger(Am.KEY_LOADING, { frag: e }),
          null === this.fragCurrent &&
            (a = Promise.reject(
              new Error("frag load aborted, context changed in KEY_LOADING")
            )));
      const o = this.fragPrevious;
      if (Jm(e) && (!o || e.sn !== o.sn)) {
        const i = this.shouldLoadParts(t.details, e.end);
        i !== this.loadingParts &&
          (this.log(
            `LL-Part loading ${i ? "ON" : "OFF"} loading sn ${
              null == o ? void 0 : o.sn
            }->${e.sn}`
          ),
          (this.loadingParts = i));
      }
      if (((i = Math.max(e.start, i || 0)), this.loadingParts && Jm(e))) {
        const r = n.partList;
        if (r && s) {
          i > e.end && n.fragmentHint && (e = n.fragmentHint);
          const o = this.getNextPart(r, e, i);
          if (o > -1) {
            const c = r[o];
            let d;
            return (
              (e = this.fragCurrent = c.fragment),
              this.log(
                `Loading ${e.type} sn: ${e.sn} part: ${
                  c.index
                } (${o}/${r.length - 1}) of ${this.fragInfo(e, !1, c)}) cc: ${
                  e.cc
                } [${n.startSN}-${n.endSN}], target: ${parseFloat(
                  i.toFixed(3)
                )}`
              ),
              (this.nextLoadPosition = c.start + c.duration),
              (this.state = ZT.FRAG_LOADING),
              (d = a
                ? a
                    .then(i =>
                      !i || this.fragContextChanged(i.frag)
                        ? null
                        : this.doFragPartsLoad(e, c, t, s)
                    )
                    .catch(e => this.handleFragLoadError(e))
                : this.doFragPartsLoad(e, c, t, s).catch(e =>
                    this.handleFragLoadError(e)
                  )),
              this.hls.trigger(Am.FRAG_LOADING, {
                frag: e,
                part: c,
                targetBufferTime: i
              }),
              null === this.fragCurrent
                ? Promise.reject(
                    new Error(
                      "frag load aborted, context changed in FRAG_LOADING parts"
                    )
                  )
                : d
            );
          }
          if (!e.url || this.loadedEndOfParts(r, i))
            return Promise.resolve(null);
        }
      }
      if (Jm(e) && this.loadingParts)
        this.log(`LL-Part loading OFF after next part miss @${i.toFixed(2)}`),
          (this.loadingParts = !1);
      else if (!e.url) return Promise.resolve(null);
      this.log(
        `Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${
          e.cc
        } ${
          n ? "[" + n.startSN + "-" + n.endSN + "]" : ""
        }, target: ${parseFloat(i.toFixed(3))}`
      ),
        Tm(e.sn) &&
          !this.bitrateTest &&
          (this.nextLoadPosition = e.start + e.duration),
        (this.state = ZT.FRAG_LOADING);
      const c = this.config.progressive;
      let d;
      return (
        (d =
          c && a
            ? a
                .then(t =>
                  !t || this.fragContextChanged(null == t ? void 0 : t.frag)
                    ? null
                    : this.fragmentLoader.load(e, s)
                )
                .catch(e => this.handleFragLoadError(e))
            : Promise.all([this.fragmentLoader.load(e, c ? s : void 0), a])
                .then(([e]) => (!c && e && s && s(e), e))
                .catch(e => this.handleFragLoadError(e))),
        this.hls.trigger(Am.FRAG_LOADING, { frag: e, targetBufferTime: i }),
        null === this.fragCurrent
          ? Promise.reject(
              new Error("frag load aborted, context changed in FRAG_LOADING")
            )
          : d
      );
    }
    doFragPartsLoad(e, t, i, s) {
      return new Promise((r, n) => {
        var a;
        const o = [],
          c = null == (a = i.details) ? void 0 : a.partList,
          d = t => {
            this.fragmentLoader
              .loadPart(e, t, s)
              .then(s => {
                o[t.index] = s;
                const n = s.part;
                this.hls.trigger(Am.FRAG_LOADED, s);
                const a =
                  KT(i.details, e.sn, t.index + 1) || WT(c, e.sn, t.index + 1);
                if (!a) return r({ frag: e, part: n, partsLoaded: o });
                d(a);
              })
              .catch(n);
          };
        d(t);
      });
    }
    handleFragLoadError(e) {
      if ("data" in e) {
        const t = e.data;
        e.data && t.details === ym.INTERNAL_ABORTED
          ? this.handleFragLoadAborted(t.frag, t.part)
          : this.hls.trigger(Am.ERROR, t);
      } else this.hls.trigger(Am.ERROR, { type: Rm.OTHER_ERROR, details: ym.INTERNAL_EXCEPTION, err: e, error: e, fatal: !0 });
      return null;
    }
    _handleTransmuxerFlush(e) {
      const t = this.getCurrentContext(e);
      if (!t || this.state !== ZT.PARSING)
        return void (
          this.fragCurrent ||
          this.state === ZT.STOPPED ||
          this.state === ZT.ERROR ||
          (this.state = ZT.IDLE)
        );
      const { frag: i, part: s, level: r } = t,
        n = self.performance.now();
      (i.stats.parsing.end = n), s && (s.stats.parsing.end = n);
      const a = this.getLevelDetails(),
        o = (a && i.sn > a.endSN) || this.shouldLoadParts(a, i.end);
      o !== this.loadingParts &&
        (this.log(
          `LL-Part loading ${
            o ? "ON" : "OFF"
          } after parsing segment ending @${i.end.toFixed(2)}`
        ),
        (this.loadingParts = o)),
        this.updateLevelTiming(i, s, r, e.partial);
    }
    shouldLoadParts(e, t) {
      if (this.config.lowLatencyMode) {
        if (!e) return this.loadingParts;
        if (null != e && e.partList) {
          var i;
          const r = e.partList[0];
          if (
            t >=
            r.end + ((null == (i = e.fragmentHint) ? void 0 : i.duration) || 0)
          ) {
            var s;
            if (
              (this.hls.hasEnoughToStart
                ? (null == (s = this.media) ? void 0 : s.currentTime) ||
                  this.lastCurrentTime
                : this.getLoadPosition()) >
              r.start - r.fragment.duration
            )
              return !0;
          }
        }
      }
      return !1;
    }
    getCurrentContext(e) {
      const { levels: t, fragCurrent: i } = this,
        { level: s, sn: r, part: n } = e;
      if (null == t || !t[s])
        return (
          this.warn(
            `Levels object was unset while buffering fragment ${r} of ${this.playlistLabel()} ${s}. The current chunk will not be buffered.`
          ),
          null
        );
      const a = t[s],
        o = a.details,
        c = n > -1 ? KT(o, r, n) : null,
        d = c
          ? c.fragment
          : (function(e, t, i) {
              if (!e) return null;
              let s = e.fragments[t - e.startSN];
              return (
                s ||
                ((s = e.fragmentHint),
                s && s.sn === t
                  ? s
                  : t < e.startSN && i && i.sn === t
                  ? i
                  : null)
              );
            })(o, r, i);
      return d
        ? (i && i !== d && (d.stats = i.stats), { frag: d, part: c, level: a })
        : null;
    }
    bufferFragmentData(e, t, i, s, r) {
      var n;
      if (!e || this.state !== ZT.PARSING) return;
      const { data1: a, data2: o } = e;
      let c = a;
      if ((a && o && (c = Sg(a, o)), null == (n = c) || !n.length)) return;
      const d = {
        type: e.type,
        frag: t,
        part: i,
        chunkMeta: s,
        parent: t.type,
        data: c
      };
      if (
        (this.hls.trigger(Am.BUFFER_APPENDING, d),
        e.dropped && e.independent && !i)
      ) {
        if (r) return;
        this.flushBufferGap(t);
      }
    }
    flushBufferGap(e) {
      const t = this.media;
      if (!t) return;
      if (!K_.isBuffered(t, t.currentTime))
        return void this.flushMainBuffer(0, e.start);
      const i = t.currentTime,
        s = K_.bufferInfo(t, i, 0),
        r = e.duration,
        n = Math.min(2 * this.config.maxFragLookUpTolerance, 0.25 * r),
        a = Math.max(Math.min(e.start - n, s.end - n), i + n);
      e.start - a > n && this.flushMainBuffer(a, e.start);
    }
    getFwdBufferInfo(e, t) {
      var i;
      const s = this.getLoadPosition();
      if (!Tm(s)) return null;
      const r =
        this.lastCurrentTime > s || (null != (i = this.media) && i.paused)
          ? 0
          : this.config.maxBufferHole;
      return this.getFwdBufferInfoAtPos(e, s, t, r);
    }
    getFwdBufferInfoAtPos(e, t, i, s) {
      const r = K_.bufferInfo(e, t, s);
      if (0 === r.len && void 0 !== r.nextStart) {
        const n = this.fragmentTracker.getBufferedFrag(t, i);
        if (n && (r.nextStart <= n.end || n.gap)) {
          const i = Math.max(Math.min(r.nextStart, n.end) - t, s);
          return K_.bufferInfo(e, t, i);
        }
      }
      return r;
    }
    getMaxBufferLength(e) {
      const { config: t } = this;
      let i;
      return (
        (i = e
          ? Math.max((8 * t.maxBufferSize) / e, t.maxBufferLength)
          : t.maxBufferLength),
        Math.min(i, t.maxMaxBufferLength)
      );
    }
    reduceMaxBufferLength(e, t) {
      const i = this.config,
        s = Math.max(Math.min(e - t, i.maxBufferLength), t),
        r = Math.max(e - 3 * t, i.maxMaxBufferLength / 2, s);
      return (
        r >= s &&
        ((i.maxMaxBufferLength = r),
        this.warn(`Reduce max buffer length to ${r}s`),
        !0)
      );
    }
    getAppendedFrag(e, t = Cm.MAIN) {
      var i;
      const s =
        null == (i = this.fragmentTracker) ? void 0 : i.getAppendedFrag(e, t);
      return s && "fragment" in s ? s.fragment : s;
    }
    getNextFragment(e, t) {
      const i = t.fragments,
        s = i.length;
      if (!s) return null;
      const { config: r } = this,
        n = i[0].start,
        a = r.lowLatencyMode && !!t.partList;
      let o = null;
      if (t.live) {
        const d = r.initialLiveManifestSize;
        if (s < d)
          return (
            this.warn(
              `Not enough fragments to start playback (have: ${s}, need: ${d})`
            ),
            null
          );
        if (
          (!t.PTSKnown &&
            !this.startFragRequested &&
            -1 === this.startPosition) ||
          e < n
        ) {
          var c;
          a &&
            !this.loadingParts &&
            (this.log("LL-Part loading ON for initial live fragment"),
            (this.loadingParts = !0)),
            (o = this.getInitialLiveFragment(t, i));
          const s = this.hls.startPosition,
            r = this.hls.liveSyncPosition,
            d = o ? (-1 !== s && s >= n ? s : r) || o.start : e;
          this.log(
            `Setting startPosition to ${d} to match start frag at live edge. mainStart: ${s} liveSyncPosition: ${r} frag.start: ${
              null == (c = o) ? void 0 : c.start
            }`
          ),
            (this.startPosition = this.nextLoadPosition = d);
        }
      } else e <= n && (o = i[0]);
      if (!o) {
        const i = this.loadingParts ? t.partEnd : t.fragmentEnd;
        o = this.getFragmentAtPosition(e, i, t);
      }
      let d = this.filterReplacedPrimary(o, t);
      if (!d && o) {
        const e = o.sn - t.startSN;
        d = this.filterReplacedPrimary(i[e + 1] || null, t);
      }
      return this.mapToInitFragWhenRequired(d);
    }
    isLoopLoading(e, t) {
      const i = this.fragmentTracker.getState(e);
      return (i === b_ || (i === C_ && !!e.gap)) && this.nextLoadPosition > t;
    }
    getNextFragmentLoopLoading(e, t, i, s, r) {
      let n = null;
      if (
        e.gap &&
        ((n = this.getNextFragment(this.nextLoadPosition, t)),
        n && !n.gap && i.nextStart)
      ) {
        const e = this.getFwdBufferInfoAtPos(
          this.mediaBuffer ? this.mediaBuffer : this.media,
          i.nextStart,
          s,
          0
        );
        if (null !== e && i.len + e.len >= r) {
          const e = n.sn;
          return (
            this.loopSn !== e &&
              (this.log(
                `buffer full after gaps in "${s}" playlist starting at sn: ${e}`
              ),
              (this.loopSn = e)),
            null
          );
        }
      }
      return (this.loopSn = void 0), n;
    }
    get primaryPrefetch() {
      if (tS(this.hls.config)) {
        var e, t;
        if (
          null == (e = this.hls.interstitialsManager) ||
          null == (t = e.playingItem)
            ? void 0
            : t.event
        )
          return !0;
      }
      return !1;
    }
    filterReplacedPrimary(e, t) {
      if (!e) return e;
      if (tS(this.hls.config) && e.type !== Cm.SUBTITLE) {
        const i = this.hls.interstitialsManager,
          s = null == i ? void 0 : i.bufferingItem;
        if (s) {
          const i = s.event;
          if (i) {
            if (
              i.appendInPlace ||
              Math.abs(e.start - s.start) > 1 ||
              0 === s.start
            )
              return null;
          } else {
            if (e.end <= s.start && !1 === (null == t ? void 0 : t.live))
              return null;
            if (
              e.start > s.end &&
              s.nextEvent &&
              (s.nextEvent.appendInPlace || e.start - s.end > 1)
            )
              return null;
          }
        }
        const r = null == i ? void 0 : i.playerQueue;
        if (r)
          for (let t = r.length; t--; ) {
            const i = r[t].interstitial;
            if (
              i.appendInPlace &&
              e.start >= i.startTime &&
              e.end <= i.resumeTime
            )
              return null;
          }
      }
      return e;
    }
    mapToInitFragWhenRequired(e) {
      return null == e ||
        !e.initSegment ||
        (null != e && e.initSegment.data) ||
        this.bitrateTest
        ? e
        : e.initSegment;
    }
    getNextPart(e, t, i) {
      let s = -1,
        r = !1,
        n = !0;
      for (let a = 0, o = e.length; a < o; a++) {
        const o = e[a];
        if (((n = n && !o.independent), s > -1 && i < o.start)) break;
        const c = o.loaded;
        c ? (s = -1) : (r || o.independent || n) && o.fragment === t && (s = a),
          (r = c);
      }
      return s;
    }
    loadedEndOfParts(e, t) {
      const i = e[e.length - 1];
      return i && t > i.start && i.loaded;
    }
    getInitialLiveFragment(e, t) {
      const i = this.fragPrevious;
      let s = null;
      if (i) {
        if (
          (e.hasProgramDateTime &&
            (this.log(
              `Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`
            ),
            (s = (function(e, t, i) {
              if (null === t || !Array.isArray(e) || !e.length || !Tm(t))
                return null;
              if (t < (e[0].programDateTime || 0)) return null;
              if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;
              i = i || 0;
              for (let s = 0; s < e.length; ++s) {
                const r = e[s];
                if (f_(t, i, r)) return r;
              }
              return null;
            })(t, i.endProgramDateTime, this.config.maxFragLookUpTolerance))),
          !s)
        ) {
          const r = i.sn + 1;
          if (r >= e.startSN && r <= e.endSN) {
            const n = t[r - e.startSN];
            i.cc === n.cc &&
              ((s = n),
              this.log(
                `Live playlist, switching playlist, load frag with next SN: ${s.sn}`
              ));
          }
          s ||
            ((s = E_(t, i.cc)),
            s &&
              this.log(
                `Live playlist, switching playlist, load frag with same CC: ${s.sn}`
              ));
        }
      } else {
        const t = this.hls.liveSyncPosition;
        null !== t &&
          (s = this.getFragmentAtPosition(
            t,
            this.bitrateTest ? e.fragmentEnd : e.edge,
            e
          ));
      }
      return s;
    }
    getFragmentAtPosition(e, t, i) {
      const { config: s } = this;
      let { fragPrevious: r } = this,
        { fragments: n, endSN: a } = i;
      const { fragmentHint: o } = i,
        { maxFragLookUpTolerance: c } = s,
        d = i.partList,
        l = !!(this.loadingParts && null != d && d.length && o);
      let h;
      if (
        (l &&
          o &&
          !this.bitrateTest &&
          d[d.length - 1].fragment.sn === o.sn &&
          ((n = n.concat(o)), (a = o.sn)),
        e < t)
      ) {
        var u;
        h = u_(
          r,
          n,
          e,
          e < this.lastCurrentTime ||
            e > t - c ||
            (null != (u = this.media) && u.paused) ||
            !this.startFragRequested
            ? 0
            : c
        );
      } else h = n[n.length - 1];
      if (h) {
        const e = h.sn - i.startSN,
          t = this.fragmentTracker.getState(h);
        if (
          ((t === b_ || (t === C_ && h.gap)) && (r = h),
          r &&
            h.sn === r.sn &&
            (!l || d[0].fragment.sn > h.sn || (!i.live && !l)))
        ) {
          if (r && h.level === r.level) {
            const t = n[e + 1];
            h = h.sn < a && this.fragmentTracker.getState(t) !== b_ ? t : null;
          }
        }
      }
      return h;
    }
    alignPlaylists(e, t, i) {
      const s = e.fragments.length;
      if (!s) return this.warn("No fragments in live playlist"), 0;
      const r = e.fragmentStart,
        n = !t,
        a = e.alignedSliding && Tm(r);
      if (n || (!a && !r)) {
        !(function(e, t) {
          e &&
            (zT(t, e),
            !t.alignedSliding && e && JT(t, e),
            t.alignedSliding || !e || t.skippedSegments || GT(e, t, !1));
        })(i, e);
        const r = e.fragmentStart;
        return (
          this.log(
            `Live playlist sliding: ${r.toFixed(2)} start-sn: ${
              t ? t.startSN : "na"
            }->${e.startSN} fragments: ${s}`
          ),
          r
        );
      }
      return r;
    }
    waitForCdnTuneIn(e) {
      return (
        e.live &&
        e.canBlockReload &&
        e.partTarget &&
        e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
      );
    }
    setStartPosition(e, t) {
      let i = this.startPosition;
      i < t && (i = -1);
      const s = this.timelineOffset;
      if (-1 === i) {
        const r = null !== this.startTimeOffset,
          n = r ? this.startTimeOffset : e.startTimeOffset;
        null !== n && Tm(n)
          ? ((i = t + n),
            n < 0 && (i += e.edge),
            (i = Math.min(Math.max(t, i), t + e.totalduration)),
            this.log(
              `Setting startPosition to ${i} for start time offset ${n} found in ${
                r ? "multivariant" : "media"
              } playlist`
            ),
            (this.startPosition = i))
          : e.live
          ? ((i = this.hls.liveSyncPosition || t),
            this.log(`Setting startPosition to -1 to start at live edge ${i}`),
            (this.startPosition = -1))
          : (this.log("setting startPosition to 0 by default"),
            (this.startPosition = i = 0)),
          (this.lastCurrentTime = i + s);
      }
      this.nextLoadPosition = i + s;
    }
    getLoadPosition() {
      var e;
      const { media: t } = this;
      let i = 0;
      return (
        null != (e = this.hls) && e.hasEnoughToStart && t
          ? (i = t.currentTime)
          : this.nextLoadPosition >= 0 && (i = this.nextLoadPosition),
        i
      );
    }
    handleFragLoadAborted(e, t) {
      this.transmuxer &&
        e.type === this.playlistType &&
        Jm(e) &&
        e.stats.aborted &&
        (this.warn(
          `Fragment ${e.sn}${
            t ? " part " + t.index : ""
          } of ${this.playlistLabel()} ${e.level} was aborted`
        ),
        this.resetFragmentLoading(e));
    }
    resetFragmentLoading(e) {
      (this.fragCurrent &&
        (this.fragContextChanged(e) ||
          this.state === ZT.FRAG_LOADING_WAITING_RETRY)) ||
        (this.state = ZT.IDLE);
    }
    onFragmentOrKeyLoadError(e, t) {
      if (t.chunkMeta && !t.frag) {
        const e = this.getCurrentContext(t.chunkMeta);
        e && (t.frag = e.frag);
      }
      const i = t.frag;
      if (!i || i.type !== e || !this.levels) return;
      var s;
      if (this.fragContextChanged(i))
        return void this.warn(
          `Frag load error must match current frag to retry ${i.url} > ${
            null == (s = this.fragCurrent) ? void 0 : s.url
          }`
        );
      const r = t.details === ym.FRAG_GAP;
      r && this.fragmentTracker.fragBuffered(i, !0);
      const n = t.errorAction,
        { action: a, flags: o, retryCount: c = 0, retryConfig: d } = n || {},
        l = !!n && !!d,
        h = l && a === v_.RetryRequest,
        u = l && !n.resolved && o === R_.MoveAllAlternatesMatchingHost;
      if (!h && u && Jm(i) && !i.endList)
        this.resetFragmentErrors(e), this.treatAsGap(i), (n.resolved = !0);
      else if ((h || u) && c < d.maxNumRetry) {
        this.resetStartWhenNotLoaded(this.levelLastLoaded);
        const s = __(d, c);
        this.warn(
          `Fragment ${i.sn} of ${e} ${i.level} errored with ${
            t.details
          }, retrying loading ${c + 1}/${d.maxNumRetry} in ${s}ms`
        ),
          (n.resolved = !0),
          (this.retryDate = self.performance.now() + s),
          (this.state = ZT.FRAG_LOADING_WAITING_RETRY);
      } else if (d && n) {
        if ((this.resetFragmentErrors(e), !(c < d.maxNumRetry)))
          return void this.warn(
            `${t.details} reached or exceeded max retry (${c})`
          );
        r || a === v_.RemoveAlternatePermanently || (n.resolved = !0);
      } else
        a === v_.SendAlternateToPenaltyBox
          ? (this.state = ZT.WAITING_LEVEL)
          : (this.state = ZT.ERROR);
      this.tickImmediate();
    }
    reduceLengthAndFlushBuffer(e) {
      if (this.state === ZT.PARSING || this.state === ZT.PARSED) {
        const t = e.frag,
          i = e.parent,
          s = this.getFwdBufferInfo(this.mediaBuffer, i),
          r = s && s.len > 0.5;
        r &&
          this.reduceMaxBufferLength(
            s.len,
            (null == t ? void 0 : t.duration) || 10
          );
        const n = !r;
        return (
          n &&
            this.warn(
              `Buffer full error while media.currentTime is not buffered, flush ${i} buffer`
            ),
          t &&
            (this.fragmentTracker.removeFragment(t),
            (this.nextLoadPosition = t.start)),
          this.resetLoadingState(),
          n
        );
      }
      return !1;
    }
    resetFragmentErrors(e) {
      e === Cm.AUDIO && (this.fragCurrent = null),
        this.hls.hasEnoughToStart || (this.startFragRequested = !1),
        this.state !== ZT.STOPPED && (this.state = ZT.IDLE);
    }
    afterBufferFlushed(e, t, i) {
      if (!e) return;
      const s = K_.getBuffered(e);
      this.fragmentTracker.detectEvictedFragments(t, s, i),
        this.state === ZT.ENDED && this.resetLoadingState();
    }
    resetLoadingState() {
      this.log("Reset loading state"),
        (this.fragCurrent = null),
        (this.fragPrevious = null),
        this.state !== ZT.STOPPED && (this.state = ZT.IDLE);
    }
    resetStartWhenNotLoaded(e) {
      if (!this.hls.hasEnoughToStart) {
        this.startFragRequested = !1;
        const t = e ? e.details : null;
        null != t && t.live
          ? (this.log("resetting startPosition for live start"),
            (this.startPosition = -1),
            this.setStartPosition(t, t.fragmentStart),
            this.resetLoadingState())
          : (this.nextLoadPosition = this.startPosition);
      }
    }
    resetWhenMissingContext(e) {
      this.warn(
        `The loading context changed while buffering fragment ${
          e.sn
        } of ${this.playlistLabel()} ${
          e.level
        }. This chunk will not be buffered.`
      ),
        this.removeUnbufferedFrags(),
        this.resetStartWhenNotLoaded(this.levelLastLoaded),
        this.resetLoadingState();
    }
    removeUnbufferedFrags(e = 0) {
      this.fragmentTracker.removeFragmentsInRange(
        e,
        1 / 0,
        this.playlistType,
        !1,
        !0
      );
    }
    updateLevelTiming(e, t, i, s) {
      const r = i.details;
      if (!r) return void this.warn("level.details undefined");
      var n;
      if (
        !Object.keys(e.elementaryStreams).reduce((t, n) => {
          const a = e.elementaryStreams[n];
          if (a) {
            const o = a.endPTS - a.startPTS;
            if (o <= 0)
              return (
                this.warn(
                  `Could not parse fragment ${e.sn} ${n} duration reliably (${o})`
                ),
                t || !1
              );
            const c = s
              ? 0
              : FT(r, e, a.startPTS, a.endPTS, a.startDTS, a.endDTS);
            return (
              this.hls.trigger(Am.LEVEL_PTS_UPDATED, {
                details: r,
                level: i,
                drift: c,
                type: n,
                frag: e,
                start: a.startPTS,
                end: a.endPTS
              }),
              !0
            );
          }
          return t;
        }, !1) &&
        (0 === i.fragmentError && this.treatAsGap(e, i),
        null === (null == (n = this.transmuxer) ? void 0 : n.error))
      ) {
        const t = new Error(
          `Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${
            e.level
          } resetting transmuxer to fallback to playlist timing`
        );
        if (
          (this.warn(t.message),
          this.hls.trigger(Am.ERROR, {
            type: Rm.MEDIA_ERROR,
            details: ym.FRAG_PARSING_ERROR,
            fatal: !1,
            error: t,
            frag: e,
            reason: `Found no media in msn ${
              e.sn
            } of ${this.playlistLabel()} "${i.url}"`
          }),
          !this.hls)
        )
          return;
        this.resetTransmuxer();
      }
      (this.state = ZT.PARSED),
        this.log(
          `Parsed ${e.type} sn: ${e.sn}${
            t ? " part: " + t.index : ""
          } of ${this.fragInfo(e, !1, t)})`
        ),
        this.hls.trigger(Am.FRAG_PARSED, { frag: e, part: t });
    }
    playlistLabel() {
      return this.playlistType === Cm.MAIN ? "level" : "track";
    }
    fragInfo(e, t = !0, i) {
      var s, r;
      return `${this.playlistLabel()} ${e.level} (${i ? "part" : "frag"}:[${(null != (s = t && !i ? e.startPTS : (i || e).start) ? s : NaN).toFixed(3)}-${(null != (r = t && !i ? e.endPTS : (i || e).end) ? r : NaN).toFixed(3)}]${i && "main" === e.type ? "INDEPENDENT=" + (i.independent ? "YES" : "NO") : ""}`;
    }
    treatAsGap(e, t) {
      t && t.fragmentError++,
        (e.gap = !0),
        this.fragmentTracker.removeFragment(e),
        this.fragmentTracker.fragBuffered(e, !0);
    }
    resetTransmuxer() {
      var e;
      null == (e = this.transmuxer) || e.reset();
    }
    recoverWorkerError(e) {
      "demuxerWorker" === e.event &&
        (this.fragmentTracker.removeAllFragments(),
        this.transmuxer &&
          (this.transmuxer.destroy(), (this.transmuxer = null)),
        this.resetStartWhenNotLoaded(this.levelLastLoaded),
        this.resetLoadingState());
    }
    set state(e) {
      const t = this._state;
      t !== e && ((this._state = e), this.log(`${t}->${e}`));
    }
    get state() {
      return this._state;
    }
  }
  function tS(e) {
    return !!e.interstitialsController && !1 !== e.enableInterstitialPlayback;
  }
  class iS {
    constructor() {
      (this.chunks = []), (this.dataLength = 0);
    }
    push(e) {
      this.chunks.push(e), (this.dataLength += e.length);
    }
    flush() {
      const { chunks: e, dataLength: t } = this;
      let i;
      return e.length
        ? ((i =
            1 === e.length
              ? e[0]
              : (function(e, t) {
                  const i = new Uint8Array(t);
                  let s = 0;
                  for (let t = 0; t < e.length; t++) {
                    const r = e[t];
                    i.set(r, s), (s += r.length);
                  }
                  return i;
                })(e, t)),
          this.reset(),
          i)
        : new Uint8Array(0);
    }
    reset() {
      (this.chunks.length = 0), (this.dataLength = 0);
    }
  }
  var sS,
    rS = { exports: {} };
  var nS =
      (sS ||
        ((sS = 1),
        (function(e) {
          var t = Object.prototype.hasOwnProperty,
            i = "~";
          function s() {}
          function r(e, t, i) {
            (this.fn = e), (this.context = t), (this.once = i || !1);
          }
          function n(e, t, s, n, a) {
            if ("function" != typeof s)
              throw new TypeError("The listener must be a function");
            var o = new r(s, n || e, a),
              c = i ? i + t : t;
            return (
              e._events[c]
                ? e._events[c].fn
                  ? (e._events[c] = [e._events[c], o])
                  : e._events[c].push(o)
                : ((e._events[c] = o), e._eventsCount++),
              e
            );
          }
          function a(e, t) {
            0 == --e._eventsCount ? (e._events = new s()) : delete e._events[t];
          }
          function o() {
            (this._events = new s()), (this._eventsCount = 0);
          }
          Object.create &&
            ((s.prototype = Object.create(null)),
            new s().__proto__ || (i = !1)),
            (o.prototype.eventNames = function() {
              var e,
                s,
                r = [];
              if (0 === this._eventsCount) return r;
              for (s in (e = this._events))
                t.call(e, s) && r.push(i ? s.slice(1) : s);
              return Object.getOwnPropertySymbols
                ? r.concat(Object.getOwnPropertySymbols(e))
                : r;
            }),
            (o.prototype.listeners = function(e) {
              var t = i ? i + e : e,
                s = this._events[t];
              if (!s) return [];
              if (s.fn) return [s.fn];
              for (var r = 0, n = s.length, a = new Array(n); r < n; r++)
                a[r] = s[r].fn;
              return a;
            }),
            (o.prototype.listenerCount = function(e) {
              var t = i ? i + e : e,
                s = this._events[t];
              return s ? (s.fn ? 1 : s.length) : 0;
            }),
            (o.prototype.emit = function(e, t, s, r, n, a) {
              var o = i ? i + e : e;
              if (!this._events[o]) return !1;
              var c,
                d,
                l = this._events[o],
                h = arguments.length;
              if (l.fn) {
                switch (
                  (l.once && this.removeListener(e, l.fn, void 0, !0), h)
                ) {
                  case 1:
                    return l.fn.call(l.context), !0;
                  case 2:
                    return l.fn.call(l.context, t), !0;
                  case 3:
                    return l.fn.call(l.context, t, s), !0;
                  case 4:
                    return l.fn.call(l.context, t, s, r), !0;
                  case 5:
                    return l.fn.call(l.context, t, s, r, n), !0;
                  case 6:
                    return l.fn.call(l.context, t, s, r, n, a), !0;
                }
                for (d = 1, c = new Array(h - 1); d < h; d++)
                  c[d - 1] = arguments[d];
                l.fn.apply(l.context, c);
              } else {
                var u,
                  p = l.length;
                for (d = 0; d < p; d++)
                  switch (
                    (l[d].once && this.removeListener(e, l[d].fn, void 0, !0),
                    h)
                  ) {
                    case 1:
                      l[d].fn.call(l[d].context);
                      break;
                    case 2:
                      l[d].fn.call(l[d].context, t);
                      break;
                    case 3:
                      l[d].fn.call(l[d].context, t, s);
                      break;
                    case 4:
                      l[d].fn.call(l[d].context, t, s, r);
                      break;
                    default:
                      if (!c)
                        for (u = 1, c = new Array(h - 1); u < h; u++)
                          c[u - 1] = arguments[u];
                      l[d].fn.apply(l[d].context, c);
                  }
              }
              return !0;
            }),
            (o.prototype.on = function(e, t, i) {
              return n(this, e, t, i, !1);
            }),
            (o.prototype.once = function(e, t, i) {
              return n(this, e, t, i, !0);
            }),
            (o.prototype.removeListener = function(e, t, s, r) {
              var n = i ? i + e : e;
              if (!this._events[n]) return this;
              if (!t) return a(this, n), this;
              var o = this._events[n];
              if (o.fn)
                o.fn !== t ||
                  (r && !o.once) ||
                  (s && o.context !== s) ||
                  a(this, n);
              else {
                for (var c = 0, d = [], l = o.length; c < l; c++)
                  (o[c].fn !== t ||
                    (r && !o[c].once) ||
                    (s && o[c].context !== s)) &&
                    d.push(o[c]);
                d.length
                  ? (this._events[n] = 1 === d.length ? d[0] : d)
                  : a(this, n);
              }
              return this;
            }),
            (o.prototype.removeAllListeners = function(e) {
              var t;
              return (
                e
                  ? ((t = i ? i + e : e), this._events[t] && a(this, t))
                  : ((this._events = new s()), (this._eventsCount = 0)),
                this
              );
            }),
            (o.prototype.off = o.prototype.removeListener),
            (o.prototype.addListener = o.prototype.on),
            (o.prefixed = i),
            (o.EventEmitter = o),
            (e.exports = o);
        })(rS)),
      rS.exports),
    aS = Km(nS);
  const oS = "1.6.0",
    cS = {};
  function dS(e, t) {
    return (
      t + 10 <= e.length &&
      51 === e[t] &&
      68 === e[t + 1] &&
      73 === e[t + 2] &&
      e[t + 3] < 255 &&
      e[t + 4] < 255 &&
      e[t + 6] < 128 &&
      e[t + 7] < 128 &&
      e[t + 8] < 128 &&
      e[t + 9] < 128
    );
  }
  function lS(e, t) {
    return (
      t + 10 <= e.length &&
      73 === e[t] &&
      68 === e[t + 1] &&
      51 === e[t + 2] &&
      e[t + 3] < 255 &&
      e[t + 4] < 255 &&
      e[t + 6] < 128 &&
      e[t + 7] < 128 &&
      e[t + 8] < 128 &&
      e[t + 9] < 128
    );
  }
  function hS(e, t) {
    let i = 0;
    return (
      (i = (127 & e[t]) << 21),
      (i |= (127 & e[t + 1]) << 14),
      (i |= (127 & e[t + 2]) << 7),
      (i |= 127 & e[t + 3]),
      i
    );
  }
  function uS(e, t) {
    const i = t;
    let s = 0;
    for (; lS(e, t); ) {
      s += 10;
      (s += hS(e, t + 6)), dS(e, t + 10) && (s += 10), (t += s);
    }
    if (s > 0) return e.subarray(i, i + s);
  }
  function pS(e, t) {
    return 255 === e[t] && 240 == (246 & e[t + 1]);
  }
  function fS(e, t) {
    return 1 & e[t + 1] ? 7 : 9;
  }
  function ES(e, t) {
    return ((3 & e[t + 3]) << 11) | (e[t + 4] << 3) | ((224 & e[t + 5]) >>> 5);
  }
  function mS(e, t) {
    return t + 1 < e.length && pS(e, t);
  }
  function gS(e, t) {
    if (mS(e, t)) {
      const i = fS(e, t);
      if (t + i >= e.length) return !1;
      const s = ES(e, t);
      if (s <= i) return !1;
      const r = t + s;
      return r === e.length || mS(e, r);
    }
    return !1;
  }
  function _S(e, t, i, s, r) {
    if (!e.samplerate) {
      const n = (function(e, t, i, s) {
        const r = t[i + 2],
          n = (r >> 2) & 15;
        if (n > 12) {
          const t = new Error(`invalid ADTS sampling index:${n}`);
          return void e.emit(Am.ERROR, Am.ERROR, {
            type: Rm.MEDIA_ERROR,
            details: ym.FRAG_PARSING_ERROR,
            fatal: !0,
            error: t,
            reason: t.message
          });
        }
        const a = 1 + ((r >> 6) & 3),
          o = ((t[i + 3] >> 6) & 3) | ((1 & r) << 2),
          c = "mp4a.40." + a,
          d = [
            96e3,
            88200,
            64e3,
            48e3,
            44100,
            32e3,
            24e3,
            22050,
            16e3,
            12e3,
            11025,
            8e3,
            7350
          ][n];
        let l = n;
        (5 !== a && 29 !== a) || (l -= 3);
        const h = [(a << 3) | ((14 & l) >> 1), ((1 & l) << 7) | (o << 3)];
        return (
          Bm.log(
            `manifest codec:${s}, parsed codec:${c}, channels:${o}, rate:${d} (ADTS object type:${a} sampling index:${n})`
          ),
          {
            config: h,
            samplerate: d,
            channelCount: o,
            codec: c,
            parsedCodec: c,
            manifestCodec: s
          }
        );
      })(t, i, s, r);
      if (!n) return;
      wm(e, n);
    }
  }
  function TS(e) {
    return 9216e4 / e;
  }
  function SS(e, t, i, s, r) {
    const n = s + r * TS(e.samplerate),
      a = (function(e, t) {
        const i = fS(e, t);
        if (t + i <= e.length) {
          const s = ES(e, t) - i;
          if (s > 0) return { headerLength: i, frameLength: s };
        }
      })(t, i);
    let o;
    if (a) {
      const { frameLength: s, headerLength: r } = a,
        c = r + s,
        d = Math.max(0, i + c - t.length);
      d
        ? ((o = new Uint8Array(c - r)), o.set(t.subarray(i + r, t.length), 0))
        : (o = t.subarray(i + r, i + c));
      const l = { unit: o, pts: n };
      return d || e.samples.push(l), { sample: l, length: c, missing: d };
    }
    const c = t.length - i;
    (o = new Uint8Array(c)), o.set(t.subarray(i, t.length), 0);
    return { sample: { unit: o, pts: n }, length: c, missing: -1 };
  }
  function vS(e, t) {
    return lS(e, t) && hS(e, t + 6) + 10 <= e.length - t;
  }
  function RS(e, t) {
    if (e < 0) return -RS(-e, t);
    const i = Math.pow(10, t);
    if (Math.abs(((e * i) % 1) - 0.5) < Number.EPSILON) {
      const t = Math.floor(e * i);
      return (t % 2 == 0 ? t : t + 1) / i;
    }
    return Math.round(e * i) / i;
  }
  function yS(e, t = 0, i = 1 / 0) {
    return (function(e, t, i, s) {
      const r = (function(e) {
        return e instanceof ArrayBuffer ? e : e.buffer;
      })(e);
      let n = 1;
      "BYTES_PER_ELEMENT" in s && (n = s.BYTES_PER_ELEMENT);
      const a =
          ((h = e),
          h &&
          h.buffer instanceof ArrayBuffer &&
          void 0 !== h.byteLength &&
          void 0 !== h.byteOffset
            ? e.byteOffset
            : 0),
        o = (a + e.byteLength) / n,
        c = (a + t) / n,
        d = Math.floor(Math.max(0, Math.min(c, o))),
        l = Math.floor(Math.min(d + Math.max(i, 0), o));
      var h;
      return new s(r, d, l - d);
    })(e, t, i, Uint8Array);
  }
  function AS(e) {
    const t = {
      key: e.type,
      description: "",
      data: "",
      mimeType: null,
      pictureType: null
    };
    if (e.size < 2) return;
    if (3 !== e.data[0])
      return void console.log(
        "Ignore frame with unrecognized character encoding"
      );
    const i = e.data.subarray(1).indexOf(0);
    if (-1 === i) return;
    const s = jm(yS(e.data, 1, i)),
      r = e.data[2 + i],
      n = e.data.subarray(3 + i).indexOf(0);
    if (-1 === n) return;
    const a = jm(yS(e.data, 3 + i, n));
    let o;
    return (
      (o =
        "--\x3e" === s
          ? jm(yS(e.data, 4 + i + n))
          : (function(e) {
              return e instanceof ArrayBuffer
                ? e
                : 0 == e.byteOffset && e.byteLength == e.buffer.byteLength
                ? e.buffer
                : new Uint8Array(e).buffer;
            })(e.data.subarray(4 + i + n))),
      (t.mimeType = s),
      (t.pictureType = r),
      (t.description = a),
      (t.data = o),
      t
    );
  }
  function IS(e) {
    return "PRIV" === e.type
      ? (function(e) {
          if (e.size < 2) return;
          const t = jm(e.data, !0),
            i = new Uint8Array(e.data.subarray(t.length + 1));
          return { key: e.type, info: t, data: i.buffer };
        })(e)
      : "W" === e.type[0]
      ? (function(e) {
          if ("WXXX" === e.type) {
            if (e.size < 2) return;
            let t = 1;
            const i = jm(e.data.subarray(t), !0);
            t += i.length + 1;
            const s = jm(e.data.subarray(t));
            return { key: e.type, info: i, data: s };
          }
          const t = jm(e.data);
          return { key: e.type, info: "", data: t };
        })(e)
      : "APIC" === e.type
      ? AS(e)
      : (function(e) {
          if (e.size < 2) return;
          if ("TXXX" === e.type) {
            let t = 1;
            const i = jm(e.data.subarray(t), !0);
            t += i.length + 1;
            const s = jm(e.data.subarray(t));
            return { key: e.type, info: i, data: s };
          }
          const t = jm(e.data.subarray(1));
          return { key: e.type, info: "", data: t };
        })(e);
  }
  function CS(e) {
    const t = String.fromCharCode(e[0], e[1], e[2], e[3]),
      i = hS(e, 4);
    return { type: t, size: i, data: e.subarray(10, 10 + i) };
  }
  const bS = 10,
    OS = 10;
  function DS(e) {
    let t = 0;
    const i = [];
    for (; lS(e, t); ) {
      const s = hS(e, t + 6);
      (e[t + 5] >> 6) & 1 && (t += bS), (t += bS);
      const r = t + s;
      for (; t + OS < r; ) {
        const s = CS(e.subarray(t)),
          r = IS(s);
        r && i.push(r), (t += s.size + bS);
      }
      dS(e, t) && (t += bS);
    }
    return i;
  }
  function wS(e) {
    return (
      e &&
      "PRIV" === e.key &&
      "com.apple.streaming.transportStreamTimestamp" === e.info
    );
  }
  function LS(e) {
    if (8 === e.data.byteLength) {
      const t = new Uint8Array(e.data),
        i = 1 & t[3];
      let s = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
      return (s /= 45), i && (s += 47721858.84), Math.round(s);
    }
  }
  function NS(e) {
    const t = DS(e);
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      if (wS(i)) return LS(i);
    }
  }
  let PS = (function(e) {
    return (
      (e.audioId3 = "org.id3"),
      (e.dateRange = "com.apple.quicktime.HLS"),
      (e.emsg = "https://aomedia.org/emsg/ID3"),
      (e.misbklv = "urn:misb:KLV:bin:1910.1"),
      e
    );
  })({});
  function kS(e = "", t = 9e4) {
    return {
      type: e,
      id: -1,
      pid: -1,
      inputTimeScale: t,
      sequenceNumber: -1,
      samples: [],
      dropped: 0
    };
  }
  class MS {
    constructor() {
      (this._audioTrack = void 0),
        (this._id3Track = void 0),
        (this.frameIndex = 0),
        (this.cachedData = null),
        (this.basePTS = null),
        (this.initPTS = null),
        (this.lastPTS = null);
    }
    resetInitSegment(e, t, i, s) {
      this._id3Track = {
        type: "id3",
        id: 3,
        pid: -1,
        inputTimeScale: 9e4,
        sequenceNumber: 0,
        samples: [],
        dropped: 0
      };
    }
    resetTimeStamp(e) {
      (this.initPTS = e), this.resetContiguity();
    }
    resetContiguity() {
      (this.basePTS = null), (this.lastPTS = null), (this.frameIndex = 0);
    }
    canParse(e, t) {
      return !1;
    }
    appendFrame(e, t, i) {}
    demux(e, t) {
      this.cachedData &&
        ((e = Sg(this.cachedData, e)), (this.cachedData = null));
      let i,
        s = uS(e, 0),
        r = s ? s.length : 0;
      const n = this._audioTrack,
        a = this._id3Track,
        o = s ? NS(s) : void 0,
        c = e.length;
      for (
        (null === this.basePTS || (0 === this.frameIndex && Tm(o))) &&
          ((this.basePTS = US(o, t, this.initPTS)),
          (this.lastPTS = this.basePTS)),
          null === this.lastPTS && (this.lastPTS = this.basePTS),
          s &&
            s.length > 0 &&
            a.samples.push({
              pts: this.lastPTS,
              dts: this.lastPTS,
              data: s,
              type: PS.audioId3,
              duration: Number.POSITIVE_INFINITY
            });
        r < c;

      ) {
        if (this.canParse(e, r)) {
          const t = this.appendFrame(n, e, r);
          t
            ? (this.frameIndex++,
              (this.lastPTS = t.sample.pts),
              (r += t.length),
              (i = r))
            : (r = c);
        } else
          vS(e, r)
            ? ((s = uS(e, r)),
              a.samples.push({
                pts: this.lastPTS,
                dts: this.lastPTS,
                data: s,
                type: PS.audioId3,
                duration: Number.POSITIVE_INFINITY
              }),
              (r += s.length),
              (i = r))
            : r++;
        if (r === c && i !== c) {
          const t = e.slice(i);
          this.cachedData
            ? (this.cachedData = Sg(this.cachedData, t))
            : (this.cachedData = t);
        }
      }
      return { audioTrack: n, videoTrack: kS(), id3Track: a, textTrack: kS() };
    }
    demuxSampleAes(e, t, i) {
      return Promise.reject(
        new Error(
          `[${this}] This demuxer does not support Sample-AES decryption`
        )
      );
    }
    flush(e) {
      const t = this.cachedData;
      return (
        t && ((this.cachedData = null), this.demux(t, 0)),
        {
          audioTrack: this._audioTrack,
          videoTrack: kS(),
          id3Track: this._id3Track,
          textTrack: kS()
        }
      );
    }
    destroy() {
      (this.cachedData = null), (this._audioTrack = this._id3Track = void 0);
    }
  }
  const US = (e, t, i) => {
    if (Tm(e)) return 90 * e;
    return 9e4 * t + (i ? (9e4 * i.baseTime) / i.timescale : 0);
  };
  let xS = null;
  const FS = [
      32,
      64,
      96,
      128,
      160,
      192,
      224,
      256,
      288,
      320,
      352,
      384,
      416,
      448,
      32,
      48,
      56,
      64,
      80,
      96,
      112,
      128,
      160,
      192,
      224,
      256,
      320,
      384,
      32,
      40,
      48,
      56,
      64,
      80,
      96,
      112,
      128,
      160,
      192,
      224,
      256,
      320,
      32,
      48,
      56,
      64,
      80,
      96,
      112,
      128,
      144,
      160,
      176,
      192,
      224,
      256,
      8,
      16,
      24,
      32,
      40,
      48,
      56,
      64,
      80,
      96,
      112,
      128,
      144,
      160
    ],
    BS = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
    VS = [
      [0, 72, 144, 12],
      [0, 0, 0, 0],
      [0, 72, 144, 12],
      [0, 144, 144, 12]
    ],
    GS = [0, 1, 1, 4];
  function jS(e, t, i, s, r) {
    if (i + 24 > t.length) return;
    const n = HS(t, i);
    if (n && i + n.frameLength <= t.length) {
      const a = s + r * ((9e4 * n.samplesPerFrame) / n.sampleRate),
        o = { unit: t.subarray(i, i + n.frameLength), pts: a, dts: a };
      return (
        (e.config = []),
        (e.channelCount = n.channelCount),
        (e.samplerate = n.sampleRate),
        e.samples.push(o),
        { sample: o, length: n.frameLength, missing: 0 }
      );
    }
  }
  function HS(e, t) {
    const i = (e[t + 1] >> 3) & 3,
      s = (e[t + 1] >> 1) & 3,
      r = (e[t + 2] >> 4) & 15,
      n = (e[t + 2] >> 2) & 3;
    if (1 !== i && 0 !== r && 15 !== r && 3 !== n) {
      const a = (e[t + 2] >> 1) & 1,
        o = e[t + 3] >> 6,
        c = 1e3 * FS[14 * (3 === i ? 3 - s : 3 === s ? 3 : 4) + r - 1],
        d = BS[3 * (3 === i ? 0 : 2 === i ? 1 : 2) + n],
        l = 3 === o ? 1 : 2,
        h = VS[i][s],
        u = GS[s],
        p = 8 * h * u,
        f = Math.floor((h * c) / d + a) * u;
      if (null === xS) {
        const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
        xS = e ? parseInt(e[1]) : 0;
      }
      return (
        !!xS &&
          xS <= 87 &&
          2 === s &&
          c >= 224e3 &&
          0 === o &&
          (e[t + 3] = 128 | e[t + 3]),
        { sampleRate: d, channelCount: l, frameLength: f, samplesPerFrame: p }
      );
    }
  }
  function KS(e, t) {
    return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1]);
  }
  function WS(e, t) {
    return t + 1 < e.length && KS(e, t);
  }
  function YS(e, t) {
    if (t + 1 < e.length && KS(e, t)) {
      const i = 4,
        s = HS(e, t);
      let r = i;
      null != s && s.frameLength && (r = s.frameLength);
      const n = t + r;
      return n === e.length || WS(e, n);
    }
    return !1;
  }
  const $S = (e, t) => {
    let i = 0,
      s = 5;
    t += s;
    const r = new Uint32Array(1),
      n = new Uint32Array(1),
      a = new Uint8Array(1);
    for (; s > 0; ) {
      a[0] = e[t];
      const o = Math.min(s, 8),
        c = 8 - o;
      (n[0] = (4278190080 >>> (24 + c)) << c),
        (r[0] = (a[0] & n[0]) >> c),
        (i = i ? (i << o) | r[0] : r[0]),
        (t += 1),
        (s -= o);
    }
    return i;
  };
  class qS extends MS {
    constructor(e) {
      super(), (this.observer = void 0), (this.observer = e);
    }
    resetInitSegment(e, t, i, s) {
      super.resetInitSegment(e, t, i, s),
        (this._audioTrack = {
          container: "audio/ac-3",
          type: "audio",
          id: 2,
          pid: -1,
          sequenceNumber: 0,
          segmentCodec: "ac3",
          samples: [],
          manifestCodec: t,
          duration: s,
          inputTimeScale: 9e4,
          dropped: 0
        });
    }
    canParse(e, t) {
      return t + 64 < e.length;
    }
    appendFrame(e, t, i) {
      const s = XS(e, t, i, this.basePTS, this.frameIndex);
      if (-1 !== s) {
        return {
          sample: e.samples[e.samples.length - 1],
          length: s,
          missing: 0
        };
      }
    }
    static probe(e) {
      if (!e) return !1;
      const t = uS(e, 0);
      if (!t) return !1;
      const i = t.length;
      return (
        11 === e[i] && 119 === e[i + 1] && void 0 !== NS(t) && $S(e, i) < 16
      );
    }
  }
  function XS(e, t, i, s, r) {
    if (i + 8 > t.length) return -1;
    if (11 !== t[i] || 119 !== t[i + 1]) return -1;
    const n = t[i + 4] >> 6;
    if (n >= 3) return -1;
    const a = [48e3, 44100, 32e3][n],
      o = 63 & t[i + 4],
      c =
        2 *
        [
          64,
          69,
          96,
          64,
          70,
          96,
          80,
          87,
          120,
          80,
          88,
          120,
          96,
          104,
          144,
          96,
          105,
          144,
          112,
          121,
          168,
          112,
          122,
          168,
          128,
          139,
          192,
          128,
          140,
          192,
          160,
          174,
          240,
          160,
          175,
          240,
          192,
          208,
          288,
          192,
          209,
          288,
          224,
          243,
          336,
          224,
          244,
          336,
          256,
          278,
          384,
          256,
          279,
          384,
          320,
          348,
          480,
          320,
          349,
          480,
          384,
          417,
          576,
          384,
          418,
          576,
          448,
          487,
          672,
          448,
          488,
          672,
          512,
          557,
          768,
          512,
          558,
          768,
          640,
          696,
          960,
          640,
          697,
          960,
          768,
          835,
          1152,
          768,
          836,
          1152,
          896,
          975,
          1344,
          896,
          976,
          1344,
          1024,
          1114,
          1536,
          1024,
          1115,
          1536,
          1152,
          1253,
          1728,
          1152,
          1254,
          1728,
          1280,
          1393,
          1920,
          1280,
          1394,
          1920
        ][3 * o + n];
    if (i + c > t.length) return -1;
    const d = t[i + 6] >> 5;
    let l = 0;
    2 === d ? (l += 2) : (1 & d && 1 !== d && (l += 2), 4 & d && (l += 2));
    const h = (((t[i + 6] << 8) | t[i + 7]) >> (12 - l)) & 1,
      u = [2, 1, 2, 3, 3, 4, 4, 5][d] + h,
      p = t[i + 5] >> 3,
      f = 7 & t[i + 5],
      E = new Uint8Array([
        (n << 6) | (p << 1) | (f >> 2),
        ((3 & f) << 6) | (d << 3) | (h << 2) | (o >> 4),
        (o << 4) & 224
      ]),
      m = s + r * ((1536 / a) * 9e4),
      g = t.subarray(i, i + c);
    return (
      (e.config = E),
      (e.channelCount = u),
      (e.samplerate = a),
      e.samples.push({ unit: g, pts: m }),
      c
    );
  }
  const zS = /\/emsg[-/]ID3/i;
  function JS(e, t) {
    return Tm(e.presentationTime)
      ? e.presentationTime / e.timeScale
      : t + e.presentationTimeDelta / e.timeScale;
  }
  class QS {
    constructor(e, t, i) {
      (this.keyData = void 0),
        (this.decrypter = void 0),
        (this.keyData = i),
        (this.decrypter = new M_(t, { removePKCS7Padding: !1 }));
    }
    decryptBuffer(e) {
      return this.decrypter.decrypt(
        e,
        this.keyData.key.buffer,
        this.keyData.iv.buffer,
        L_.cbc
      );
    }
    decryptAacSample(e, t, i) {
      const s = e[t].unit;
      if (s.length <= 16) return;
      const r = s.subarray(16, s.length - (s.length % 16)),
        n = r.buffer.slice(r.byteOffset, r.byteOffset + r.length);
      this.decryptBuffer(n).then(r => {
        const n = new Uint8Array(r);
        s.set(n, 16),
          this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, i);
      });
    }
    decryptAacSamples(e, t, i) {
      for (; ; t++) {
        if (t >= e.length) return void i();
        if (
          !(e[t].unit.length < 32) &&
          (this.decryptAacSample(e, t, i), !this.decrypter.isSync())
        )
          return;
      }
    }
    getAvcEncryptedData(e) {
      const t = 16 * Math.floor((e.length - 48) / 160) + 16,
        i = new Int8Array(t);
      let s = 0;
      for (let t = 32; t < e.length - 16; t += 160, s += 16)
        i.set(e.subarray(t, t + 16), s);
      return i;
    }
    getAvcDecryptedUnit(e, t) {
      const i = new Uint8Array(t);
      let s = 0;
      for (let t = 32; t < e.length - 16; t += 160, s += 16)
        e.set(i.subarray(s, s + 16), t);
      return e;
    }
    decryptAvcSample(e, t, i, s, r) {
      const n = Ig(r.data),
        a = this.getAvcEncryptedData(n);
      this.decryptBuffer(a.buffer).then(a => {
        (r.data = this.getAvcDecryptedUnit(n, a)),
          this.decrypter.isSync() || this.decryptAvcSamples(e, t, i + 1, s);
      });
    }
    decryptAvcSamples(e, t, i, s) {
      if (e instanceof Uint8Array)
        throw new Error("Cannot decrypt samples of type Uint8Array");
      for (; ; t++, i = 0) {
        if (t >= e.length) return void s();
        const r = e[t].units;
        for (; !(i >= r.length); i++) {
          const n = r[i];
          if (
            !(
              n.data.length <= 48 ||
              (1 !== n.type && 5 !== n.type) ||
              (this.decryptAvcSample(e, t, i, s, n), this.decrypter.isSync())
            )
          )
            return;
        }
      }
    }
  }
  class ZS {
    constructor() {
      this.VideoSample = null;
    }
    createVideoSample(e, t, i) {
      return { key: e, frame: !1, pts: t, dts: i, units: [], length: 0 };
    }
    getLastNalUnit(e) {
      var t;
      let i,
        s = this.VideoSample;
      if (
        ((s && 0 !== s.units.length) || (s = e[e.length - 1]),
        null != (t = s) && t.units)
      ) {
        const e = s.units;
        i = e[e.length - 1];
      }
      return i;
    }
    pushAccessUnit(e, t) {
      if (e.units.length && e.frame) {
        if (void 0 === e.pts) {
          const i = t.samples,
            s = i.length;
          if (!s) return void t.dropped++;
          {
            const t = i[s - 1];
            (e.pts = t.pts), (e.dts = t.dts);
          }
        }
        t.samples.push(e);
      }
    }
    parseNALu(e, t, i) {
      const s = t.byteLength;
      let r = e.naluState || 0;
      const n = r,
        a = [];
      let o,
        c,
        d,
        l = 0,
        h = -1,
        u = 0;
      for (
        -1 === r && ((h = 0), (u = this.getNALuType(t, 0)), (r = 0), (l = 1));
        l < s;

      )
        if (((o = t[l++]), r))
          if (1 !== r)
            if (o)
              if (1 === o) {
                if (((c = l - r - 1), h >= 0)) {
                  const e = { data: t.subarray(h, c), type: u };
                  a.push(e);
                } else {
                  const i = this.getLastNalUnit(e.samples);
                  i &&
                    (n &&
                      l <= 4 - n &&
                      i.state &&
                      (i.data = i.data.subarray(0, i.data.byteLength - n)),
                    c > 0 &&
                      ((i.data = Sg(i.data, t.subarray(0, c))), (i.state = 0)));
                }
                l < s
                  ? ((d = this.getNALuType(t, l)), (h = l), (u = d), (r = 0))
                  : (r = -1);
              } else r = 0;
            else r = 3;
          else r = o ? 0 : 2;
        else r = o ? 0 : 1;
      if (h >= 0 && r >= 0) {
        const e = { data: t.subarray(h, s), type: u, state: r };
        a.push(e);
      }
      if (0 === a.length) {
        const i = this.getLastNalUnit(e.samples);
        i && (i.data = Sg(i.data, t));
      }
      return (e.naluState = r), a;
    }
  }
  class ev {
    constructor(e) {
      (this.data = void 0),
        (this.bytesAvailable = void 0),
        (this.word = void 0),
        (this.bitsAvailable = void 0),
        (this.data = e),
        (this.bytesAvailable = e.byteLength),
        (this.word = 0),
        (this.bitsAvailable = 0);
    }
    loadWord() {
      const e = this.data,
        t = this.bytesAvailable,
        i = e.byteLength - t,
        s = new Uint8Array(4),
        r = Math.min(4, t);
      if (0 === r) throw new Error("no bytes available");
      s.set(e.subarray(i, i + r)),
        (this.word = new DataView(s.buffer).getUint32(0)),
        (this.bitsAvailable = 8 * r),
        (this.bytesAvailable -= r);
    }
    skipBits(e) {
      let t;
      (e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable)),
        this.bitsAvailable > e
          ? ((this.word <<= e), (this.bitsAvailable -= e))
          : ((t = (e -= this.bitsAvailable) >> 3),
            (e -= t << 3),
            (this.bytesAvailable -= t),
            this.loadWord(),
            (this.word <<= e),
            (this.bitsAvailable -= e));
    }
    readBits(e) {
      let t = Math.min(this.bitsAvailable, e);
      const i = this.word >>> (32 - t);
      if (
        (e > 32 && Bm.error("Cannot read more than 32 bits at a time"),
        (this.bitsAvailable -= t),
        this.bitsAvailable > 0)
      )
        this.word <<= t;
      else {
        if (!(this.bytesAvailable > 0)) throw new Error("no bits available");
        this.loadWord();
      }
      return (
        (t = e - t),
        t > 0 && this.bitsAvailable ? (i << t) | this.readBits(t) : i
      );
    }
    skipLZ() {
      let e;
      for (e = 0; e < this.bitsAvailable; ++e)
        if (0 != (this.word & (2147483648 >>> e)))
          return (this.word <<= e), (this.bitsAvailable -= e), e;
      return this.loadWord(), e + this.skipLZ();
    }
    skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }
    skipEG() {
      this.skipBits(1 + this.skipLZ());
    }
    readUEG() {
      const e = this.skipLZ();
      return this.readBits(e + 1) - 1;
    }
    readEG() {
      const e = this.readUEG();
      return 1 & e ? (1 + e) >>> 1 : -1 * (e >>> 1);
    }
    readBoolean() {
      return 1 === this.readBits(1);
    }
    readUByte() {
      return this.readBits(8);
    }
    readUShort() {
      return this.readBits(16);
    }
    readUInt() {
      return this.readBits(32);
    }
  }
  class tv extends ZS {
    parsePES(e, t, i, s) {
      const r = this.parseNALu(e, i.data, s);
      let n,
        a = this.VideoSample,
        o = !1;
      (i.data = null),
        a &&
          r.length &&
          !e.audFound &&
          (this.pushAccessUnit(a, e),
          (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts))),
        r.forEach(s => {
          var r, c;
          switch (s.type) {
            case 1: {
              let t = !1;
              n = !0;
              const r = s.data;
              if (o && r.length > 4) {
                const e = this.readSliceType(r);
                (2 !== e && 4 !== e && 7 !== e && 9 !== e) || (t = !0);
              }
              var d;
              if (t)
                null != (d = a) &&
                  d.frame &&
                  !a.key &&
                  (this.pushAccessUnit(a, e), (a = this.VideoSample = null));
              a ||
                (a = this.VideoSample = this.createVideoSample(
                  !0,
                  i.pts,
                  i.dts
                )),
                (a.frame = !0),
                (a.key = t);
              break;
            }
            case 5:
              (n = !0),
                null != (r = a) &&
                  r.frame &&
                  !a.key &&
                  (this.pushAccessUnit(a, e), (a = this.VideoSample = null)),
                a ||
                  (a = this.VideoSample = this.createVideoSample(
                    !0,
                    i.pts,
                    i.dts
                  )),
                (a.key = !0),
                (a.frame = !0);
              break;
            case 6:
              (n = !0), Ag(s.data, 1, i.pts, t.samples);
              break;
            case 7: {
              var l, h;
              (n = !0), (o = !0);
              const t = s.data,
                i = this.readSPS(t);
              if (
                !e.sps ||
                e.width !== i.width ||
                e.height !== i.height ||
                (null == (l = e.pixelRatio) ? void 0 : l[0]) !==
                  i.pixelRatio[0] ||
                (null == (h = e.pixelRatio) ? void 0 : h[1]) !== i.pixelRatio[1]
              ) {
                (e.width = i.width),
                  (e.height = i.height),
                  (e.pixelRatio = i.pixelRatio),
                  (e.sps = [t]);
                const s = t.subarray(1, 4);
                let r = "avc1.";
                for (let e = 0; e < 3; e++) {
                  let t = s[e].toString(16);
                  t.length < 2 && (t = "0" + t), (r += t);
                }
                e.codec = r;
              }
              break;
            }
            case 8:
              (n = !0), (e.pps = [s.data]);
              break;
            case 9:
              (n = !0),
                (e.audFound = !0),
                null != (c = a) &&
                  c.frame &&
                  (this.pushAccessUnit(a, e), (a = null)),
                a ||
                  (a = this.VideoSample = this.createVideoSample(
                    !1,
                    i.pts,
                    i.dts
                  ));
              break;
            case 12:
              n = !0;
              break;
            default:
              n = !1;
          }
          if (a && n) {
            a.units.push(s);
          }
        }),
        s && a && (this.pushAccessUnit(a, e), (this.VideoSample = null));
    }
    getNALuType(e, t) {
      return 31 & e[t];
    }
    readSliceType(e) {
      const t = new ev(e);
      return t.readUByte(), t.readUEG(), t.readUEG();
    }
    skipScalingList(e, t) {
      let i,
        s = 8,
        r = 8;
      for (let n = 0; n < e; n++)
        0 !== r && ((i = t.readEG()), (r = (s + i + 256) % 256)),
          (s = 0 === r ? s : r);
    }
    readSPS(e) {
      const t = new ev(e);
      let i,
        s,
        r,
        n = 0,
        a = 0,
        o = 0,
        c = 0;
      const d = t.readUByte.bind(t),
        l = t.readBits.bind(t),
        h = t.readUEG.bind(t),
        u = t.readBoolean.bind(t),
        p = t.skipBits.bind(t),
        f = t.skipEG.bind(t),
        E = t.skipUEG.bind(t),
        m = this.skipScalingList.bind(this);
      d();
      const g = d();
      if (
        (l(5),
        p(3),
        d(),
        E(),
        100 === g ||
          110 === g ||
          122 === g ||
          244 === g ||
          44 === g ||
          83 === g ||
          86 === g ||
          118 === g ||
          128 === g)
      ) {
        const e = h();
        if ((3 === e && p(1), E(), E(), p(1), u()))
          for (s = 3 !== e ? 8 : 12, r = 0; r < s; r++)
            u() && m(r < 6 ? 16 : 64, t);
      }
      E();
      const _ = h();
      if (0 === _) h();
      else if (1 === _) for (p(1), f(), f(), i = h(), r = 0; r < i; r++) f();
      E(), p(1);
      const T = h(),
        S = h(),
        v = l(1);
      0 === v && p(1),
        p(1),
        u() && ((n = h()), (a = h()), (o = h()), (c = h()));
      let R = [1, 1];
      if (u() && u()) {
        switch (d()) {
          case 1:
            R = [1, 1];
            break;
          case 2:
            R = [12, 11];
            break;
          case 3:
            R = [10, 11];
            break;
          case 4:
            R = [16, 11];
            break;
          case 5:
            R = [40, 33];
            break;
          case 6:
            R = [24, 11];
            break;
          case 7:
            R = [20, 11];
            break;
          case 8:
            R = [32, 11];
            break;
          case 9:
            R = [80, 33];
            break;
          case 10:
            R = [18, 11];
            break;
          case 11:
            R = [15, 11];
            break;
          case 12:
            R = [64, 33];
            break;
          case 13:
            R = [160, 99];
            break;
          case 14:
            R = [4, 3];
            break;
          case 15:
            R = [3, 2];
            break;
          case 16:
            R = [2, 1];
            break;
          case 255:
            R = [(d() << 8) | d(), (d() << 8) | d()];
        }
      }
      return {
        width: Math.ceil(16 * (T + 1) - 2 * n - 2 * a),
        height: (2 - v) * (S + 1) * 16 - (v ? 2 : 4) * (o + c),
        pixelRatio: R
      };
    }
  }
  class iv extends ZS {
    constructor(...e) {
      super(...e), (this.initVPS = null);
    }
    parsePES(e, t, i, s) {
      const r = this.parseNALu(e, i.data, s);
      let n,
        a = this.VideoSample,
        o = !1;
      (i.data = null),
        a &&
          r.length &&
          !e.audFound &&
          (this.pushAccessUnit(a, e),
          (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts))),
        r.forEach(s => {
          var r, c;
          switch (s.type) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
              a ||
                (a = this.VideoSample = this.createVideoSample(
                  !1,
                  i.pts,
                  i.dts
                )),
                (a.frame = !0),
                (n = !0);
              break;
            case 16:
            case 17:
            case 18:
            case 21:
              var d;
              if (((n = !0), o))
                null != (d = a) &&
                  d.frame &&
                  !a.key &&
                  (this.pushAccessUnit(a, e), (a = this.VideoSample = null));
              a ||
                (a = this.VideoSample = this.createVideoSample(
                  !0,
                  i.pts,
                  i.dts
                )),
                (a.key = !0),
                (a.frame = !0);
              break;
            case 19:
            case 20:
              (n = !0),
                null != (r = a) &&
                  r.frame &&
                  !a.key &&
                  (this.pushAccessUnit(a, e), (a = this.VideoSample = null)),
                a ||
                  (a = this.VideoSample = this.createVideoSample(
                    !0,
                    i.pts,
                    i.dts
                  )),
                (a.key = !0),
                (a.frame = !0);
              break;
            case 39:
              (n = !0), Ag(s.data, 2, i.pts, t.samples);
              break;
            case 32:
              (n = !0),
                e.vps ||
                  ("object" != typeof e.params && (e.params = {}),
                  (e.params = wm(e.params, this.readVPS(s.data))),
                  (this.initVPS = s.data)),
                (e.vps = [s.data]);
              break;
            case 33:
              if (
                ((n = !0),
                (o = !0),
                void 0 === e.vps ||
                  e.vps[0] === this.initVPS ||
                  void 0 === e.sps ||
                  this.matchSPS(e.sps[0], s.data) ||
                  ((this.initVPS = e.vps[0]), (e.sps = e.pps = void 0)),
                !e.sps)
              ) {
                const t = this.readSPS(s.data);
                (e.width = t.width),
                  (e.height = t.height),
                  (e.pixelRatio = t.pixelRatio),
                  (e.codec = t.codecString),
                  (e.sps = []),
                  "object" != typeof e.params && (e.params = {});
                for (const i in t.params) e.params[i] = t.params[i];
              }
              this.pushParameterSet(e.sps, s.data, e.vps),
                a ||
                  (a = this.VideoSample = this.createVideoSample(
                    !0,
                    i.pts,
                    i.dts
                  )),
                (a.key = !0);
              break;
            case 34:
              if (((n = !0), "object" == typeof e.params)) {
                if (!e.pps) {
                  e.pps = [];
                  const t = this.readPPS(s.data);
                  for (const i in t) e.params[i] = t[i];
                }
                this.pushParameterSet(e.pps, s.data, e.vps);
              }
              break;
            case 35:
              (n = !0),
                (e.audFound = !0),
                null != (c = a) &&
                  c.frame &&
                  (this.pushAccessUnit(a, e), (a = null)),
                a ||
                  (a = this.VideoSample = this.createVideoSample(
                    !1,
                    i.pts,
                    i.dts
                  ));
              break;
            default:
              n = !1;
          }
          if (a && n) {
            a.units.push(s);
          }
        }),
        s && a && (this.pushAccessUnit(a, e), (this.VideoSample = null));
    }
    pushParameterSet(e, t, i) {
      ((i && i[0] === this.initVPS) || (!i && !e.length)) && e.push(t);
    }
    getNALuType(e, t) {
      return (126 & e[t]) >>> 1;
    }
    ebsp2rbsp(e) {
      const t = new Uint8Array(e.byteLength);
      let i = 0;
      for (let s = 0; s < e.byteLength; s++)
        (s >= 2 && 3 === e[s] && 0 === e[s - 1] && 0 === e[s - 2]) ||
          ((t[i] = e[s]), i++);
      return new Uint8Array(t.buffer, 0, i);
    }
    pushAccessUnit(e, t) {
      super.pushAccessUnit(e, t), this.initVPS && (this.initVPS = null);
    }
    readVPS(e) {
      const t = new ev(e);
      t.readUByte(), t.readUByte(), t.readBits(4), t.skipBits(2), t.readBits(6);
      return {
        numTemporalLayers: t.readBits(3) + 1,
        temporalIdNested: t.readBoolean()
      };
    }
    readSPS(e) {
      const t = new ev(this.ebsp2rbsp(e));
      t.readUByte(), t.readUByte(), t.readBits(4);
      const i = t.readBits(3);
      t.readBoolean();
      const s = t.readBits(2),
        r = t.readBoolean(),
        n = t.readBits(5),
        a = t.readUByte(),
        o = t.readUByte(),
        c = t.readUByte(),
        d = t.readUByte(),
        l = t.readUByte(),
        h = t.readUByte(),
        u = t.readUByte(),
        p = t.readUByte(),
        f = t.readUByte(),
        E = t.readUByte(),
        m = t.readUByte(),
        g = [],
        _ = [];
      for (let e = 0; e < i; e++)
        g.push(t.readBoolean()), _.push(t.readBoolean());
      if (i > 0) for (let e = i; e < 8; e++) t.readBits(2);
      for (let e = 0; e < i; e++)
        g[e] &&
          (t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte(),
          t.readUByte()),
          _[e] && t.readUByte();
      t.readUEG();
      const T = t.readUEG();
      3 == T && t.skipBits(1);
      const S = t.readUEG(),
        v = t.readUEG(),
        R = t.readBoolean();
      let y = 0,
        A = 0,
        I = 0,
        C = 0;
      R &&
        ((y += t.readUEG()),
        (A += t.readUEG()),
        (I += t.readUEG()),
        (C += t.readUEG()));
      const b = t.readUEG(),
        O = t.readUEG(),
        D = t.readUEG();
      for (let e = t.readBoolean() ? 0 : i; e <= i; e++)
        t.skipUEG(), t.skipUEG(), t.skipUEG();
      t.skipUEG(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipUEG();
      if (t.readBoolean()) {
        if (t.readBoolean())
          for (let e = 0; e < 4; e++)
            for (let i = 0; i < (3 === e ? 2 : 6); i++) {
              if (t.readBoolean()) {
                const i = Math.min(64, 1 << (4 + (e << 1)));
                e > 1 && t.readEG();
                for (let e = 0; e < i; e++) t.readEG();
              } else t.readUEG();
            }
      }
      t.readBoolean(), t.readBoolean();
      t.readBoolean() &&
        (t.readUByte(), t.skipUEG(), t.skipUEG(), t.readBoolean());
      const w = t.readUEG();
      let L = 0;
      for (let e = 0; e < w; e++) {
        let i = !1;
        if ((0 !== e && (i = t.readBoolean()), i)) {
          e === w && t.readUEG(), t.readBoolean(), t.readUEG();
          let i = 0;
          for (let e = 0; e <= L; e++) {
            const e = t.readBoolean();
            let s = !1;
            e || (s = t.readBoolean()), (e || s) && i++;
          }
          L = i;
        } else {
          const e = t.readUEG(),
            i = t.readUEG();
          L = e + i;
          for (let i = 0; i < e; i++) t.readUEG(), t.readBoolean();
          for (let e = 0; e < i; e++) t.readUEG(), t.readBoolean();
        }
      }
      if (t.readBoolean()) {
        const e = t.readUEG();
        for (let i = 0; i < e; i++) {
          for (let e = 0; e < D + 4; e++) t.readBits(1);
          t.readBits(1);
        }
      }
      let N = 0,
        P = 1,
        k = 1,
        M = !0,
        U = 1,
        x = 0;
      t.readBoolean(), t.readBoolean();
      let F = !1;
      if (t.readBoolean()) {
        if (t.readBoolean()) {
          const e = t.readUByte();
          e > 0 && e < 16
            ? ((P = [
                1,
                12,
                10,
                16,
                40,
                24,
                20,
                32,
                80,
                18,
                15,
                64,
                160,
                4,
                3,
                2
              ][e - 1]),
              (k = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1][
                e - 1
              ]))
            : 255 === e && ((P = t.readBits(16)), (k = t.readBits(16)));
        }
        t.readBoolean() && t.readBoolean();
        if (t.readBoolean()) {
          t.readBits(3), t.readBoolean();
          t.readBoolean() && (t.readUByte(), t.readUByte(), t.readUByte());
        }
        t.readBoolean() && (t.readUEG(), t.readUEG()),
          t.readBoolean(),
          t.readBoolean(),
          t.readBoolean(),
          (F = t.readBoolean()),
          F &&
            ((y += t.readUEG()),
            (A += t.readUEG()),
            (I += t.readUEG()),
            (C += t.readUEG()));
        if (t.readBoolean()) {
          (U = t.readBits(32)), (x = t.readBits(32));
          t.readBoolean() && t.readUEG();
          if (t.readBoolean()) {
            const e = t.readBoolean(),
              s = t.readBoolean();
            let r = !1;
            (e || s) &&
              ((r = t.readBoolean()),
              r &&
                (t.readUByte(), t.readBits(5), t.readBoolean(), t.readBits(5)),
              t.readBits(4),
              t.readBits(4),
              r && t.readBits(4),
              t.readBits(5),
              t.readBits(5),
              t.readBits(5));
            for (let n = 0; n <= i; n++) {
              M = t.readBoolean();
              let i = !1;
              M || t.readBoolean() ? t.readEG() : (i = t.readBoolean());
              const n = i ? 1 : t.readUEG() + 1;
              if (e)
                for (let e = 0; e < n; e++)
                  t.readUEG(),
                    t.readUEG(),
                    r && (t.readUEG(), t.readUEG()),
                    t.skipBits(1);
              if (s)
                for (let e = 0; e < n; e++)
                  t.readUEG(),
                    t.readUEG(),
                    r && (t.readUEG(), t.readUEG()),
                    t.skipBits(1);
            }
          }
        }
        t.readBoolean() &&
          (t.readBoolean(),
          t.readBoolean(),
          t.readBoolean(),
          (N = t.readUEG()));
      }
      let B = S,
        V = v;
      if (R || F) {
        let e = 1,
          t = 1;
        1 === T ? (e = t = 2) : 2 == T && (e = 2),
          (B = S - e * A - e * y),
          (V = v - t * C - t * I);
      }
      const G = s ? ["A", "B", "C"][s] : "",
        j = (a << 24) | (o << 16) | (c << 8) | d;
      let H = 0;
      for (let e = 0; e < 32; e++) H = (H | (((j >> e) & 1) << (31 - e))) >>> 0;
      let K = H.toString(16);
      1 === n && "2" === K && (K = "6");
      return {
        codecString: `hvc1.${G}${n}.${K}.${r ? "H" : "L"}${m}.B0`,
        params: {
          general_tier_flag: r,
          general_profile_idc: n,
          general_profile_space: s,
          general_profile_compatibility_flags: [a, o, c, d],
          general_constraint_indicator_flags: [l, h, u, p, f, E],
          general_level_idc: m,
          bit_depth: b + 8,
          bit_depth_luma_minus8: b,
          bit_depth_chroma_minus8: O,
          min_spatial_segmentation_idc: N,
          chroma_format_idc: T,
          frame_rate: { fixed: M, fps: x / U }
        },
        width: B,
        height: V,
        pixelRatio: [P, k]
      };
    }
    readPPS(e) {
      const t = new ev(this.ebsp2rbsp(e));
      t.readUByte(),
        t.readUByte(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipBits(2),
        t.skipBits(3),
        t.skipBits(2),
        t.skipUEG(),
        t.skipUEG(),
        t.skipEG(),
        t.skipBits(2);
      t.readBoolean() && t.skipUEG(), t.skipEG(), t.skipEG(), t.skipBits(4);
      const i = t.readBoolean(),
        s = t.readBoolean();
      let r = 1;
      return (
        s && i ? (r = 0) : s ? (r = 3) : i && (r = 2), { parallelismType: r }
      );
    }
    matchSPS(e, t) {
      return (
        String.fromCharCode.apply(null, e).substr(3) ===
        String.fromCharCode.apply(null, t).substr(3)
      );
    }
  }
  const sv = 188;
  class rv {
    constructor(e, t, i, s) {
      (this.logger = void 0),
        (this.observer = void 0),
        (this.config = void 0),
        (this.typeSupported = void 0),
        (this.sampleAes = null),
        (this.pmtParsed = !1),
        (this.audioCodec = void 0),
        (this.videoCodec = void 0),
        (this._pmtId = -1),
        (this._videoTrack = void 0),
        (this._audioTrack = void 0),
        (this._id3Track = void 0),
        (this._txtTrack = void 0),
        (this.aacOverFlow = null),
        (this.remainderData = null),
        (this.videoParser = void 0),
        (this.observer = e),
        (this.config = t),
        (this.typeSupported = i),
        (this.logger = s),
        (this.videoParser = null);
    }
    static probe(e, t) {
      const i = rv.syncOffset(e);
      return (
        i > 0 &&
          t.warn(`MPEG2-TS detected but first sync word found @ offset ${i}`),
        -1 !== i
      );
    }
    static syncOffset(e) {
      const t = e.length;
      let i = Math.min(940, t - sv) + 1,
        s = 0;
      for (; s < i; ) {
        let r = !1,
          n = -1,
          a = 0;
        for (let o = s; o < t; o += sv) {
          if (71 !== e[o] || (t - o !== sv && 71 !== e[o + sv])) {
            if (a) return -1;
            break;
          }
          if (
            (a++,
            -1 === n &&
              ((n = o),
              0 !== n && (i = Math.min(n + 18612, e.length - sv) + 1)),
            r || (r = 0 === nv(e, o)),
            r && a > 1 && ((0 === n && a > 2) || o + sv > i))
          )
            return n;
        }
        s++;
      }
      return -1;
    }
    static createTrack(e, t) {
      return {
        container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
        type: e,
        id: sg[e],
        pid: -1,
        inputTimeScale: 9e4,
        sequenceNumber: 0,
        samples: [],
        dropped: 0,
        duration: "audio" === e ? t : void 0
      };
    }
    resetInitSegment(e, t, i, s) {
      (this.pmtParsed = !1),
        (this._pmtId = -1),
        (this._videoTrack = rv.createTrack("video")),
        (this._videoTrack.duration = s),
        (this._audioTrack = rv.createTrack("audio", s)),
        (this._id3Track = rv.createTrack("id3")),
        (this._txtTrack = rv.createTrack("text")),
        (this._audioTrack.segmentCodec = "aac"),
        (this.aacOverFlow = null),
        (this.remainderData = null),
        (this.audioCodec = t),
        (this.videoCodec = i);
    }
    resetTimeStamp() {}
    resetContiguity() {
      const { _audioTrack: e, _videoTrack: t, _id3Track: i } = this;
      e && (e.pesData = null),
        t && (t.pesData = null),
        i && (i.pesData = null),
        (this.aacOverFlow = null),
        (this.remainderData = null);
    }
    demux(e, t, i = !1, s = !1) {
      let r;
      i || (this.sampleAes = null);
      const n = this._videoTrack,
        a = this._audioTrack,
        o = this._id3Track,
        c = this._txtTrack;
      let d = n.pid,
        l = n.pesData,
        h = a.pid,
        u = o.pid,
        p = a.pesData,
        f = o.pesData,
        E = null,
        m = this.pmtParsed,
        g = this._pmtId,
        _ = e.length;
      if (
        (this.remainderData &&
          ((_ = (e = Sg(this.remainderData, e)).length),
          (this.remainderData = null)),
        _ < sv && !s)
      )
        return (
          (this.remainderData = e),
          { audioTrack: a, videoTrack: n, id3Track: o, textTrack: c }
        );
      const T = Math.max(0, rv.syncOffset(e));
      (_ -= (_ - T) % sv),
        _ < e.byteLength &&
          !s &&
          (this.remainderData = new Uint8Array(
            e.buffer,
            _,
            e.buffer.byteLength - _
          ));
      let S = 0;
      for (let t = T; t < _; t += sv)
        if (71 === e[t]) {
          const s = !!(64 & e[t + 1]),
            _ = nv(e, t);
          let S;
          if ((48 & e[t + 3]) >> 4 > 1) {
            if (((S = t + 5 + e[t + 4]), S === t + sv)) continue;
          } else S = t + 4;
          switch (_) {
            case d:
              if (s) {
                if (l && (r = lv(l, this.logger))) {
                  if (null === this.videoParser)
                    switch (n.segmentCodec) {
                      case "avc":
                        this.videoParser = new tv();
                        break;
                      case "hevc":
                        this.videoParser = new iv();
                    }
                  null !== this.videoParser &&
                    this.videoParser.parsePES(n, c, r, !1);
                }
                l = { data: [], size: 0 };
              }
              l && (l.data.push(e.subarray(S, t + sv)), (l.size += t + sv - S));
              break;
            case h:
              if (s) {
                if (p && (r = lv(p, this.logger)))
                  switch (a.segmentCodec) {
                    case "aac":
                      this.parseAACPES(a, r);
                      break;
                    case "mp3":
                      this.parseMPEGPES(a, r);
                      break;
                    case "ac3":
                      this.parseAC3PES(a, r);
                  }
                p = { data: [], size: 0 };
              }
              p && (p.data.push(e.subarray(S, t + sv)), (p.size += t + sv - S));
              break;
            case u:
              s &&
                (f && (r = lv(f, this.logger)) && this.parseID3PES(o, r),
                (f = { data: [], size: 0 })),
                f &&
                  (f.data.push(e.subarray(S, t + sv)), (f.size += t + sv - S));
              break;
            case 0:
              s && (S += e[S] + 1), (g = this._pmtId = av(e, S));
              break;
            case g: {
              s && (S += e[S] + 1);
              const r = ov(
                e,
                S,
                this.typeSupported,
                i,
                this.observer,
                this.logger
              );
              (d = r.videoPid),
                d > 0 && ((n.pid = d), (n.segmentCodec = r.segmentVideoCodec)),
                (h = r.audioPid),
                h > 0 && ((a.pid = h), (a.segmentCodec = r.segmentAudioCodec)),
                (u = r.id3Pid),
                u > 0 && (o.pid = u),
                null === E ||
                  m ||
                  (this.logger.warn(
                    `MPEG-TS PMT found at ${t} after unknown PID '${E}'. Backtracking to sync byte @${T} to parse all TS packets.`
                  ),
                  (E = null),
                  (t = T - 188)),
                (m = this.pmtParsed = !0);
              break;
            }
            case 17:
            case 8191:
              break;
            default:
              E = _;
          }
        } else S++;
      S > 0 &&
        cv(
          this.observer,
          new Error(`Found ${S} TS packet/s that do not start with 0x47`),
          void 0,
          this.logger
        ),
        (n.pesData = l),
        (a.pesData = p),
        (o.pesData = f);
      const v = { audioTrack: a, videoTrack: n, id3Track: o, textTrack: c };
      return s && this.extractRemainingSamples(v), v;
    }
    flush() {
      const { remainderData: e } = this;
      let t;
      return (
        (this.remainderData = null),
        (t = e
          ? this.demux(e, -1, !1, !0)
          : {
              videoTrack: this._videoTrack,
              audioTrack: this._audioTrack,
              id3Track: this._id3Track,
              textTrack: this._txtTrack
            }),
        this.extractRemainingSamples(t),
        this.sampleAes ? this.decrypt(t, this.sampleAes) : t
      );
    }
    extractRemainingSamples(e) {
      const { audioTrack: t, videoTrack: i, id3Track: s, textTrack: r } = e,
        n = i.pesData,
        a = t.pesData,
        o = s.pesData;
      let c;
      if (n && (c = lv(n, this.logger))) {
        if (null === this.videoParser)
          switch (i.segmentCodec) {
            case "avc":
              this.videoParser = new tv();
              break;
            case "hevc":
              this.videoParser = new iv();
          }
        null !== this.videoParser &&
          (this.videoParser.parsePES(i, r, c, !0), (i.pesData = null));
      } else i.pesData = n;
      if (a && (c = lv(a, this.logger))) {
        switch (t.segmentCodec) {
          case "aac":
            this.parseAACPES(t, c);
            break;
          case "mp3":
            this.parseMPEGPES(t, c);
            break;
          case "ac3":
            this.parseAC3PES(t, c);
        }
        t.pesData = null;
      } else null != a && a.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), (t.pesData = a);
      o && (c = lv(o, this.logger))
        ? (this.parseID3PES(s, c), (s.pesData = null))
        : (s.pesData = o);
    }
    demuxSampleAes(e, t, i) {
      const s = this.demux(e, i, !0, !this.config.progressive),
        r = (this.sampleAes = new QS(this.observer, this.config, t));
      return this.decrypt(s, r);
    }
    decrypt(e, t) {
      return new Promise(i => {
        const { audioTrack: s, videoTrack: r } = e;
        s.samples && "aac" === s.segmentCodec
          ? t.decryptAacSamples(s.samples, 0, () => {
              r.samples
                ? t.decryptAvcSamples(r.samples, 0, 0, () => {
                    i(e);
                  })
                : i(e);
            })
          : r.samples &&
            t.decryptAvcSamples(r.samples, 0, 0, () => {
              i(e);
            });
      });
    }
    destroy() {
      this.observer && this.observer.removeAllListeners(),
        (this.config = this.logger = this.observer = null),
        (this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null),
        (this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0);
    }
    parseAACPES(e, t) {
      let i = 0;
      const s = this.aacOverFlow;
      let r,
        n,
        a,
        o = t.data;
      if (s) {
        this.aacOverFlow = null;
        const t = s.missing,
          r = s.sample.unit.byteLength;
        if (-1 === t) o = Sg(s.sample.unit, o);
        else {
          const n = r - t;
          s.sample.unit.set(o.subarray(0, t), n),
            e.samples.push(s.sample),
            (i = s.missing);
        }
      }
      for (r = i, n = o.length; r < n - 1 && !mS(o, r); r++);
      if (r !== i) {
        let e;
        const t = r < n - 1;
        if (
          ((e = t
            ? `AAC PES did not start with ADTS header,offset:${r}`
            : "No ADTS header found in AAC PES"),
          cv(this.observer, new Error(e), t, this.logger),
          !t)
        )
          return;
      }
      if ((_S(e, this.observer, o, r, this.audioCodec), void 0 !== t.pts))
        a = t.pts;
      else {
        if (!s)
          return void this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
        {
          const t = TS(e.samplerate);
          a = s.sample.pts + t;
        }
      }
      let c,
        d = 0;
      for (; r < n; ) {
        if (((c = SS(e, o, r, a, d)), (r += c.length), c.missing)) {
          this.aacOverFlow = c;
          break;
        }
        for (d++; r < n - 1 && !mS(o, r); r++);
      }
    }
    parseMPEGPES(e, t) {
      const i = t.data,
        s = i.length;
      let r = 0,
        n = 0;
      const a = t.pts;
      if (void 0 !== a)
        for (; n < s; )
          if (WS(i, n)) {
            const t = jS(e, i, n, a, r);
            if (!t) break;
            (n += t.length), r++;
          } else n++;
      else this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
    }
    parseAC3PES(e, t) {
      {
        const i = t.data,
          s = t.pts;
        if (void 0 === s)
          return void this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
        const r = i.length;
        let n,
          a = 0,
          o = 0;
        for (; o < r && (n = XS(e, i, o, s, a++)) > 0; ) o += n;
      }
    }
    parseID3PES(e, t) {
      if (void 0 === t.pts)
        return void this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      const i = wm({}, t, {
        type: this._videoTrack ? PS.emsg : PS.audioId3,
        duration: Number.POSITIVE_INFINITY
      });
      e.samples.push(i);
    }
  }
  function nv(e, t) {
    return ((31 & e[t + 1]) << 8) + e[t + 2];
  }
  function av(e, t) {
    return ((31 & e[t + 10]) << 8) | e[t + 11];
  }
  function ov(e, t, i, s, r, n) {
    const a = {
        audioPid: -1,
        videoPid: -1,
        id3Pid: -1,
        segmentVideoCodec: "avc",
        segmentAudioCodec: "aac"
      },
      o = t + 3 + (((15 & e[t + 1]) << 8) | e[t + 2]) - 4;
    for (t += 12 + (((15 & e[t + 10]) << 8) | e[t + 11]); t < o; ) {
      const o = nv(e, t),
        c = ((15 & e[t + 3]) << 8) | e[t + 4];
      switch (e[t]) {
        case 207:
          if (!s) {
            dv("ADTS AAC", n);
            break;
          }
        case 15:
          -1 === a.audioPid && (a.audioPid = o);
          break;
        case 21:
          -1 === a.id3Pid && (a.id3Pid = o);
          break;
        case 219:
          if (!s) {
            dv("H.264", n);
            break;
          }
        case 27:
          -1 === a.videoPid && (a.videoPid = o);
          break;
        case 3:
        case 4:
          i.mpeg || i.mp3
            ? -1 === a.audioPid &&
              ((a.audioPid = o), (a.segmentAudioCodec = "mp3"))
            : n.log("MPEG audio found, not supported in this browser");
          break;
        case 193:
          if (!s) {
            dv("AC-3", n);
            break;
          }
        case 129:
          i.ac3
            ? -1 === a.audioPid &&
              ((a.audioPid = o), (a.segmentAudioCodec = "ac3"))
            : n.log("AC-3 audio found, not supported in this browser");
          break;
        case 6:
          if (-1 === a.audioPid && c > 0) {
            let s = t + 5,
              r = c;
            for (; r > 2; ) {
              if (106 === e[s])
                !0 !== i.ac3
                  ? n.log(
                      "AC-3 audio found, not supported in this browser for now"
                    )
                  : ((a.audioPid = o), (a.segmentAudioCodec = "ac3"));
              const t = e[s + 1] + 2;
              (s += t), (r -= t);
            }
          }
          break;
        case 194:
        case 135:
          return (
            cv(r, new Error("Unsupported EC-3 in M2TS found"), void 0, n), a
          );
        case 36:
          -1 === a.videoPid &&
            ((a.videoPid = o),
            (a.segmentVideoCodec = "hevc"),
            n.log("HEVC in M2TS found"));
      }
      t += c + 5;
    }
    return a;
  }
  function cv(e, t, i, s) {
    s.warn(`parsing error: ${t.message}`),
      e.emit(Am.ERROR, Am.ERROR, {
        type: Rm.MEDIA_ERROR,
        details: ym.FRAG_PARSING_ERROR,
        fatal: !1,
        levelRetry: i,
        error: t,
        reason: t.message
      });
  }
  function dv(e, t) {
    t.log(`${e} with AES-128-CBC encryption found in unencrypted stream`);
  }
  function lv(e, t) {
    let i,
      s,
      r,
      n,
      a,
      o = 0;
    const c = e.data;
    if (!e || 0 === e.size) return null;
    for (; c[0].length < 19 && c.length > 1; )
      (c[0] = Sg(c[0], c[1])), c.splice(1, 1);
    i = c[0];
    if (1 === (i[0] << 16) + (i[1] << 8) + i[2]) {
      if (((s = (i[4] << 8) + i[5]), s && s > e.size - 6)) return null;
      const d = i[7];
      192 & d &&
        ((n =
          536870912 * (14 & i[9]) +
          4194304 * (255 & i[10]) +
          16384 * (254 & i[11]) +
          128 * (255 & i[12]) +
          (254 & i[13]) / 2),
        64 & d
          ? ((a =
              536870912 * (14 & i[14]) +
              4194304 * (255 & i[15]) +
              16384 * (254 & i[16]) +
              128 * (255 & i[17]) +
              (254 & i[18]) / 2),
            n - a > 54e5 &&
              (t.warn(
                `${Math.round(
                  (n - a) / 9e4
                )}s delta between PTS and DTS, align them`
              ),
              (n = a)))
          : (a = n)),
        (r = i[8]);
      let l = r + 9;
      if (e.size <= l) return null;
      e.size -= l;
      const h = new Uint8Array(e.size);
      for (let e = 0, t = c.length; e < t; e++) {
        i = c[e];
        let t = i.byteLength;
        if (l) {
          if (l > t) {
            l -= t;
            continue;
          }
          (i = i.subarray(l)), (t -= l), (l = 0);
        }
        h.set(i, o), (o += t);
      }
      return s && (s -= r + 3), { data: h, pts: n, dts: a, len: s };
    }
    return null;
  }
  class hv {
    static getSilentFrame(e, t) {
      if ("mp4a.40.2" === e) {
        if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (3 === t)
          return new Uint8Array([
            0,
            200,
            0,
            128,
            32,
            132,
            1,
            38,
            64,
            8,
            100,
            0,
            142
          ]);
        if (4 === t)
          return new Uint8Array([
            0,
            200,
            0,
            128,
            32,
            132,
            1,
            38,
            64,
            8,
            100,
            0,
            128,
            44,
            128,
            8,
            2,
            56
          ]);
        if (5 === t)
          return new Uint8Array([
            0,
            200,
            0,
            128,
            32,
            132,
            1,
            38,
            64,
            8,
            100,
            0,
            130,
            48,
            4,
            153,
            0,
            33,
            144,
            2,
            56
          ]);
        if (6 === t)
          return new Uint8Array([
            0,
            200,
            0,
            128,
            32,
            132,
            1,
            38,
            64,
            8,
            100,
            0,
            130,
            48,
            4,
            153,
            0,
            33,
            144,
            2,
            0,
            178,
            0,
            32,
            8,
            224
          ]);
      } else {
        if (1 === t)
          return new Uint8Array([
            1,
            64,
            34,
            128,
            163,
            78,
            230,
            128,
            186,
            8,
            0,
            0,
            0,
            28,
            6,
            241,
            193,
            10,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            94
          ]);
        if (2 === t)
          return new Uint8Array([
            1,
            64,
            34,
            128,
            163,
            94,
            230,
            128,
            186,
            8,
            0,
            0,
            0,
            0,
            149,
            0,
            6,
            241,
            161,
            10,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            94
          ]);
        if (3 === t)
          return new Uint8Array([
            1,
            64,
            34,
            128,
            163,
            94,
            230,
            128,
            186,
            8,
            0,
            0,
            0,
            0,
            149,
            0,
            6,
            241,
            161,
            10,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            90,
            94
          ]);
      }
    }
  }
  const uv = Math.pow(2, 32) - 1;
  class pv {
    static init() {
      let e;
      for (e in ((pv.types = {
        avc1: [],
        avcC: [],
        hvc1: [],
        hvcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        ".mp3": [],
        dac3: [],
        "ac-3": [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      }),
      pv.types))
        pv.types.hasOwnProperty(e) &&
          (pv.types[e] = [
            e.charCodeAt(0),
            e.charCodeAt(1),
            e.charCodeAt(2),
            e.charCodeAt(3)
          ]);
      const t = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          118,
          105,
          100,
          101,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          86,
          105,
          100,
          101,
          111,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
        ]),
        i = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          115,
          111,
          117,
          110,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          83,
          111,
          117,
          110,
          100,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
        ]);
      pv.HDLR_TYPES = { video: t, audio: i };
      const s = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          12,
          117,
          114,
          108,
          32,
          0,
          0,
          0,
          1
        ]),
        r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
      (pv.STTS = pv.STSC = pv.STCO = r),
        (pv.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
        (pv.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])),
        (pv.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])),
        (pv.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]));
      const n = new Uint8Array([105, 115, 111, 109]),
        a = new Uint8Array([97, 118, 99, 49]),
        o = new Uint8Array([0, 0, 0, 1]);
      (pv.FTYP = pv.box(pv.types.ftyp, n, o, n, a)),
        (pv.DINF = pv.box(pv.types.dinf, pv.box(pv.types.dref, s)));
    }
    static box(e, ...t) {
      let i = 8,
        s = t.length;
      const r = s;
      for (; s--; ) i += t[s].byteLength;
      const n = new Uint8Array(i);
      for (
        n[0] = (i >> 24) & 255,
          n[1] = (i >> 16) & 255,
          n[2] = (i >> 8) & 255,
          n[3] = 255 & i,
          n.set(e, 4),
          s = 0,
          i = 8;
        s < r;
        s++
      )
        n.set(t[s], i), (i += t[s].byteLength);
      return n;
    }
    static hdlr(e) {
      return pv.box(pv.types.hdlr, pv.HDLR_TYPES[e]);
    }
    static mdat(e) {
      return pv.box(pv.types.mdat, e);
    }
    static mdhd(e, t) {
      t *= e;
      const i = Math.floor(t / (uv + 1)),
        s = Math.floor(t % (uv + 1));
      return pv.box(
        pv.types.mdhd,
        new Uint8Array([
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          2,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          (e >> 24) & 255,
          (e >> 16) & 255,
          (e >> 8) & 255,
          255 & e,
          i >> 24,
          (i >> 16) & 255,
          (i >> 8) & 255,
          255 & i,
          s >> 24,
          (s >> 16) & 255,
          (s >> 8) & 255,
          255 & s,
          85,
          196,
          0,
          0
        ])
      );
    }
    static mdia(e) {
      return pv.box(
        pv.types.mdia,
        pv.mdhd(e.timescale || 0, e.duration || 0),
        pv.hdlr(e.type),
        pv.minf(e)
      );
    }
    static mfhd(e) {
      return pv.box(
        pv.types.mfhd,
        new Uint8Array([
          0,
          0,
          0,
          0,
          e >> 24,
          (e >> 16) & 255,
          (e >> 8) & 255,
          255 & e
        ])
      );
    }
    static minf(e) {
      return "audio" === e.type
        ? pv.box(
            pv.types.minf,
            pv.box(pv.types.smhd, pv.SMHD),
            pv.DINF,
            pv.stbl(e)
          )
        : pv.box(
            pv.types.minf,
            pv.box(pv.types.vmhd, pv.VMHD),
            pv.DINF,
            pv.stbl(e)
          );
    }
    static moof(e, t, i) {
      return pv.box(pv.types.moof, pv.mfhd(e), pv.traf(i, t));
    }
    static moov(e) {
      let t = e.length;
      const i = [];
      for (; t--; ) i[t] = pv.trak(e[t]);
      return pv.box.apply(
        null,
        [pv.types.moov, pv.mvhd(e[0].timescale || 0, e[0].duration || 0)]
          .concat(i)
          .concat(pv.mvex(e))
      );
    }
    static mvex(e) {
      let t = e.length;
      const i = [];
      for (; t--; ) i[t] = pv.trex(e[t]);
      return pv.box.apply(null, [pv.types.mvex, ...i]);
    }
    static mvhd(e, t) {
      t *= e;
      const i = Math.floor(t / (uv + 1)),
        s = Math.floor(t % (uv + 1)),
        r = new Uint8Array([
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          2,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          (e >> 24) & 255,
          (e >> 16) & 255,
          (e >> 8) & 255,
          255 & e,
          i >> 24,
          (i >> 16) & 255,
          (i >> 8) & 255,
          255 & i,
          s >> 24,
          (s >> 16) & 255,
          (s >> 8) & 255,
          255 & s,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          64,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          255,
          255,
          255,
          255
        ]);
      return pv.box(pv.types.mvhd, r);
    }
    static sdtp(e) {
      const t = e.samples || [],
        i = new Uint8Array(4 + t.length);
      let s, r;
      for (s = 0; s < t.length; s++)
        (r = t[s].flags),
          (i[s + 4] =
            (r.dependsOn << 4) | (r.isDependedOn << 2) | r.hasRedundancy);
      return pv.box(pv.types.sdtp, i);
    }
    static stbl(e) {
      return pv.box(
        pv.types.stbl,
        pv.stsd(e),
        pv.box(pv.types.stts, pv.STTS),
        pv.box(pv.types.stsc, pv.STSC),
        pv.box(pv.types.stsz, pv.STSZ),
        pv.box(pv.types.stco, pv.STCO)
      );
    }
    static avc1(e) {
      let t,
        i,
        s,
        r = [],
        n = [];
      for (t = 0; t < e.sps.length; t++)
        (i = e.sps[t]),
          (s = i.byteLength),
          r.push((s >>> 8) & 255),
          r.push(255 & s),
          (r = r.concat(Array.prototype.slice.call(i)));
      for (t = 0; t < e.pps.length; t++)
        (i = e.pps[t]),
          (s = i.byteLength),
          n.push((s >>> 8) & 255),
          n.push(255 & s),
          (n = n.concat(Array.prototype.slice.call(i)));
      const a = pv.box(
          pv.types.avcC,
          new Uint8Array(
            [1, r[3], r[4], r[5], 255, 224 | e.sps.length]
              .concat(r)
              .concat([e.pps.length])
              .concat(n)
          )
        ),
        o = e.width,
        c = e.height,
        d = e.pixelRatio[0],
        l = e.pixelRatio[1];
      return pv.box(
        pv.types.avc1,
        new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          (o >> 8) & 255,
          255 & o,
          (c >> 8) & 255,
          255 & c,
          0,
          72,
          0,
          0,
          0,
          72,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          18,
          100,
          97,
          105,
          108,
          121,
          109,
          111,
          116,
          105,
          111,
          110,
          47,
          104,
          108,
          115,
          46,
          106,
          115,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          24,
          17,
          17
        ]),
        a,
        pv.box(
          pv.types.btrt,
          new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])
        ),
        pv.box(
          pv.types.pasp,
          new Uint8Array([
            d >> 24,
            (d >> 16) & 255,
            (d >> 8) & 255,
            255 & d,
            l >> 24,
            (l >> 16) & 255,
            (l >> 8) & 255,
            255 & l
          ])
        )
      );
    }
    static esds(e) {
      const t = e.config;
      return new Uint8Array([
        0,
        0,
        0,
        0,
        3,
        25,
        0,
        1,
        0,
        4,
        17,
        64,
        21,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        5,
        2,
        ...t,
        6,
        1,
        2
      ]);
    }
    static audioStsd(e) {
      const t = e.samplerate || 0;
      return new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        e.channelCount || 0,
        0,
        16,
        0,
        0,
        0,
        0,
        (t >> 8) & 255,
        255 & t,
        0,
        0
      ]);
    }
    static mp4a(e) {
      return pv.box(
        pv.types.mp4a,
        pv.audioStsd(e),
        pv.box(pv.types.esds, pv.esds(e))
      );
    }
    static mp3(e) {
      return pv.box(pv.types[".mp3"], pv.audioStsd(e));
    }
    static ac3(e) {
      return pv.box(
        pv.types["ac-3"],
        pv.audioStsd(e),
        pv.box(pv.types.dac3, e.config)
      );
    }
    static stsd(e) {
      const { segmentCodec: t } = e;
      if ("audio" === e.type) {
        if ("aac" === t) return pv.box(pv.types.stsd, pv.STSD, pv.mp4a(e));
        if ("ac3" === t && e.config)
          return pv.box(pv.types.stsd, pv.STSD, pv.ac3(e));
        if ("mp3" === t && "mp3" === e.codec)
          return pv.box(pv.types.stsd, pv.STSD, pv.mp3(e));
      } else {
        if (!e.pps || !e.sps) throw new Error("video track missing pps or sps");
        if ("avc" === t) return pv.box(pv.types.stsd, pv.STSD, pv.avc1(e));
        if ("hevc" === t && e.vps)
          return pv.box(pv.types.stsd, pv.STSD, pv.hvc1(e));
      }
      throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`);
    }
    static tkhd(e) {
      const t = e.id,
        i = (e.duration || 0) * (e.timescale || 0),
        s = e.width || 0,
        r = e.height || 0,
        n = Math.floor(i / (uv + 1)),
        a = Math.floor(i % (uv + 1));
      return pv.box(
        pv.types.tkhd,
        new Uint8Array([
          1,
          0,
          0,
          7,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          2,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          (t >> 24) & 255,
          (t >> 16) & 255,
          (t >> 8) & 255,
          255 & t,
          0,
          0,
          0,
          0,
          n >> 24,
          (n >> 16) & 255,
          (n >> 8) & 255,
          255 & n,
          a >> 24,
          (a >> 16) & 255,
          (a >> 8) & 255,
          255 & a,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          64,
          0,
          0,
          0,
          (s >> 8) & 255,
          255 & s,
          0,
          0,
          (r >> 8) & 255,
          255 & r,
          0,
          0
        ])
      );
    }
    static traf(e, t) {
      const i = pv.sdtp(e),
        s = e.id,
        r = Math.floor(t / (uv + 1)),
        n = Math.floor(t % (uv + 1));
      return pv.box(
        pv.types.traf,
        pv.box(
          pv.types.tfhd,
          new Uint8Array([
            0,
            0,
            0,
            0,
            s >> 24,
            (s >> 16) & 255,
            (s >> 8) & 255,
            255 & s
          ])
        ),
        pv.box(
          pv.types.tfdt,
          new Uint8Array([
            1,
            0,
            0,
            0,
            r >> 24,
            (r >> 16) & 255,
            (r >> 8) & 255,
            255 & r,
            n >> 24,
            (n >> 16) & 255,
            (n >> 8) & 255,
            255 & n
          ])
        ),
        pv.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8),
        i
      );
    }
    static trak(e) {
      return (
        (e.duration = e.duration || 4294967295),
        pv.box(pv.types.trak, pv.tkhd(e), pv.mdia(e))
      );
    }
    static trex(e) {
      const t = e.id;
      return pv.box(
        pv.types.trex,
        new Uint8Array([
          0,
          0,
          0,
          0,
          t >> 24,
          (t >> 16) & 255,
          (t >> 8) & 255,
          255 & t,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1
        ])
      );
    }
    static trun(e, t) {
      const i = e.samples || [],
        s = i.length,
        r = 12 + 16 * s,
        n = new Uint8Array(r);
      let a, o, c, d, l, h;
      for (
        t += 8 + r,
          n.set(
            [
              "video" === e.type ? 1 : 0,
              0,
              15,
              1,
              (s >>> 24) & 255,
              (s >>> 16) & 255,
              (s >>> 8) & 255,
              255 & s,
              (t >>> 24) & 255,
              (t >>> 16) & 255,
              (t >>> 8) & 255,
              255 & t
            ],
            0
          ),
          a = 0;
        a < s;
        a++
      )
        (o = i[a]),
          (c = o.duration),
          (d = o.size),
          (l = o.flags),
          (h = o.cts),
          n.set(
            [
              (c >>> 24) & 255,
              (c >>> 16) & 255,
              (c >>> 8) & 255,
              255 & c,
              (d >>> 24) & 255,
              (d >>> 16) & 255,
              (d >>> 8) & 255,
              255 & d,
              (l.isLeading << 2) | l.dependsOn,
              (l.isDependedOn << 6) |
                (l.hasRedundancy << 4) |
                (l.paddingValue << 1) |
                l.isNonSync,
              61440 & l.degradPrio,
              15 & l.degradPrio,
              (h >>> 24) & 255,
              (h >>> 16) & 255,
              (h >>> 8) & 255,
              255 & h
            ],
            12 + 16 * a
          );
      return pv.box(pv.types.trun, n);
    }
    static initSegment(e) {
      pv.types || pv.init();
      const t = pv.moov(e);
      return Sg(pv.FTYP, t);
    }
    static hvc1(e) {
      const t = e.params,
        i = [e.vps, e.sps, e.pps],
        s = new Uint8Array([
          1,
          (t.general_profile_space << 6) |
            (t.general_tier_flag ? 32 : 0) |
            t.general_profile_idc,
          t.general_profile_compatibility_flags[0],
          t.general_profile_compatibility_flags[1],
          t.general_profile_compatibility_flags[2],
          t.general_profile_compatibility_flags[3],
          t.general_constraint_indicator_flags[0],
          t.general_constraint_indicator_flags[1],
          t.general_constraint_indicator_flags[2],
          t.general_constraint_indicator_flags[3],
          t.general_constraint_indicator_flags[4],
          t.general_constraint_indicator_flags[5],
          t.general_level_idc,
          240 | (t.min_spatial_segmentation_idc >> 8),
          255 & t.min_spatial_segmentation_idc,
          252 | t.parallelismType,
          252 | t.chroma_format_idc,
          248 | t.bit_depth_luma_minus8,
          248 | t.bit_depth_chroma_minus8,
          0,
          parseInt(t.frame_rate.fps),
          3 |
            (t.temporal_id_nested << 2) |
            (t.num_temporal_layers << 3) |
            (t.frame_rate.fixed ? 64 : 0),
          i.length
        ]);
      let r = s.length;
      for (let e = 0; e < i.length; e += 1) {
        r += 3;
        for (let t = 0; t < i[e].length; t += 1) r += 2 + i[e][t].length;
      }
      const n = new Uint8Array(r);
      n.set(s, 0), (r = s.length);
      const a = i.length - 1;
      for (let e = 0; e < i.length; e += 1) {
        n.set(
          new Uint8Array([(32 + e) | (e === a ? 128 : 0), 0, i[e].length]),
          r
        ),
          (r += 3);
        for (let t = 0; t < i[e].length; t += 1)
          n.set(new Uint8Array([i[e][t].length >> 8, 255 & i[e][t].length]), r),
            (r += 2),
            n.set(i[e][t], r),
            (r += i[e][t].length);
      }
      const o = pv.box(pv.types.hvcC, n),
        c = e.width,
        d = e.height,
        l = e.pixelRatio[0],
        h = e.pixelRatio[1];
      return pv.box(
        pv.types.hvc1,
        new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          (c >> 8) & 255,
          255 & c,
          (d >> 8) & 255,
          255 & d,
          0,
          72,
          0,
          0,
          0,
          72,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          18,
          100,
          97,
          105,
          108,
          121,
          109,
          111,
          116,
          105,
          111,
          110,
          47,
          104,
          108,
          115,
          46,
          106,
          115,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          24,
          17,
          17
        ]),
        o,
        pv.box(
          pv.types.btrt,
          new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])
        ),
        pv.box(
          pv.types.pasp,
          new Uint8Array([
            l >> 24,
            (l >> 16) & 255,
            (l >> 8) & 255,
            255 & l,
            h >> 24,
            (h >> 16) & 255,
            (h >> 8) & 255,
            255 & h
          ])
        )
      );
    }
  }
  (pv.types = void 0),
    (pv.HDLR_TYPES = void 0),
    (pv.STTS = void 0),
    (pv.STSC = void 0),
    (pv.STCO = void 0),
    (pv.STSZ = void 0),
    (pv.VMHD = void 0),
    (pv.SMHD = void 0),
    (pv.STSD = void 0),
    (pv.FTYP = void 0),
    (pv.DINF = void 0);
  const fv = 9e4;
  function Ev(e, t, i = 1, s = !1) {
    const r = e * t * i;
    return s ? Math.round(r) : r;
  }
  function mv(e, t = !1) {
    return Ev(e, 1e3, 1 / fv, t);
  }
  let gv,
    _v = null,
    Tv = null;
  function Sv(e, t, i, s) {
    return {
      duration: t,
      size: i,
      cts: s,
      flags: {
        isLeading: 0,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradPrio: 0,
        dependsOn: e ? 2 : 1,
        isNonSync: e ? 0 : 1
      }
    };
  }
  class vv {
    constructor(e, t, i, s) {
      if (
        ((this.logger = void 0),
        (this.observer = void 0),
        (this.config = void 0),
        (this.typeSupported = void 0),
        (this.ISGenerated = !1),
        (this._initPTS = null),
        (this._initDTS = null),
        (this.nextAvcDts = null),
        (this.nextAudioPts = null),
        (this.videoSampleDuration = null),
        (this.isAudioContiguous = !1),
        (this.isVideoContiguous = !1),
        (this.videoTrackConfig = void 0),
        (this.observer = e),
        (this.config = t),
        (this.typeSupported = i),
        (this.logger = s),
        (this.ISGenerated = !1),
        null === _v)
      ) {
        const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
        _v = e ? parseInt(e[1]) : 0;
      }
      if (null === Tv) {
        const e = navigator.userAgent.match(/Safari\/(\d+)/i);
        Tv = e ? parseInt(e[1]) : 0;
      }
    }
    destroy() {
      this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
    }
    resetTimeStamp(e) {
      this.logger.log("[mp4-remuxer]: initPTS & initDTS reset"),
        (this._initPTS = this._initDTS = e);
    }
    resetNextTimestamp() {
      this.logger.log("[mp4-remuxer]: reset next timestamp"),
        (this.isVideoContiguous = !1),
        (this.isAudioContiguous = !1);
    }
    resetInitSegment() {
      this.logger.log("[mp4-remuxer]: ISGenerated flag reset"),
        (this.ISGenerated = !1),
        (this.videoTrackConfig = void 0);
    }
    getVideoStartPts(e) {
      let t = !1;
      const i = e[0].pts,
        s = e.reduce((e, s) => {
          let r = s.pts,
            n = r - e;
          return (
            n < -4294967296 && ((t = !0), (r = Rv(r, i)), (n = r - e)),
            n > 0 ? e : r
          );
        }, i);
      return t && this.logger.debug("PTS rollover detected"), s;
    }
    remux(e, t, i, s, r, n, a, o) {
      let c,
        d,
        l,
        h,
        u,
        p,
        f = r,
        E = r;
      const m = e.pid > -1,
        g = t.pid > -1,
        _ = t.samples.length,
        T = e.samples.length > 0,
        S = (a && _ > 0) || _ > 1;
      if (((!m || T) && (!g || S)) || this.ISGenerated || a) {
        if (this.ISGenerated) {
          var v, R, y, A;
          const e = this.videoTrackConfig;
          ((e &&
            (t.width !== e.width ||
              t.height !== e.height ||
              (null == (v = t.pixelRatio) ? void 0 : v[0]) !==
                (null == (R = e.pixelRatio) ? void 0 : R[0]) ||
              (null == (y = t.pixelRatio) ? void 0 : y[1]) !==
                (null == (A = e.pixelRatio) ? void 0 : A[1]))) ||
            (!e && S) ||
            (null === this.nextAudioPts && T)) &&
            this.resetInitSegment();
        }
        this.ISGenerated || (l = this.generateIS(e, t, r, n));
        const i = this.isVideoContiguous;
        let s,
          a = -1;
        if (
          S &&
          ((a = (function(e) {
            for (let t = 0; t < e.length; t++) if (e[t].key) return t;
            return -1;
          })(t.samples)),
          !i && this.config.forceKeyFrameOnDiscontinuity)
        )
          if (((p = !0), a > 0)) {
            this.logger.warn(
              `[mp4-remuxer]: Dropped ${a} out of ${_} video samples due to a missing keyframe`
            );
            const e = this.getVideoStartPts(t.samples);
            (t.samples = t.samples.slice(a)),
              (t.dropped += a),
              (E += (t.samples[0].pts - e) / t.inputTimeScale),
              (s = E);
          } else
            -1 === a &&
              (this.logger.warn(
                `[mp4-remuxer]: No keyframe found out of ${_} video samples`
              ),
              (p = !1));
        if (this.ISGenerated) {
          if (T && S) {
            const i = this.getVideoStartPts(t.samples),
              s = (Rv(e.samples[0].pts, i) - i) / t.inputTimeScale;
            (f += Math.max(0, s)), (E += Math.max(0, -s));
          }
          if (T) {
            if (
              (e.samplerate ||
                (this.logger.warn(
                  "[mp4-remuxer]: regenerate InitSegment as audio detected"
                ),
                (l = this.generateIS(e, t, r, n))),
              (d = this.remuxAudio(
                e,
                f,
                this.isAudioContiguous,
                n,
                g || S || o === Cm.AUDIO ? E : void 0
              )),
              S)
            ) {
              const s = d ? d.endPTS - d.startPTS : 0;
              t.inputTimeScale ||
                (this.logger.warn(
                  "[mp4-remuxer]: regenerate InitSegment as video detected"
                ),
                (l = this.generateIS(e, t, r, n))),
                (c = this.remuxVideo(t, E, i, s));
            }
          } else S && (c = this.remuxVideo(t, E, i, 0));
          c &&
            ((c.firstKeyFrame = a),
            (c.independent = -1 !== a),
            (c.firstKeyFramePTS = s));
        }
      }
      return (
        this.ISGenerated &&
          this._initPTS &&
          this._initDTS &&
          (i.samples.length && (u = yv(i, r, this._initPTS, this._initDTS)),
          s.samples.length && (h = Av(s, r, this._initPTS))),
        { audio: d, video: c, initSegment: l, independent: p, text: h, id3: u }
      );
    }
    generateIS(e, t, i, s) {
      const r = e.samples,
        n = t.samples,
        a = this.typeSupported,
        o = {},
        c = this._initPTS;
      let d,
        l,
        h,
        u = !c || s,
        p = "audio/mp4";
      if ((u && (d = l = 1 / 0), e.config && r.length)) {
        switch (((e.timescale = e.samplerate), e.segmentCodec)) {
          case "mp3":
            a.mpeg
              ? ((p = "audio/mpeg"), (e.codec = ""))
              : a.mp3 && (e.codec = "mp3");
            break;
          case "ac3":
            e.codec = "ac-3";
        }
        (o.audio = {
          id: "audio",
          container: p,
          codec: e.codec,
          initSegment:
            "mp3" === e.segmentCodec && a.mpeg
              ? new Uint8Array(0)
              : pv.initSegment([e]),
          metadata: { channelCount: e.channelCount }
        }),
          u &&
            ((h = e.inputTimeScale),
            c && h === c.timescale
              ? (u = !1)
              : (d = l = r[0].pts - Math.round(h * i)));
      }
      if (t.sps && t.pps && n.length) {
        if (
          ((t.timescale = t.inputTimeScale),
          (o.video = {
            id: "main",
            container: "video/mp4",
            codec: t.codec,
            initSegment: pv.initSegment([t]),
            metadata: { width: t.width, height: t.height }
          }),
          u)
        )
          if (((h = t.inputTimeScale), c && h === c.timescale)) u = !1;
          else {
            const e = this.getVideoStartPts(n),
              t = Math.round(h * i);
            (l = Math.min(l, Rv(n[0].dts, e) - t)), (d = Math.min(d, e - t));
          }
        this.videoTrackConfig = {
          width: t.width,
          height: t.height,
          pixelRatio: t.pixelRatio
        };
      }
      if (Object.keys(o).length)
        return (
          (this.ISGenerated = !0),
          u
            ? ((this._initPTS = { baseTime: d, timescale: h }),
              (this._initDTS = { baseTime: l, timescale: h }))
            : (d = h = void 0),
          { tracks: o, initPTS: d, timescale: h }
        );
    }
    remuxVideo(e, t, i, s) {
      const r = e.inputTimeScale,
        n = e.samples,
        a = [],
        o = n.length,
        c = this._initPTS;
      let d,
        l,
        h = this.nextAvcDts,
        u = 8,
        p = this.videoSampleDuration,
        f = Number.POSITIVE_INFINITY,
        E = Number.NEGATIVE_INFINITY,
        m = !1;
      if (!i || null === h) {
        const e = t * r,
          s = n[0].pts - Rv(n[0].dts, n[0].pts);
        _v && null !== h && Math.abs(e - s - h) < 15e3 ? (i = !0) : (h = e - s);
      }
      const g = (c.baseTime * r) / c.timescale;
      for (let e = 0; e < o; e++) {
        const t = n[e];
        (t.pts = Rv(t.pts - g, h)),
          (t.dts = Rv(t.dts - g, h)),
          t.dts < n[e > 0 ? e - 1 : e].dts && (m = !0);
      }
      m &&
        n.sort(function(e, t) {
          const i = e.dts - t.dts,
            s = e.pts - t.pts;
          return i || s;
        }),
        (d = n[0].dts),
        (l = n[n.length - 1].dts);
      const _ = l - d,
        T = _ ? Math.round(_ / (o - 1)) : p || e.inputTimeScale / 30;
      if (i) {
        const i = d - h,
          s = i > T,
          r = i < -1;
        if (
          (s || r) &&
          (s
            ? this.logger.warn(
                `${(e.segmentCodec || "").toUpperCase()}: ${mv(
                  i,
                  !0
                )} ms (${i}dts) hole between fragments detected at ${t.toFixed(
                  3
                )}`
              )
            : this.logger.warn(
                `${(e.segmentCodec || "").toUpperCase()}: ${mv(
                  -i,
                  !0
                )} ms (${i}dts) overlapping between fragments detected at ${t.toFixed(
                  3
                )}`
              ),
          !r || h >= n[0].pts || _v)
        ) {
          d = h;
          const e = n[0].pts - i;
          if (s) (n[0].dts = d), (n[0].pts = e);
          else {
            let t = !0;
            for (let s = 0; s < n.length && !(n[s].dts > e && t); s++) {
              const e = n[s].pts;
              if (((n[s].dts -= i), (n[s].pts -= i), s < n.length - 1)) {
                const i = n[s + 1].pts;
                t = i <= n[s].pts == i <= e;
              }
            }
          }
          this.logger.log(
            `Video: Initial PTS/DTS adjusted: ${mv(e, !0)}/${mv(
              d,
              !0
            )}, delta: ${mv(i, !0)} ms`
          );
        }
      }
      d = Math.max(0, d);
      let S = 0,
        v = 0,
        R = d;
      for (let e = 0; e < o; e++) {
        const t = n[e],
          i = t.units,
          s = i.length;
        let r = 0;
        for (let e = 0; e < s; e++) r += i[e].data.length;
        (v += r),
          (S += s),
          (t.length = r),
          t.dts < R ? ((t.dts = R), (R += (T / 4) | 0 || 1)) : (R = t.dts),
          (f = Math.min(t.pts, f)),
          (E = Math.max(t.pts, E));
      }
      l = n[o - 1].dts;
      const y = v + 4 * S + 8;
      let A;
      try {
        A = new Uint8Array(y);
      } catch (e) {
        return void this.observer.emit(Am.ERROR, Am.ERROR, {
          type: Rm.MUX_ERROR,
          details: ym.REMUX_ALLOC_ERROR,
          fatal: !1,
          error: e,
          bytes: y,
          reason: `fail allocating video mdat ${y}`
        });
      }
      const I = new DataView(A.buffer);
      I.setUint32(0, y), A.set(pv.types.mdat, 4);
      let C = !1,
        b = Number.POSITIVE_INFINITY,
        O = Number.POSITIVE_INFINITY,
        D = Number.NEGATIVE_INFINITY,
        w = Number.NEGATIVE_INFINITY;
      for (let e = 0; e < o; e++) {
        const t = n[e],
          i = t.units;
        let c,
          d = 0;
        for (let e = 0, t = i.length; e < t; e++) {
          const t = i[e],
            s = t.data,
            r = t.data.byteLength;
          I.setUint32(u, r), (u += 4), A.set(s, u), (u += r), (d += 4 + r);
        }
        if (e < o - 1) (p = n[e + 1].dts - t.dts), (c = n[e + 1].pts - t.pts);
        else {
          const i = this.config,
            a = e > 0 ? t.dts - n[e - 1].dts : T;
          if (
            ((c = e > 0 ? t.pts - n[e - 1].pts : T),
            i.stretchShortVideoTrack && null !== this.nextAudioPts)
          ) {
            const e = Math.floor(i.maxBufferHole * r),
              n = (s ? f + s * r : this.nextAudioPts) - t.pts;
            n > e
              ? ((p = n - a),
                p < 0 ? (p = a) : (C = !0),
                this.logger.log(
                  `[mp4-remuxer]: It is approximately ${n /
                    90} ms to the next segment; using duration ${p /
                    90} ms for the last video frame.`
                ))
              : (p = a);
          } else p = a;
        }
        const l = Math.round(t.pts - t.dts);
        (b = Math.min(b, p)),
          (D = Math.max(D, p)),
          (O = Math.min(O, c)),
          (w = Math.max(w, c)),
          a.push(Sv(t.key, p, d, l));
      }
      if (a.length)
        if (_v) {
          if (_v < 70) {
            const e = a[0].flags;
            (e.dependsOn = 2), (e.isNonSync = 0);
          }
        } else if (Tv && w - O < D - b && T / D < 0.025 && 0 === a[0].cts) {
          this.logger.warn(
            "Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration."
          );
          let e = d;
          for (let t = 0, i = a.length; t < i; t++) {
            const s = e + a[t].duration,
              r = e + a[t].cts;
            if (t < i - 1) {
              const e = s + a[t + 1].cts;
              a[t].duration = e - r;
            } else a[t].duration = t ? a[t - 1].duration : T;
            (a[t].cts = 0), (e = s);
          }
        }
      (p = C || !p ? T : p),
        (this.nextAvcDts = h = l + p),
        (this.videoSampleDuration = p),
        (this.isVideoContiguous = !0);
      const L = {
        data1: pv.moof(e.sequenceNumber++, d, wm(e, { samples: a })),
        data2: A,
        startPTS: f / r,
        endPTS: (E + p) / r,
        startDTS: d / r,
        endDTS: h / r,
        type: "video",
        hasAudio: !1,
        hasVideo: !0,
        nb: a.length,
        dropped: e.dropped
      };
      return (e.samples = []), (e.dropped = 0), L;
    }
    getSamplesPerFrame(e) {
      switch (e.segmentCodec) {
        case "mp3":
          return 1152;
        case "ac3":
          return 1536;
        default:
          return 1024;
      }
    }
    remuxAudio(e, t, i, s, r) {
      const n = e.inputTimeScale,
        a = n / (e.samplerate ? e.samplerate : n),
        o = this.getSamplesPerFrame(e),
        c = o * a,
        d = this._initPTS,
        l = "mp3" === e.segmentCodec && this.typeSupported.mpeg,
        h = [],
        u = void 0 !== r;
      let p = e.samples,
        f = l ? 0 : 8,
        E = this.nextAudioPts || -1;
      const m = t * n,
        g = (d.baseTime * n) / d.timescale;
      if (
        ((this.isAudioContiguous = i =
          i ||
          (p.length &&
            E > 0 &&
            ((s && Math.abs(m - E) < 9e3) ||
              Math.abs(Rv(p[0].pts - g, m) - E) < 20 * c))),
        p.forEach(function(e) {
          e.pts = Rv(e.pts - g, m);
        }),
        !i || E < 0)
      ) {
        if (((p = p.filter(e => e.pts >= 0)), !p.length)) return;
        E = 0 === r ? 0 : s && !u ? Math.max(0, m) : p[0].pts;
      }
      if ("aac" === e.segmentCodec) {
        const t = this.config.maxAudioFramesDrift;
        for (let i = 0, s = E; i < p.length; i++) {
          const r = p[i],
            a = r.pts,
            o = a - s,
            d = Math.abs((1e3 * o) / n);
          if (o <= -t * c && u)
            0 === i &&
              (this.logger.warn(
                `Audio frame @ ${(a / n).toFixed(
                  3
                )}s overlaps nextAudioPts by ${Math.round((1e3 * o) / n)} ms.`
              ),
              (this.nextAudioPts = E = s = a));
          else if (o >= t * c && d < 1e4 && u) {
            let t = Math.round(o / c);
            (s = a - t * c),
              s < 0 && (t--, (s += c)),
              0 === i && (this.nextAudioPts = E = s),
              this.logger.warn(
                `[mp4-remuxer]: Injecting ${t} audio frame @ ${(s / n).toFixed(
                  3
                )}s due to ${Math.round((1e3 * o) / n)} ms gap.`
              );
            for (let n = 0; n < t; n++) {
              const t = Math.max(s, 0);
              let n = hv.getSilentFrame(
                e.parsedCodec || e.manifestCodec || e.codec,
                e.channelCount
              );
              n ||
                (this.logger.log(
                  "[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."
                ),
                (n = r.unit.subarray())),
                p.splice(i, 0, { unit: n, pts: t }),
                (s += c),
                i++;
            }
          }
          (r.pts = s), (s += c);
        }
      }
      let _,
        T = null,
        S = null,
        v = 0,
        R = p.length;
      for (; R--; ) v += p[R].unit.byteLength;
      for (let t = 0, s = p.length; t < s; t++) {
        const s = p[t],
          r = s.unit;
        let n = s.pts;
        if (null !== S) {
          h[t - 1].duration = Math.round((n - S) / a);
        } else {
          if ((i && "aac" === e.segmentCodec && (n = E), (T = n), !(v > 0)))
            return;
          v += f;
          try {
            _ = new Uint8Array(v);
          } catch (e) {
            return void this.observer.emit(Am.ERROR, Am.ERROR, {
              type: Rm.MUX_ERROR,
              details: ym.REMUX_ALLOC_ERROR,
              fatal: !1,
              error: e,
              bytes: v,
              reason: `fail allocating audio mdat ${v}`
            });
          }
          if (!l) {
            new DataView(_.buffer).setUint32(0, v), _.set(pv.types.mdat, 4);
          }
        }
        _.set(r, f);
        const c = r.byteLength;
        (f += c), h.push(Sv(!0, o, c, 0)), (S = n);
      }
      const y = h.length;
      if (!y) return;
      const A = h[h.length - 1];
      this.nextAudioPts = E = S + a * A.duration;
      const I = l
        ? new Uint8Array(0)
        : pv.moof(e.sequenceNumber++, T / a, wm({}, e, { samples: h }));
      e.samples = [];
      const C = T / n,
        b = E / n,
        O = {
          data1: I,
          data2: _,
          startPTS: C,
          endPTS: b,
          startDTS: C,
          endDTS: b,
          type: "audio",
          hasAudio: !0,
          hasVideo: !1,
          nb: y
        };
      return (this.isAudioContiguous = !0), O;
    }
  }
  function Rv(e, t) {
    let i;
    if (null === t) return e;
    for (i = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296; )
      e += i;
    return e;
  }
  function yv(e, t, i, s) {
    const r = e.samples.length;
    if (!r) return;
    const n = e.inputTimeScale;
    for (let a = 0; a < r; a++) {
      const r = e.samples[a];
      (r.pts = Rv(r.pts - (i.baseTime * n) / i.timescale, t * n) / n),
        (r.dts = Rv(r.dts - (s.baseTime * n) / s.timescale, t * n) / n);
    }
    const a = e.samples;
    return (e.samples = []), { samples: a };
  }
  function Av(e, t, i) {
    const s = e.samples.length;
    if (!s) return;
    const r = e.inputTimeScale;
    for (let n = 0; n < s; n++) {
      const s = e.samples[n];
      s.pts = Rv(s.pts - (i.baseTime * r) / i.timescale, t * r) / r;
    }
    e.samples.sort((e, t) => e.pts - t.pts);
    const n = e.samples;
    return (e.samples = []), { samples: n };
  }
  function Iv(e, t) {
    const i = null == e ? void 0 : e.codec;
    if (i && i.length > 4) return i;
    if (t === Xm.AUDIO) {
      if ("ec-3" === i || "ac-3" === i || "alac" === i) return i;
      if ("fLaC" === i || "Opus" === i) {
        return Fg(i, !1);
      }
      return Bm.warn(`Unhandled audio codec "${i}" in mp4 MAP`), i || "mp4a";
    }
    return Bm.warn(`Unhandled video codec "${i}" in mp4 MAP`), i || "avc1";
  }
  try {
    gv = self.performance.now.bind(self.performance);
  } catch (e) {
    gv = Date.now;
  }
  const Cv = [
    {
      demux: class {
        constructor(e, t) {
          (this.remainderData = null),
            (this.timeOffset = 0),
            (this.config = void 0),
            (this.videoTrack = void 0),
            (this.audioTrack = void 0),
            (this.id3Track = void 0),
            (this.txtTrack = void 0),
            (this.config = t);
        }
        resetTimeStamp() {}
        resetInitSegment(e, t, i, s) {
          const r = (this.videoTrack = kS("video", 1)),
            n = (this.audioTrack = kS("audio", 1)),
            a = (this.txtTrack = kS("text", 1));
          if (
            ((this.id3Track = kS("id3", 1)),
            (this.timeOffset = 0),
            null == e || !e.byteLength)
          )
            return;
          const o = ug(e);
          if (o.video) {
            const { id: e, timescale: t, codec: i, supplemental: s } = o.video;
            (r.id = e),
              (r.timescale = a.timescale = t),
              (r.codec = i),
              (r.supplemental = s);
          }
          if (o.audio) {
            const { id: e, timescale: t, codec: i } = o.audio;
            (n.id = e), (n.timescale = t), (n.codec = i);
          }
          (a.id = sg.text),
            (r.sampleDuration = 0),
            (r.duration = n.duration = s);
        }
        resetContiguity() {
          this.remainderData = null;
        }
        static probe(e) {
          return (function(e) {
            const t = e.byteLength;
            for (let i = 0; i < t; ) {
              const s = ag(e, i);
              if (
                s > 8 &&
                109 === e[i + 4] &&
                111 === e[i + 5] &&
                111 === e[i + 6] &&
                102 === e[i + 7]
              )
                return !0;
              i = s > 1 ? i + s : t;
            }
            return !1;
          })(e);
        }
        demux(e, t) {
          this.timeOffset = t;
          let i = e;
          const s = this.videoTrack,
            r = this.txtTrack;
          if (this.config.progressive) {
            this.remainderData && (i = Sg(this.remainderData, e));
            const t = (function(e) {
              const t = { valid: null, remainder: null },
                i = lg(e, ["moof"]);
              if (i.length < 2) return (t.remainder = e), t;
              const s = i[i.length - 1];
              return (
                (t.valid = e.slice(0, s.byteOffset - 8)),
                (t.remainder = e.slice(s.byteOffset - 8)),
                t
              );
            })(i);
            (this.remainderData = t.remainder),
              (s.samples = t.valid || new Uint8Array());
          } else s.samples = i;
          const n = this.extractID3Track(s, t);
          return (
            (r.samples = vg(t, s)),
            {
              videoTrack: s,
              audioTrack: this.audioTrack,
              id3Track: n,
              textTrack: this.txtTrack
            }
          );
        }
        flush() {
          const e = this.timeOffset,
            t = this.videoTrack,
            i = this.txtTrack;
          (t.samples = this.remainderData || new Uint8Array()),
            (this.remainderData = null);
          const s = this.extractID3Track(t, this.timeOffset);
          return (
            (i.samples = vg(e, t)),
            { videoTrack: t, audioTrack: kS(), id3Track: s, textTrack: kS() }
          );
        }
        extractID3Track(e, t) {
          const i = this.id3Track;
          if (e.samples.length) {
            const s = lg(e.samples, ["emsg"]);
            s &&
              s.forEach(e => {
                const s = (function(e) {
                  const t = e[0];
                  let i = "",
                    s = "",
                    r = 0,
                    n = 0,
                    a = 0,
                    o = 0,
                    c = 0,
                    d = 0;
                  if (0 === t) {
                    for (; "\0" !== rg(e.subarray(d, d + 1)); )
                      (i += rg(e.subarray(d, d + 1))), (d += 1);
                    for (
                      i += rg(e.subarray(d, d + 1)), d += 1;
                      "\0" !== rg(e.subarray(d, d + 1));

                    )
                      (s += rg(e.subarray(d, d + 1))), (d += 1);
                    (s += rg(e.subarray(d, d + 1))),
                      (d += 1),
                      (r = ag(e, 12)),
                      (n = ag(e, 16)),
                      (o = ag(e, 20)),
                      (c = ag(e, 24)),
                      (d = 28);
                  } else if (1 === t) {
                    (d += 4), (r = ag(e, d)), (d += 4);
                    const t = ag(e, d);
                    d += 4;
                    const n = ag(e, d);
                    for (
                      d += 4,
                        a = 2 ** 32 * t + n,
                        Sm(a) ||
                          ((a = Number.MAX_SAFE_INTEGER),
                          Bm.warn(
                            "Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box"
                          )),
                        o = ag(e, d),
                        d += 4,
                        c = ag(e, d),
                        d += 4;
                      "\0" !== rg(e.subarray(d, d + 1));

                    )
                      (i += rg(e.subarray(d, d + 1))), (d += 1);
                    for (
                      i += rg(e.subarray(d, d + 1)), d += 1;
                      "\0" !== rg(e.subarray(d, d + 1));

                    )
                      (s += rg(e.subarray(d, d + 1))), (d += 1);
                    (s += rg(e.subarray(d, d + 1))), (d += 1);
                  }
                  return {
                    schemeIdUri: i,
                    value: s,
                    timeScale: r,
                    presentationTime: a,
                    presentationTimeDelta: n,
                    eventDuration: o,
                    id: c,
                    payload: e.subarray(d, e.byteLength)
                  };
                })(e);
                if (zS.test(s.schemeIdUri)) {
                  const e = JS(s, t);
                  let r =
                    4294967295 === s.eventDuration
                      ? Number.POSITIVE_INFINITY
                      : s.eventDuration / s.timeScale;
                  r <= 0.001 && (r = Number.POSITIVE_INFINITY);
                  const n = s.payload;
                  i.samples.push({
                    data: n,
                    len: n.byteLength,
                    dts: e,
                    pts: e,
                    type: PS.emsg,
                    duration: r
                  });
                } else if (
                  this.config.enableEmsgKLVMetadata &&
                  s.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")
                ) {
                  const e = JS(s, t);
                  i.samples.push({
                    data: s.payload,
                    len: s.payload.byteLength,
                    dts: e,
                    pts: e,
                    type: PS.misbklv,
                    duration: Number.POSITIVE_INFINITY
                  });
                }
              });
          }
          return i;
        }
        demuxSampleAes(e, t, i) {
          return Promise.reject(
            new Error("The MP4 demuxer does not support SAMPLE-AES decryption")
          );
        }
        destroy() {
          (this.config = null),
            (this.remainderData = null),
            (this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0);
        }
      },
      remux: class {
        constructor(e, t, i, s) {
          (this.logger = void 0),
            (this.emitInitSegment = !1),
            (this.audioCodec = void 0),
            (this.videoCodec = void 0),
            (this.initData = void 0),
            (this.initPTS = null),
            (this.initTracks = void 0),
            (this.lastEndTime = null),
            (this.logger = s);
        }
        destroy() {}
        resetTimeStamp(e) {
          (this.initPTS = e), (this.lastEndTime = null);
        }
        resetNextTimestamp() {
          this.lastEndTime = null;
        }
        resetInitSegment(e, t, i, s) {
          (this.audioCodec = t),
            (this.videoCodec = i),
            this.generateInitSegment(
              (function(e, t) {
                if (!e || !t) return e;
                const i = t.keyId;
                i &&
                  t.isCommonEncryption &&
                  lg(e, ["moov", "trak"]).forEach(e => {
                    const t = lg(e, [
                      "mdia",
                      "minf",
                      "stbl",
                      "stsd"
                    ])[0].subarray(8);
                    let s = lg(t, ["enca"]);
                    const r = s.length > 0;
                    r || (s = lg(t, ["encv"])),
                      s.forEach(e => {
                        lg(r ? e.subarray(28) : e.subarray(78), [
                          "sinf"
                        ]).forEach(e => {
                          const t = _g(e);
                          if (t) {
                            const e = t.subarray(8, 24);
                            e.some(e => 0 !== e) ||
                              (Bm.log(
                                `[eme] Patching keyId in 'enc${
                                  r ? "a" : "v"
                                }>sinf>>tenc' box: ${Hm.hexDump(
                                  e
                                )} -> ${Hm.hexDump(i)}`
                              ),
                              t.set(i, 8));
                          }
                        });
                      });
                  });
                return e;
              })(e, s)
            ),
            (this.emitInitSegment = !0);
        }
        generateInitSegment(e) {
          let { audioCodec: t, videoCodec: i } = this;
          if (null == e || !e.byteLength)
            return (this.initTracks = void 0), void (this.initData = void 0);
          const s = (this.initData = ug(e));
          s.audio && (t = Iv(s.audio, Xm.AUDIO)),
            s.video && (i = Iv(s.video, Xm.VIDEO));
          const r = {};
          s.audio && s.video
            ? (r.audiovideo = {
                container: "video/mp4",
                codec: t + "," + i,
                supplemental: s.video.supplemental,
                initSegment: e,
                id: "main"
              })
            : s.audio
            ? (r.audio = {
                container: "audio/mp4",
                codec: t,
                initSegment: e,
                id: "audio"
              })
            : s.video
            ? (r.video = {
                container: "video/mp4",
                codec: i,
                supplemental: s.video.supplemental,
                initSegment: e,
                id: "main"
              })
            : this.logger.warn(
                "[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."
              ),
            (this.initTracks = r);
        }
        remux(e, t, i, s, r, n) {
          var a, o;
          let { initPTS: c, lastEndTime: d } = this;
          const l = {
            audio: void 0,
            video: void 0,
            text: s,
            id3: i,
            initSegment: void 0
          };
          Tm(d) || (d = this.lastEndTime = r || 0);
          const h = t.samples;
          if (null == h || !h.length) return l;
          const u = { initPTS: void 0, timescale: 1 };
          let p = this.initData;
          if (
            ((null != (a = p) && a.length) ||
              (this.generateInitSegment(h), (p = this.initData)),
            null == (o = p) || !o.length)
          )
            return (
              this.logger.warn(
                "[passthrough-remuxer.ts]: Failed to generate initSegment."
              ),
              l
            );
          this.emitInitSegment &&
            ((u.tracks = this.initTracks), (this.emitInitSegment = !1));
          const f = (function(e, t) {
              let i = 0,
                s = 0,
                r = 0;
              const n = lg(e, ["moof", "traf"]);
              for (let e = 0; e < n.length; e++) {
                const a = n[e],
                  o = lg(a, ["tfhd"])[0],
                  c = t[ag(o, 4)];
                if (!c) continue;
                const d = c.default,
                  l = ag(o, 0) | (null == d ? void 0 : d.flags);
                let h = null == d ? void 0 : d.duration;
                8 & l && (h = ag(o, 2 & l ? 12 : 8));
                const u = c.timescale || 9e4,
                  p = lg(a, ["trun"]);
                for (let e = 0; e < p.length; e++)
                  (i = Tg(p[e])),
                    !i && h && (i = h * ag(p[e], 4)),
                    c.type === Xm.VIDEO
                      ? (s += i / u)
                      : c.type === Xm.AUDIO && (r += i / u);
              }
              if (0 === s && 0 === r) {
                let t = 1 / 0,
                  i = 0,
                  s = 0;
                const r = lg(e, ["sidx"]);
                for (let e = 0; e < r.length; e++) {
                  const n = hg(r[e]);
                  if (null != n && n.references) {
                    t = Math.min(t, n.earliestPresentationTime / n.timescale);
                    const e = n.references.reduce(
                      (e, t) => e + t.info.duration || 0,
                      0
                    );
                    (i = Math.max(
                      i,
                      e + n.earliestPresentationTime / n.timescale
                    )),
                      (s = i - t);
                  }
                }
                if (s && Tm(s)) return s;
              }
              return s || r;
            })(h, p),
            E = (function(e, t) {
              return lg(t, ["moof", "traf"]).reduce((t, i) => {
                const s = lg(i, ["tfdt"])[0],
                  r = s[0],
                  n = lg(i, ["tfhd"]).reduce((t, i) => {
                    const n = ag(i, 4),
                      a = e[n];
                    if (a) {
                      let e = ag(s, 4);
                      if (1 === r) {
                        if (e === tg)
                          return (
                            Bm.warn(
                              "[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"
                            ),
                            t
                          );
                        (e *= tg + 1), (e += ag(s, 8));
                      }
                      const i = e / (a.timescale || 9e4);
                      if (Tm(i) && (null === t || i < t)) return i;
                    }
                    return t;
                  }, null);
                return null !== n && Tm(n) && (null === t || n < t) ? n : t;
              }, null);
            })(p, h),
            m = null === E ? r : E;
          (!n && c) ||
            (!(function(e, t, i, s) {
              if (null === e) return !0;
              const r = Math.max(s, 1),
                n = t - e.baseTime / e.timescale;
              return Math.abs(n - i) > r;
            })(c, m, r, f) &&
              u.timescale === c.timescale) ||
            ((u.initPTS = m - r),
            c &&
              1 === c.timescale &&
              this.logger.warn(
                `Adjusting initPTS @${r} from ${c.baseTime / c.timescale} to ${
                  u.initPTS
                }`
              ),
            (this.initPTS = c = { baseTime: u.initPTS, timescale: 1 }));
          const g = e ? m - c.baseTime / c.timescale : d,
            _ = g + f;
          !(function(e, t, i) {
            lg(t, ["moof", "traf"]).forEach(t => {
              lg(t, ["tfhd"]).forEach(s => {
                const r = ag(s, 4),
                  n = e[r];
                if (!n) return;
                const a = n.timescale || 9e4;
                lg(t, ["tfdt"]).forEach(e => {
                  const t = e[0],
                    s = i * a;
                  if (s) {
                    let i = ag(e, 4);
                    if (0 === t) (i -= s), (i = Math.max(i, 0)), dg(e, 4, i);
                    else {
                      (i *= Math.pow(2, 32)),
                        (i += ag(e, 8)),
                        (i -= s),
                        (i = Math.max(i, 0));
                      const t = Math.floor(i / (tg + 1)),
                        r = Math.floor(i % (tg + 1));
                      dg(e, 4, t), dg(e, 8, r);
                    }
                  }
                });
              });
            });
          })(p, h, c.baseTime / c.timescale),
            f > 0
              ? (this.lastEndTime = _)
              : (this.logger.warn(
                  "Duration parsed from mp4 should be greater than zero"
                ),
                this.resetNextTimestamp());
          const T = !!p.audio,
            S = !!p.video;
          let v = "";
          T && (v += "audio"), S && (v += "video");
          const R = {
            data1: h,
            startPTS: g,
            startDTS: g,
            endPTS: _,
            endDTS: _,
            type: v,
            hasAudio: T,
            hasVideo: S,
            nb: 1,
            dropped: 0
          };
          return (
            (l.audio = "audio" === R.type ? R : void 0),
            (l.video = "audio" !== R.type ? R : void 0),
            (l.initSegment = u),
            (l.id3 = yv(i, r, c, c)),
            s.samples.length && (l.text = Av(s, r, c)),
            l
          );
        }
      }
    },
    { demux: rv, remux: vv },
    {
      demux: class extends MS {
        constructor(e, t) {
          super(),
            (this.observer = void 0),
            (this.config = void 0),
            (this.observer = e),
            (this.config = t);
        }
        resetInitSegment(e, t, i, s) {
          super.resetInitSegment(e, t, i, s),
            (this._audioTrack = {
              container: "audio/adts",
              type: "audio",
              id: 2,
              pid: -1,
              sequenceNumber: 0,
              segmentCodec: "aac",
              samples: [],
              manifestCodec: t,
              duration: s,
              inputTimeScale: 9e4,
              dropped: 0
            });
        }
        static probe(e, t) {
          if (!e) return !1;
          const i = uS(e, 0);
          let s = (null == i ? void 0 : i.length) || 0;
          if (YS(e, s)) return !1;
          for (let i = e.length; s < i; s++)
            if (gS(e, s)) return t.log("ADTS sync word found !"), !0;
          return !1;
        }
        canParse(e, t) {
          return (function(e, t) {
            return (
              (function(e, t) {
                return t + 5 < e.length;
              })(e, t) &&
              pS(e, t) &&
              ES(e, t) <= e.length - t
            );
          })(e, t);
        }
        appendFrame(e, t, i) {
          _S(e, this.observer, t, i, e.manifestCodec);
          const s = SS(e, t, i, this.basePTS, this.frameIndex);
          if (s && 0 === s.missing) return s;
        }
      },
      remux: vv
    },
    {
      demux: class extends MS {
        resetInitSegment(e, t, i, s) {
          super.resetInitSegment(e, t, i, s),
            (this._audioTrack = {
              container: "audio/mpeg",
              type: "audio",
              id: 2,
              pid: -1,
              sequenceNumber: 0,
              segmentCodec: "mp3",
              samples: [],
              manifestCodec: t,
              duration: s,
              inputTimeScale: 9e4,
              dropped: 0
            });
        }
        static probe(e) {
          if (!e) return !1;
          const t = uS(e, 0);
          let i = (null == t ? void 0 : t.length) || 0;
          if (
            t &&
            11 === e[i] &&
            119 === e[i + 1] &&
            void 0 !== NS(t) &&
            $S(e, i) <= 16
          )
            return !1;
          for (let t = e.length; i < t; i++)
            if (YS(e, i)) return Bm.log("MPEG Audio sync word found !"), !0;
          return !1;
        }
        canParse(e, t) {
          return (function(e, t) {
            return KS(e, t) && 4 <= e.length - t;
          })(e, t);
        }
        appendFrame(e, t, i) {
          if (null !== this.basePTS)
            return jS(e, t, i, this.basePTS, this.frameIndex);
        }
      },
      remux: vv
    }
  ];
  Cv.splice(2, 0, { demux: qS, remux: vv });
  class bv {
    constructor(e, t, i, s, r, n) {
      (this.asyncResult = !1),
        (this.logger = void 0),
        (this.observer = void 0),
        (this.typeSupported = void 0),
        (this.config = void 0),
        (this.id = void 0),
        (this.demuxer = void 0),
        (this.remuxer = void 0),
        (this.decrypter = void 0),
        (this.probe = void 0),
        (this.decryptionPromise = null),
        (this.transmuxConfig = void 0),
        (this.currentTransmuxState = void 0),
        (this.observer = e),
        (this.typeSupported = t),
        (this.config = i),
        (this.id = r),
        (this.logger = n);
    }
    configure(e) {
      (this.transmuxConfig = e), this.decrypter && this.decrypter.reset();
    }
    push(e, t, i, s) {
      const r = i.transmuxing;
      r.executeStart = gv();
      let n = new Uint8Array(e);
      const { currentTransmuxState: a, transmuxConfig: o } = this;
      s && (this.currentTransmuxState = s);
      const {
          contiguous: c,
          discontinuity: d,
          trackSwitch: l,
          accurateTimeOffset: h,
          timeOffset: u,
          initSegmentChange: p
        } = s || a,
        {
          audioCodec: f,
          videoCodec: E,
          defaultInitPts: m,
          duration: g,
          initSegmentData: _
        } = o,
        T = (function(e, t) {
          let i = null;
          e.byteLength > 0 &&
            null != (null == t ? void 0 : t.key) &&
            null !== t.iv &&
            null != t.method &&
            (i = t);
          return i;
        })(n, t);
      if (T && iT(T.method)) {
        const e = this.getDecrypter(),
          t = sT(T.method);
        if (!e.isSync())
          return (
            (this.asyncResult = !0),
            (this.decryptionPromise = e
              .webCryptoDecrypt(n, T.key.buffer, T.iv.buffer, t)
              .then(e => {
                const t = this.push(e, null, i);
                return (this.decryptionPromise = null), t;
              })),
            this.decryptionPromise
          );
        {
          let s = e.softwareDecrypt(n, T.key.buffer, T.iv.buffer, t);
          if (i.part > -1) {
            const t = e.flush();
            s = t ? t.buffer : t;
          }
          if (!s) return (r.executeEnd = gv()), Ov(i);
          n = new Uint8Array(s);
        }
      }
      const S = this.needsProbing(d, l);
      if (S) {
        const e = this.configureTransmuxer(n);
        if (e)
          return (
            this.logger.warn(`[transmuxer] ${e.message}`),
            this.observer.emit(Am.ERROR, Am.ERROR, {
              type: Rm.MEDIA_ERROR,
              details: ym.FRAG_PARSING_ERROR,
              fatal: !1,
              error: e,
              reason: e.message
            }),
            (r.executeEnd = gv()),
            Ov(i)
          );
      }
      (d || l || p || S) && this.resetInitSegment(_, f, E, g, t),
        (d || p || S) && this.resetInitialTimestamp(m),
        c || this.resetContiguity();
      const v = this.transmux(n, T, u, h, i);
      this.asyncResult = Dv(v);
      const R = this.currentTransmuxState;
      return (
        (R.contiguous = !0),
        (R.discontinuity = !1),
        (R.trackSwitch = !1),
        (r.executeEnd = gv()),
        v
      );
    }
    flush(e) {
      const t = e.transmuxing;
      t.executeStart = gv();
      const {
        decrypter: i,
        currentTransmuxState: s,
        decryptionPromise: r
      } = this;
      if (r) return (this.asyncResult = !0), r.then(() => this.flush(e));
      const n = [],
        { timeOffset: a } = s;
      if (i) {
        const t = i.flush();
        t && n.push(this.push(t.buffer, null, e));
      }
      const { demuxer: o, remuxer: c } = this;
      if (!o || !c) {
        t.executeEnd = gv();
        const i = [Ov(e)];
        return this.asyncResult ? Promise.resolve(i) : i;
      }
      const d = o.flush(a);
      return Dv(d)
        ? ((this.asyncResult = !0), d.then(t => (this.flushRemux(n, t, e), n)))
        : (this.flushRemux(n, d, e), this.asyncResult ? Promise.resolve(n) : n);
    }
    flushRemux(e, t, i) {
      const { audioTrack: s, videoTrack: r, id3Track: n, textTrack: a } = t,
        { accurateTimeOffset: o, timeOffset: c } = this.currentTransmuxState;
      this.logger.log(
        `[transmuxer.ts]: Flushed ${this.id} sn: ${i.sn}${
          i.part > -1 ? " part: " + i.part : ""
        } of ${this.id === Cm.MAIN ? "level" : "track"} ${i.level}`
      );
      const d = this.remuxer.remux(s, r, n, a, c, o, !0, this.id);
      e.push({ remuxResult: d, chunkMeta: i }),
        (i.transmuxing.executeEnd = gv());
    }
    resetInitialTimestamp(e) {
      const { demuxer: t, remuxer: i } = this;
      t && i && (t.resetTimeStamp(e), i.resetTimeStamp(e));
    }
    resetContiguity() {
      const { demuxer: e, remuxer: t } = this;
      e && t && (e.resetContiguity(), t.resetNextTimestamp());
    }
    resetInitSegment(e, t, i, s, r) {
      const { demuxer: n, remuxer: a } = this;
      n &&
        a &&
        (n.resetInitSegment(e, t, i, s), a.resetInitSegment(e, t, i, r));
    }
    destroy() {
      this.demuxer && (this.demuxer.destroy(), (this.demuxer = void 0)),
        this.remuxer && (this.remuxer.destroy(), (this.remuxer = void 0));
    }
    transmux(e, t, i, s, r) {
      let n;
      return (
        (n =
          t && "SAMPLE-AES" === t.method
            ? this.transmuxSampleAes(e, t, i, s, r)
            : this.transmuxUnencrypted(e, i, s, r)),
        n
      );
    }
    transmuxUnencrypted(e, t, i, s) {
      const {
        audioTrack: r,
        videoTrack: n,
        id3Track: a,
        textTrack: o
      } = this.demuxer.demux(e, t, !1, !this.config.progressive);
      return {
        remuxResult: this.remuxer.remux(r, n, a, o, t, i, !1, this.id),
        chunkMeta: s
      };
    }
    transmuxSampleAes(e, t, i, s, r) {
      return this.demuxer
        .demuxSampleAes(e, t, i)
        .then(e => ({
          remuxResult: this.remuxer.remux(
            e.audioTrack,
            e.videoTrack,
            e.id3Track,
            e.textTrack,
            i,
            s,
            !1,
            this.id
          ),
          chunkMeta: r
        }));
    }
    configureTransmuxer(e) {
      const { config: t, observer: i, typeSupported: s } = this;
      let r;
      for (let t = 0, i = Cv.length; t < i; t++) {
        var n;
        if (null != (n = Cv[t].demux) && n.probe(e, this.logger)) {
          r = Cv[t];
          break;
        }
      }
      if (!r)
        return new Error("Failed to find demuxer by probing fragment data");
      const a = this.demuxer,
        o = this.remuxer,
        c = r.remux,
        d = r.demux;
      (o && o instanceof c) || (this.remuxer = new c(i, t, s, this.logger)),
        (a && a instanceof d) ||
          ((this.demuxer = new d(i, t, s, this.logger)),
          (this.probe = d.probe));
    }
    needsProbing(e, t) {
      return !this.demuxer || !this.remuxer || e || t;
    }
    getDecrypter() {
      let e = this.decrypter;
      return e || (e = this.decrypter = new M_(this.config)), e;
    }
  }
  const Ov = e => ({ remuxResult: {}, chunkMeta: e });
  function Dv(e) {
    return "then" in e && e.then instanceof Function;
  }
  class wv {
    constructor(e, t, i, s, r) {
      (this.audioCodec = void 0),
        (this.videoCodec = void 0),
        (this.initSegmentData = void 0),
        (this.duration = void 0),
        (this.defaultInitPts = void 0),
        (this.audioCodec = e),
        (this.videoCodec = t),
        (this.initSegmentData = i),
        (this.duration = s),
        (this.defaultInitPts = r || null);
    }
  }
  class Lv {
    constructor(e, t, i, s, r, n) {
      (this.discontinuity = void 0),
        (this.contiguous = void 0),
        (this.accurateTimeOffset = void 0),
        (this.trackSwitch = void 0),
        (this.timeOffset = void 0),
        (this.initSegmentChange = void 0),
        (this.discontinuity = e),
        (this.contiguous = t),
        (this.accurateTimeOffset = i),
        (this.trackSwitch = s),
        (this.timeOffset = r),
        (this.initSegmentChange = n);
    }
  }
  let Nv = 0;
  class Pv {
    constructor(e, t, i, s) {
      (this.error = null),
        (this.hls = void 0),
        (this.id = void 0),
        (this.instanceNo = Nv++),
        (this.observer = void 0),
        (this.frag = null),
        (this.part = null),
        (this.useWorker = void 0),
        (this.workerContext = null),
        (this.transmuxer = null),
        (this.onTransmuxComplete = void 0),
        (this.onFlush = void 0),
        (this.onWorkerMessage = e => {
          const t = e.data,
            i = this.hls;
          if (i && null != t && t.event && t.instanceNo === this.instanceNo)
            switch (t.event) {
              case "init": {
                var s;
                const e =
                  null == (s = this.workerContext) ? void 0 : s.objectURL;
                e && self.URL.revokeObjectURL(e);
                break;
              }
              case "transmuxComplete":
                this.handleTransmuxComplete(t.data);
                break;
              case "flush":
                this.onFlush(t.data);
                break;
              case "workerLog":
                i.logger[t.data.logType] &&
                  i.logger[t.data.logType](t.data.message);
                break;
              default:
                (t.data = t.data || {}),
                  (t.data.frag = this.frag),
                  (t.data.part = this.part),
                  (t.data.id = this.id),
                  i.trigger(t.event, t.data);
            }
        }),
        (this.onWorkerError = e => {
          if (!this.hls) return;
          const t = new Error(`${e.message}  (${e.filename}:${e.lineno})`);
          (this.hls.config.enableWorker = !1),
            this.hls.logger.warn(
              `Error in "${this.id}" Web Worker, fallback to inline`
            ),
            this.hls.trigger(Am.ERROR, {
              type: Rm.OTHER_ERROR,
              details: ym.INTERNAL_EXCEPTION,
              fatal: !1,
              event: "demuxerWorker",
              error: t
            });
        });
      const r = e.config;
      (this.hls = e),
        (this.id = t),
        (this.useWorker = !!r.enableWorker),
        (this.onTransmuxComplete = i),
        (this.onFlush = s);
      const n = (e, t) => {
        ((t = t || {}).frag = this.frag || void 0),
          e === Am.ERROR &&
            ((t.parent = this.id),
            (t.part = this.part),
            (this.error = t.error)),
          this.hls.trigger(e, t);
      };
      (this.observer = new aS()),
        this.observer.on(Am.FRAG_DECRYPTED, n),
        this.observer.on(Am.ERROR, n);
      const a = Gg(r.preferManagedMediaSource);
      if (this.useWorker && "undefined" != typeof Worker) {
        const i = this.hls.logger;
        if (r.workerPath || "function" == typeof __HLS_WORKER_BUNDLE__) {
          try {
            r.workerPath
              ? (i.log(`loading Web Worker ${r.workerPath} for "${t}"`),
                (this.workerContext = (function(e) {
                  const t = cS[e];
                  if (t) return t.clientCount++, t;
                  const i = new self.URL(e, self.location.href).href,
                    s = {
                      worker: new self.Worker(i),
                      scriptURL: i,
                      clientCount: 1
                    };
                  return (cS[e] = s), s;
                })(r.workerPath)))
              : (i.log(`injecting Web Worker for "${t}"`),
                (this.workerContext = (function() {
                  const e = cS[oS];
                  if (e) return e.clientCount++, e;
                  const t = new self.Blob(
                      [
                        `var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`
                      ],
                      { type: "text/javascript" }
                    ),
                    i = self.URL.createObjectURL(t),
                    s = {
                      worker: new self.Worker(i),
                      objectURL: i,
                      clientCount: 1
                    };
                  return (cS[oS] = s), s;
                })()));
            const { worker: e } = this.workerContext;
            e.addEventListener("message", this.onWorkerMessage),
              e.addEventListener("error", this.onWorkerError),
              e.postMessage({
                instanceNo: this.instanceNo,
                cmd: "init",
                typeSupported: a,
                id: t,
                config: i_(r)
              });
          } catch (s) {
            i.warn(`Error setting up "${t}" Web Worker, fallback to inline`, s),
              this.terminateWorker(),
              (this.error = null),
              (this.transmuxer = new bv(this.observer, a, r, "", t, e.logger));
          }
          return;
        }
      }
      this.transmuxer = new bv(this.observer, a, r, "", t, e.logger);
    }
    reset() {
      if (((this.frag = null), (this.part = null), this.workerContext)) {
        const e = this.instanceNo;
        this.instanceNo = Nv++;
        const t = this.hls.config,
          i = Gg(t.preferManagedMediaSource);
        this.workerContext.worker.postMessage({
          instanceNo: this.instanceNo,
          cmd: "reset",
          resetNo: e,
          typeSupported: i,
          id: this.id,
          config: i_(t)
        });
      }
    }
    terminateWorker() {
      if (this.workerContext) {
        const { worker: e } = this.workerContext;
        (this.workerContext = null),
          e.removeEventListener("message", this.onWorkerMessage),
          e.removeEventListener("error", this.onWorkerError),
          (function(e) {
            const t = cS[e || oS];
            if (t && 1 == t.clientCount--) {
              const { worker: i, objectURL: s } = t;
              delete cS[e || oS],
                s && self.URL.revokeObjectURL(s),
                i.terminate();
            }
          })(this.hls.config.workerPath);
      }
    }
    destroy() {
      if (this.workerContext)
        this.terminateWorker(),
          (this.onWorkerMessage = this.onWorkerError = null);
      else {
        const e = this.transmuxer;
        e && (e.destroy(), (this.transmuxer = null));
      }
      const e = this.observer;
      e && e.removeAllListeners(),
        (this.frag = null),
        (this.part = null),
        (this.observer = null),
        (this.hls = null);
    }
    push(e, t, i, s, r, n, a, o, c, d) {
      var l, h;
      c.transmuxing.start = self.performance.now();
      const { instanceNo: u, transmuxer: p } = this,
        f = n ? n.start : r.start,
        E = r.decryptdata,
        m = this.frag,
        g = !(m && r.cc === m.cc),
        _ = !(m && c.level === m.level),
        T = m ? c.sn - m.sn : -1,
        S = this.part ? c.part - this.part.index : -1,
        v =
          0 === T &&
          c.id > 1 &&
          c.id === (null == m ? void 0 : m.stats.chunkCount),
        R = !_ && (1 === T || (0 === T && (1 === S || (v && S <= 0)))),
        y = self.performance.now();
      (_ || T || 0 === r.stats.parsing.start) && (r.stats.parsing.start = y),
        !n || (!S && R) || (n.stats.parsing.start = y);
      const A = !(
          m &&
          (null == (l = r.initSegment) ? void 0 : l.url) ===
            (null == (h = m.initSegment) ? void 0 : h.url)
        ),
        I = new Lv(g, R, o, _, f, A);
      if (!R || g || A) {
        this.hls.logger.log(
          `[transmuxer-interface]: Starting new transmux session for ${
            r.type
          } sn: ${c.sn}${c.part > -1 ? " part: " + c.part : ""} ${
            this.id === Cm.MAIN ? "level" : "track"
          }: ${c.level} id: ${
            c.id
          }\n        discontinuity: ${g}\n        trackSwitch: ${_}\n        contiguous: ${R}\n        accurateTimeOffset: ${o}\n        timeOffset: ${f}\n        initSegmentChange: ${A}`
        );
        const e = new wv(i, s, t, a, d);
        this.configureTransmuxer(e);
      }
      if (((this.frag = r), (this.part = n), this.workerContext))
        this.workerContext.worker.postMessage(
          {
            instanceNo: u,
            cmd: "demux",
            data: e,
            decryptdata: E,
            chunkMeta: c,
            state: I
          },
          e instanceof ArrayBuffer ? [e] : []
        );
      else if (p) {
        const t = p.push(e, E, c, I);
        Dv(t)
          ? t
              .then(e => {
                this.handleTransmuxComplete(e);
              })
              .catch(e => {
                this.transmuxerError(e, c, "transmuxer-interface push error");
              })
          : this.handleTransmuxComplete(t);
      }
    }
    flush(e) {
      e.transmuxing.start = self.performance.now();
      const { instanceNo: t, transmuxer: i } = this;
      if (this.workerContext)
        this.workerContext.worker.postMessage({
          instanceNo: t,
          cmd: "flush",
          chunkMeta: e
        });
      else if (i) {
        const t = i.flush(e);
        Dv(t)
          ? t
              .then(t => {
                this.handleFlushResult(t, e);
              })
              .catch(t => {
                this.transmuxerError(t, e, "transmuxer-interface flush error");
              })
          : this.handleFlushResult(t, e);
      }
    }
    transmuxerError(e, t, i) {
      this.hls &&
        ((this.error = e),
        this.hls.trigger(Am.ERROR, {
          type: Rm.MEDIA_ERROR,
          details: ym.FRAG_PARSING_ERROR,
          chunkMeta: t,
          frag: this.frag || void 0,
          part: this.part || void 0,
          fatal: !1,
          error: e,
          err: e,
          reason: i
        }));
    }
    handleFlushResult(e, t) {
      e.forEach(e => {
        this.handleTransmuxComplete(e);
      }),
        this.onFlush(t);
    }
    configureTransmuxer(e) {
      const { instanceNo: t, transmuxer: i } = this;
      this.workerContext
        ? this.workerContext.worker.postMessage({
            instanceNo: t,
            cmd: "configure",
            config: e
          })
        : i && i.configure(e);
    }
    handleTransmuxComplete(e) {
      (e.chunkMeta.transmuxing.end = self.performance.now()),
        this.onTransmuxComplete(e);
    }
  }
  class kv extends Pm {
    constructor(e, t) {
      super(t, e.logger),
        (this.hls = void 0),
        (this.canLoad = !1),
        (this.timer = -1),
        (this.hls = e);
    }
    destroy() {
      this.clearTimer(), (this.hls = this.log = this.warn = null);
    }
    clearTimer() {
      -1 !== this.timer && (self.clearTimeout(this.timer), (this.timer = -1));
    }
    startLoad() {
      (this.canLoad = !0), this.loadPlaylist();
    }
    stopLoad() {
      (this.canLoad = !1), this.clearTimer();
    }
    switchParams(e, t, i) {
      const s = null == t ? void 0 : t.renditionReports;
      if (s) {
        let r = -1;
        for (let i = 0; i < s.length; i++) {
          const n = s[i];
          let a;
          try {
            a = new self.URL(n.URI, t.url).href;
          } catch (e) {
            this.warn(`Could not construct new URL for Rendition Report: ${e}`),
              (a = n.URI || "");
          }
          if (a === e) {
            r = i;
            break;
          }
          a === e.substring(0, a.length) && (r = i);
        }
        if (-1 !== r) {
          const e = s[r],
            n = parseInt(e["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn);
          let a =
            parseInt(e["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex);
          if (this.hls.config.lowLatencyMode) {
            const e = Math.min(t.age - t.partTarget, t.targetduration);
            a >= 0 && e > t.partTarget && (a += 1);
          }
          const o = i && Jg(i);
          return new Qg(n, a >= 0 ? a : void 0, o);
        }
      }
    }
    loadPlaylist(e) {
      this.clearTimer();
    }
    loadingPlaylist(e, t) {
      this.clearTimer();
    }
    shouldLoadPlaylist(e) {
      return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
    }
    getUrlWithDirectives(e, t) {
      if (t)
        try {
          return t.addDirectives(e);
        } catch (e) {
          this.warn(
            `Could not construct new URL with HLS Delivery Directives: ${e}`
          );
        }
      return e;
    }
    playlistLoaded(e, t, i) {
      const { details: s, stats: r } = t,
        n = self.performance.now(),
        a = r.loading.first ? Math.max(0, n - r.loading.first) : 0;
      s.advancedDateTime = Date.now() - a;
      const o = this.hls.config.timelineOffset;
      if (o !== s.appliedTimelineOffset) {
        const e = Math.max(o || 0, 0);
        (s.appliedTimelineOffset = e),
          s.fragments.forEach(t => {
            t.start = t.playlistOffset + e;
          });
      }
      if (s.live || (null != i && i.live)) {
        const o = "levelInfo" in t ? t.levelInfo : t.track;
        if ((s.reloaded(i), i && s.fragments.length > 0)) {
          BT(i, s);
          const e = s.playlistParsingError;
          if (e) {
            this.warn(e);
            const i = this.hls;
            if (!i.config.ignorePlaylistParsingErrors) {
              var c;
              const { networkDetails: n } = t;
              return void i.trigger(Am.ERROR, {
                type: Rm.NETWORK_ERROR,
                details: ym.LEVEL_PARSING_ERROR,
                fatal: !1,
                url: s.url,
                error: e,
                reason: e.message,
                level: t.level || void 0,
                parent: null == (c = s.fragments[0]) ? void 0 : c.type,
                networkDetails: n,
                stats: r
              });
            }
            s.playlistParsingError = null;
          }
        }
        -1 === s.requestScheduled && (s.requestScheduled = r.loading.start);
        const d = this.hls.mainForwardBufferInfo,
          l = d ? d.end - d.len : 0,
          h = HT(s, 1e3 * (s.edge - l));
        if (
          (s.requestScheduled + h < n
            ? (s.requestScheduled = n)
            : (s.requestScheduled += h),
          this.log(
            `live playlist ${e} ${
              s.advanced
                ? "REFRESHED " + s.lastPartSn + "-" + s.lastPartIndex
                : s.updated
                ? "UPDATED"
                : "MISSED"
            }`
          ),
          !this.canLoad || !s.live)
        )
          return;
        let u, p, f;
        if (s.canBlockReload && s.endSN && s.advanced) {
          const e = this.hls.config.lowLatencyMode,
            r = s.lastPartSn,
            a = s.endSN,
            c = s.lastPartIndex,
            d = r === a;
          -1 !== c
            ? d
              ? ((p = a + 1), (f = e ? 0 : c))
              : ((p = r), (f = e ? c + 1 : s.maxPartIndex))
            : (p = a + 1);
          const l = s.age,
            h = l + s.ageHeader;
          let E = Math.min(h - s.partTarget, 1.5 * s.targetduration);
          if (E > 0) {
            if (h > 3 * s.targetduration)
              this.log(
                `Playlist last advanced ${l.toFixed(
                  2
                )}s ago. Omitting segment and part directives.`
              ),
                (p = void 0),
                (f = void 0);
            else if (
              null != i &&
              i.tuneInGoal &&
              h - s.partTarget > i.tuneInGoal
            )
              this.warn(
                `CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${E} with playlist age: ${s.age}`
              ),
                (E = 0);
            else {
              const e = Math.floor(E / s.targetduration);
              if (((p += e), void 0 !== f)) {
                f += Math.round((E % s.targetduration) / s.partTarget);
              }
              this.log(
                `CDN Tune-in age: ${s.ageHeader}s last advanced ${l.toFixed(
                  2
                )}s goal: ${E} skip sn ${e} to part ${f}`
              );
            }
            s.tuneInGoal = E;
          }
          if (
            ((u = this.getDeliveryDirectives(s, t.deliveryDirectives, p, f)),
            e || !d)
          )
            return (s.requestScheduled = n), void this.loadingPlaylist(o, u);
        } else
          (s.canBlockReload || s.canSkipUntil) &&
            (u = this.getDeliveryDirectives(s, t.deliveryDirectives, p, f));
        u &&
          void 0 !== p &&
          s.canBlockReload &&
          (s.requestScheduled = r.loading.first + Math.max(h - 2 * a, h / 2)),
          this.scheduleLoading(o, u, s);
      } else this.clearTimer();
    }
    scheduleLoading(e, t, i) {
      const s = i || e.details;
      if (!s) return void this.loadingPlaylist(e, t);
      const r = self.performance.now(),
        n = s.requestScheduled;
      if (r >= n) return void this.loadingPlaylist(e, t);
      const a = n - r;
      this.log(
        `reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(
          a
        )} ms`
      ),
        this.clearTimer(),
        (this.timer = self.setTimeout(() => this.loadingPlaylist(e, t), a));
    }
    getDeliveryDirectives(e, t, i, s) {
      let r = Jg(e);
      return (
        null != t &&
          t.skip &&
          e.deltaUpdateFailed &&
          ((i = t.msn), (s = t.part), (r = zg.No)),
        new Qg(i, s, r)
      );
    }
    checkRetry(e) {
      const t = e.details,
        i = m_(e),
        s = e.errorAction,
        { action: r, retryCount: n = 0, retryConfig: a } = s || {},
        o =
          !!s &&
          !!a &&
          (r === v_.RetryRequest ||
            (!s.resolved && r === v_.SendAlternateToPenaltyBox));
      if (o) {
        var c;
        if (n >= a.maxNumRetry) return !1;
        if (i && null != (c = e.context) && c.deliveryDirectives)
          this.warn(
            `Retrying playlist loading ${n + 1}/${
              a.maxNumRetry
            } after "${t}" without delivery-directives`
          ),
            this.loadPlaylist();
        else {
          const e = __(a, n);
          this.clearTimer(),
            (this.timer = self.setTimeout(() => this.loadPlaylist(), e)),
            this.warn(
              `Retrying playlist loading ${n + 1}/${
                a.maxNumRetry
              } after "${t}" in ${e}ms`
            );
        }
        (e.levelRetry = !0), (s.resolved = !0);
      }
      return o;
    }
  }
  function Mv(e, t) {
    if (e.length !== t.length) return !1;
    for (let i = 0; i < e.length; i++)
      if (!Uv(e[i].attrs, t[i].attrs)) return !1;
    return !0;
  }
  function Uv(e, t, i) {
    const s = e["STABLE-RENDITION-ID"];
    return s && !i
      ? s === t["STABLE-RENDITION-ID"]
      : !(
          i || [
            "LANGUAGE",
            "NAME",
            "CHARACTERISTICS",
            "AUTOSELECT",
            "DEFAULT",
            "FORCED",
            "ASSOC-LANGUAGE"
          ]
        ).some(i => e[i] !== t[i]);
  }
  function xv(e, t) {
    return (
      t.label.toLowerCase() === e.name.toLowerCase() &&
      (!t.language || t.language.toLowerCase() === (e.lang || "").toLowerCase())
    );
  }
  class Fv {
    constructor(e) {
      (this.tracks = void 0),
        (this.queues = { video: [], audio: [], audiovideo: [] }),
        (this.tracks = e);
    }
    destroy() {
      this.tracks = this.queues = null;
    }
    append(e, t, i) {
      if (null === this.queues || null === this.tracks) return;
      const s = this.queues[t];
      s.push(e), 1 !== s.length || i || this.executeNext(t);
    }
    appendBlocker(e) {
      return new Promise(t => {
        const i = {
          label: "async-blocker",
          execute: t,
          onStart: () => {},
          onComplete: () => {},
          onError: () => {}
        };
        this.append(i, e);
      });
    }
    prependBlocker(e) {
      return new Promise(t => {
        if (this.queues) {
          const i = {
            label: "async-blocker-prepend",
            execute: t,
            onStart: () => {},
            onComplete: () => {},
            onError: () => {}
          };
          this.queues[e].unshift(i);
        }
      });
    }
    removeBlockers() {
      null !== this.queues &&
        [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(
          e => {
            var t;
            const i = null == (t = e[0]) ? void 0 : t.label;
            ("async-blocker" !== i && "async-blocker-prepend" !== i) ||
              (e[0].execute(), e.splice(0, 1));
          }
        );
    }
    unblockAudio(e) {
      if (null === this.queues) return;
      this.queues.audio[0] === e && this.shiftAndExecuteNext("audio");
    }
    executeNext(e) {
      if (null === this.queues || null === this.tracks) return;
      const t = this.queues[e];
      if (t.length) {
        const s = t[0];
        try {
          s.execute();
        } catch (t) {
          var i;
          if ((s.onError(t), null === this.queues || null === this.tracks))
            return;
          const r = null == (i = this.tracks[e]) ? void 0 : i.buffer;
          (null != r && r.updating) || this.shiftAndExecuteNext(e);
        }
      }
    }
    shiftAndExecuteNext(e) {
      null !== this.queues && (this.queues[e].shift(), this.executeNext(e));
    }
    current(e) {
      var t;
      return (null == (t = this.queues) ? void 0 : t[e][0]) || null;
    }
    toString() {
      const { queues: e, tracks: t } = this;
      return null === e || null === t
        ? "<destroyed>"
        : `\n${this.list("video")}\n${this.list("audio")}\n${this.list(
            "audiovideo"
          )}}`;
    }
    list(e) {
      var t, i;
      return (null != (t = this.queues) && t[e]) ||
        (null != (i = this.tracks) && i[e])
        ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}`
        : "";
    }
    listSbInfo(e) {
      var t;
      const i = null == (t = this.tracks) ? void 0 : t[e],
        s = null == i ? void 0 : i.buffer;
      return s
        ? `SourceBuffer${s.updating ? " updating" : ""}${
            i.ended ? " ended" : ""
          }${i.ending ? " ending" : ""}`
        : "none";
    }
    listOps(e) {
      var t;
      return (
        (null == (t = this.queues)
          ? void 0
          : t[e].map(e => e.label).join(", ")) || ""
      );
    }
  }
  const Bv = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/,
    Vv = "HlsJsTrackRemovedError";
  class Gv extends Error {
    constructor(e) {
      super(e), (this.name = Vv);
    }
  }
  function jv(e) {
    const t = e.querySelectorAll("source");
    [].slice.call(t).forEach(t => {
      e.removeChild(t);
    });
  }
  function Hv(e) {
    return "audio" === e ? 1 : 0;
  }
  class Kv {
    constructor(e) {
      (this.hls = void 0),
        (this.autoLevelCapping = void 0),
        (this.firstLevel = void 0),
        (this.media = void 0),
        (this.restrictedLevels = void 0),
        (this.timer = void 0),
        (this.clientRect = void 0),
        (this.streamController = void 0),
        (this.hls = e),
        (this.autoLevelCapping = Number.POSITIVE_INFINITY),
        (this.firstLevel = -1),
        (this.media = null),
        (this.restrictedLevels = []),
        (this.timer = void 0),
        (this.clientRect = null),
        this.registerListeners();
    }
    setStreamController(e) {
      this.streamController = e;
    }
    destroy() {
      this.hls && this.unregisterListener(),
        this.timer && this.stopCapping(),
        (this.media = null),
        (this.clientRect = null),
        (this.hls = this.streamController = null);
    }
    registerListeners() {
      const { hls: e } = this;
      e.on(Am.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
        e.on(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(Am.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(Am.BUFFER_CODECS, this.onBufferCodecs, this),
        e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    unregisterListener() {
      const { hls: e } = this;
      e.off(Am.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
        e.off(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(Am.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(Am.BUFFER_CODECS, this.onBufferCodecs, this),
        e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    onFpsDropLevelCapping(e, t) {
      const i = this.hls.levels[t.droppedLevel];
      this.isLevelAllowed(i) &&
        this.restrictedLevels.push({
          bitrate: i.bitrate,
          height: i.height,
          width: i.width
        });
    }
    onMediaAttaching(e, t) {
      (this.media = t.media instanceof HTMLVideoElement ? t.media : null),
        (this.clientRect = null),
        this.timer && this.hls.levels.length && this.detectPlayerSize();
    }
    onManifestParsed(e, t) {
      const i = this.hls;
      (this.restrictedLevels = []),
        (this.firstLevel = t.firstLevel),
        i.config.capLevelToPlayerSize && t.video && this.startCapping();
    }
    onLevelsUpdated(e, t) {
      this.timer && Tm(this.autoLevelCapping) && this.detectPlayerSize();
    }
    onBufferCodecs(e, t) {
      this.hls.config.capLevelToPlayerSize && t.video && this.startCapping();
    }
    onMediaDetaching() {
      this.stopCapping(), (this.media = null);
    }
    detectPlayerSize() {
      if (this.media) {
        if (this.mediaHeight <= 0 || this.mediaWidth <= 0)
          return void (this.clientRect = null);
        const e = this.hls.levels;
        if (e.length) {
          const t = this.hls,
            i = this.getMaxLevel(e.length - 1);
          i !== this.autoLevelCapping &&
            t.logger.log(
              `Setting autoLevelCapping to ${i}: ${e[i].height}p@${e[i].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`
            ),
            (t.autoLevelCapping = i),
            t.autoLevelEnabled &&
              t.autoLevelCapping > this.autoLevelCapping &&
              this.streamController &&
              this.streamController.nextLevelSwitch(),
            (this.autoLevelCapping = t.autoLevelCapping);
        }
      }
    }
    getMaxLevel(e) {
      const t = this.hls.levels;
      if (!t.length) return -1;
      const i = t.filter((t, i) => this.isLevelAllowed(t) && i <= e);
      return (
        (this.clientRect = null),
        Kv.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight)
      );
    }
    startCapping() {
      this.timer ||
        ((this.autoLevelCapping = Number.POSITIVE_INFINITY),
        self.clearInterval(this.timer),
        (this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3)),
        this.detectPlayerSize());
    }
    stopCapping() {
      (this.restrictedLevels = []),
        (this.firstLevel = -1),
        (this.autoLevelCapping = Number.POSITIVE_INFINITY),
        this.timer && (self.clearInterval(this.timer), (this.timer = void 0));
    }
    getDimensions() {
      if (this.clientRect) return this.clientRect;
      const e = this.media,
        t = { width: 0, height: 0 };
      if (e) {
        const i = e.getBoundingClientRect();
        (t.width = i.width),
          (t.height = i.height),
          t.width ||
            t.height ||
            ((t.width = i.right - i.left || e.width || 0),
            (t.height = i.bottom - i.top || e.height || 0));
      }
      return (this.clientRect = t), t;
    }
    get mediaWidth() {
      return this.getDimensions().width * this.contentScaleFactor;
    }
    get mediaHeight() {
      return this.getDimensions().height * this.contentScaleFactor;
    }
    get contentScaleFactor() {
      let e = 1;
      if (!this.hls.config.ignoreDevicePixelRatio)
        try {
          e = self.devicePixelRatio;
        } catch (e) {}
      return Math.min(e, this.hls.config.maxDevicePixelRatio);
    }
    isLevelAllowed(e) {
      return !this.restrictedLevels.some(
        t =>
          e.bitrate === t.bitrate &&
          e.width === t.width &&
          e.height === t.height
      );
    }
    static getMaxLevelByMediaSize(e, t, i) {
      if (null == e || !e.length) return -1;
      let s = e.length - 1;
      const r = Math.max(t, i);
      for (let t = 0; t < e.length; t += 1) {
        const i = e[t];
        if (
          (i.width >= r || i.height >= r) &&
          ((n = i),
          !(a = e[t + 1]) || n.width !== a.width || n.height !== a.height)
        ) {
          s = t;
          break;
        }
      }
      var n, a;
      return s;
    }
  }
  const Wv = {
      MANIFEST: "m",
      AUDIO: "a",
      VIDEO: "v",
      MUXED: "av",
      INIT: "i",
      CAPTION: "c",
      TIMED_TEXT: "tt",
      KEY: "k",
      OTHER: "o"
    },
    Yv = { HLS: "h" },
    $v = {
      OBJECT: "CMCD-Object",
      REQUEST: "CMCD-Request",
      SESSION: "CMCD-Session",
      STATUS: "CMCD-Status"
    },
    qv = {
      [$v.OBJECT]: ["br", "d", "ot", "tb"],
      [$v.REQUEST]: ["bl", "dl", "mtp", "nor", "nrr", "su"],
      [$v.SESSION]: ["cid", "pr", "sf", "sid", "st", "v"],
      [$v.STATUS]: ["bs", "rtp"]
    };
  class Xv {
    constructor(e, t) {
      Array.isArray(e) && (e = e.map(e => (e instanceof Xv ? e : new Xv(e)))),
        (this.value = e),
        (this.params = t);
    }
  }
  const zv = "Dict";
  function Jv(e, t, i, s) {
    return new Error(
      `failed to ${e} "${((r = t),
      Array.isArray(r)
        ? JSON.stringify(r)
        : r instanceof Map
        ? "Map{}"
        : r instanceof Set
        ? "Set{}"
        : "object" == typeof r
        ? JSON.stringify(r)
        : String(r))}" as ${i}`,
      { cause: s }
    );
    var r;
  }
  function Qv(e, t, i) {
    return Jv("serialize", e, t, i);
  }
  class Zv {
    constructor(e) {
      this.description = e;
    }
  }
  const eR = "Bare Item",
    tR = "Boolean";
  const iR = "Byte Sequence";
  function sR(e) {
    if (!1 === ArrayBuffer.isView(e)) throw Qv(e, iR);
    return `:${((t = e), btoa(String.fromCharCode(...t)))}:`;
    var t;
  }
  const rR = "Integer";
  function nR(e) {
    if (
      (function(e) {
        return e < -999999999999999 || 999999999999999 < e;
      })(e)
    )
      throw Qv(e, rR);
    return e.toString();
  }
  const aR = "Decimal";
  function oR(e) {
    const t = RS(e, 3);
    if (Math.floor(Math.abs(t)).toString().length > 12) throw Qv(e, aR);
    const i = t.toString();
    return i.includes(".") ? i : `${i}.0`;
  }
  const cR = "String",
    dR = /[\x00-\x1f\x7f]+/;
  const lR = "Token";
  function hR(e) {
    const t = (function(e) {
      return e.description || e.toString().slice(7, -1);
    })(e);
    if (!1 === /^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(t))
      throw Qv(t, lR);
    return t;
  }
  function uR(e) {
    switch (typeof e) {
      case "number":
        if (!Tm(e)) throw Qv(e, eR);
        return Number.isInteger(e) ? nR(e) : oR(e);
      case "string":
        return (function(e) {
          if (dR.test(e)) throw Qv(e, cR);
          return `"${e.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
        })(e);
      case "symbol":
        return hR(e);
      case "boolean":
        return (function(e) {
          if ("boolean" != typeof e) throw Qv(e, tR);
          return e ? "?1" : "?0";
        })(e);
      case "object":
        if (e instanceof Date)
          return (function(e) {
            return `@${nR(e.getTime() / 1e3)}`;
          })(e);
        if (e instanceof Uint8Array) return sR(e);
        if (e instanceof Zv) return hR(e);
      default:
        throw Qv(e, eR);
    }
  }
  const pR = "Key";
  function fR(e) {
    if (!1 === /^[a-z*][a-z0-9\-_.*]*$/.test(e)) throw Qv(e, pR);
    return e;
  }
  function ER(e) {
    return null == e
      ? ""
      : Object.entries(e)
          .map(([e, t]) => (!0 === t ? `;${fR(e)}` : `;${fR(e)}=${uR(t)}`))
          .join("");
  }
  function mR(e) {
    return e instanceof Xv ? `${uR(e.value)}${ER(e.params)}` : uR(e);
  }
  function gR(e, t = { whitespace: !0 }) {
    if ("object" != typeof e) throw Qv(e, zv);
    const i = e instanceof Map ? e.entries() : Object.entries(e),
      s = (null == t ? void 0 : t.whitespace) ? " " : "";
    return Array.from(i)
      .map(([e, t]) => {
        t instanceof Xv == !1 && (t = new Xv(t));
        let i = fR(e);
        var s;
        return (
          !0 === t.value
            ? (i += ER(t.params))
            : ((i += "="),
              Array.isArray(t.value)
                ? (i += `(${(s = t).value.map(mR).join(" ")})${ER(s.params)}`)
                : (i += mR(t))),
          i
        );
      })
      .join(`,${s}`);
  }
  const _R = e => Math.round(e),
    TR = e => 100 * _R(e / 100),
    SR = {
      br: _R,
      d: _R,
      bl: TR,
      dl: TR,
      mtp: TR,
      nor: (e, t) => (
        (null == t ? void 0 : t.baseUrl) &&
          (e = (function(e, t) {
            const i = new URL(e),
              s = new URL(t);
            if (i.origin !== s.origin) return e;
            const r = i.pathname.split("/").slice(1),
              n = s.pathname.split("/").slice(1, -1);
            for (; r[0] === n[0]; ) r.shift(), n.shift();
            for (; n.length; ) n.shift(), r.unshift("..");
            return r.join("/");
          })(e, t.baseUrl)),
        encodeURIComponent(e)
      ),
      rtp: TR,
      tb: _R
    };
  function vR(e, t) {
    const i = {};
    if (null == e || "object" != typeof e) return i;
    const s = Object.keys(e).sort(),
      r = wm({}, SR, null == t ? void 0 : t.formatters),
      n = null == t ? void 0 : t.filter;
    return (
      s.forEach(s => {
        if (null == n ? void 0 : n(s)) return;
        let a = e[s];
        const o = r[s];
        o && (a = o(a, t)),
          ("v" === s && 1 === a) ||
            ("pr" == s && 1 === a) ||
            ((function(e) {
              return "number" == typeof e
                ? Tm(e)
                : null != e && "" !== e && !1 !== e;
            })(a) &&
              ((function(e) {
                return "ot" === e || "sf" === e || "st" === e;
              })(s) &&
                "string" == typeof a &&
                (a = new Zv(a)),
              (i[s] = a)));
      }),
      i
    );
  }
  function RR(e, t = {}) {
    return e
      ? (function(e, t) {
          return gR(e, t);
        })(vR(e, t), wm({ whitespace: !1 }, t))
      : "";
  }
  function yR(e, t, i) {
    return wm(
      e,
      (function(e, t = {}) {
        const i = {};
        if (!e) return i;
        const s = Object.entries(e),
          r = Object.entries(qv).concat(
            Object.entries((null == t ? void 0 : t.customHeaderMap) || {})
          ),
          n = s.reduce((e, t) => {
            var i, s;
            const [n, a] = t,
              o =
                (null === (i = r.find(e => e[1].includes(n))) || void 0 === i
                  ? void 0
                  : i[0]) || $v.REQUEST;
            return (
              (null !== (s = e[o]) && void 0 !== s) || (e[o] = {}),
              (e[o][n] = a),
              e
            );
          }, {});
        return Object.entries(n).reduce(
          (e, [i, s]) => ((e[i] = RR(s, t)), e),
          i
        );
      })(t, i)
    );
  }
  const AR = "CMCD";
  const IR = /CMCD=[^&#]+/;
  function CR(e, t, i) {
    const s = (function(e, t = {}) {
      if (!e) return "";
      const i = RR(e, t);
      return `${AR}=${encodeURIComponent(i)}`;
    })(t, i);
    if (!s) return e;
    if (IR.test(e)) return e.replace(IR, s);
    const r = e.includes("?") ? "&" : "?";
    return `${e}${r}${s}`;
  }
  function bR(e, t, i, s) {
    e &&
      Object.keys(t).forEach(r => {
        const n = e
          .filter(e => e.groupId === r)
          .map(e => {
            const n = wm({}, e);
            return (
              (n.details = void 0),
              (n.attrs = new Q_(n.attrs)),
              (n.url = n.attrs.URI = OR(
                e.url,
                e.attrs["STABLE-RENDITION-ID"],
                "PER-RENDITION-URIS",
                i
              )),
              (n.groupId = n.attrs["GROUP-ID"] = t[r]),
              (n.attrs["PATHWAY-ID"] = s),
              n
            );
          });
        e.push(...n);
      });
  }
  function OR(e, t, i, s) {
    const { HOST: r, PARAMS: n, [i]: a } = s;
    let o;
    t && ((o = null == a ? void 0 : a[t]), o && (e = o));
    const c = new self.URL(e);
    return (
      r && !o && (c.host = r),
      n &&
        Object.keys(n)
          .sort()
          .forEach(e => {
            e && c.searchParams.set(e, n[e]);
          }),
      c.href
    );
  }
  class DR extends Pm {
    constructor(e) {
      super("eme", e.logger),
        (this.hls = void 0),
        (this.config = void 0),
        (this.media = null),
        (this.keyFormatPromise = null),
        (this.keySystemAccessPromises = {}),
        (this._requestLicenseFailureCount = 0),
        (this.mediaKeySessions = []),
        (this.keyIdToKeySessionPromise = {}),
        (this.setMediaKeysQueue = DR.CDMCleanupPromise
          ? [DR.CDMCleanupPromise]
          : []),
        (this.onMediaEncrypted = e => {
          const { initDataType: t, initData: i } = e,
            s = `"${e.type}" event: init data type: "${t}"`;
          if ((this.debug(s), null !== i)) {
            if (!this.keyFormatPromise) {
              let e = Object.keys(this.keySystemAccessPromises);
              e.length || (e = fT(this.config));
              const t = e.map(pT).filter(e => !!e);
              this.keyFormatPromise = this.getKeyFormatPromise(t);
            }
            this.keyFormatPromise.then(r => {
              const n = lT(r);
              let a, o;
              if ("sinf" === t) {
                if (n !== cT.FAIRPLAY)
                  return void this.warn(
                    `Ignoring unexpected "${e.type}" event with init data type: "${t}" for selected key-system ${n}`
                  );
                const r = rg(new Uint8Array(i));
                try {
                  const e = _g(rT(JSON.parse(r).sinf));
                  if (!e)
                    throw new Error(
                      "'schm' box missing or not cbcs/cenc with schi > tenc"
                    );
                  (a = new Uint8Array(e.subarray(8, 24))), (o = cT.FAIRPLAY);
                } catch (e) {
                  return void this.warn(`${s} Failed to parse sinf: ${e}`);
                }
              } else {
                if (n !== cT.WIDEVINE && n !== cT.PLAYREADY)
                  return void this.warn(
                    `Ignoring unexpected "${e.type}" event with init data type: "${t}" for selected key-system ${n}`
                  );
                const r = (function(e) {
                    const t = [];
                    if (e instanceof ArrayBuffer) {
                      const i = e.byteLength;
                      let s = 0;
                      for (; s + 32 < i; ) {
                        const i = bg(new DataView(e, s));
                        t.push(i), (s += i.size);
                      }
                    }
                    return t;
                  })(i),
                  c = r.filter(e => !!e.systemId && uT(e.systemId) === n);
                c.length > 1 &&
                  this.warn(
                    `${s} Using first of ${c.length} pssh found for selected key-system ${n}`
                  );
                const d = c[0];
                if (!d)
                  return void (0 === r.length || r.some(e => !e.systemId)
                    ? this.warn(`${s} contains incomplete or invalid pssh data`)
                    : this.log(
                        `ignoring ${s} for ${r
                          .map(e => uT(e.systemId))
                          .join(",")} pssh data in favor of playlist keys`
                      ));
                if (((o = uT(d.systemId)), 0 === d.version && d.data))
                  if (o === cT.WIDEVINE) {
                    const e = d.data.length - 22;
                    a = new Uint8Array(d.data.subarray(e, e + 16));
                  } else o === cT.PLAYREADY && (a = gT(d.data));
              }
              if (!o || !a) return;
              const c = Hm.hexDump(a),
                { keyIdToKeySessionPromise: d, mediaKeySessions: l } = this;
              let h = d[c];
              for (let e = 0; e < l.length; e++) {
                const s = l[e],
                  r = s.decryptdata;
                if (!r.keyId) continue;
                const n = Hm.hexDump(r.keyId);
                if (c === n || -1 !== r.uri.replace(/-/g, "").indexOf(c)) {
                  if (((h = d[n]), r.pssh)) break;
                  delete d[n],
                    (r.pssh = new Uint8Array(i)),
                    (r.keyId = a),
                    (h = d[c] = h.then(() =>
                      this.generateRequestWithPreferredKeySession(
                        s,
                        t,
                        i,
                        "encrypted-event-key-match"
                      )
                    )),
                    h.catch(e => this.handleError(e));
                  break;
                }
              }
              if (!h) {
                if (o !== n)
                  return void this.log(
                    `Ignoring "${e.type}" event with ${o} init data for selected key-system ${n}`
                  );
                (h = d[c] = this.getKeySystemSelectionPromise([o]).then(
                  ({ keySystem: e, mediaKeys: s }) => {
                    var r;
                    this.throwIfDestroyed();
                    const n = new TT(
                      "ISO-23001-7",
                      c,
                      null != (r = pT(e)) ? r : ""
                    );
                    return (
                      (n.pssh = new Uint8Array(i)),
                      (n.keyId = a),
                      this.attemptSetMediaKeys(e, s).then(() => {
                        this.throwIfDestroyed();
                        const r = this.createMediaKeySessionContext({
                          decryptdata: n,
                          keySystem: e,
                          mediaKeys: s
                        });
                        return this.generateRequestWithPreferredKeySession(
                          r,
                          t,
                          i,
                          "encrypted-event-no-match"
                        );
                      })
                    );
                  }
                )),
                  h.catch(e => this.handleError(e));
              }
            });
          }
        }),
        (this.onWaitingForKey = e => {
          this.log(`"${e.type}" event`);
        }),
        (this.hls = e),
        (this.config = e.config),
        this.registerListeners();
    }
    destroy() {
      const e = this.media;
      this.unregisterListeners(), this.onMediaDetached(), this._clear(e);
      const t = this.config;
      (t.requestMediaKeySystemAccessFunc = null),
        (t.licenseXhrSetup = t.licenseResponseCallback = void 0),
        (t.drmSystems = t.drmSystemOptions = {}),
        (this.hls = this.config = this.keyIdToKeySessionPromise = null),
        (this.onMediaEncrypted = this.onWaitingForKey = null);
    }
    registerListeners() {
      this.hls.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.on(Am.MEDIA_DETACHED, this.onMediaDetached, this),
        this.hls.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.on(Am.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    unregisterListeners() {
      this.hls.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.off(Am.MEDIA_DETACHED, this.onMediaDetached, this),
        this.hls.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.off(Am.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    getLicenseServerUrl(e) {
      const { drmSystems: t, widevineLicenseUrl: i } = this.config,
        s = t[e];
      return s ? s.licenseUrl : e === cT.WIDEVINE && i ? i : void 0;
    }
    getLicenseServerUrlOrThrow(e) {
      const t = this.getLicenseServerUrl(e);
      if (void 0 === t)
        throw new Error(
          `no license server URL configured for key-system "${e}"`
        );
      return t;
    }
    getServerCertificateUrl(e) {
      const { drmSystems: t } = this.config,
        i = t[e];
      if (i) return i.serverCertificateUrl;
      this.log(`No Server Certificate in config.drmSystems["${e}"]`);
    }
    attemptKeySystemAccess(e) {
      const t = this.hls.levels,
        i = (e, t, i) => !!e && i.indexOf(e) === t,
        s = t.map(e => e.audioCodec).filter(i),
        r = t.map(e => e.videoCodec).filter(i);
      return (
        s.length + r.length === 0 && r.push("avc1.42e01e"),
        new Promise((t, i) => {
          const n = e => {
            const a = e.shift();
            this.getMediaKeysPromise(a, s, r)
              .then(e => t({ keySystem: a, mediaKeys: e }))
              .catch(t => {
                e.length
                  ? n(e)
                  : i(
                      t instanceof wR
                        ? t
                        : new wR(
                            {
                              type: Rm.KEY_SYSTEM_ERROR,
                              details: ym.KEY_SYSTEM_NO_ACCESS,
                              error: t,
                              fatal: !0
                            },
                            t.message
                          )
                    );
              });
          };
          n(e);
        })
      );
    }
    requestMediaKeySystemAccess(e, t) {
      const { requestMediaKeySystemAccessFunc: i } = this.config;
      if ("function" != typeof i) {
        let e = `Configured requestMediaKeySystemAccess is not a function ${i}`;
        return (
          null === ET &&
            "http:" === self.location.protocol &&
            (e = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`),
          Promise.reject(new Error(e))
        );
      }
      return i(e, t);
    }
    getMediaKeysPromise(e, t, i) {
      const s = (function(e, t, i, s) {
          let r;
          switch (e) {
            case cT.FAIRPLAY:
              r = ["cenc", "sinf"];
              break;
            case cT.WIDEVINE:
            case cT.PLAYREADY:
              r = ["cenc"];
              break;
            case cT.CLEARKEY:
              r = ["cenc", "keyids"];
              break;
            default:
              throw new Error(`Unknown key-system: ${e}`);
          }
          return (function(e, t, i, s) {
            return [
              {
                initDataTypes: e,
                persistentState: s.persistentState || "optional",
                distinctiveIdentifier: s.distinctiveIdentifier || "optional",
                sessionTypes: s.sessionTypes || [s.sessionType || "temporary"],
                audioCapabilities: t.map(e => ({
                  contentType: `audio/mp4; codecs=${e}`,
                  robustness: s.audioRobustness || "",
                  encryptionScheme: s.audioEncryptionScheme || null
                })),
                videoCapabilities: i.map(e => ({
                  contentType: `video/mp4; codecs=${e}`,
                  robustness: s.videoRobustness || "",
                  encryptionScheme: s.videoEncryptionScheme || null
                }))
              }
            ];
          })(r, t, i, s);
        })(e, t, i, this.config.drmSystemOptions),
        r = this.keySystemAccessPromises[e];
      let n = null == r ? void 0 : r.keySystemAccess;
      if (!n) {
        this.log(
          `Requesting encrypted media "${e}" key-system access with config: ${i_(
            s
          )}`
        ),
          (n = this.requestMediaKeySystemAccess(e, s));
        const t = (this.keySystemAccessPromises[e] = { keySystemAccess: n });
        return (
          n.catch(t => {
            this.log(`Failed to obtain access to key-system "${e}": ${t}`);
          }),
          n.then(i => {
            this.log(`Access for key-system "${i.keySystem}" obtained`);
            const s = this.fetchServerCertificate(e);
            return (
              this.log(`Create media-keys for "${e}"`),
              (t.mediaKeys = i
                .createMediaKeys()
                .then(
                  t => (
                    this.log(`Media-keys created for "${e}"`),
                    s.then(i =>
                      i ? this.setMediaKeysServerCertificate(t, e, i) : t
                    )
                  )
                )),
              t.mediaKeys.catch(t => {
                this.error(`Failed to create media-keys for "${e}"}: ${t}`);
              }),
              t.mediaKeys
            );
          })
        );
      }
      return n.then(() => r.mediaKeys);
    }
    createMediaKeySessionContext({
      decryptdata: e,
      keySystem: t,
      mediaKeys: i
    }) {
      this.log(
        `Creating key-system session "${t}" keyId: ${Hm.hexDump(e.keyId || [])}`
      );
      const s = i.createSession(),
        r = {
          decryptdata: e,
          keySystem: t,
          mediaKeys: i,
          mediaKeysSession: s,
          keyStatus: "status-pending"
        };
      return this.mediaKeySessions.push(r), r;
    }
    renewKeySession(e) {
      const t = e.decryptdata;
      if (t.pssh) {
        const i = this.createMediaKeySessionContext(e),
          s = this.getKeyIdString(t),
          r = "cenc";
        this.keyIdToKeySessionPromise[
          s
        ] = this.generateRequestWithPreferredKeySession(
          i,
          r,
          t.pssh.buffer,
          "expired"
        );
      } else this.warn("Could not renew expired session. Missing pssh initData.");
      this.removeSession(e);
    }
    getKeyIdString(e) {
      if (!e) throw new Error("Could not read keyId of undefined decryptdata");
      if (null === e.keyId) throw new Error("keyId is null");
      return Hm.hexDump(e.keyId);
    }
    updateKeySession(e, t) {
      var i;
      const s = e.mediaKeysSession;
      return (
        this.log(
          `Updating key-session "${s.sessionId}" for keyID ${Hm.hexDump(
            (null == (i = e.decryptdata) ? void 0 : i.keyId) || []
          )}\n      } (data length: ${t ? t.byteLength : t})`
        ),
        s.update(t)
      );
    }
    selectKeySystemFormat(e) {
      const t = Object.keys(e.levelkeys || {});
      return (
        this.keyFormatPromise ||
          (this.log(
            `Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${
              e.level
            }) key formats ${t.join(", ")}`
          ),
          (this.keyFormatPromise = this.getKeyFormatPromise(t))),
        this.keyFormatPromise
      );
    }
    getKeyFormatPromise(e) {
      return new Promise((t, i) => {
        const s = fT(this.config),
          r = e.map(lT).filter(e => !!e && -1 !== s.indexOf(e));
        return this.getKeySystemSelectionPromise(r)
          .then(({ keySystem: e }) => {
            const s = pT(e);
            s
              ? t(s)
              : i(new Error(`Unable to find format for key-system "${e}"`));
          })
          .catch(i);
      });
    }
    loadKey(e) {
      const t = e.keyInfo.decryptdata,
        i = this.getKeyIdString(t),
        s = `(keyId: ${i} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
      this.log(`Starting session for key ${s}`);
      let r = this.keyIdToKeySessionPromise[i];
      if (!r) {
        r = this.getKeySystemForKeyPromise(t).then(
          ({ keySystem: i, mediaKeys: r }) => (
            this.throwIfDestroyed(),
            this.log(
              `Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${s}`
            ),
            this.attemptSetMediaKeys(i, r).then(
              () => (
                this.throwIfDestroyed(),
                this.createMediaKeySessionContext({
                  keySystem: i,
                  mediaKeys: r,
                  decryptdata: t
                })
              )
            )
          )
        );
        (this.keyIdToKeySessionPromise[i] = r.then(e => {
          const i = t.pssh ? t.pssh.buffer : null;
          return this.generateRequestWithPreferredKeySession(
            e,
            "cenc",
            i,
            "playlist-key"
          );
        })).catch(e => this.handleError(e));
      }
      return r;
    }
    throwIfDestroyed(e = "Invalid state") {
      if (!this.hls) throw new Error("invalid state");
    }
    handleError(e) {
      this.hls &&
        (this.error(e.message),
        e instanceof wR
          ? this.hls.trigger(Am.ERROR, e.data)
          : this.hls.trigger(Am.ERROR, {
              type: Rm.KEY_SYSTEM_ERROR,
              details: ym.KEY_SYSTEM_NO_KEYS,
              error: e,
              fatal: !0
            }));
    }
    getKeySystemForKeyPromise(e) {
      const t = this.getKeyIdString(e),
        i = this.keyIdToKeySessionPromise[t];
      if (!i) {
        const t = lT(e.keyFormat),
          i = t ? [t] : fT(this.config);
        return this.attemptKeySystemAccess(i);
      }
      return i;
    }
    getKeySystemSelectionPromise(e) {
      if ((e.length || (e = fT(this.config)), 0 === e.length))
        throw new wR(
          {
            type: Rm.KEY_SYSTEM_ERROR,
            details: ym.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
            fatal: !0
          },
          `Missing key-system license configuration options ${i_({
            drmSystems: this.config.drmSystems
          })}`
        );
      return this.attemptKeySystemAccess(e);
    }
    attemptSetMediaKeys(e, t) {
      const i = this.setMediaKeysQueue.slice();
      this.log(`Setting media-keys for "${e}"`);
      const s = Promise.all(i).then(() => {
        if (!this.media)
          throw new Error(
            "Attempted to set mediaKeys without media element attached"
          );
        return this.media.setMediaKeys(t);
      });
      return (
        this.setMediaKeysQueue.push(s),
        s.then(() => {
          this.log(`Media-keys set for "${e}"`),
            i.push(s),
            (this.setMediaKeysQueue = this.setMediaKeysQueue.filter(
              e => -1 === i.indexOf(e)
            ));
        })
      );
    }
    generateRequestWithPreferredKeySession(e, t, i, s) {
      var r, n;
      const a =
        null == (r = this.config.drmSystems) || null == (n = r[e.keySystem])
          ? void 0
          : n.generateRequest;
      if (a)
        try {
          const s = a.call(this.hls, t, i, e);
          if (!s)
            throw new Error(
              "Invalid response from configured generateRequest filter"
            );
          (t = s.initDataType),
            (i = s.initData ? s.initData : null),
            (e.decryptdata.pssh = i ? new Uint8Array(i) : null);
        } catch (e) {
          var o;
          if ((this.warn(e.message), null != (o = this.hls) && o.config.debug))
            throw e;
        }
      if (null === i)
        return (
          this.log(`Skipping key-session request for "${s}" (no initData)`),
          Promise.resolve(e)
        );
      const c = this.getKeyIdString(e.decryptdata);
      this.log(
        `Generating key-session request for "${s}": ${c} (init data type: ${t} length: ${
          i ? i.byteLength : null
        })`
      );
      const d = new aS(),
        l = (e._onmessage = t => {
          const i = e.mediaKeysSession;
          if (!i) return void d.emit("error", new Error("invalid state"));
          const { messageType: s, message: r } = t;
          this.log(
            `"${s}" message event for session "${i.sessionId}" message size: ${r.byteLength}`
          ),
            "license-request" === s || "license-renewal" === s
              ? this.renewLicense(e, r).catch(e => {
                  d.eventNames().length
                    ? d.emit("error", e)
                    : this.handleError(e);
                })
              : "license-release" === s
              ? e.keySystem === cT.FAIRPLAY &&
                (this.updateKeySession(e, nT("acknowledged")),
                this.removeSession(e))
              : this.warn(`unhandled media key message type "${s}"`);
        }),
        h = (e._onkeystatuseschange = t => {
          if (!e.mediaKeysSession)
            return void d.emit("error", new Error("invalid state"));
          this.onKeyStatusChange(e);
          const i = e.keyStatus;
          d.emit("keyStatus", i),
            "expired" === i &&
              (this.warn(`${e.keySystem} expired for key ${c}`),
              this.renewKeySession(e));
        });
      e.mediaKeysSession.addEventListener("message", l),
        e.mediaKeysSession.addEventListener("keystatuseschange", h);
      const u = new Promise((e, t) => {
        d.on("error", t),
          d.on("keyStatus", i => {
            i.startsWith("usable")
              ? e()
              : "output-restricted" === i
              ? t(
                  new wR(
                    {
                      type: Rm.KEY_SYSTEM_ERROR,
                      details: ym.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                      fatal: !1
                    },
                    "HDCP level output restricted"
                  )
                )
              : "internal-error" === i
              ? t(
                  new wR(
                    {
                      type: Rm.KEY_SYSTEM_ERROR,
                      details: ym.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                      fatal: !0
                    },
                    `key status changed to "${i}"`
                  )
                )
              : "expired" === i
              ? t(new Error("key expired while generating request"))
              : this.warn(`unhandled key status change "${i}"`);
          });
      });
      return e.mediaKeysSession
        .generateRequest(t, i)
        .then(() => {
          var t;
          this.log(
            `Request generated for key-session "${
              null == (t = e.mediaKeysSession) ? void 0 : t.sessionId
            }" keyId: ${c}`
          );
        })
        .catch(e => {
          throw new wR(
            {
              type: Rm.KEY_SYSTEM_ERROR,
              details: ym.KEY_SYSTEM_NO_SESSION,
              error: e,
              fatal: !1
            },
            `Error generating key-session request: ${e}`
          );
        })
        .then(() => u)
        .catch(t => {
          throw (d.removeAllListeners(), this.removeSession(e), t);
        })
        .then(() => (d.removeAllListeners(), e));
    }
    onKeyStatusChange(e) {
      e.mediaKeysSession.keyStatuses.forEach((t, i) => {
        this.log(
          `key status change "${t}" for keyStatuses keyId: ${Hm.hexDump(
            "buffer" in i
              ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength)
              : new Uint8Array(i)
          )} session keyId: ${Hm.hexDump(
            new Uint8Array(e.decryptdata.keyId || [])
          )} uri: ${e.decryptdata.uri}`
        ),
          (e.keyStatus = t);
      });
    }
    fetchServerCertificate(e) {
      const t = this.config,
        i = new (0, t.loader)(t),
        s = this.getServerCertificateUrl(e);
      return s
        ? (this.log(`Fetching server certificate for "${e}"`),
          new Promise((r, n) => {
            const a = { responseType: "arraybuffer", url: s },
              o = t.certLoadPolicy.default,
              c = {
                loadPolicy: o,
                timeout: o.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
              },
              d = {
                onSuccess: (e, t, i, s) => {
                  r(e.data);
                },
                onError: (t, i, r, o) => {
                  n(
                    new wR(
                      {
                        type: Rm.KEY_SYSTEM_ERROR,
                        details:
                          ym.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: r,
                        response: Nm({ url: a.url, data: void 0 }, t)
                      },
                      `"${e}" certificate request failed (${s}). Status: ${t.code} (${t.text})`
                    )
                  );
                },
                onTimeout: (t, i, r) => {
                  n(
                    new wR(
                      {
                        type: Rm.KEY_SYSTEM_ERROR,
                        details:
                          ym.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: r,
                        response: { url: a.url, data: void 0 }
                      },
                      `"${e}" certificate request timed out (${s})`
                    )
                  );
                },
                onAbort: (e, t, i) => {
                  n(new Error("aborted"));
                }
              };
            i.load(a, c, d);
          }))
        : Promise.resolve();
    }
    setMediaKeysServerCertificate(e, t, i) {
      return new Promise((s, r) => {
        e.setServerCertificate(i)
          .then(r => {
            this.log(
              `setServerCertificate ${
                r ? "success" : "not supported by CDM"
              } (${null == i ? void 0 : i.byteLength}) on "${t}"`
            ),
              s(e);
          })
          .catch(e => {
            r(
              new wR(
                {
                  type: Rm.KEY_SYSTEM_ERROR,
                  details: ym.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                  error: e,
                  fatal: !0
                },
                e.message
              )
            );
          });
      });
    }
    renewLicense(e, t) {
      return this.requestLicense(e, new Uint8Array(t)).then(t =>
        this.updateKeySession(e, new Uint8Array(t)).catch(e => {
          throw new wR(
            {
              type: Rm.KEY_SYSTEM_ERROR,
              details: ym.KEY_SYSTEM_SESSION_UPDATE_FAILED,
              error: e,
              fatal: !0
            },
            e.message
          );
        })
      );
    }
    unpackPlayReadyKeyMessage(e, t) {
      const i = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
      if (!i.includes("PlayReadyKeyMessage"))
        return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t;
      const s = new DOMParser().parseFromString(i, "application/xml"),
        r = s.querySelectorAll("HttpHeader");
      if (r.length > 0) {
        let t;
        for (let i = 0, s = r.length; i < s; i++) {
          var n, a;
          t = r[i];
          const s =
              null == (n = t.querySelector("name")) ? void 0 : n.textContent,
            o = null == (a = t.querySelector("value")) ? void 0 : a.textContent;
          s && o && e.setRequestHeader(s, o);
        }
      }
      const o = s.querySelector("Challenge"),
        c = null == o ? void 0 : o.textContent;
      if (!c) throw new Error("Cannot find <Challenge> in key message");
      return nT(atob(c));
    }
    setupLicenseXHR(e, t, i, s) {
      const r = this.config.licenseXhrSetup;
      return r
        ? Promise.resolve()
            .then(() => {
              if (!i.decryptdata) throw new Error("Key removed");
              return r.call(this.hls, e, t, i, s);
            })
            .catch(n => {
              if (!i.decryptdata) throw n;
              return e.open("POST", t, !0), r.call(this.hls, e, t, i, s);
            })
            .then(i => {
              e.readyState || e.open("POST", t, !0);
              return { xhr: e, licenseChallenge: i || s };
            })
        : (e.open("POST", t, !0),
          Promise.resolve({ xhr: e, licenseChallenge: s }));
    }
    requestLicense(e, t) {
      const i = this.config.keyLoadPolicy.default;
      return new Promise((s, r) => {
        const n = this.getLicenseServerUrlOrThrow(e.keySystem);
        this.log(`Sending license request to URL: ${n}`);
        const a = new XMLHttpRequest();
        (a.responseType = "arraybuffer"),
          (a.onreadystatechange = () => {
            if (!this.hls || !e.mediaKeysSession)
              return r(new Error("invalid state"));
            if (4 === a.readyState)
              if (200 === a.status) {
                this._requestLicenseFailureCount = 0;
                let t = a.response;
                this.log(
                  `License received ${
                    t instanceof ArrayBuffer ? t.byteLength : t
                  }`
                );
                const i = this.config.licenseResponseCallback;
                if (i)
                  try {
                    t = i.call(this.hls, a, n, e);
                  } catch (e) {
                    this.error(e);
                  }
                s(t);
              } else {
                const o = i.errorRetry,
                  c = o ? o.maxNumRetry : 0;
                if (
                  (this._requestLicenseFailureCount++,
                  this._requestLicenseFailureCount > c ||
                    (a.status >= 400 && a.status < 500))
                )
                  r(
                    new wR(
                      {
                        type: Rm.KEY_SYSTEM_ERROR,
                        details: ym.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: a,
                        response: {
                          url: n,
                          data: void 0,
                          code: a.status,
                          text: a.statusText
                        }
                      },
                      `License Request XHR failed (${n}). Status: ${a.status} (${a.statusText})`
                    )
                  );
                else {
                  const i = c - this._requestLicenseFailureCount + 1;
                  this.warn(`Retrying license request, ${i} attempts left`),
                    this.requestLicense(e, t).then(s, r);
                }
              }
          }),
          e.licenseXhr &&
            e.licenseXhr.readyState !== XMLHttpRequest.DONE &&
            e.licenseXhr.abort(),
          (e.licenseXhr = a),
          this.setupLicenseXHR(a, n, e, t).then(
            ({ xhr: t, licenseChallenge: i }) => {
              e.keySystem == cT.PLAYREADY &&
                (i = this.unpackPlayReadyKeyMessage(t, i)),
                t.send(i);
            }
          );
      });
    }
    onMediaAttached(e, t) {
      if (!this.config.emeEnabled) return;
      const i = t.media;
      (this.media = i),
        i.removeEventListener("encrypted", this.onMediaEncrypted),
        i.removeEventListener("waitingforkey", this.onWaitingForKey),
        i.addEventListener("encrypted", this.onMediaEncrypted),
        i.addEventListener("waitingforkey", this.onWaitingForKey);
    }
    onMediaDetached() {
      const e = this.media;
      e &&
        (e.removeEventListener("encrypted", this.onMediaEncrypted),
        e.removeEventListener("waitingforkey", this.onWaitingForKey),
        (this.media = null));
    }
    _clear(e) {
      var t;
      const i = this.mediaKeySessions;
      (this._requestLicenseFailureCount = 0),
        (this.setMediaKeysQueue = []),
        (this.mediaKeySessions = []),
        (this.keyIdToKeySessionPromise = {}),
        TT.clearKeyUriToKeyIdMap();
      const s = i.length;
      DR.CDMCleanupPromise = Promise.all(
        i
          .map(e => this.removeSession(e))
          .concat(
            null == e || null == (t = e.setMediaKeys(null))
              ? void 0
              : t.catch(e => {
                  var t;
                  this.log(`Could not clear media keys: ${e}`),
                    null == (t = this.hls) ||
                      t.trigger(Am.ERROR, {
                        type: Rm.OTHER_ERROR,
                        details: ym.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
                        fatal: !1,
                        error: new Error(`Could not clear media keys: ${e}`)
                      });
                })
          )
      )
        .then(() => {
          s &&
            (this.log("finished closing key sessions and clearing media keys"),
            (i.length = 0));
        })
        .catch(e => {
          var t;
          this.log(`Could not close sessions and clear media keys: ${e}`),
            null == (t = this.hls) ||
              t.trigger(Am.ERROR, {
                type: Rm.OTHER_ERROR,
                details: ym.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                fatal: !1,
                error: new Error(
                  `Could not close sessions and clear media keys: ${e}`
                )
              });
        });
    }
    onManifestLoading() {
      this.keyFormatPromise = null;
    }
    onManifestLoaded(e, { sessionKeys: t }) {
      if (t && this.config.emeEnabled && !this.keyFormatPromise) {
        const e = t.reduce(
          (e, t) => (-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e),
          []
        );
        this.log(`Selecting key-system from session-keys ${e.join(", ")}`),
          (this.keyFormatPromise = this.getKeyFormatPromise(e));
      }
    }
    removeSession(e) {
      const { mediaKeysSession: t, licenseXhr: i } = e;
      if (t) {
        this.log(`Remove licenses and keys and close session ${t.sessionId}`),
          e._onmessage &&
            (t.removeEventListener("message", e._onmessage),
            (e._onmessage = void 0)),
          e._onkeystatuseschange &&
            (t.removeEventListener("keystatuseschange", e._onkeystatuseschange),
            (e._onkeystatuseschange = void 0)),
          i && i.readyState !== XMLHttpRequest.DONE && i.abort(),
          (e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0);
        const s = this.mediaKeySessions.indexOf(e);
        return (
          s > -1 && this.mediaKeySessions.splice(s, 1),
          t
            .remove()
            .catch(e => {
              var t;
              this.log(`Could not remove session: ${e}`),
                null == (t = this.hls) ||
                  t.trigger(Am.ERROR, {
                    type: Rm.OTHER_ERROR,
                    details: ym.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
                    fatal: !1,
                    error: new Error(`Could not remove session: ${e}`)
                  });
            })
            .then(() => t.close())
            .catch(e => {
              var t;
              this.log(`Could not close session: ${e}`),
                null == (t = this.hls) ||
                  t.trigger(Am.ERROR, {
                    type: Rm.OTHER_ERROR,
                    details: ym.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                    fatal: !1,
                    error: new Error(`Could not close session: ${e}`)
                  });
            })
        );
      }
    }
  }
  DR.CDMCleanupPromise = void 0;
  class wR extends Error {
    constructor(e, t) {
      super(t),
        (this.data = void 0),
        e.error || (e.error = new Error(t)),
        (this.data = e),
        (e.err = e.error);
    }
  }
  function LR(e, t) {
    let i;
    try {
      i = new Event("addtrack");
    } catch (e) {
      (i = document.createEvent("Event")), i.initEvent("addtrack", !1, !1);
    }
    (i.track = e), t.dispatchEvent(i);
  }
  function NR(e, t) {
    const i = e.mode;
    if (
      ("disabled" === i && (e.mode = "hidden"),
      e.cues && !e.cues.getCueById(t.id))
    )
      try {
        if ((e.addCue(t), !e.cues.getCueById(t.id)))
          throw new Error(`addCue is failed for: ${t}`);
      } catch (i) {
        Bm.debug(`[texttrack-utils]: ${i}`);
        try {
          const i = new self.TextTrackCue(t.startTime, t.endTime, t.text);
          (i.id = t.id), e.addCue(i);
        } catch (e) {
          Bm.debug(
            `[texttrack-utils]: Legacy TextTrackCue fallback failed: ${e}`
          );
        }
      }
    "disabled" === i && (e.mode = i);
  }
  function PR(e, t) {
    const i = e.mode;
    if (("disabled" === i && (e.mode = "hidden"), e.cues))
      for (let i = e.cues.length; i--; )
        t && e.cues[i].removeEventListener("enter", t), e.removeCue(e.cues[i]);
    "disabled" === i && (e.mode = i);
  }
  function kR(e, t, i, s) {
    const r = e.mode;
    if (
      ("disabled" === r && (e.mode = "hidden"), e.cues && e.cues.length > 0)
    ) {
      const r = (function(e, t, i) {
        const s = [],
          r = (function(e, t) {
            if (t <= e[0].startTime) return 0;
            const i = e.length - 1;
            if (t > e[i].endTime) return -1;
            let s,
              r = 0,
              n = i;
            for (; r <= n; )
              if (((s = Math.floor((n + r) / 2)), t < e[s].startTime))
                n = s - 1;
              else {
                if (!(t > e[s].startTime && r < i)) return s;
                r = s + 1;
              }
            return e[r].startTime - t < t - e[n].startTime ? r : n;
          })(e, t);
        if (r > -1)
          for (let n = r, a = e.length; n < a; n++) {
            const r = e[n];
            if (r.startTime >= t && r.endTime <= i) s.push(r);
            else if (r.startTime > i) return s;
          }
        return s;
      })(e.cues, t, i);
      for (let t = 0; t < r.length; t++) (s && !s(r[t])) || e.removeCue(r[t]);
    }
    "disabled" === r && (e.mode = r);
  }
  function MR(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      ("subtitles" !== s.kind && "captions" !== s.kind) ||
        !s.label ||
        t.push(e[i]);
    }
    return t;
  }
  function UR(e) {
    let t = 5381,
      i = e.length;
    for (; i; ) t = (33 * t) ^ e.charCodeAt(--i);
    return (t >>> 0).toString();
  }
  const xR = 0.025;
  let FR = (function(e) {
    return (e[(e.Point = 0)] = "Point"), (e[(e.Range = 1)] = "Range"), e;
  })({});
  function BR(e, t, i) {
    return `${e.identifier}-${i + 1}-${UR(t)}`;
  }
  class VR {
    constructor(e, t) {
      (this.base = void 0),
        (this._duration = null),
        (this._timelineStart = null),
        (this.appendInPlaceDisabled = void 0),
        (this.appendInPlaceStarted = void 0),
        (this.dateRange = void 0),
        (this.hasPlayed = !1),
        (this.cumulativeDuration = 0),
        (this.resumeOffset = NaN),
        (this.playoutLimit = NaN),
        (this.restrictions = { skip: !1, jump: !1 }),
        (this.snapOptions = { out: !1, in: !1 }),
        (this.assetList = []),
        (this.assetListLoader = void 0),
        (this.assetListResponse = null),
        (this.resumeAnchor = void 0),
        (this.error = void 0),
        (this.resetOnResume = void 0),
        (this.base = t),
        (this.dateRange = e),
        this.setDateRange(e);
    }
    setDateRange(e) {
      (this.dateRange = e),
        (this.resumeOffset = e.attr.optionalFloat(
          "X-RESUME-OFFSET",
          this.resumeOffset
        )),
        (this.playoutLimit = e.attr.optionalFloat(
          "X-PLAYOUT-LIMIT",
          this.playoutLimit
        )),
        (this.restrictions = e.attr.enumeratedStringList(
          "X-RESTRICT",
          this.restrictions
        )),
        (this.snapOptions = e.attr.enumeratedStringList(
          "X-SNAP",
          this.snapOptions
        ));
    }
    reset() {
      var e;
      (this.appendInPlaceStarted = !1),
        null == (e = this.assetListLoader) || e.destroy(),
        (this.assetListLoader = void 0),
        this.supplementsPrimary ||
          ((this.assetListResponse = null),
          (this.assetList = []),
          (this._duration = null));
    }
    isAssetPastPlayoutLimit(e) {
      if (e >= this.assetList.length) return !0;
      const t = this.playoutLimit;
      if (e <= 0 || isNaN(t)) return !1;
      return this.assetList[e].startOffset > t;
    }
    findAssetIndex(e) {
      return this.assetList.indexOf(e);
    }
    get identifier() {
      return this.dateRange.id;
    }
    get startDate() {
      return this.dateRange.startDate;
    }
    get startTime() {
      const e = this.dateRange.startTime;
      if (this.snapOptions.out) {
        const t = this.dateRange.tagAnchor;
        if (t) return GR(e, t);
      }
      return e;
    }
    get startOffset() {
      return this.cue.pre ? 0 : this.startTime;
    }
    get startIsAligned() {
      if (0 === this.startTime || this.snapOptions.out) return !0;
      const e = this.dateRange.tagAnchor;
      if (e) {
        const t = this.dateRange.startTime;
        return t - GR(t, e) < 0.1;
      }
      return !1;
    }
    get resumptionOffset() {
      const e = this.resumeOffset,
        t = Tm(e) ? e : this.duration;
      return this.cumulativeDuration + t;
    }
    get resumeTime() {
      const e = this.startOffset + this.resumptionOffset;
      if (this.snapOptions.in) {
        const t = this.resumeAnchor;
        if (t) return GR(e, t);
      }
      return e;
    }
    get appendInPlace() {
      return (
        !!this.appendInPlaceStarted ||
        (!this.appendInPlaceDisabled &&
          !(
            this.cue.once ||
            this.cue.pre ||
            !this.startIsAligned ||
            !(
              (isNaN(this.playoutLimit) && isNaN(this.resumeOffset)) ||
              (this.resumeOffset &&
                this.duration &&
                Math.abs(this.resumeOffset - this.duration) < xR)
            )
          ))
      );
    }
    set appendInPlace(e) {
      this.appendInPlaceStarted
        ? (this.resetOnResume = !e)
        : (this.appendInPlaceDisabled = !e);
    }
    get timelineStart() {
      return null !== this._timelineStart
        ? this._timelineStart
        : this.startTime;
    }
    set timelineStart(e) {
      this._timelineStart = e;
    }
    get duration() {
      const e = this.playoutLimit;
      let t;
      return (
        (t =
          null !== this._duration
            ? this._duration
            : this.dateRange.duration
            ? this.dateRange.duration
            : this.dateRange.plannedDuration || 0),
        !isNaN(e) && e < t && (t = e),
        t
      );
    }
    set duration(e) {
      this._duration = e;
    }
    get cue() {
      return this.dateRange.cue;
    }
    get timelineOccupancy() {
      return "RANGE" === this.dateRange.attr["X-TIMELINE-OCCUPIES"]
        ? FR.Range
        : FR.Point;
    }
    get supplementsPrimary() {
      return "PRIMARY" === this.dateRange.attr["X-TIMELINE-STYLE"];
    }
    get contentMayVary() {
      return "NO" !== this.dateRange.attr["X-CONTENT-MAY-VARY"];
    }
    get assetUrl() {
      return this.dateRange.attr["X-ASSET-URI"];
    }
    get assetListUrl() {
      return this.dateRange.attr["X-ASSET-LIST"];
    }
    get baseUrl() {
      return this.base.url;
    }
    get assetListLoaded() {
      return this.assetList.length > 0 || null !== this.assetListResponse;
    }
    toString() {
      return `["${
        (e = this).identifier
      }" ${e.cue.pre ? "<pre>" : e.cue.post ? "<post>" : ""}${e.timelineStart.toFixed(2)}-${e.resumeTime.toFixed(2)}]`;
      var e;
    }
  }
  function GR(e, t) {
    return e - t.start < t.duration / 2 &&
      !(Math.abs(e - (t.start + t.duration)) < xR)
      ? t.start
      : t.start + t.duration;
  }
  function jR(e, t, i) {
    const s = new self.URL(e, i);
    return (
      "data:" !== s.protocol && s.searchParams.set("_HLS_primary_id", t), s
    );
  }
  function HR(e) {
    const t = e.timelineStart,
      i = e.duration || 0;
    return `["${e.identifier}" ${t.toFixed(2)}-${(t + i).toFixed(2)}]`;
  }
  class KR {
    constructor(e, t, i, s) {
      (this.hls = void 0),
        (this.interstitial = void 0),
        (this.assetItem = void 0),
        (this.tracks = null),
        (this.hasDetails = !1),
        (this.mediaAttached = null),
        (this._currentTime = void 0),
        (this._bufferedEosTime = void 0),
        (this.checkPlayout = () => {
          const e = this.interstitial.playoutLimit,
            t = this.currentTime;
          this.startOffset + t >= e &&
            this.hls.trigger(Am.PLAYOUT_LIMIT_REACHED, {});
        });
      const r = (this.hls = new e(t));
      (this.interstitial = i), (this.assetItem = s);
      let n = s.uri;
      try {
        n = jR(n, r.sessionId).href;
      } catch (e) {}
      r.loadSource(n);
      const a = () => {
        this.hasDetails = !0;
      };
      r.once(Am.LEVEL_LOADED, a),
        r.once(Am.AUDIO_TRACK_LOADED, a),
        r.once(Am.SUBTITLE_TRACK_LOADED, a),
        r.on(Am.MEDIA_ATTACHING, (e, { media: t }) => {
          this.removeMediaListeners(), (this.mediaAttached = t);
          this.interstitial.playoutLimit &&
            t.addEventListener("timeupdate", this.checkPlayout);
        });
    }
    bufferedInPlaceToEnd(e) {
      var t;
      if (!this.interstitial.appendInPlace) return !1;
      if (null != (t = this.hls) && t.bufferedToEnd) return !0;
      if (!e || !this._bufferedEosTime) return !1;
      const i = this.timelineOffset,
        s = K_.bufferInfo(e, i, 0);
      return this.getAssetTime(s.end) >= this._bufferedEosTime - 0.02;
    }
    get destroyed() {
      var e;
      return !(null != (e = this.hls) && e.userConfig);
    }
    get assetId() {
      return this.assetItem.identifier;
    }
    get interstitialId() {
      return this.assetItem.parentIdentifier;
    }
    get media() {
      var e;
      return (null == (e = this.hls) ? void 0 : e.media) || null;
    }
    get bufferedEnd() {
      const e = this.media || this.mediaAttached;
      if (!e)
        return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
      const t = K_.bufferInfo(e, e.currentTime, 0.001);
      return this.getAssetTime(t.end);
    }
    get currentTime() {
      const e = this.media || this.mediaAttached;
      return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;
    }
    get duration() {
      const e = this.assetItem.duration;
      return e || 0;
    }
    get remaining() {
      const e = this.duration;
      return e ? Math.max(0, e - this.currentTime) : 0;
    }
    get startOffset() {
      return this.assetItem.startOffset;
    }
    get timelineOffset() {
      var e;
      return (null == (e = this.hls) ? void 0 : e.config.timelineOffset) || 0;
    }
    set timelineOffset(e) {
      const t = this.timelineOffset;
      if (e !== t) {
        const i = e - t;
        if (Math.abs(i) > 1 / 9e4) {
          if (this.hasDetails)
            throw new Error(
              "Cannot set timelineOffset after playlists are loaded"
            );
          this.hls.config.timelineOffset = e;
        }
      }
    }
    getAssetTime(e) {
      const t = this.timelineOffset,
        i = this.duration;
      return Math.min(Math.max(0, e - t), i);
    }
    removeMediaListeners() {
      const e = this.mediaAttached;
      e &&
        ((this._currentTime = e.currentTime),
        this.bufferSnapShot(),
        e.removeEventListener("timeupdate", this.checkPlayout));
    }
    bufferSnapShot() {
      var e;
      this.mediaAttached &&
        null != (e = this.hls) &&
          e.bufferedToEnd &&
          (this._bufferedEosTime = this.bufferedEnd);
    }
    destroy() {
      this.removeMediaListeners(),
        this.hls.destroy(),
        (this.hls = this.interstitial = null),
        (this.tracks = this.mediaAttached = this.checkPlayout = null);
    }
    attachMedia(e) {
      this.hls.attachMedia(e);
    }
    detachMedia() {
      this.removeMediaListeners(),
        (this.mediaAttached = null),
        this.hls.detachMedia();
    }
    resumeBuffering() {
      this.hls.resumeBuffering();
    }
    pauseBuffering() {
      this.hls.pauseBuffering();
    }
    transferMedia() {
      return this.bufferSnapShot(), this.hls.transferMedia();
    }
    on(e, t, i) {
      this.hls.on(e, t);
    }
    once(e, t, i) {
      this.hls.once(e, t);
    }
    off(e, t, i) {
      this.hls.off(e, t);
    }
    toString() {
      var e, t;
      return `HlsAssetPlayer: ${HR(
        this.assetItem
      )} ${null == (e = this.hls) ? void 0 : e.sessionId} ${null != (t = this.interstitial) && t.appendInPlace ? "append-in-place" : ""}`;
    }
  }
  class WR extends Pm {
    constructor(e, t) {
      super("interstitials-sched", t),
        (this.onScheduleUpdate = void 0),
        (this.eventMap = {}),
        (this.events = null),
        (this.items = null),
        (this.durations = { primary: 0, playout: 0, integrated: 0 }),
        (this.onScheduleUpdate = e);
    }
    destroy() {
      this.reset(), (this.onScheduleUpdate = null);
    }
    reset() {
      (this.eventMap = {}),
        this.setDurations(0, 0, 0),
        this.events && this.events.forEach(e => e.reset()),
        (this.events = this.items = null);
    }
    resetErrorsInRange(e, t) {
      return this.events
        ? this.events.reduce(
            (i, s) =>
              e <= s.startOffset && t > s.startOffset
                ? (delete s.error, i + 1)
                : i,
            0
          )
        : 0;
    }
    get duration() {
      const e = this.items;
      return e ? e[e.length - 1].end : 0;
    }
    get length() {
      return this.items ? this.items.length : 0;
    }
    getEvent(e) {
      return (e && this.eventMap[e]) || null;
    }
    hasEvent(e) {
      return e in this.eventMap;
    }
    findItemIndex(e, t) {
      if (e.event) return this.findEventIndex(e.event.identifier);
      let i = -1;
      e.nextEvent
        ? (i = this.findEventIndex(e.nextEvent.identifier) - 1)
        : e.previousEvent &&
          (i = this.findEventIndex(e.previousEvent.identifier) + 1);
      const s = this.items;
      if (s)
        for (
          s[i] ||
          (void 0 === t && (t = e.start), (i = this.findItemIndexAtTime(t)));
          i >= 0 && null != (r = s[i]) && r.event;

        ) {
          var r;
          i--;
        }
      return i;
    }
    findItemIndexAtTime(e, t) {
      const i = this.items;
      if (i)
        for (let s = 0; s < i.length; s++) {
          let r = i[s];
          if (
            (t && "primary" !== t && (r = r[t]),
            e === r.start || (e > r.start && e < r.end))
          )
            return s;
        }
      return -1;
    }
    findJumpRestrictedIndex(e, t) {
      const i = this.items;
      if (i)
        for (let s = e; s <= t && i[s]; s++) {
          const e = i[s].event;
          if (null != e && e.restrictions.jump && !e.appendInPlace) return s;
        }
      return -1;
    }
    findEventIndex(e) {
      const t = this.items;
      if (t)
        for (let s = t.length; s--; ) {
          var i;
          if ((null == (i = t[s].event) ? void 0 : i.identifier) === e)
            return s;
        }
      return -1;
    }
    findAssetIndex(e, t) {
      const i = e.assetList,
        s = i.length;
      if (s > 1)
        for (let e = 0; e < s; e++) {
          const s = i[e];
          if (!s.error) {
            const i = s.timelineStart;
            if (t === i || (t > i && t < i + (s.duration || 0))) return e;
          }
        }
      return 0;
    }
    get assetIdAtEnd() {
      var e, t;
      const i =
        null == (e = this.items) || null == (t = e[this.length - 1])
          ? void 0
          : t.event;
      if (i) {
        const e = i.assetList,
          t = e[e.length - 1];
        if (t) return t.identifier;
      }
      return null;
    }
    parseInterstitialDateRanges(e, t) {
      const i = e.main.details,
        { dateRanges: s } = i,
        r = this.events,
        n = this.parseDateRanges(s, { url: i.url }, t),
        a = Object.keys(s),
        o = r ? r.filter(e => !a.includes(e.identifier)) : [];
      n.length &&
        n.sort((e, t) => {
          const i = e.cue.pre,
            s = e.cue.post,
            r = t.cue.pre,
            n = t.cue.post;
          if (i && !r) return -1;
          if (r && !i) return 1;
          if (s && !n) return 1;
          if (n && !s) return -1;
          if (!(i || r || s || n)) {
            const i = e.startTime,
              s = t.startTime;
            if (i !== s) return i - s;
          }
          return e.dateRange.tagOrder - t.dateRange.tagOrder;
        }),
        (this.events = n),
        o.forEach(e => {
          this.removeEvent(e);
        }),
        this.updateSchedule(e, o);
    }
    updateSchedule(e, t = []) {
      const i = this.events || [];
      if (i.length || t.length || this.length < 2) {
        const s = this.items,
          r = this.parseSchedule(i, e),
          n =
            t.length ||
            (null == s ? void 0 : s.length) !== r.length ||
            r.some(
              (e, t) =>
                Math.abs(e.playout.start - s[t].playout.start) > 0.005 ||
                Math.abs(e.playout.end - s[t].playout.end) > 0.005
            );
        n && ((this.items = r), this.onScheduleUpdate(t, s));
      }
    }
    parseDateRanges(e, t, i) {
      const s = [],
        r = Object.keys(e);
      for (let n = 0; n < r.length; n++) {
        const a = r[n],
          o = e[a];
        if (o.isInterstitial) {
          let e = this.eventMap[a];
          e
            ? e.setDateRange(o)
            : ((e = new VR(o, t)),
              (this.eventMap[a] = e),
              !1 === i && (e.appendInPlace = i)),
            s.push(e);
        }
      }
      return s;
    }
    parseSchedule(e, t) {
      const i = [],
        s = t.main.details,
        r = s.live ? 1 / 0 : s.edge;
      let n = 0;
      if (
        (e = e.filter(e => !(e.error || (e.cue.once && e.hasPlayed)))).length
      ) {
        this.resolveOffsets(e, t);
        let s = 0,
          o = 0;
        if (
          (e.forEach((t, a) => {
            const c = t.cue.pre,
              d = t.cue.post,
              l = e[a - 1] || null,
              h = t.appendInPlace,
              u = d ? r : t.startOffset,
              p = t.duration,
              f = t.timelineOccupancy === FR.Range ? p : 0,
              E = t.resumptionOffset,
              m = (null == l ? void 0 : l.startTime) === u,
              g = u + t.cumulativeDuration;
            let _ = h ? g + p : u + E;
            if (c || (!d && u <= 0)) {
              const e = o;
              (o += f), (t.timelineStart = g);
              const s = n;
              (n += p),
                i.push({
                  event: t,
                  start: g,
                  end: _,
                  playout: { start: s, end: n },
                  integrated: { start: e, end: o }
                });
            } else {
              if (!(u <= r)) return;
              {
                if (!m) {
                  const r = u - s;
                  if (r > 0.033) {
                    const c = s,
                      d = o;
                    o += r;
                    const l = n;
                    n += r;
                    const h = {
                      previousEvent: e[a - 1] || null,
                      nextEvent: t,
                      start: c,
                      end: c + r,
                      playout: { start: l, end: n },
                      integrated: { start: d, end: o }
                    };
                    i.push(h);
                  } else
                    r > 0 &&
                      l &&
                      ((l.cumulativeDuration += r), (i[i.length - 1].end = u));
                }
                d && (_ = g), (t.timelineStart = g);
                const r = o;
                o += f;
                const c = n;
                (n += p),
                  i.push({
                    event: t,
                    start: g,
                    end: _,
                    playout: { start: c, end: n },
                    integrated: { start: r, end: o }
                  });
              }
            }
            const T = t.resumeTime;
            s = d || T > r ? r : T;
          }),
          s < r)
        ) {
          var a;
          const e = s,
            t = o,
            c = r - s;
          o += c;
          const d = n;
          (n += c),
            i.push({
              previousEvent:
                (null == (a = i[i.length - 1]) ? void 0 : a.event) || null,
              nextEvent: null,
              start: s,
              end: e + c,
              playout: { start: d, end: n },
              integrated: { start: t, end: o }
            });
        }
        this.setDurations(r, n, o);
      } else {
        const e = 0;
        i.push({
          previousEvent: null,
          nextEvent: null,
          start: e,
          end: r,
          playout: { start: e, end: r },
          integrated: { start: e, end: r }
        }),
          this.setDurations(r, r, r);
      }
      return i;
    }
    setDurations(e, t, i) {
      this.durations = { primary: e, playout: t, integrated: i };
    }
    resolveOffsets(e, t) {
      const i = t.main.details,
        s = i.live ? 1 / 0 : i.edge;
      let r = 0,
        n = -1;
      e.forEach((a, o) => {
        const c = a.cue.pre,
          d = a.cue.post,
          l = c ? 0 : d ? s : a.startTime;
        this.updateAssetDurations(a);
        if (
          (n === l ? (a.cumulativeDuration = r) : ((r = 0), (n = l)),
          !d &&
            a.snapOptions.in &&
            (a.resumeAnchor =
              u_(null, i.fragments, a.startOffset + a.resumptionOffset, 0, 0) ||
              void 0),
          a.appendInPlace && !a.appendInPlaceStarted)
        ) {
          this.primaryCanResumeInPlaceAt(a, t) || (a.appendInPlace = !1);
        }
        if (!a.appendInPlace && o + 1 < e.length) {
          e[o + 1].startTime - e[o].resumeTime < 0.033 &&
            ((e[o + 1].appendInPlace = !1),
            e[o + 1].appendInPlace &&
              this.warn(
                `Could not change append strategy for abutting event ${a}`
              ));
        }
        const h = Tm(a.resumeOffset) ? a.resumeOffset : a.duration;
        r += h;
      });
    }
    primaryCanResumeInPlaceAt(e, t) {
      const i = e.resumeTime,
        s = e.startTime + e.resumptionOffset;
      if (Math.abs(i - s) > xR)
        return (
          this.log(
            `"${e.identifier}" resumption ${i} not aligned with estimated timeline end ${s}`
          ),
          !1
        );
      if (!t)
        return (
          this.log(
            `"${e.identifier}" resumption ${i} can not be aligned with media (none selected)`
          ),
          !1
        );
      return !Object.keys(t).some(s => {
        const r = t[s].details,
          n = r.edge;
        if (i >= n)
          return (
            this.log(
              `"${e.identifier}" resumption ${i} past ${s} playlist end ${n}`
            ),
            !1
          );
        const a = u_(null, r.fragments, i);
        if (!a)
          return (
            this.log(
              `"${e.identifier}" resumption ${i} does not align with any fragments in ${s} playlist (${r.fragStart}-${r.fragmentEnd})`
            ),
            !0
          );
        const o = "audio" === s ? 0.175 : 0;
        return (
          !(Math.abs(a.start - i) < xR + o || Math.abs(a.end - i) < xR + o) &&
          (this.log(
            `"${e.identifier}" resumption ${i} not aligned with ${s} fragment bounds (${a.start}-${a.end} sn: ${a.sn} cc: ${a.cc})`
          ),
          !0)
        );
      });
    }
    updateAssetDurations(e) {
      if (!e.assetListLoaded) return;
      const t = e.timelineStart;
      let i = 0,
        s = !1,
        r = !1;
      e.assetList.forEach((e, n) => {
        const a = t + i;
        (e.startOffset = i),
          (e.timelineStart = a),
          s || (s = null === e.duration),
          r || (r = !!e.error);
        const o = e.error ? 0 : e.duration || 0;
        i += o;
      }),
        (e.duration = s && !r ? Math.max(i, e.duration) : i);
    }
    removeEvent(e) {
      e.reset(), delete this.eventMap[e.identifier];
    }
  }
  function YR(e) {
    return `[${
      e.event ? '"' + e.event.identifier + '"' : "primary"
    }: ${e.start.toFixed(2)}-${e.end.toFixed(2)}]`;
  }
  class $R {
    constructor(e) {
      (this.hls = void 0), (this.hls = e);
    }
    destroy() {
      this.hls = null;
    }
    loadAssetList(e, t) {
      const i = e.assetListUrl;
      let s;
      try {
        s = jR(i, this.hls.sessionId, e.baseUrl);
      } catch (t) {
        const s = this.assignAssetListError(e, ym.ASSET_LIST_LOAD_ERROR, t, i);
        return void this.hls.trigger(Am.ERROR, s);
      }
      t &&
        "data:" !== s.protocol &&
        s.searchParams.set("_HLS_start_offset", "" + t);
      const r = this.hls.config,
        n = new (0, r.loader)(r),
        a = { responseType: "json", url: s.href },
        o = r.interstitialAssetListLoadPolicy.default,
        c = {
          loadPolicy: o,
          timeout: o.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        },
        d = {
          onSuccess: (t, i, s, r) => {
            const n = t.data,
              a = null == n ? void 0 : n.ASSETS;
            if (Array.isArray(a))
              (e.assetListResponse = n),
                this.hls.trigger(Am.ASSET_LIST_LOADED, {
                  event: e,
                  assetListResponse: n,
                  networkDetails: r
                });
            else {
              const t = this.assignAssetListError(
                e,
                ym.ASSET_LIST_PARSING_ERROR,
                new Error("Invalid interstitial asset list"),
                s.url,
                i,
                r
              );
              this.hls.trigger(Am.ERROR, t);
            }
          },
          onError: (t, i, s, r) => {
            const n = this.assignAssetListError(
              e,
              ym.ASSET_LIST_LOAD_ERROR,
              new Error(
                `Error loading X-ASSET-LIST: HTTP status ${t.code} ${t.text} (${i.url})`
              ),
              i.url,
              r,
              s
            );
            this.hls.trigger(Am.ERROR, n);
          },
          onTimeout: (t, i, s) => {
            const r = this.assignAssetListError(
              e,
              ym.ASSET_LIST_LOAD_TIMEOUT,
              new Error(`Timeout loading X-ASSET-LIST (${i.url})`),
              i.url,
              t,
              s
            );
            this.hls.trigger(Am.ERROR, r);
          }
        };
      return (
        n.load(a, c, d),
        this.hls.trigger(Am.ASSET_LIST_LOADING, { event: e }),
        n
      );
    }
    assignAssetListError(e, t, i, s, r, n) {
      return (
        (e.error = i),
        {
          type: Rm.NETWORK_ERROR,
          details: t,
          fatal: !1,
          interstitial: e,
          url: s,
          error: i,
          networkDetails: n,
          stats: r
        }
      );
    }
  }
  function qR(e, t, i) {
    XR(e, t, i), e.addEventListener(t, i);
  }
  function XR(e, t, i) {
    e.removeEventListener(t, i);
  }
  function zR(e) {
    null == e || e.play().catch(() => {});
  }
  class JR {
    constructor(e) {
      this.buffered = void 0;
      const t = (t, i, s) => {
        if ((i >>>= 0) > s - 1)
          throw new DOMException(
            `Failed to execute '${t}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${s})`
          );
        return e[i][t];
      };
      this.buffered = {
        get length() {
          return e.length;
        },
        end: i => t("end", i, e.length),
        start: i => t("start", i, e.length)
      };
    }
  }
  const QR = {
      42: 225,
      92: 233,
      94: 237,
      95: 243,
      96: 250,
      123: 231,
      124: 247,
      125: 209,
      126: 241,
      127: 9608,
      128: 174,
      129: 176,
      130: 189,
      131: 191,
      132: 8482,
      133: 162,
      134: 163,
      135: 9834,
      136: 224,
      137: 32,
      138: 232,
      139: 226,
      140: 234,
      141: 238,
      142: 244,
      143: 251,
      144: 193,
      145: 201,
      146: 211,
      147: 218,
      148: 220,
      149: 252,
      150: 8216,
      151: 161,
      152: 42,
      153: 8217,
      154: 9473,
      155: 169,
      156: 8480,
      157: 8226,
      158: 8220,
      159: 8221,
      160: 192,
      161: 194,
      162: 199,
      163: 200,
      164: 202,
      165: 203,
      166: 235,
      167: 206,
      168: 207,
      169: 239,
      170: 212,
      171: 217,
      172: 249,
      173: 219,
      174: 171,
      175: 187,
      176: 195,
      177: 227,
      178: 205,
      179: 204,
      180: 236,
      181: 210,
      182: 242,
      183: 213,
      184: 245,
      185: 123,
      186: 125,
      187: 92,
      188: 94,
      189: 95,
      190: 124,
      191: 8764,
      192: 196,
      193: 228,
      194: 214,
      195: 246,
      196: 223,
      197: 165,
      198: 164,
      199: 9475,
      200: 197,
      201: 229,
      202: 216,
      203: 248,
      204: 9487,
      205: 9491,
      206: 9495,
      207: 9499
    },
    ZR = e => String.fromCharCode(QR[e] || e),
    ey = 15,
    ty = 100,
    iy = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 },
    sy = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 },
    ry = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 },
    ny = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 },
    ay = [
      "white",
      "green",
      "blue",
      "cyan",
      "red",
      "yellow",
      "magenta",
      "black",
      "transparent"
    ];
  class oy {
    constructor() {
      (this.time = null), (this.verboseLevel = 0);
    }
    log(e, t) {
      if (this.verboseLevel >= e) {
        const i = "function" == typeof t ? t() : t;
        Bm.log(`${this.time} [${e}] ${i}`);
      }
    }
  }
  const cy = function(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) t.push(e[i].toString(16));
    return t;
  };
  class dy {
    constructor() {
      (this.foreground = "white"),
        (this.underline = !1),
        (this.italics = !1),
        (this.background = "black"),
        (this.flash = !1);
    }
    reset() {
      (this.foreground = "white"),
        (this.underline = !1),
        (this.italics = !1),
        (this.background = "black"),
        (this.flash = !1);
    }
    setStyles(e) {
      const t = ["foreground", "underline", "italics", "background", "flash"];
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        e.hasOwnProperty(s) && (this[s] = e[s]);
      }
    }
    isDefault() {
      return (
        "white" === this.foreground &&
        !this.underline &&
        !this.italics &&
        "black" === this.background &&
        !this.flash
      );
    }
    equals(e) {
      return (
        this.foreground === e.foreground &&
        this.underline === e.underline &&
        this.italics === e.italics &&
        this.background === e.background &&
        this.flash === e.flash
      );
    }
    copy(e) {
      (this.foreground = e.foreground),
        (this.underline = e.underline),
        (this.italics = e.italics),
        (this.background = e.background),
        (this.flash = e.flash);
    }
    toString() {
      return (
        "color=" +
        this.foreground +
        ", underline=" +
        this.underline +
        ", italics=" +
        this.italics +
        ", background=" +
        this.background +
        ", flash=" +
        this.flash
      );
    }
  }
  class ly {
    constructor() {
      (this.uchar = " "), (this.penState = new dy());
    }
    reset() {
      (this.uchar = " "), this.penState.reset();
    }
    setChar(e, t) {
      (this.uchar = e), this.penState.copy(t);
    }
    setPenState(e) {
      this.penState.copy(e);
    }
    equals(e) {
      return this.uchar === e.uchar && this.penState.equals(e.penState);
    }
    copy(e) {
      (this.uchar = e.uchar), this.penState.copy(e.penState);
    }
    isEmpty() {
      return " " === this.uchar && this.penState.isDefault();
    }
  }
  class hy {
    constructor(e) {
      (this.chars = []),
        (this.pos = 0),
        (this.currPenState = new dy()),
        (this.cueStartTime = null),
        (this.logger = void 0);
      for (let e = 0; e < ty; e++) this.chars.push(new ly());
      this.logger = e;
    }
    equals(e) {
      for (let t = 0; t < ty; t++)
        if (!this.chars[t].equals(e.chars[t])) return !1;
      return !0;
    }
    copy(e) {
      for (let t = 0; t < ty; t++) this.chars[t].copy(e.chars[t]);
    }
    isEmpty() {
      let e = !0;
      for (let t = 0; t < ty; t++)
        if (!this.chars[t].isEmpty()) {
          e = !1;
          break;
        }
      return e;
    }
    setCursor(e) {
      this.pos !== e && (this.pos = e),
        this.pos < 0
          ? (this.logger.log(3, "Negative cursor position " + this.pos),
            (this.pos = 0))
          : this.pos > ty &&
            (this.logger.log(3, "Too large cursor position " + this.pos),
            (this.pos = ty));
    }
    moveCursor(e) {
      const t = this.pos + e;
      if (e > 1)
        for (let e = this.pos + 1; e < t + 1; e++)
          this.chars[e].setPenState(this.currPenState);
      this.setCursor(t);
    }
    backSpace() {
      this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
    }
    insertChar(e) {
      e >= 144 && this.backSpace();
      const t = ZR(e);
      this.pos >= ty
        ? this.logger.log(
            0,
            () =>
              "Cannot insert " +
              e.toString(16) +
              " (" +
              t +
              ") at position " +
              this.pos +
              ". Skipping it!"
          )
        : (this.chars[this.pos].setChar(t, this.currPenState),
          this.moveCursor(1));
    }
    clearFromPos(e) {
      let t;
      for (t = e; t < ty; t++) this.chars[t].reset();
    }
    clear() {
      this.clearFromPos(0), (this.pos = 0), this.currPenState.reset();
    }
    clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
    getTextString() {
      const e = [];
      let t = !0;
      for (let i = 0; i < ty; i++) {
        const s = this.chars[i].uchar;
        " " !== s && (t = !1), e.push(s);
      }
      return t ? "" : e.join("");
    }
    setPenStyles(e) {
      this.currPenState.setStyles(e);
      this.chars[this.pos].setPenState(this.currPenState);
    }
  }
  class uy {
    constructor(e) {
      (this.rows = []),
        (this.currRow = 14),
        (this.nrRollUpRows = null),
        (this.lastOutputScreen = null),
        (this.logger = void 0);
      for (let t = 0; t < ey; t++) this.rows.push(new hy(e));
      this.logger = e;
    }
    reset() {
      for (let e = 0; e < ey; e++) this.rows[e].clear();
      this.currRow = 14;
    }
    equals(e) {
      let t = !0;
      for (let i = 0; i < ey; i++)
        if (!this.rows[i].equals(e.rows[i])) {
          t = !1;
          break;
        }
      return t;
    }
    copy(e) {
      for (let t = 0; t < ey; t++) this.rows[t].copy(e.rows[t]);
    }
    isEmpty() {
      let e = !0;
      for (let t = 0; t < ey; t++)
        if (!this.rows[t].isEmpty()) {
          e = !1;
          break;
        }
      return e;
    }
    backSpace() {
      this.rows[this.currRow].backSpace();
    }
    clearToEndOfRow() {
      this.rows[this.currRow].clearToEndOfRow();
    }
    insertChar(e) {
      this.rows[this.currRow].insertChar(e);
    }
    setPen(e) {
      this.rows[this.currRow].setPenStyles(e);
    }
    moveCursor(e) {
      this.rows[this.currRow].moveCursor(e);
    }
    setCursor(e) {
      this.logger.log(2, "setCursor: " + e);
      this.rows[this.currRow].setCursor(e);
    }
    setPAC(e) {
      this.logger.log(2, () => "pacData = " + i_(e));
      let t = e.row - 1;
      if (
        (this.nrRollUpRows &&
          t < this.nrRollUpRows - 1 &&
          (t = this.nrRollUpRows - 1),
        this.nrRollUpRows && this.currRow !== t)
      ) {
        for (let e = 0; e < ey; e++) this.rows[e].clear();
        const e = this.currRow + 1 - this.nrRollUpRows,
          i = this.lastOutputScreen;
        if (i) {
          const s = i.rows[e].cueStartTime,
            r = this.logger.time;
          if (null !== s && null !== r && s < r)
            for (let s = 0; s < this.nrRollUpRows; s++)
              this.rows[t - this.nrRollUpRows + s + 1].copy(i.rows[e + s]);
        }
      }
      this.currRow = t;
      const i = this.rows[this.currRow];
      if (null !== e.indent) {
        const t = e.indent,
          s = Math.max(t - 1, 0);
        i.setCursor(e.indent), (e.color = i.chars[s].penState.foreground);
      }
      const s = {
        foreground: e.color,
        underline: e.underline,
        italics: e.italics,
        background: "black",
        flash: !1
      };
      this.setPen(s);
    }
    setBkgData(e) {
      this.logger.log(2, () => "bkgData = " + i_(e)),
        this.backSpace(),
        this.setPen(e),
        this.insertChar(32);
    }
    setRollUpRows(e) {
      this.nrRollUpRows = e;
    }
    rollUp() {
      if (null === this.nrRollUpRows)
        return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      this.logger.log(1, () => this.getDisplayText());
      const e = this.currRow + 1 - this.nrRollUpRows,
        t = this.rows.splice(e, 1)[0];
      t.clear(),
        this.rows.splice(this.currRow, 0, t),
        this.logger.log(2, "Rolling up");
    }
    getDisplayText(e) {
      e = e || !1;
      const t = [];
      let i = "",
        s = -1;
      for (let i = 0; i < ey; i++) {
        const r = this.rows[i].getTextString();
        r &&
          ((s = i + 1),
          e ? t.push("Row " + s + ": '" + r + "'") : t.push(r.trim()));
      }
      return (
        t.length > 0 && (i = e ? "[" + t.join(" | ") + "]" : t.join("\n")), i
      );
    }
    getTextAndFormat() {
      return this.rows;
    }
  }
  class py {
    constructor(e, t, i) {
      (this.chNr = void 0),
        (this.outputFilter = void 0),
        (this.mode = void 0),
        (this.verbose = void 0),
        (this.displayedMemory = void 0),
        (this.nonDisplayedMemory = void 0),
        (this.lastOutputScreen = void 0),
        (this.currRollUpRow = void 0),
        (this.writeScreen = void 0),
        (this.cueStartTime = void 0),
        (this.logger = void 0),
        (this.chNr = e),
        (this.outputFilter = t),
        (this.mode = null),
        (this.verbose = 0),
        (this.displayedMemory = new uy(i)),
        (this.nonDisplayedMemory = new uy(i)),
        (this.lastOutputScreen = new uy(i)),
        (this.currRollUpRow = this.displayedMemory.rows[14]),
        (this.writeScreen = this.displayedMemory),
        (this.mode = null),
        (this.cueStartTime = null),
        (this.logger = i);
    }
    reset() {
      (this.mode = null),
        this.displayedMemory.reset(),
        this.nonDisplayedMemory.reset(),
        this.lastOutputScreen.reset(),
        this.outputFilter.reset(),
        (this.currRollUpRow = this.displayedMemory.rows[14]),
        (this.writeScreen = this.displayedMemory),
        (this.mode = null),
        (this.cueStartTime = null);
    }
    getHandler() {
      return this.outputFilter;
    }
    setHandler(e) {
      this.outputFilter = e;
    }
    setPAC(e) {
      this.writeScreen.setPAC(e);
    }
    setBkgData(e) {
      this.writeScreen.setBkgData(e);
    }
    setMode(e) {
      e !== this.mode &&
        ((this.mode = e),
        this.logger.log(2, () => "MODE=" + e),
        "MODE_POP-ON" === this.mode
          ? (this.writeScreen = this.nonDisplayedMemory)
          : ((this.writeScreen = this.displayedMemory),
            this.writeScreen.reset()),
        "MODE_ROLL-UP" !== this.mode &&
          ((this.displayedMemory.nrRollUpRows = null),
          (this.nonDisplayedMemory.nrRollUpRows = null)),
        (this.mode = e));
    }
    insertChars(e) {
      for (let t = 0; t < e.length; t++) this.writeScreen.insertChar(e[t]);
      const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
      this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)),
        ("MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode) ||
          (this.logger.log(
            1,
            () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)
          ),
          this.outputDataUpdate());
    }
    ccRCL() {
      this.logger.log(2, "RCL - Resume Caption Loading"),
        this.setMode("MODE_POP-ON");
    }
    ccBS() {
      this.logger.log(2, "BS - BackSpace"),
        "MODE_TEXT" !== this.mode &&
          (this.writeScreen.backSpace(),
          this.writeScreen === this.displayedMemory && this.outputDataUpdate());
    }
    ccAOF() {}
    ccAON() {}
    ccDER() {
      this.logger.log(2, "DER- Delete to End of Row"),
        this.writeScreen.clearToEndOfRow(),
        this.outputDataUpdate();
    }
    ccRU(e) {
      this.logger.log(2, "RU(" + e + ") - Roll Up"),
        (this.writeScreen = this.displayedMemory),
        this.setMode("MODE_ROLL-UP"),
        this.writeScreen.setRollUpRows(e);
    }
    ccFON() {
      this.logger.log(2, "FON - Flash On"),
        this.writeScreen.setPen({ flash: !0 });
    }
    ccRDC() {
      this.logger.log(2, "RDC - Resume Direct Captioning"),
        this.setMode("MODE_PAINT-ON");
    }
    ccTR() {
      this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
    }
    ccRTD() {
      this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
    }
    ccEDM() {
      this.logger.log(2, "EDM - Erase Displayed Memory"),
        this.displayedMemory.reset(),
        this.outputDataUpdate(!0);
    }
    ccCR() {
      this.logger.log(2, "CR - Carriage Return"),
        this.writeScreen.rollUp(),
        this.outputDataUpdate(!0);
    }
    ccENM() {
      this.logger.log(2, "ENM - Erase Non-displayed Memory"),
        this.nonDisplayedMemory.reset();
    }
    ccEOC() {
      if (
        (this.logger.log(2, "EOC - End Of Caption"),
        "MODE_POP-ON" === this.mode)
      ) {
        const e = this.displayedMemory;
        (this.displayedMemory = this.nonDisplayedMemory),
          (this.nonDisplayedMemory = e),
          (this.writeScreen = this.nonDisplayedMemory),
          this.logger.log(
            1,
            () => "DISP: " + this.displayedMemory.getDisplayText()
          );
      }
      this.outputDataUpdate(!0);
    }
    ccTO(e) {
      this.logger.log(2, "TO(" + e + ") - Tab Offset"),
        this.writeScreen.moveCursor(e);
    }
    ccMIDROW(e) {
      const t = { flash: !1 };
      if (((t.underline = e % 2 == 1), (t.italics = e >= 46), t.italics))
        t.foreground = "white";
      else {
        const i = Math.floor(e / 2) - 16,
          s = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
        t.foreground = s[i];
      }
      this.logger.log(2, "MIDROW: " + i_(t)), this.writeScreen.setPen(t);
    }
    outputDataUpdate(e = !1) {
      const t = this.logger.time;
      null !== t &&
        this.outputFilter &&
        (null !== this.cueStartTime || this.displayedMemory.isEmpty()
          ? this.displayedMemory.equals(this.lastOutputScreen) ||
            (this.outputFilter.newCue(
              this.cueStartTime,
              t,
              this.lastOutputScreen
            ),
            e &&
              this.outputFilter.dispatchCue &&
              this.outputFilter.dispatchCue(),
            (this.cueStartTime = this.displayedMemory.isEmpty() ? null : t))
          : (this.cueStartTime = t),
        this.lastOutputScreen.copy(this.displayedMemory));
    }
    cueSplitAtTime(e) {
      this.outputFilter &&
        (this.displayedMemory.isEmpty() ||
          (this.outputFilter.newCue &&
            this.outputFilter.newCue(
              this.cueStartTime,
              e,
              this.displayedMemory
            ),
          (this.cueStartTime = e)));
    }
  }
  class fy {
    constructor(e, t, i) {
      (this.channels = void 0),
        (this.currentChannel = 0),
        (this.cmdHistory = { a: null, b: null }),
        (this.logger = void 0);
      const s = (this.logger = new oy());
      this.channels = [null, new py(e, t, s), new py(e + 1, i, s)];
    }
    getHandler(e) {
      return this.channels[e].getHandler();
    }
    setHandler(e, t) {
      this.channels[e].setHandler(t);
    }
    addData(e, t) {
      this.logger.time = e;
      for (let e = 0; e < t.length; e += 2) {
        const i = 127 & t[e],
          s = 127 & t[e + 1];
        let r = !1,
          n = null;
        if (0 === i && 0 === s) continue;
        this.logger.log(
          3,
          () => "[" + cy([t[e], t[e + 1]]) + "] -> (" + cy([i, s]) + ")"
        );
        const a = this.cmdHistory;
        if (i >= 16 && i <= 31) {
          if (my(i, s, a)) {
            Ey(null, null, a),
              this.logger.log(
                3,
                () => "Repeated command (" + cy([i, s]) + ") is dropped"
              );
            continue;
          }
          Ey(i, s, this.cmdHistory),
            (r = this.parseCmd(i, s)),
            r || (r = this.parseMidrow(i, s)),
            r || (r = this.parsePAC(i, s)),
            r || (r = this.parseBackgroundAttributes(i, s));
        } else Ey(null, null, a);
        if (!r && ((n = this.parseChars(i, s)), n)) {
          const e = this.currentChannel;
          if (e && e > 0) {
            this.channels[e].insertChars(n);
          } else this.logger.log(2, "No channel found yet. TEXT-MODE?");
        }
        r ||
          n ||
          this.logger.log(
            2,
            () =>
              "Couldn't parse cleaned data " +
              cy([i, s]) +
              " orig: " +
              cy([t[e], t[e + 1]])
          );
      }
    }
    parseCmd(e, t) {
      if (
        !(
          (20 === e || 28 === e || 21 === e || 29 === e) &&
          t >= 32 &&
          t <= 47
        ) &&
        !((23 === e || 31 === e) && t >= 33 && t <= 35)
      )
        return !1;
      const i = 20 === e || 21 === e || 23 === e ? 1 : 2,
        s = this.channels[i];
      return (
        20 === e || 21 === e || 28 === e || 29 === e
          ? 32 === t
            ? s.ccRCL()
            : 33 === t
            ? s.ccBS()
            : 34 === t
            ? s.ccAOF()
            : 35 === t
            ? s.ccAON()
            : 36 === t
            ? s.ccDER()
            : 37 === t
            ? s.ccRU(2)
            : 38 === t
            ? s.ccRU(3)
            : 39 === t
            ? s.ccRU(4)
            : 40 === t
            ? s.ccFON()
            : 41 === t
            ? s.ccRDC()
            : 42 === t
            ? s.ccTR()
            : 43 === t
            ? s.ccRTD()
            : 44 === t
            ? s.ccEDM()
            : 45 === t
            ? s.ccCR()
            : 46 === t
            ? s.ccENM()
            : 47 === t && s.ccEOC()
          : s.ccTO(t - 32),
        (this.currentChannel = i),
        !0
      );
    }
    parseMidrow(e, t) {
      let i = 0;
      if ((17 === e || 25 === e) && t >= 32 && t <= 47) {
        if (((i = 17 === e ? 1 : 2), i !== this.currentChannel))
          return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
        const s = this.channels[i];
        return (
          !!s &&
          (s.ccMIDROW(t),
          this.logger.log(3, () => "MIDROW (" + cy([e, t]) + ")"),
          !0)
        );
      }
      return !1;
    }
    parsePAC(e, t) {
      let i;
      if (
        !(
          ((e >= 17 && e <= 23) || (e >= 25 && e <= 31)) &&
          t >= 64 &&
          t <= 127
        ) &&
        !((16 === e || 24 === e) && t >= 64 && t <= 95)
      )
        return !1;
      const s = e <= 23 ? 1 : 2;
      i =
        t >= 64 && t <= 95
          ? 1 === s
            ? iy[e]
            : ry[e]
          : 1 === s
          ? sy[e]
          : ny[e];
      const r = this.channels[s];
      return (
        !!r &&
        (r.setPAC(this.interpretPAC(i, t)), (this.currentChannel = s), !0)
      );
    }
    interpretPAC(e, t) {
      let i;
      const s = {
        color: null,
        italics: !1,
        indent: null,
        underline: !1,
        row: e
      };
      return (
        (i = t > 95 ? t - 96 : t - 64),
        (s.underline = 1 == (1 & i)),
        i <= 13
          ? (s.color = [
              "white",
              "green",
              "blue",
              "cyan",
              "red",
              "yellow",
              "magenta",
              "white"
            ][Math.floor(i / 2)])
          : i <= 15
          ? ((s.italics = !0), (s.color = "white"))
          : (s.indent = 4 * Math.floor((i - 16) / 2)),
        s
      );
    }
    parseChars(e, t) {
      let i,
        s = null,
        r = null;
      if (
        (e >= 25 ? ((i = 2), (r = e - 8)) : ((i = 1), (r = e)),
        r >= 17 && r <= 19)
      ) {
        let e;
        (e = 17 === r ? t + 80 : 18 === r ? t + 112 : t + 144),
          this.logger.log(
            2,
            () => "Special char '" + ZR(e) + "' in channel " + i
          ),
          (s = [e]);
      } else e >= 32 && e <= 127 && (s = 0 === t ? [e] : [e, t]);
      return (
        s && this.logger.log(3, () => "Char codes =  " + cy(s).join(",")), s
      );
    }
    parseBackgroundAttributes(e, t) {
      if (
        !((16 === e || 24 === e) && t >= 32 && t <= 47) &&
        !((23 === e || 31 === e) && t >= 45 && t <= 47)
      )
        return !1;
      let i;
      const s = {};
      16 === e || 24 === e
        ? ((i = Math.floor((t - 32) / 2)),
          (s.background = ay[i]),
          t % 2 == 1 && (s.background = s.background + "_semi"))
        : 45 === t
        ? (s.background = "transparent")
        : ((s.foreground = "black"), 47 === t && (s.underline = !0));
      const r = e <= 23 ? 1 : 2;
      return this.channels[r].setBkgData(s), !0;
    }
    reset() {
      for (let e = 0; e < Object.keys(this.channels).length; e++) {
        const t = this.channels[e];
        t && t.reset();
      }
      Ey(null, null, this.cmdHistory);
    }
    cueSplitAtTime(e) {
      for (let t = 0; t < this.channels.length; t++) {
        const i = this.channels[t];
        i && i.cueSplitAtTime(e);
      }
    }
  }
  function Ey(e, t, i) {
    (i.a = e), (i.b = t);
  }
  function my(e, t, i) {
    return i.a === e && i.b === t;
  }
  var gy = (function() {
    if (null != oT && oT.VTTCue) return self.VTTCue;
    const e = ["", "lr", "rl"],
      t = ["start", "middle", "end", "left", "right"];
    function i(e, t) {
      if ("string" != typeof t) return !1;
      if (!Array.isArray(e)) return !1;
      const i = t.toLowerCase();
      return !!~e.indexOf(i) && i;
    }
    function s(e) {
      return i(t, e);
    }
    function r(e, ...t) {
      let i = 1;
      for (; i < arguments.length; i++) {
        const t = arguments[i];
        for (const i in t) e[i] = t[i];
      }
      return e;
    }
    function n(t, n, a) {
      const o = this,
        c = { enumerable: !0 };
      o.hasBeenReset = !1;
      let d = "",
        l = !1,
        h = t,
        u = n,
        p = a,
        f = null,
        E = "",
        m = !0,
        g = "auto",
        _ = "start",
        T = 50,
        S = "middle",
        v = 50,
        R = "middle";
      Object.defineProperty(
        o,
        "id",
        r({}, c, {
          get: function() {
            return d;
          },
          set: function(e) {
            d = "" + e;
          }
        })
      ),
        Object.defineProperty(
          o,
          "pauseOnExit",
          r({}, c, {
            get: function() {
              return l;
            },
            set: function(e) {
              l = !!e;
            }
          })
        ),
        Object.defineProperty(
          o,
          "startTime",
          r({}, c, {
            get: function() {
              return h;
            },
            set: function(e) {
              if ("number" != typeof e)
                throw new TypeError("Start time must be set to a number.");
              (h = e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "endTime",
          r({}, c, {
            get: function() {
              return u;
            },
            set: function(e) {
              if ("number" != typeof e)
                throw new TypeError("End time must be set to a number.");
              (u = e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "text",
          r({}, c, {
            get: function() {
              return p;
            },
            set: function(e) {
              (p = "" + e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "region",
          r({}, c, {
            get: function() {
              return f;
            },
            set: function(e) {
              (f = e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "vertical",
          r({}, c, {
            get: function() {
              return E;
            },
            set: function(t) {
              const s = (function(t) {
                return i(e, t);
              })(t);
              if (!1 === s)
                throw new SyntaxError(
                  "An invalid or illegal string was specified."
                );
              (E = s), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "snapToLines",
          r({}, c, {
            get: function() {
              return m;
            },
            set: function(e) {
              (m = !!e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "line",
          r({}, c, {
            get: function() {
              return g;
            },
            set: function(e) {
              if ("number" != typeof e && "auto" !== e)
                throw new SyntaxError(
                  "An invalid number or illegal string was specified."
                );
              (g = e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "lineAlign",
          r({}, c, {
            get: function() {
              return _;
            },
            set: function(e) {
              const t = s(e);
              if (!t)
                throw new SyntaxError(
                  "An invalid or illegal string was specified."
                );
              (_ = t), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "position",
          r({}, c, {
            get: function() {
              return T;
            },
            set: function(e) {
              if (e < 0 || e > 100)
                throw new Error("Position must be between 0 and 100.");
              (T = e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "positionAlign",
          r({}, c, {
            get: function() {
              return S;
            },
            set: function(e) {
              const t = s(e);
              if (!t)
                throw new SyntaxError(
                  "An invalid or illegal string was specified."
                );
              (S = t), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "size",
          r({}, c, {
            get: function() {
              return v;
            },
            set: function(e) {
              if (e < 0 || e > 100)
                throw new Error("Size must be between 0 and 100.");
              (v = e), (this.hasBeenReset = !0);
            }
          })
        ),
        Object.defineProperty(
          o,
          "align",
          r({}, c, {
            get: function() {
              return R;
            },
            set: function(e) {
              const t = s(e);
              if (!t)
                throw new SyntaxError(
                  "An invalid or illegal string was specified."
                );
              (R = t), (this.hasBeenReset = !0);
            }
          })
        ),
        (o.displayState = void 0);
    }
    return (
      (n.prototype.getCueAsHTML = function() {
        return self.WebVTT.convertCueToDOMTree(self, this.text);
      }),
      n
    );
  })();
  class _y {
    decode(e, t) {
      if (!e) return "";
      if ("string" != typeof e)
        throw new Error("Error - expected string data.");
      return decodeURIComponent(encodeURIComponent(e));
    }
  }
  function Ty(e) {
    function t(e, t, i, s) {
      return 3600 * (0 | e) + 60 * (0 | t) + (0 | i) + parseFloat(s || 0);
    }
    const i = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
    return i
      ? parseFloat(i[2]) > 59
        ? t(i[2], i[3], 0, i[4])
        : t(i[1], i[2], i[3], i[4])
      : null;
  }
  class Sy {
    constructor() {
      this.values = Object.create(null);
    }
    set(e, t) {
      this.get(e) || "" === t || (this.values[e] = t);
    }
    get(e, t, i) {
      return i
        ? this.has(e)
          ? this.values[e]
          : t[i]
        : this.has(e)
        ? this.values[e]
        : t;
    }
    has(e) {
      return e in this.values;
    }
    alt(e, t, i) {
      for (let s = 0; s < i.length; ++s)
        if (t === i[s]) {
          this.set(e, t);
          break;
        }
    }
    integer(e, t) {
      /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
    }
    percent(e, t) {
      if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
        const i = parseFloat(t);
        if (i >= 0 && i <= 100) return this.set(e, i), !0;
      }
      return !1;
    }
  }
  function vy(e, t, i, s) {
    const r = s ? e.split(s) : [e];
    for (const e in r) {
      if ("string" != typeof r[e]) continue;
      const s = r[e].split(i);
      if (2 !== s.length) continue;
      t(s[0], s[1]);
    }
  }
  const Ry = new gy(0, 0, ""),
    yy = "middle" === Ry.align ? "middle" : "center";
  function Ay(e, t, i) {
    const s = e;
    function r() {
      const t = Ty(e);
      if (null === t) throw new Error("Malformed timestamp: " + s);
      return (e = e.replace(/^[^\sa-zA-Z-]+/, "")), t;
    }
    function n() {
      e = e.replace(/^\s+/, "");
    }
    if ((n(), (t.startTime = r()), n(), "--\x3e" !== e.slice(0, 3)))
      throw new Error(
        "Malformed time stamp (time stamps must be separated by '--\x3e'): " + s
      );
    (e = e.slice(3)),
      n(),
      (t.endTime = r()),
      n(),
      (function(e, t) {
        const s = new Sy();
        vy(
          e,
          function(e, t) {
            let r;
            switch (e) {
              case "region":
                for (let r = i.length - 1; r >= 0; r--)
                  if (i[r].id === t) {
                    s.set(e, i[r].region);
                    break;
                  }
                break;
              case "vertical":
                s.alt(e, t, ["rl", "lr"]);
                break;
              case "line":
                (r = t.split(",")),
                  s.integer(e, r[0]),
                  s.percent(e, r[0]) && s.set("snapToLines", !1),
                  s.alt(e, r[0], ["auto"]),
                  2 === r.length &&
                    s.alt("lineAlign", r[1], ["start", yy, "end"]);
                break;
              case "position":
                (r = t.split(",")),
                  s.percent(e, r[0]),
                  2 === r.length &&
                    s.alt("positionAlign", r[1], [
                      "start",
                      yy,
                      "end",
                      "line-left",
                      "line-right",
                      "auto"
                    ]);
                break;
              case "size":
                s.percent(e, t);
                break;
              case "align":
                s.alt(e, t, ["start", yy, "end", "left", "right"]);
            }
          },
          /:/,
          /\s/
        ),
          (t.region = s.get("region", null)),
          (t.vertical = s.get("vertical", ""));
        let r = s.get("line", "auto");
        "auto" === r && -1 === Ry.line && (r = -1),
          (t.line = r),
          (t.lineAlign = s.get("lineAlign", "start")),
          (t.snapToLines = s.get("snapToLines", !0)),
          (t.size = s.get("size", 100)),
          (t.align = s.get("align", yy));
        let n = s.get("position", "auto");
        "auto" === n &&
          50 === Ry.position &&
          (n =
            "start" === t.align || "left" === t.align
              ? 0
              : "end" === t.align || "right" === t.align
              ? 100
              : 50),
          (t.position = n);
      })(e, t);
  }
  function Iy(e) {
    return e.replace(/<br(?: \/)?>/gi, "\n");
  }
  class Cy {
    constructor() {
      (this.state = "INITIAL"),
        (this.buffer = ""),
        (this.decoder = new _y()),
        (this.regionList = []),
        (this.cue = null),
        (this.oncue = void 0),
        (this.onparsingerror = void 0),
        (this.onflush = void 0);
    }
    parse(e) {
      const t = this;
      function i() {
        let e = t.buffer,
          i = 0;
        for (e = Iy(e); i < e.length && "\r" !== e[i] && "\n" !== e[i]; ) ++i;
        const s = e.slice(0, i);
        return (
          "\r" === e[i] && ++i, "\n" === e[i] && ++i, (t.buffer = e.slice(i)), s
        );
      }
      e && (t.buffer += t.decoder.decode(e, { stream: !0 }));
      try {
        let e = "";
        if ("INITIAL" === t.state) {
          if (!/\r\n|\n/.test(t.buffer)) return this;
          e = i();
          const s = e.match(/^(Ã¯Â»Â¿)?WEBVTT([ \t].*)?$/);
          if (null == s || !s[0])
            throw new Error("Malformed WebVTT signature.");
          t.state = "HEADER";
        }
        let s = !1;
        for (; t.buffer; ) {
          if (!/\r\n|\n/.test(t.buffer)) return this;
          switch ((s ? (s = !1) : (e = i()), t.state)) {
            case "HEADER":
              /:/.test(e)
                ? vy(e, function(e, t) {}, /:/)
                : e || (t.state = "ID");
              continue;
            case "NOTE":
              e || (t.state = "ID");
              continue;
            case "ID":
              if (/^NOTE($|[ \t])/.test(e)) {
                t.state = "NOTE";
                break;
              }
              if (!e) continue;
              if (
                ((t.cue = new gy(0, 0, "")),
                (t.state = "CUE"),
                -1 === e.indexOf("--\x3e"))
              ) {
                t.cue.id = e;
                continue;
              }
            case "CUE":
              if (!t.cue) {
                t.state = "BADCUE";
                continue;
              }
              try {
                Ay(e, t.cue, t.regionList);
              } catch (e) {
                (t.cue = null), (t.state = "BADCUE");
                continue;
              }
              t.state = "CUETEXT";
              continue;
            case "CUETEXT":
              {
                const i = -1 !== e.indexOf("--\x3e");
                if (!e || (i && (s = !0))) {
                  t.oncue && t.cue && t.oncue(t.cue),
                    (t.cue = null),
                    (t.state = "ID");
                  continue;
                }
                if (null === t.cue) continue;
                t.cue.text && (t.cue.text += "\n"), (t.cue.text += e);
              }
              continue;
            case "BADCUE":
              e || (t.state = "ID");
          }
        }
      } catch (e) {
        "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue),
          (t.cue = null),
          (t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE");
      }
      return this;
    }
    flush() {
      const e = this;
      try {
        if (
          ((e.cue || "HEADER" === e.state) && ((e.buffer += "\n\n"), e.parse()),
          "INITIAL" === e.state || "BADWEBVTT" === e.state)
        )
          throw new Error("Malformed WebVTT signature.");
      } catch (t) {
        e.onparsingerror && e.onparsingerror(t);
      }
      return e.onflush && e.onflush(), this;
    }
  }
  const by = /\r\n|\n\r|\n|\r/g,
    Oy = function(e, t, i = 0) {
      return e.slice(i, i + t.length) === t;
    },
    Dy = function(e) {
      let t = parseInt(e.slice(-3));
      const i = parseInt(e.slice(-6, -4)),
        s = parseInt(e.slice(-9, -7)),
        r = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
      if (!(Tm(t) && Tm(i) && Tm(s) && Tm(r)))
        throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
      return (t += 1e3 * i), (t += 6e4 * s), (t += 36e5 * r), t;
    };
  function wy(e, t, i) {
    return UR(e.toString()) + UR(t.toString()) + UR(i);
  }
  const Ly = function(e, t, i) {
    let s = e[t],
      r = e[s.prevCC];
    if (!r || (!r.new && s.new))
      return (e.ccOffset = e.presentationOffset = s.start), void (s.new = !1);
    for (; null != (n = r) && n.new; ) {
      var n;
      (e.ccOffset += s.start - r.start),
        (s.new = !1),
        (s = r),
        (r = e[s.prevCC]);
    }
    e.presentationOffset = i;
  };
  function Ny(e, t, i, s, r, n, a) {
    const o = new Cy(),
      c = jm(new Uint8Array(e))
        .trim()
        .replace(by, "\n")
        .split("\n"),
      d = [],
      l = t
        ? (function(e, t = 1) {
            return Ev(e, fv, 1 / t);
          })(t.baseTime, t.timescale)
        : 0;
    let h,
      u = "00:00.000",
      p = 0,
      f = 0,
      E = !0;
    (o.oncue = function(e) {
      const n = i[s];
      let a = i.ccOffset;
      const o = (p - l) / 9e4;
      if (
        (null != n &&
          n.new &&
          (void 0 !== f ? (a = i.ccOffset = n.start) : Ly(i, s, o)),
        o)
      ) {
        if (!t) return void (h = new Error("Missing initPTS for VTT MPEGTS"));
        a = o - i.presentationOffset;
      }
      const c = e.endTime - e.startTime,
        u = Rv(9e4 * (e.startTime + a - f), 9e4 * r) / 9e4;
      (e.startTime = Math.max(u, 0)), (e.endTime = Math.max(u + c, 0));
      const E = e.text.trim();
      (e.text = decodeURIComponent(encodeURIComponent(E))),
        e.id || (e.id = wy(e.startTime, e.endTime, E)),
        e.endTime > 0 && d.push(e);
    }),
      (o.onparsingerror = function(e) {
        h = e;
      }),
      (o.onflush = function() {
        h ? a(h) : n(d);
      }),
      c.forEach(e => {
        if (E) {
          if (Oy(e, "X-TIMESTAMP-MAP=")) {
            (E = !1),
              e
                .slice(16)
                .split(",")
                .forEach(e => {
                  Oy(e, "LOCAL:")
                    ? (u = e.slice(6))
                    : Oy(e, "MPEGTS:") && (p = parseInt(e.slice(7)));
                });
            try {
              f = Dy(u) / 1e3;
            } catch (e) {
              h = e;
            }
            return;
          }
          "" === e && (E = !1);
        }
        o.parse(e + "\n");
      }),
      o.flush();
  }
  const Py = "stpp.ttml.im1t",
    ky = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
    My = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
    Uy = {
      left: "start",
      center: "center",
      right: "end",
      start: "start",
      end: "end"
    };
  function xy(e, t, i, s) {
    const r = lg(new Uint8Array(e), ["mdat"]);
    if (0 === r.length) return void s(new Error("Could not parse IMSC1 mdat"));
    const n = r.map(e => jm(e)),
      a = (function(e, t, i = 1, s = !1) {
        return Ev(e, t, 1 / i, s);
      })(t.baseTime, 1, t.timescale);
    try {
      n.forEach(e =>
        i(
          (function(e, t) {
            const i = new DOMParser().parseFromString(e, "text/xml"),
              s = i.getElementsByTagName("tt")[0];
            if (!s) throw new Error("Invalid ttml");
            const r = {
                frameRate: 30,
                subFrameRate: 1,
                frameRateMultiplier: 0,
                tickRate: 0
              },
              n = Object.keys(r).reduce(
                (e, t) => ((e[t] = s.getAttribute(`ttp:${t}`) || r[t]), e),
                {}
              ),
              a = "preserve" !== s.getAttribute("xml:space"),
              o = By(Fy(s, "styling", "style")),
              c = By(Fy(s, "layout", "region")),
              d = Fy(s, "body", "[begin]");
            return [].map
              .call(d, e => {
                const i = Vy(e, a);
                if (!i || !e.hasAttribute("begin")) return null;
                const s = Hy(e.getAttribute("begin"), n),
                  r = Hy(e.getAttribute("dur"), n);
                let d = Hy(e.getAttribute("end"), n);
                if (null === s) throw jy(e);
                if (null === d) {
                  if (null === r) throw jy(e);
                  d = s + r;
                }
                const l = new gy(s - t, d - t, i);
                l.id = wy(l.startTime, l.endTime, l.text);
                const h = (function(e, t, i) {
                    const s = "http://www.w3.org/ns/ttml#styling";
                    let r = null;
                    const n = [
                        "displayAlign",
                        "textAlign",
                        "color",
                        "backgroundColor",
                        "fontSize",
                        "fontFamily"
                      ],
                      a =
                        null != e && e.hasAttribute("style")
                          ? e.getAttribute("style")
                          : null;
                    a && i.hasOwnProperty(a) && (r = i[a]);
                    return n.reduce((i, n) => {
                      const a = Gy(t, s, n) || Gy(e, s, n) || Gy(r, s, n);
                      return a && (i[n] = a), i;
                    }, {});
                  })(
                    c[e.getAttribute("region")],
                    o[e.getAttribute("style")],
                    o
                  ),
                  { textAlign: u } = h;
                if (u) {
                  const e = Uy[u];
                  e && (l.lineAlign = e), (l.align = u);
                }
                return wm(l, h), l;
              })
              .filter(e => null !== e);
          })(e, a)
        )
      );
    } catch (e) {
      s(e);
    }
  }
  function Fy(e, t, i) {
    const s = e.getElementsByTagName(t)[0];
    return s ? [].slice.call(s.querySelectorAll(i)) : [];
  }
  function By(e) {
    return e.reduce((e, t) => {
      const i = t.getAttribute("xml:id");
      return i && (e[i] = t), e;
    }, {});
  }
  function Vy(e, t) {
    return [].slice.call(e.childNodes).reduce((e, i, s) => {
      var r;
      return "br" === i.nodeName && s
        ? e + "\n"
        : null != (r = i.childNodes) && r.length
        ? Vy(i, t)
        : t
        ? e + i.textContent.trim().replace(/\s+/g, " ")
        : e + i.textContent;
    }, "");
  }
  function Gy(e, t, i) {
    return e && e.hasAttributeNS(t, i) ? e.getAttributeNS(t, i) : null;
  }
  function jy(e) {
    return new Error(`Could not parse ttml timestamp ${e}`);
  }
  function Hy(e, t) {
    if (!e) return null;
    let i = Ty(e);
    return (
      null === i &&
        (ky.test(e)
          ? (i = (function(e, t) {
              const i = ky.exec(e),
                s = (0 | i[4]) + (0 | i[5]) / t.subFrameRate;
              return (
                3600 * (0 | i[1]) +
                60 * (0 | i[2]) +
                (0 | i[3]) +
                s / t.frameRate
              );
            })(e, t))
          : My.test(e) &&
            (i = (function(e, t) {
              const i = My.exec(e),
                s = Number(i[1]);
              switch (i[2]) {
                case "h":
                  return 3600 * s;
                case "m":
                  return 60 * s;
                case "ms":
                  return 1e3 * s;
                case "f":
                  return s / t.frameRate;
                case "t":
                  return s / t.tickRate;
              }
              return s;
            })(e, t))),
      i
    );
  }
  class Ky {
    constructor(e, t) {
      (this.timelineController = void 0),
        (this.cueRanges = []),
        (this.trackName = void 0),
        (this.startTime = null),
        (this.endTime = null),
        (this.screen = null),
        (this.timelineController = e),
        (this.trackName = t);
    }
    dispatchCue() {
      null !== this.startTime &&
        (this.timelineController.addCues(
          this.trackName,
          this.startTime,
          this.endTime,
          this.screen,
          this.cueRanges
        ),
        (this.startTime = null));
    }
    newCue(e, t, i) {
      (null === this.startTime || this.startTime > e) && (this.startTime = e),
        (this.endTime = t),
        (this.screen = i),
        this.timelineController.createCaptionsTrack(this.trackName);
    }
    reset() {
      (this.cueRanges = []), (this.startTime = null);
    }
  }
  function Wy(e) {
    return e.characteristics &&
      /transcribes-spoken-dialog/gi.test(e.characteristics) &&
      /describes-music-and-sound/gi.test(e.characteristics)
      ? "captions"
      : "subtitles";
  }
  function Yy(e, t) {
    return !!e && e.kind === Wy(t) && xv(t, e);
  }
  const $y = /\s/,
    qy = {
      newCue(e, t, i, s) {
        const r = [];
        let n, a, o, c, d;
        const l = self.VTTCue || self.TextTrackCue;
        for (let u = 0; u < s.rows.length; u++)
          if (((n = s.rows[u]), (o = !0), (c = 0), (d = ""), !n.isEmpty())) {
            var h;
            for (let e = 0; e < n.chars.length; e++)
              $y.test(n.chars[e].uchar) && o
                ? c++
                : ((d += n.chars[e].uchar), (o = !1));
            (n.cueStartTime = t), t === i && (i += 1e-4), c >= 16 ? c-- : c++;
            const s = Iy(d.trim()),
              p = wy(t, i, s);
            (null != e && null != (h = e.cues) && h.getCueById(p)) ||
              ((a = new l(t, i, s)),
              (a.id = p),
              (a.line = u + 1),
              (a.align = "left"),
              (a.position = 10 + Math.min(80, 10 * Math.floor((8 * c) / 32))),
              r.push(a));
          }
        return (
          e &&
            r.length &&
            (r.sort((e, t) =>
              "auto" === e.line || "auto" === t.line
                ? 0
                : e.line > 8 && t.line > 8
                ? t.line - e.line
                : e.line - t.line
            ),
            r.forEach(t => NR(e, t))),
          r
        );
      }
    };
  const Xy = /(\d+)-(\d+)\/(\d+)/;
  class zy {
    constructor(e) {
      (this.fetchSetup = void 0),
        (this.requestTimeout = void 0),
        (this.request = null),
        (this.response = null),
        (this.controller = void 0),
        (this.context = null),
        (this.config = null),
        (this.callbacks = null),
        (this.stats = void 0),
        (this.loader = null),
        (this.fetchSetup = e.fetchSetup || Jy),
        (this.controller = new self.AbortController()),
        (this.stats = new qm());
    }
    destroy() {
      (this.loader = this.callbacks = this.context = this.config = this.request = null),
        this.abortInternal(),
        (this.response = null),
        (this.fetchSetup = this.controller = this.stats = null);
    }
    abortInternal() {
      this.controller &&
        !this.stats.loading.end &&
        ((this.stats.aborted = !0), this.controller.abort());
    }
    abort() {
      var e;
      this.abortInternal(),
        null != (e = this.callbacks) &&
          e.onAbort &&
          this.callbacks.onAbort(this.stats, this.context, this.response);
    }
    load(e, t, i) {
      const s = this.stats;
      if (s.loading.start) throw new Error("Loader can only be used once.");
      s.loading.start = self.performance.now();
      const r = (function(e, t) {
          const i = {
            method: "GET",
            mode: "cors",
            credentials: "same-origin",
            signal: t,
            headers: new self.Headers(wm({}, e.headers))
          };
          e.rangeEnd &&
            i.headers.set(
              "Range",
              "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)
            );
          return i;
        })(e, this.controller.signal),
        n = "arraybuffer" === e.responseType,
        a = n ? "byteLength" : "length",
        { maxTimeToFirstByteMs: o, maxLoadTimeMs: c } = t.loadPolicy;
      (this.context = e),
        (this.config = t),
        (this.callbacks = i),
        (this.request = this.fetchSetup(e, r)),
        self.clearTimeout(this.requestTimeout),
        (t.timeout = o && Tm(o) ? o : c),
        (this.requestTimeout = self.setTimeout(() => {
          this.callbacks &&
            (this.abortInternal(),
            this.callbacks.onTimeout(s, e, this.response));
        }, t.timeout));
      (Dv(this.request)
        ? this.request.then(self.fetch)
        : self.fetch(this.request)
      )
        .then(i => {
          var r;
          this.response = this.loader = i;
          const a = Math.max(self.performance.now(), s.loading.start);
          if (
            (self.clearTimeout(this.requestTimeout),
            (t.timeout = c),
            (this.requestTimeout = self.setTimeout(() => {
              this.callbacks &&
                (this.abortInternal(),
                this.callbacks.onTimeout(s, e, this.response));
            }, c - (a - s.loading.start))),
            !i.ok)
          ) {
            const { status: e, statusText: t } = i;
            throw new Qy(t || "fetch, bad network response", e, i);
          }
          (s.loading.first = a),
            (s.total =
              (function(e) {
                const t = e.get("Content-Range");
                if (t) {
                  const e = (function(e) {
                    const t = Xy.exec(e);
                    if (t) return parseInt(t[2]) - parseInt(t[1]) + 1;
                  })(t);
                  if (Tm(e)) return e;
                }
                const i = e.get("Content-Length");
                if (i) return parseInt(i);
              })(i.headers) || s.total);
          const o = null == (r = this.callbacks) ? void 0 : r.onProgress;
          return o && Tm(t.highWaterMark)
            ? this.loadProgressively(i, s, e, t.highWaterMark, o)
            : n
            ? i.arrayBuffer()
            : "json" === e.responseType
            ? i.json()
            : i.text();
        })
        .then(i => {
          var r, n;
          const o = this.response;
          if (!o) throw new Error("loader destroyed");
          self.clearTimeout(this.requestTimeout),
            (s.loading.end = Math.max(self.performance.now(), s.loading.first));
          const c = i[a];
          c && (s.loaded = s.total = c);
          const d = { url: o.url, data: i, code: o.status },
            l = null == (r = this.callbacks) ? void 0 : r.onProgress;
          l && !Tm(t.highWaterMark) && l(s, e, i, o),
            null == (n = this.callbacks) || n.onSuccess(d, s, e, o);
        })
        .catch(t => {
          var i;
          if ((self.clearTimeout(this.requestTimeout), s.aborted)) return;
          const r = (t && t.code) || 0,
            n = t ? t.message : null;
          null == (i = this.callbacks) ||
            i.onError({ code: r, text: n }, e, t ? t.details : null, s);
        });
    }
    getCacheAge() {
      let e = null;
      if (this.response) {
        const t = this.response.headers.get("age");
        e = t ? parseFloat(t) : null;
      }
      return e;
    }
    getResponseHeader(e) {
      return this.response ? this.response.headers.get(e) : null;
    }
    loadProgressively(e, t, i, s = 0, r) {
      const n = new iS(),
        a = e.body.getReader(),
        o = () =>
          a
            .read()
            .then(a => {
              if (a.done)
                return (
                  n.dataLength && r(t, i, n.flush().buffer, e),
                  Promise.resolve(new ArrayBuffer(0))
                );
              const c = a.value,
                d = c.length;
              return (
                (t.loaded += d),
                d < s || n.dataLength
                  ? (n.push(c),
                    n.dataLength >= s && r(t, i, n.flush().buffer, e))
                  : r(t, i, c.buffer, e),
                o()
              );
            })
            .catch(() => Promise.reject());
      return o();
    }
  }
  function Jy(e, t) {
    return new self.Request(e.url, t);
  }
  class Qy extends Error {
    constructor(e, t, i) {
      super(e),
        (this.code = void 0),
        (this.details = void 0),
        (this.code = t),
        (this.details = i);
    }
  }
  const Zy = /^age:\s*[\d.]+\s*$/im;
  class eA {
    constructor(e) {
      (this.xhrSetup = void 0),
        (this.requestTimeout = void 0),
        (this.retryTimeout = void 0),
        (this.retryDelay = void 0),
        (this.config = null),
        (this.callbacks = null),
        (this.context = null),
        (this.loader = null),
        (this.stats = void 0),
        (this.xhrSetup = (e && e.xhrSetup) || null),
        (this.stats = new qm()),
        (this.retryDelay = 0);
    }
    destroy() {
      (this.callbacks = null),
        this.abortInternal(),
        (this.loader = null),
        (this.config = null),
        (this.context = null),
        (this.xhrSetup = null);
    }
    abortInternal() {
      const e = this.loader;
      self.clearTimeout(this.requestTimeout),
        self.clearTimeout(this.retryTimeout),
        e &&
          ((e.onreadystatechange = null),
          (e.onprogress = null),
          4 !== e.readyState && ((this.stats.aborted = !0), e.abort()));
    }
    abort() {
      var e;
      this.abortInternal(),
        null != (e = this.callbacks) &&
          e.onAbort &&
          this.callbacks.onAbort(this.stats, this.context, this.loader);
    }
    load(e, t, i) {
      if (this.stats.loading.start)
        throw new Error("Loader can only be used once.");
      (this.stats.loading.start = self.performance.now()),
        (this.context = e),
        (this.config = t),
        (this.callbacks = i),
        this.loadInternal();
    }
    loadInternal() {
      const { config: e, context: t } = this;
      if (!e || !t) return;
      const i = (this.loader = new self.XMLHttpRequest()),
        s = this.stats;
      (s.loading.first = 0), (s.loaded = 0), (s.aborted = !1);
      const r = this.xhrSetup;
      r
        ? Promise.resolve()
            .then(() => {
              if (this.loader === i && !this.stats.aborted) return r(i, t.url);
            })
            .catch(e => {
              if (this.loader === i && !this.stats.aborted)
                return i.open("GET", t.url, !0), r(i, t.url);
            })
            .then(() => {
              this.loader !== i ||
                this.stats.aborted ||
                this.openAndSendXhr(i, t, e);
            })
            .catch(e => {
              var r;
              null == (r = this.callbacks) ||
                r.onError({ code: i.status, text: e.message }, t, i, s);
            })
        : this.openAndSendXhr(i, t, e);
    }
    openAndSendXhr(e, t, i) {
      e.readyState || e.open("GET", t.url, !0);
      const s = t.headers,
        { maxTimeToFirstByteMs: r, maxLoadTimeMs: n } = i.loadPolicy;
      if (s) for (const t in s) e.setRequestHeader(t, s[t]);
      t.rangeEnd &&
        e.setRequestHeader(
          "Range",
          "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)
        ),
        (e.onreadystatechange = this.readystatechange.bind(this)),
        (e.onprogress = this.loadprogress.bind(this)),
        (e.responseType = t.responseType),
        self.clearTimeout(this.requestTimeout),
        (i.timeout = r && Tm(r) ? r : n),
        (this.requestTimeout = self.setTimeout(
          this.loadtimeout.bind(this),
          i.timeout
        )),
        e.send();
    }
    readystatechange() {
      const { context: e, loader: t, stats: i } = this;
      if (!e || !t) return;
      const s = t.readyState,
        r = this.config;
      if (
        !i.aborted &&
        s >= 2 &&
        (0 === i.loading.first &&
          ((i.loading.first = Math.max(
            self.performance.now(),
            i.loading.start
          )),
          r.timeout !== r.loadPolicy.maxLoadTimeMs &&
            (self.clearTimeout(this.requestTimeout),
            (r.timeout = r.loadPolicy.maxLoadTimeMs),
            (this.requestTimeout = self.setTimeout(
              this.loadtimeout.bind(this),
              r.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)
            )))),
        4 === s)
      ) {
        self.clearTimeout(this.requestTimeout),
          (t.onreadystatechange = null),
          (t.onprogress = null);
        const s = t.status,
          c = "text" === t.responseType ? t.responseText : null;
        if (s >= 200 && s < 300) {
          const r = null != c ? c : t.response;
          if (null != r) {
            var n, a;
            i.loading.end = Math.max(self.performance.now(), i.loading.first);
            const o =
              "arraybuffer" === t.responseType ? r.byteLength : r.length;
            (i.loaded = i.total = o),
              (i.bwEstimate =
                (8e3 * i.total) / (i.loading.end - i.loading.first));
            const c = null == (n = this.callbacks) ? void 0 : n.onProgress;
            c && c(i, e, r, t);
            const d = { url: t.responseURL, data: r, code: s };
            return void (
              null == (a = this.callbacks) || a.onSuccess(d, i, e, t)
            );
          }
        }
        const d = r.loadPolicy.errorRetry;
        var o;
        if (S_(d, i.retry, !1, { url: e.url, data: void 0, code: s }))
          this.retry(d);
        else
          Bm.error(`${s} while loading ${e.url}`),
            null == (o = this.callbacks) ||
              o.onError({ code: s, text: t.statusText }, e, t, i);
      }
    }
    loadtimeout() {
      if (!this.config) return;
      const e = this.config.loadPolicy.timeoutRetry;
      if (S_(e, this.stats.retry, !0)) this.retry(e);
      else {
        var t;
        Bm.warn(
          `timeout while loading ${null == (t = this.context) ? void 0 : t.url}`
        );
        const e = this.callbacks;
        e &&
          (this.abortInternal(),
          e.onTimeout(this.stats, this.context, this.loader));
      }
    }
    retry(e) {
      const { context: t, stats: i } = this;
      (this.retryDelay = __(e, i.retry)),
        i.retry++,
        Bm.warn(
          `${status ? "HTTP Status " + status : "Timeout"} while loading ${
            null == t ? void 0 : t.url
          }, retrying ${i.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`
        ),
        this.abortInternal(),
        (this.loader = null),
        self.clearTimeout(this.retryTimeout),
        (this.retryTimeout = self.setTimeout(
          this.loadInternal.bind(this),
          this.retryDelay
        ));
    }
    loadprogress(e) {
      const t = this.stats;
      (t.loaded = e.loaded), e.lengthComputable && (t.total = e.total);
    }
    getCacheAge() {
      let e = null;
      if (this.loader && Zy.test(this.loader.getAllResponseHeaders())) {
        const t = this.loader.getResponseHeader("age");
        e = t ? parseFloat(t) : null;
      }
      return e;
    }
    getResponseHeader(e) {
      return this.loader &&
        new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(
          this.loader.getAllResponseHeaders()
        )
        ? this.loader.getResponseHeader(e)
        : null;
    }
  }
  const tA = Nm(
    Nm(
      {
        autoStartLoad: !0,
        startPosition: -1,
        defaultAudioCodec: void 0,
        debug: !1,
        capLevelOnFPSDrop: !1,
        capLevelToPlayerSize: !1,
        ignoreDevicePixelRatio: !1,
        maxDevicePixelRatio: Number.POSITIVE_INFINITY,
        preferManagedMediaSource: !0,
        initialLiveManifestSize: 1,
        maxBufferLength: 30,
        backBufferLength: 1 / 0,
        frontBufferFlushThreshold: 1 / 0,
        maxBufferSize: 6e7,
        maxFragLookUpTolerance: 0.25,
        maxBufferHole: 0.1,
        detectStallWithCurrentTimeMs: 1250,
        highBufferWatchdogPeriod: 2,
        nudgeOffset: 0.1,
        nudgeMaxRetry: 3,
        nudgeOnVideoHole: !0,
        liveSyncDurationCount: 3,
        liveSyncOnStallIncrease: 1,
        liveMaxLatencyDurationCount: 1 / 0,
        liveSyncDuration: void 0,
        liveMaxLatencyDuration: void 0,
        maxLiveSyncPlaybackRate: 1,
        liveDurationInfinity: !1,
        liveBackBufferLength: null,
        maxMaxBufferLength: 600,
        enableWorker: !0,
        workerPath: null,
        enableSoftwareAES: !0,
        startLevel: void 0,
        startFragPrefetch: !1,
        fpsDroppedMonitoringPeriod: 5e3,
        fpsDroppedMonitoringThreshold: 0.2,
        appendErrorMaxRetry: 3,
        ignorePlaylistParsingErrors: !1,
        loader: eA,
        fLoader: void 0,
        pLoader: void 0,
        xhrSetup: void 0,
        licenseXhrSetup: void 0,
        licenseResponseCallback: void 0,
        abrController: class extends Pm {
          constructor(e) {
            super("abr", e.logger),
              (this.hls = void 0),
              (this.lastLevelLoadSec = 0),
              (this.lastLoadedFragLevel = -1),
              (this.firstSelection = -1),
              (this._nextAutoLevel = -1),
              (this.nextAutoLevelKey = ""),
              (this.audioTracksByGroup = null),
              (this.codecTiers = null),
              (this.timer = -1),
              (this.fragCurrent = null),
              (this.partCurrent = null),
              (this.bitrateTestDelay = 0),
              (this.rebufferNotice = -1),
              (this.bwEstimator = void 0),
              (this._abandonRulesCheck = e => {
                var t;
                const { fragCurrent: i, partCurrent: s, hls: r } = this,
                  { autoLevelEnabled: n, media: a } = r;
                if (!i || !a) return;
                const o = performance.now(),
                  c = s ? s.stats : i.stats,
                  d = s ? s.duration : i.duration,
                  l = o - c.loading.start,
                  h = r.minAutoLevel,
                  u = i.level,
                  p = this._nextAutoLevel;
                if (c.aborted || (c.loaded && c.loaded === c.total) || u <= h)
                  return this.clearTimer(), void (this._nextAutoLevel = -1);
                if (!n) return;
                const f = p > -1 && p !== u,
                  E = !!e || f;
                if (!E && (a.paused || !a.playbackRate || !a.readyState))
                  return;
                const m = r.mainForwardBufferInfo;
                if (!E && null === m) return;
                const g = this.bwEstimator.getEstimateTTFB(),
                  _ = Math.abs(a.playbackRate);
                if (l <= Math.max(g, (d / (2 * _)) * 1e3)) return;
                const T = m ? m.len / _ : 0,
                  S = c.loading.first ? c.loading.first - c.loading.start : -1,
                  v = c.loaded && S > -1,
                  R = this.getBwEstimate(),
                  y = r.levels,
                  A = y[u],
                  I = Math.max(
                    c.loaded,
                    Math.round((d * (i.bitrate || A.averageBitrate)) / 8)
                  );
                let C = v ? l - S : l;
                C < 1 && v && (C = Math.min(l, (8 * c.loaded) / R));
                const b = v ? (1e3 * c.loaded) / C : 0,
                  O = g / 1e3,
                  D = b ? (I - c.loaded) / b : (8 * I) / R + O;
                if (D <= T) return;
                const w = b ? 8 * b : R,
                  L =
                    !0 ===
                    (null ==
                    (t =
                      (null == e ? void 0 : e.details) ||
                      this.hls.latestLevelDetails)
                      ? void 0
                      : t.live),
                  N = this.hls.config.abrBandWidthUpFactor;
                let P,
                  k = Number.POSITIVE_INFINITY;
                for (P = u - 1; P > h; P--) {
                  const e = y[P].maxBitrate,
                    t = !y[P].details || L;
                  if (
                    ((k = this.getTimeToLoadFrag(O, w, d * e, t)),
                    k < Math.min(T, d + O))
                  )
                    break;
                }
                if (k >= D) return;
                if (k > 10 * d) return;
                v
                  ? this.bwEstimator.sample(l - Math.min(g, S), c.loaded)
                  : this.bwEstimator.sampleTTFB(l);
                const M = y[P].maxBitrate;
                this.getBwEstimate() * N > M && this.resetEstimator(M);
                const U = this.findBestLevel(M, h, P, 0, T, 1, 1);
                U > -1 && (P = U),
                  this.warn(
                    `Fragment ${i.sn}${
                      s ? " part " + s.index : ""
                    } of level ${u} is loading too slowly;\n      Fragment duration: ${i.duration.toFixed(
                      3
                    )}\n      Time to underbuffer: ${T.toFixed(
                      3
                    )} s\n      Estimated load time for current fragment: ${D.toFixed(
                      3
                    )} s\n      Estimated load time for down switch fragment: ${k.toFixed(
                      3
                    )} s\n      TTFB estimate: ${0 |
                      S} ms\n      Current BW estimate: ${
                      Tm(R) ? 0 | R : "Unknown"
                    } bps\n      New BW estimate: ${0 |
                      this.getBwEstimate()} bps\n      Switching to level ${P} @ ${0 |
                      M} bps`
                  ),
                  (r.nextLoadLevel = r.nextAutoLevel = P),
                  this.clearTimer();
                const x = () => {
                  if (
                    (this.clearTimer(),
                    this.fragCurrent === i && this.hls.loadLevel === P && P > 0)
                  ) {
                    const e = this.getStarvationDelay();
                    if (
                      (this.warn(
                        `Aborting inflight request ${
                          P > 0 ? "and switching down" : ""
                        }\n      Fragment duration: ${i.duration.toFixed(
                          3
                        )} s\n      Time to underbuffer: ${e.toFixed(3)} s`
                      ),
                      i.abortRequests(),
                      (this.fragCurrent = this.partCurrent = null),
                      P > h)
                    ) {
                      let t = this.findBestLevel(
                        this.hls.levels[h].bitrate,
                        h,
                        P,
                        0,
                        e,
                        1,
                        1
                      );
                      -1 === t && (t = h),
                        (this.hls.nextLoadLevel = this.hls.nextAutoLevel = t),
                        this.resetEstimator(this.hls.levels[t].bitrate);
                    }
                  }
                };
                f || D > 2 * k
                  ? x()
                  : (this.timer = self.setInterval(x, 1e3 * k)),
                  r.trigger(Am.FRAG_LOAD_EMERGENCY_ABORTED, {
                    frag: i,
                    part: s,
                    stats: c
                  });
              }),
              (this.hls = e),
              (this.bwEstimator = this.initEstimator()),
              this.registerListeners();
          }
          resetEstimator(e) {
            e &&
              (this.log(`setting initial bwe to ${e}`),
              (this.hls.config.abrEwmaDefaultEstimate = e)),
              (this.firstSelection = -1),
              (this.bwEstimator = this.initEstimator());
          }
          initEstimator() {
            const e = this.hls.config;
            return new Om(
              e.abrEwmaSlowVoD,
              e.abrEwmaFastVoD,
              e.abrEwmaDefaultEstimate
            );
          }
          registerListeners() {
            const { hls: e } = this;
            e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
              e.on(Am.FRAG_LOADING, this.onFragLoading, this),
              e.on(Am.FRAG_LOADED, this.onFragLoaded, this),
              e.on(Am.FRAG_BUFFERED, this.onFragBuffered, this),
              e.on(Am.LEVEL_SWITCHING, this.onLevelSwitching, this),
              e.on(Am.LEVEL_LOADED, this.onLevelLoaded, this),
              e.on(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
              e.on(Am.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this),
              e.on(Am.ERROR, this.onError, this);
          }
          unregisterListeners() {
            const { hls: e } = this;
            e &&
              (e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
              e.off(Am.FRAG_LOADING, this.onFragLoading, this),
              e.off(Am.FRAG_LOADED, this.onFragLoaded, this),
              e.off(Am.FRAG_BUFFERED, this.onFragBuffered, this),
              e.off(Am.LEVEL_SWITCHING, this.onLevelSwitching, this),
              e.off(Am.LEVEL_LOADED, this.onLevelLoaded, this),
              e.off(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
              e.off(
                Am.MAX_AUTO_LEVEL_UPDATED,
                this.onMaxAutoLevelUpdated,
                this
              ),
              e.off(Am.ERROR, this.onError, this));
          }
          destroy() {
            this.unregisterListeners(),
              this.clearTimer(),
              (this.hls = this._abandonRulesCheck = null),
              (this.fragCurrent = this.partCurrent = null);
          }
          onManifestLoading(e, t) {
            (this.lastLoadedFragLevel = -1),
              (this.firstSelection = -1),
              (this.lastLevelLoadSec = 0),
              (this.fragCurrent = this.partCurrent = null),
              this.onLevelsUpdated(),
              this.clearTimer();
          }
          onLevelsUpdated() {
            this.lastLoadedFragLevel > -1 &&
              this.fragCurrent &&
              (this.lastLoadedFragLevel = this.fragCurrent.level),
              (this._nextAutoLevel = -1),
              this.onMaxAutoLevelUpdated(),
              (this.codecTiers = null),
              (this.audioTracksByGroup = null);
          }
          onMaxAutoLevelUpdated() {
            (this.firstSelection = -1), (this.nextAutoLevelKey = "");
          }
          onFragLoading(e, t) {
            const i = t.frag;
            if (!this.ignoreFragment(i)) {
              var s;
              if (!i.bitrateTest)
                (this.fragCurrent = i),
                  (this.partCurrent = null != (s = t.part) ? s : null);
              this.clearTimer(),
                (this.timer = self.setInterval(this._abandonRulesCheck, 100));
            }
          }
          onLevelSwitching(e, t) {
            this.clearTimer();
          }
          onError(e, t) {
            if (!t.fatal)
              switch (t.details) {
                case ym.BUFFER_ADD_CODEC_ERROR:
                case ym.BUFFER_APPEND_ERROR:
                  (this.lastLoadedFragLevel = -1), (this.firstSelection = -1);
                  break;
                case ym.FRAG_LOAD_TIMEOUT: {
                  const e = t.frag,
                    { fragCurrent: i, partCurrent: s } = this;
                  if (e && i && e.sn === i.sn && e.level === i.level) {
                    const t = performance.now(),
                      i = s ? s.stats : e.stats,
                      r = t - i.loading.start,
                      n = i.loading.first
                        ? i.loading.first - i.loading.start
                        : -1;
                    if (i.loaded && n > -1) {
                      const e = this.bwEstimator.getEstimateTTFB();
                      this.bwEstimator.sample(r - Math.min(e, n), i.loaded);
                    } else this.bwEstimator.sampleTTFB(r);
                  }
                  break;
                }
              }
          }
          getTimeToLoadFrag(e, t, i, s) {
            return e + i / t + (s ? e + this.lastLevelLoadSec : 0);
          }
          onLevelLoaded(e, t) {
            const i = this.hls.config,
              { loading: s } = t.stats,
              r = s.end - s.first;
            Tm(r) && (this.lastLevelLoadSec = r / 1e3),
              t.details.live
                ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive)
                : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD),
              this.timer > -1 && this._abandonRulesCheck(t.levelInfo);
          }
          onFragLoaded(e, { frag: t, part: i }) {
            const s = i ? i.stats : t.stats;
            if (
              (t.type === Cm.MAIN &&
                this.bwEstimator.sampleTTFB(s.loading.first - s.loading.start),
              !this.ignoreFragment(t))
            ) {
              if (
                (this.clearTimer(),
                t.level === this._nextAutoLevel && (this._nextAutoLevel = -1),
                (this.firstSelection = -1),
                this.hls.config.abrMaxWithRealBitrate)
              ) {
                const e = i ? i.duration : t.duration,
                  r = this.hls.levels[t.level],
                  n = (r.loaded ? r.loaded.bytes : 0) + s.loaded,
                  a = (r.loaded ? r.loaded.duration : 0) + e;
                (r.loaded = { bytes: n, duration: a }),
                  (r.realBitrate = Math.round((8 * n) / a));
              }
              if (t.bitrateTest) {
                const e = { stats: s, frag: t, part: i, id: t.type };
                this.onFragBuffered(Am.FRAG_BUFFERED, e), (t.bitrateTest = !1);
              } else this.lastLoadedFragLevel = t.level;
            }
          }
          onFragBuffered(e, t) {
            const { frag: i, part: s } = t,
              r = null != s && s.stats.loaded ? s.stats : i.stats;
            if (r.aborted) return;
            if (this.ignoreFragment(i)) return;
            const n =
              r.parsing.end -
              r.loading.start -
              Math.min(
                r.loading.first - r.loading.start,
                this.bwEstimator.getEstimateTTFB()
              );
            this.bwEstimator.sample(n, r.loaded),
              (r.bwEstimate = this.getBwEstimate()),
              i.bitrateTest
                ? (this.bitrateTestDelay = n / 1e3)
                : (this.bitrateTestDelay = 0);
          }
          ignoreFragment(e) {
            return e.type !== Cm.MAIN || "initSegment" === e.sn;
          }
          clearTimer() {
            this.timer > -1 &&
              (self.clearInterval(this.timer), (this.timer = -1));
          }
          get firstAutoLevel() {
            const { maxAutoLevel: e, minAutoLevel: t } = this.hls,
              i = this.getBwEstimate(),
              s = this.hls.config.maxStarvationDelay,
              r = this.findBestLevel(i, t, e, 0, s, 1, 1);
            if (r > -1) return r;
            const n = this.hls.firstLevel,
              a = Math.min(Math.max(n, t), e);
            return (
              this.warn(
                `Could not find best starting auto level. Defaulting to first in playlist ${n} clamped to ${a}`
              ),
              a
            );
          }
          get forcedAutoLevel() {
            return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;
          }
          get nextAutoLevel() {
            const e = this.forcedAutoLevel,
              t = this.bwEstimator.canEstimate(),
              i = this.lastLoadedFragLevel > -1;
            if (
              !(
                -1 === e ||
                (t && i && this.nextAutoLevelKey !== this.getAutoLevelKey())
              )
            )
              return e;
            const s = t && i ? this.getNextABRAutoLevel() : this.firstAutoLevel;
            if (-1 !== e) {
              const t = this.hls.levels;
              if (t.length > Math.max(e, s) && t[e].loadError <= t[s].loadError)
                return e;
            }
            return (
              (this._nextAutoLevel = s),
              (this.nextAutoLevelKey = this.getAutoLevelKey()),
              s
            );
          }
          getAutoLevelKey() {
            return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(
              2
            )}`;
          }
          getNextABRAutoLevel() {
            const { fragCurrent: e, partCurrent: t, hls: i } = this;
            if (i.levels.length <= 1) return i.loadLevel;
            const { maxAutoLevel: s, config: r, minAutoLevel: n } = i,
              a = t ? t.duration : e ? e.duration : 0,
              o = this.getBwEstimate(),
              c = this.getStarvationDelay();
            let d = r.abrBandWidthFactor,
              l = r.abrBandWidthUpFactor;
            if (c) {
              const e = this.findBestLevel(o, n, s, c, 0, d, l);
              if (e >= 0) return (this.rebufferNotice = -1), e;
            }
            let h = a
              ? Math.min(a, r.maxStarvationDelay)
              : r.maxStarvationDelay;
            if (!c) {
              const e = this.bitrateTestDelay;
              if (e) {
                (h =
                  (a ? Math.min(a, r.maxLoadingDelay) : r.maxLoadingDelay) - e),
                  this.info(
                    `bitrate test took ${Math.round(
                      1e3 * e
                    )}ms, set first fragment max fetchDuration to ${Math.round(
                      1e3 * h
                    )} ms`
                  ),
                  (d = l = 1);
              }
            }
            const u = this.findBestLevel(o, n, s, c, h, d, l);
            if (
              (this.rebufferNotice !== u &&
                ((this.rebufferNotice = u),
                this.info(
                  `${
                    c ? "rebuffering expected" : "buffer is empty"
                  }, optimal quality level ${u}`
                )),
              u > -1)
            )
              return u;
            const p = i.levels[n],
              f = i.loadLevelObj;
            return f && (null == p ? void 0 : p.bitrate) < f.bitrate
              ? n
              : i.loadLevel;
          }
          getStarvationDelay() {
            const e = this.hls,
              t = e.media;
            if (!t) return 1 / 0;
            const i = t && 0 !== t.playbackRate ? Math.abs(t.playbackRate) : 1,
              s = e.mainForwardBufferInfo;
            return (s ? s.len : 0) / i;
          }
          getBwEstimate() {
            return this.bwEstimator.canEstimate()
              ? this.bwEstimator.getEstimate()
              : this.hls.config.abrEwmaDefaultEstimate;
          }
          findBestLevel(e, t, i, s, r, n, a) {
            var o;
            const c = s + r,
              d = this.lastLoadedFragLevel,
              l = -1 === d ? this.hls.firstLevel : d,
              { fragCurrent: h, partCurrent: u } = this,
              {
                levels: p,
                allAudioTracks: f,
                loadLevel: E,
                config: m
              } = this.hls;
            if (1 === p.length) return 0;
            const g = p[l],
              _ = !(null == (o = this.hls.latestLevelDetails) || !o.live),
              T = -1 === E || -1 === d;
            let S,
              v = "SDR",
              R = (null == g ? void 0 : g.frameRate) || 0;
            const { audioPreference: y, videoPreference: A } = m,
              I = this.audioTracksByGroup || (this.audioTracksByGroup = r_(f));
            let C = -1;
            if (T) {
              if (-1 !== this.firstSelection) return this.firstSelection;
              const s =
                  this.codecTiers ||
                  (this.codecTiers = (function(e, t, i, s) {
                    return e.slice(i, s + 1).reduce((e, i, s) => {
                      if (!i.codecSet) return e;
                      const r = i.audioGroups;
                      let n = e[i.codecSet];
                      n ||
                        (e[i.codecSet] = n = {
                          minBitrate: 1 / 0,
                          minHeight: 1 / 0,
                          minFramerate: 1 / 0,
                          minIndex: s,
                          maxScore: 0,
                          videoRanges: { SDR: 0 },
                          channels: { 2: 0 },
                          hasDefaultAudio: !r,
                          fragmentError: 0
                        }),
                        (n.minBitrate = Math.min(n.minBitrate, i.bitrate));
                      const a = Math.min(i.height, i.width);
                      return (
                        (n.minHeight = Math.min(n.minHeight, a)),
                        (n.minFramerate = Math.min(
                          n.minFramerate,
                          i.frameRate
                        )),
                        (n.minIndex = Math.min(n.minIndex, s)),
                        (n.maxScore = Math.max(n.maxScore, i.score)),
                        (n.fragmentError += i.fragmentError),
                        (n.videoRanges[i.videoRange] =
                          (n.videoRanges[i.videoRange] || 0) + 1),
                        r &&
                          r.forEach(e => {
                            if (!e) return;
                            const i = t.groups[e];
                            i &&
                              ((n.hasDefaultAudio =
                                n.hasDefaultAudio || t.hasDefaultAudio
                                  ? i.hasDefault
                                  : i.hasAutoSelect ||
                                    (!t.hasDefaultAudio &&
                                      !t.hasAutoSelectAudio)),
                              Object.keys(i.channels).forEach(e => {
                                n.channels[e] =
                                  (n.channels[e] || 0) + i.channels[e];
                              }));
                          }),
                        e
                      );
                    }, {});
                  })(p, I, t, i)),
                r = (function(e, t, i, s, r) {
                  const n = Object.keys(e),
                    a = null == s ? void 0 : s.channels,
                    o = null == s ? void 0 : s.audioCodec,
                    c = null == r ? void 0 : r.videoCodec,
                    d = a && 2 === parseInt(a);
                  let l = !1,
                    h = !1,
                    u = 1 / 0,
                    p = 1 / 0,
                    f = 1 / 0,
                    E = 1 / 0,
                    m = 0,
                    g = [];
                  const { preferHDR: _, allowedVideoRanges: T } = t_(t, r);
                  for (let t = n.length; t--; ) {
                    const i = e[n[t]];
                    l || (l = i.channels[2] > 0),
                      (u = Math.min(u, i.minHeight)),
                      (p = Math.min(p, i.minFramerate)),
                      (f = Math.min(f, i.minBitrate)),
                      T.filter(e => i.videoRanges[e] > 0).length > 0 &&
                        (h = !0);
                  }
                  (u = Tm(u) ? u : 0), (p = Tm(p) ? p : 0);
                  const S = Math.max(1080, u),
                    v = Math.max(30, p);
                  (f = Tm(f) ? f : i), (i = Math.max(f, i)), h || (t = void 0);
                  const R = n.length > 1;
                  return {
                    codecSet: n.reduce((t, s) => {
                      const r = e[s];
                      if (s === t) return t;
                      if (
                        ((g = h ? T.filter(e => r.videoRanges[e] > 0) : []), R)
                      ) {
                        if (r.minBitrate > i)
                          return (
                            s_(
                              s,
                              `min bitrate of ${r.minBitrate} > current estimate of ${i}`
                            ),
                            t
                          );
                        if (!r.hasDefaultAudio)
                          return (
                            s_(
                              s,
                              "no renditions with default or auto-select sound found"
                            ),
                            t
                          );
                        if (o && s.indexOf(o.substring(0, 4)) % 5 != 0)
                          return (
                            s_(s, `audio codec preference "${o}" not found`), t
                          );
                        if (a && !d) {
                          if (!r.channels[a])
                            return (
                              s_(
                                s,
                                `no renditions with ${a} channel sound found (channels options: ${Object.keys(
                                  r.channels
                                )})`
                              ),
                              t
                            );
                        } else if ((!o || d) && l && 0 === r.channels[2])
                          return (
                            s_(s, "no renditions with stereo sound found"), t
                          );
                        if (r.minHeight > S)
                          return (
                            s_(
                              s,
                              `min resolution of ${r.minHeight} > maximum of ${S}`
                            ),
                            t
                          );
                        if (r.minFramerate > v)
                          return (
                            s_(
                              s,
                              `min framerate of ${r.minFramerate} > maximum of ${v}`
                            ),
                            t
                          );
                        if (!g.some(e => r.videoRanges[e] > 0))
                          return (
                            s_(
                              s,
                              `no variants with VIDEO-RANGE of ${i_(g)} found`
                            ),
                            t
                          );
                        if (c && s.indexOf(c.substring(0, 4)) % 5 != 0)
                          return (
                            s_(s, `video codec preference "${c}" not found`), t
                          );
                        if (r.maxScore < m)
                          return (
                            s_(
                              s,
                              `max score of ${r.maxScore} < selected max of ${m}`
                            ),
                            t
                          );
                      }
                      return t &&
                        (Mg(s) >= Mg(t) || r.fragmentError > e[t].fragmentError)
                        ? t
                        : ((E = r.minIndex), (m = r.maxScore), s);
                    }, void 0),
                    videoRanges: g,
                    preferHDR: _,
                    minFramerate: p,
                    minBitrate: f,
                    minIndex: E
                  };
                })(s, v, e, y, A),
                {
                  codecSet: n,
                  videoRanges: a,
                  minFramerate: o,
                  minBitrate: c,
                  minIndex: d,
                  preferHDR: l
                } = r;
              (C = d),
                (S = n),
                (v = l ? a[a.length - 1] : a[0]),
                (R = o),
                (e = Math.max(e, c)),
                this.log(`picked start tier ${i_(r)}`);
            } else
              (S = null == g ? void 0 : g.codecSet),
                (v = null == g ? void 0 : g.videoRange);
            const b = u ? u.duration : h ? h.duration : 0,
              O = this.bwEstimator.getEstimateTTFB() / 1e3,
              D = [];
            for (let o = i; o >= t; o--) {
              var w;
              const t = p[o],
                h = o > l;
              if (!t) continue;
              if (
                m.useMediaCapabilities &&
                !t.supportedResult &&
                !t.supportedPromise
              ) {
                const i = navigator.mediaCapabilities;
                "function" == typeof (null == i ? void 0 : i.decodingInfo) &&
                (Yg(t, I, v, R, e, y) || Rg(t.videoCodec))
                  ? ((t.supportedPromise = $g(t, I, i)),
                    t.supportedPromise.then(e => {
                      if (!this.hls) return;
                      t.supportedResult = e;
                      const i = this.hls.levels,
                        s = i.indexOf(t);
                      e.error
                        ? this.warn(
                            `MediaCapabilities decodingInfo error: "${
                              e.error
                            }" for level ${s} ${i_(e)}`
                          )
                        : e.supported ||
                          (this.warn(
                            `Unsupported MediaCapabilities decodingInfo result for level ${s} ${i_(
                              e
                            )}`
                          ),
                          s > -1 &&
                            i.length > 1 &&
                            (this.log(`Removing unsupported level ${s}`),
                            this.hls.removeLevel(s),
                            -1 === this.hls.loadLevel &&
                              (this.hls.nextLoadLevel = 0)));
                    }))
                  : (t.supportedResult = Hg);
              }
              if (
                ((S && t.codecSet !== S) ||
                  (v && t.videoRange !== v) ||
                  (h && R > t.frameRate) ||
                  (!h && R > 0 && R < t.frameRate) ||
                  (t.supportedResult &&
                    (null == (w = t.supportedResult.decodingInfoResults) ||
                      !w[0].smooth))) &&
                (!T || o !== C)
              ) {
                D.push(o);
                continue;
              }
              const f = t.details,
                g =
                  (u
                    ? null == f
                      ? void 0
                      : f.partTarget
                    : null == f
                    ? void 0
                    : f.averagetargetduration) || b;
              let A;
              A = h ? a * e : n * e;
              const L =
                  b && s >= 2 * b && 0 === r ? t.averageBitrate : t.maxBitrate,
                N = this.getTimeToLoadFrag(O, A, L * g, void 0 === f);
              if (
                A >= L &&
                (o === d || (0 === t.loadError && 0 === t.fragmentError)) &&
                (N <= O || !Tm(N) || (_ && !this.bitrateTestDelay) || N < c)
              ) {
                const e = this.forcedAutoLevel;
                return (
                  o === E ||
                    (-1 !== e && e === E) ||
                    (D.length &&
                      this.trace(
                        `Skipped level(s) ${D.join(
                          ","
                        )} of ${i} max with CODECS and VIDEO-RANGE:"${
                          p[D[0]].codecs
                        }" ${
                          p[D[0]].videoRange
                        }; not compatible with "${S}" ${v}`
                      ),
                    this.info(
                      `switch candidate:${l}->${o} adjustedbw(${Math.round(
                        A
                      )})-bitrate=${Math.round(A - L)} ttfb:${O.toFixed(
                        1
                      )} avgDuration:${g.toFixed(
                        1
                      )} maxFetchDuration:${c.toFixed(
                        1
                      )} fetchDuration:${N.toFixed(
                        1
                      )} firstSelection:${T} codecSet:${
                        t.codecSet
                      } videoRange:${t.videoRange} hls.loadLevel:${E}`
                    )),
                  T && (this.firstSelection = o),
                  o
                );
              }
            }
            return -1;
          }
          set nextAutoLevel(e) {
            const t = this.deriveNextAutoLevel(e);
            this._nextAutoLevel !== t &&
              ((this.nextAutoLevelKey = ""), (this._nextAutoLevel = t));
          }
          deriveNextAutoLevel(e) {
            const { maxAutoLevel: t, minAutoLevel: i } = this.hls;
            return Math.min(Math.max(e, i), t);
          }
        },
        bufferController: class extends Pm {
          constructor(e, t) {
            var i;
            super("buffer-controller", e.logger),
              (this.hls = void 0),
              (this.fragmentTracker = void 0),
              (this.details = null),
              (this._objectUrl = null),
              (this.operationQueue = null),
              (this.bufferCodecEventsTotal = 0),
              (this.media = null),
              (this.mediaSource = null),
              (this.lastMpegAudioChunk = null),
              (this.blockedAudioAppend = null),
              (this.lastVideoAppendEnd = 0),
              (this.appendSource = void 0),
              (this.transferData = void 0),
              (this.overrides = void 0),
              (this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }),
              (this.tracks = {}),
              (this.sourceBuffers = [
                [null, null],
                [null, null]
              ]),
              (this._onEndStreaming = e => {
                var t;
                this.hls &&
                  "open" ===
                    (null == (t = this.mediaSource) ? void 0 : t.readyState) &&
                  this.hls.pauseBuffering();
              }),
              (this._onStartStreaming = e => {
                this.hls && this.hls.resumeBuffering();
              }),
              (this._onMediaSourceOpen = e => {
                const { media: t, mediaSource: i } = this;
                e && this.log("Media source opened"),
                  t &&
                    i &&
                    (i.removeEventListener(
                      "sourceopen",
                      this._onMediaSourceOpen
                    ),
                    t.removeEventListener("emptied", this._onMediaEmptied),
                    this.updateDuration(),
                    this.hls.trigger(Am.MEDIA_ATTACHED, {
                      media: t,
                      mediaSource: i
                    }),
                    null !== this.mediaSource && this.checkPendingTracks());
              }),
              (this._onMediaSourceClose = () => {
                this.log("Media source closed");
              }),
              (this._onMediaSourceEnded = () => {
                this.log("Media source ended");
              }),
              (this._onMediaEmptied = () => {
                const { mediaSrc: e, _objectUrl: t } = this;
                e !== t &&
                  this.error(
                    `Media element src was set while attaching MediaSource (${t} > ${e})`
                  );
              }),
              (this.hls = e),
              (this.fragmentTracker = t),
              (this.appendSource =
                ((i = Vm(e.config.preferManagedMediaSource)),
                "undefined" != typeof self && i === self.ManagedMediaSource)),
              this.initTracks(),
              this.registerListeners();
          }
          hasSourceTypes() {
            return Object.keys(this.tracks).length > 0;
          }
          destroy() {
            this.unregisterListeners(),
              (this.details = null),
              (this.lastMpegAudioChunk = this.blockedAudioAppend = null),
              (this.transferData = this.overrides = void 0),
              this.operationQueue &&
                (this.operationQueue.destroy(), (this.operationQueue = null)),
              (this.hls = this.fragmentTracker = null),
              (this._onMediaSourceOpen = this._onMediaSourceClose = null),
              (this._onMediaSourceEnded = null),
              (this._onStartStreaming = this._onEndStreaming = null);
          }
          registerListeners() {
            const { hls: e } = this;
            e.on(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
              e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
              e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
              e.on(Am.MANIFEST_PARSED, this.onManifestParsed, this),
              e.on(Am.BUFFER_RESET, this.onBufferReset, this),
              e.on(Am.BUFFER_APPENDING, this.onBufferAppending, this),
              e.on(Am.BUFFER_CODECS, this.onBufferCodecs, this),
              e.on(Am.BUFFER_EOS, this.onBufferEos, this),
              e.on(Am.BUFFER_FLUSHING, this.onBufferFlushing, this),
              e.on(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
              e.on(Am.FRAG_PARSED, this.onFragParsed, this),
              e.on(Am.FRAG_CHANGED, this.onFragChanged, this),
              e.on(Am.ERROR, this.onError, this);
          }
          unregisterListeners() {
            const { hls: e } = this;
            e.off(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
              e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
              e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
              e.off(Am.MANIFEST_PARSED, this.onManifestParsed, this),
              e.off(Am.BUFFER_RESET, this.onBufferReset, this),
              e.off(Am.BUFFER_APPENDING, this.onBufferAppending, this),
              e.off(Am.BUFFER_CODECS, this.onBufferCodecs, this),
              e.off(Am.BUFFER_EOS, this.onBufferEos, this),
              e.off(Am.BUFFER_FLUSHING, this.onBufferFlushing, this),
              e.off(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
              e.off(Am.FRAG_PARSED, this.onFragParsed, this),
              e.off(Am.FRAG_CHANGED, this.onFragChanged, this),
              e.off(Am.ERROR, this.onError, this);
          }
          transferMedia() {
            const { media: e, mediaSource: t } = this;
            if (!e) return null;
            const i = {};
            if (this.operationQueue) {
              const e = this.isUpdating();
              e || this.operationQueue.removeBlockers();
              const t = this.isQueued();
              (e || t) &&
                this.warn(
                  `Transfering MediaSource with${
                    t ? " operations in queue" : ""
                  }${e ? " updating SourceBuffer(s)" : ""} ${
                    this.operationQueue
                  }`
                ),
                this.operationQueue.destroy();
            }
            const s = this.transferData;
            return (
              !this.sourceBufferCount && s && s.mediaSource === t
                ? wm(i, s.tracks)
                : this.sourceBuffers.forEach(e => {
                    const [t] = e;
                    t &&
                      ((i[t] = wm({}, this.tracks[t])), this.removeBuffer(t)),
                      (e[0] = e[1] = null);
                  }),
              { media: e, mediaSource: t, tracks: i }
            );
          }
          initTracks() {
            (this.sourceBuffers = [
              [null, null],
              [null, null]
            ]),
              (this.tracks = {}),
              this.resetQueue(),
              this.resetAppendErrors(),
              (this.lastMpegAudioChunk = this.blockedAudioAppend = null),
              (this.lastVideoAppendEnd = 0);
          }
          onManifestLoading() {
            (this.bufferCodecEventsTotal = 0), (this.details = null);
          }
          onManifestParsed(e, t) {
            var i;
            let s = 2;
            ((t.audio && !t.video) || !t.altAudio) && (s = 1),
              (this.bufferCodecEventsTotal = s),
              this.log(`${s} bufferCodec event(s) expected.`),
              null != (i = this.transferData) &&
                i.mediaSource &&
                this.sourceBufferCount &&
                s &&
                this.bufferCreated();
          }
          onMediaAttaching(e, t) {
            const i = (this.media = t.media),
              s = Vm(this.appendSource);
            if (((this.transferData = this.overrides = void 0), i && s)) {
              const e = !!t.mediaSource;
              (e || t.overrides) &&
                ((this.transferData = t), (this.overrides = t.overrides));
              const r = (this.mediaSource = t.mediaSource || new s());
              if ((this.assignMediaSource(r), e))
                (this._objectUrl = i.src), this.attachTransferred();
              else {
                const e = (this._objectUrl = self.URL.createObjectURL(r));
                if (this.appendSource)
                  try {
                    i.removeAttribute("src");
                    const t = self.ManagedMediaSource;
                    (i.disableRemotePlayback =
                      i.disableRemotePlayback || (t && r instanceof t)),
                      jv(i),
                      (function(e, t) {
                        const i = self.document.createElement("source");
                        (i.type = "video/mp4"), (i.src = t), e.appendChild(i);
                      })(i, e),
                      i.load();
                  } catch (t) {
                    i.src = e;
                  }
                else i.src = e;
              }
              i.addEventListener("emptied", this._onMediaEmptied);
            }
          }
          assignMediaSource(e) {
            var t, i;
            this.log(
              `${
                (null == (t = this.transferData) ? void 0 : t.mediaSource) === e
                  ? "transferred"
                  : "created"
              } media source: ${null == (i = e.constructor) ? void 0 : i.name}`
            ),
              e.addEventListener("sourceopen", this._onMediaSourceOpen),
              e.addEventListener("sourceended", this._onMediaSourceEnded),
              e.addEventListener("sourceclose", this._onMediaSourceClose),
              this.appendSource &&
                (e.addEventListener("startstreaming", this._onStartStreaming),
                e.addEventListener("endstreaming", this._onEndStreaming));
          }
          attachTransferred() {
            const e = this.media,
              t = this.transferData;
            if (!t || !e) return;
            const i = this.tracks,
              s = t.tracks,
              r = s ? Object.keys(s) : null,
              n = r ? r.length : 0,
              a = () => {
                this.media &&
                  this.mediaSourceOpenOrEnded &&
                  this._onMediaSourceOpen();
              };
            if (s && r && n) {
              if (!this.tracksReady)
                return (
                  (this.hls.config.startFragPrefetch = !0),
                  void this.log(
                    "attachTransferred: waiting for SourceBuffer track info"
                  )
                );
              if (
                (this.log(
                  `attachTransferred: (bufferCodecEventsTotal ${
                    this.bufferCodecEventsTotal
                  })\nrequired tracks: ${i_(i, (e, t) =>
                    "initSegment" === e ? void 0 : t
                  )};\ntransfer tracks: ${i_(s, (e, t) =>
                    "initSegment" === e ? void 0 : t
                  )}}`
                ),
                !Gm(s, i))
              ) {
                (t.mediaSource = null), (t.tracks = void 0);
                const r = e.currentTime,
                  n = this.details,
                  a = Math.max(
                    r,
                    (null == n ? void 0 : n.fragments[0].start) || 0
                  );
                return a - r > 1
                  ? void this.log(
                      `attachTransferred: waiting for playback to reach new tracks start time ${r} -> ${a}`
                    )
                  : (this.warn(
                      `attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(
                        s
                      )}"->"${Object.keys(
                        i
                      )}") start time: ${a} currentTime: ${r}`
                    ),
                    this.onMediaDetaching(Am.MEDIA_DETACHING, {}),
                    this.onMediaAttaching(Am.MEDIA_ATTACHING, t),
                    void (e.currentTime = a));
              }
              (this.transferData = void 0),
                r.forEach(e => {
                  const t = e,
                    i = s[t];
                  if (i) {
                    const e = i.buffer;
                    if (e) {
                      const s = this.fragmentTracker,
                        r = i.id;
                      if (s.hasFragments(r) || s.hasParts(r)) {
                        const i = K_.getBuffered(e);
                        s.detectEvictedFragments(t, i, r, null, !0);
                      }
                      const n = Hv(t),
                        a = [t, e];
                      (this.sourceBuffers[n] = a),
                        e.updating &&
                          this.operationQueue &&
                          this.operationQueue.prependBlocker(t),
                        this.trackSourceBuffer(t, i);
                    }
                  }
                }),
                a(),
                this.bufferCreated();
            } else
              this.log("attachTransferred: MediaSource w/o SourceBuffers"), a();
          }
          get mediaSourceOpenOrEnded() {
            var e;
            const t = null == (e = this.mediaSource) ? void 0 : e.readyState;
            return "open" === t || "ended" === t;
          }
          onMediaDetaching(e, t) {
            const i = !!t.transferMedia;
            this.transferData = this.overrides = void 0;
            const { media: s, mediaSource: r, _objectUrl: n } = this;
            if (r) {
              if (
                (this.log("media source " + (i ? "transferring" : "detaching")),
                i)
              )
                this.sourceBuffers.forEach(([e]) => {
                  e && this.removeBuffer(e);
                }),
                  this.resetQueue();
              else {
                if (this.mediaSourceOpenOrEnded) {
                  const e = "open" === r.readyState;
                  try {
                    const t = r.sourceBuffers;
                    for (let i = t.length; i--; )
                      e && t[i].abort(), r.removeSourceBuffer(t[i]);
                    e && r.endOfStream();
                  } catch (e) {
                    this.warn(
                      `onMediaDetaching: ${e.message} while calling endOfStream`
                    );
                  }
                }
                this.sourceBufferCount && this.onBufferReset();
              }
              r.removeEventListener("sourceopen", this._onMediaSourceOpen),
                r.removeEventListener("sourceended", this._onMediaSourceEnded),
                r.removeEventListener("sourceclose", this._onMediaSourceClose),
                this.appendSource &&
                  (r.removeEventListener(
                    "startstreaming",
                    this._onStartStreaming
                  ),
                  r.removeEventListener("endstreaming", this._onEndStreaming)),
                (this.mediaSource = null),
                (this._objectUrl = null);
            }
            s &&
              (s.removeEventListener("emptied", this._onMediaEmptied),
              i ||
                (n && self.URL.revokeObjectURL(n),
                this.mediaSrc === n
                  ? (s.removeAttribute("src"),
                    this.appendSource && jv(s),
                    s.load())
                  : this.warn(
                      "media|source.src was changed by a third party - skip cleanup"
                    )),
              (this.media = null)),
              this.hls.trigger(Am.MEDIA_DETACHED, t);
          }
          onBufferReset() {
            this.sourceBuffers.forEach(([e]) => {
              e && this.resetBuffer(e);
            }),
              this.initTracks();
          }
          resetBuffer(e) {
            var t;
            const i = null == (t = this.tracks[e]) ? void 0 : t.buffer;
            if ((this.removeBuffer(e), i))
              try {
                var s;
                null != (s = this.mediaSource) &&
                  s.sourceBuffers.length &&
                  this.mediaSource.removeSourceBuffer(i);
              } catch (t) {
                this.warn(`onBufferReset ${e}`, t);
              }
            delete this.tracks[e];
          }
          removeBuffer(e) {
            this.removeBufferListeners(e),
              (this.sourceBuffers[Hv(e)] = [null, null]);
            const t = this.tracks[e];
            t && (t.buffer = void 0);
          }
          resetQueue() {
            this.operationQueue && this.operationQueue.destroy(),
              (this.operationQueue = new Fv(this.tracks));
          }
          onBufferCodecs(e, t) {
            const i = this.tracks,
              s = Object.keys(t);
            this.log(
              `BUFFER_CODECS: "${s}" (current SB count ${this.sourceBufferCount})`
            );
            const r =
                ("audiovideo" in t && (i.audio || i.video)) ||
                (i.audiovideo && ("audio" in t || "video" in t)),
              n =
                !r &&
                this.sourceBufferCount &&
                this.media &&
                s.some(e => !i[e]);
            r || n
              ? this.warn(
                  `Unsupported transition between "${Object.keys(
                    i
                  )}" and "${s}" SourceBuffers`
                )
              : (s.forEach(e => {
                  var s, r, n;
                  const a = t[e],
                    {
                      id: o,
                      codec: c,
                      levelCodec: d,
                      container: l,
                      metadata: h,
                      supplemental: u
                    } = a;
                  let p = i[e];
                  const f =
                      null == (s = this.transferData) || null == (r = s.tracks)
                        ? void 0
                        : r[e],
                    E = null != f && f.buffer ? f : p,
                    m =
                      (null == E ? void 0 : E.pendingCodec) ||
                      (null == E ? void 0 : E.codec),
                    g = null == E ? void 0 : E.levelCodec;
                  p ||
                    (p = i[e] = {
                      buffer: void 0,
                      listeners: [],
                      codec: c,
                      supplemental: u,
                      container: l,
                      levelCodec: d,
                      metadata: h,
                      id: o
                    });
                  const _ = Bg(m, g),
                    T = null == _ ? void 0 : _.replace(Bv, "$1");
                  let S = Bg(c, d);
                  const v = null == (n = S) ? void 0 : n.replace(Bv, "$1");
                  S &&
                    _ &&
                    T !== v &&
                    ("audio" === e.slice(0, 5) &&
                      (S = Fg(S, this.appendSource)),
                    this.log(`switching codec ${m} to ${S}`),
                    S !== (p.pendingCodec || p.codec) && (p.pendingCodec = S),
                    (p.container = l),
                    this.appendChangeType(e, l, S));
                }),
                (this.tracksReady || this.sourceBufferCount) &&
                  (t.tracks = this.sourceBufferTracks),
                this.sourceBufferCount ||
                  (this.mediaSourceOpenOrEnded && this.checkPendingTracks()));
          }
          get sourceBufferTracks() {
            return Object.keys(this.tracks).reduce((e, t) => {
              const i = this.tracks[t];
              return (
                (e[t] = {
                  id: i.id,
                  container: i.container,
                  codec: i.codec,
                  levelCodec: i.levelCodec
                }),
                e
              );
            }, {});
          }
          appendChangeType(e, t, i) {
            const s = `${t};codecs=${i}`,
              r = {
                label: `change-type=${s}`,
                execute: () => {
                  const r = this.tracks[e];
                  if (r) {
                    const n = r.buffer;
                    null != n &&
                      n.changeType &&
                      (this.log(`changing ${e} sourceBuffer type to ${s}`),
                      n.changeType(s),
                      (r.codec = i),
                      (r.container = t));
                  }
                  this.shiftAndExecuteNext(e);
                },
                onStart: () => {},
                onComplete: () => {},
                onError: t => {
                  this.warn(`Failed to change ${e} SourceBuffer type`, t);
                }
              };
            this.append(r, e, this.isPending(this.tracks[e]));
          }
          blockAudio(e) {
            var t;
            const i = e.start,
              s = i + 0.05 * e.duration;
            if (
              !0 ===
              (null == (t = this.fragmentTracker.getAppendedFrag(i, Cm.MAIN))
                ? void 0
                : t.gap)
            )
              return;
            const r = {
              label: "block-audio",
              execute: () => {
                var e;
                const t = this.tracks.video;
                (this.lastVideoAppendEnd > s ||
                  (null != t && t.buffer && K_.isBuffered(t.buffer, s)) ||
                  !0 ===
                    (null ==
                    (e = this.fragmentTracker.getAppendedFrag(s, Cm.MAIN))
                      ? void 0
                      : e.gap)) &&
                  ((this.blockedAudioAppend = null),
                  this.shiftAndExecuteNext("audio"));
              },
              onStart: () => {},
              onComplete: () => {},
              onError: e => {
                this.warn("Error executing block-audio operation", e);
              }
            };
            (this.blockedAudioAppend = { op: r, frag: e }),
              this.append(r, "audio", !0);
          }
          unblockAudio() {
            const { blockedAudioAppend: e, operationQueue: t } = this;
            e && t && ((this.blockedAudioAppend = null), t.unblockAudio(e.op));
          }
          onBufferAppending(e, t) {
            const { tracks: i } = this,
              {
                data: s,
                type: r,
                parent: n,
                frag: a,
                part: o,
                chunkMeta: c
              } = t,
              d = c.buffering[r],
              l = a.sn,
              h = self.performance.now();
            d.start = h;
            const u = a.stats.buffering,
              p = o ? o.stats.buffering : null;
            0 === u.start && (u.start = h), p && 0 === p.start && (p.start = h);
            const f = i.audio;
            let E = !1;
            "audio" === r &&
              "audio/mpeg" === (null == f ? void 0 : f.container) &&
              ((E =
                !this.lastMpegAudioChunk ||
                1 === c.id ||
                this.lastMpegAudioChunk.sn !== c.sn),
              (this.lastMpegAudioChunk = c));
            const m = this.tracks.video,
              g = null == m ? void 0 : m.buffer;
            if (g && "initSegment" !== l) {
              const e = o || a,
                t = this.blockedAudioAppend;
              if ("audio" !== r || "main" === n || this.blockedAudioAppend) {
                if ("video" === r) {
                  const i = e.end;
                  if (t) {
                    const e = t.frag.start;
                    (i > e ||
                      i < this.lastVideoAppendEnd ||
                      K_.isBuffered(g, e)) &&
                      this.unblockAudio();
                  }
                  this.lastVideoAppendEnd = i;
                }
              } else {
                const t = e.start + 0.05 * e.duration,
                  i = g.buffered,
                  s = this.currentOp("video");
                i.length || s
                  ? !s &&
                    !K_.isBuffered(g, t) &&
                    this.lastVideoAppendEnd < t &&
                    this.blockAudio(e)
                  : this.blockAudio(e);
              }
            }
            const _ = (o || a).start,
              T = {
                label: `append-${r}`,
                execute: () => {
                  if (((d.executeStart = self.performance.now()), E)) {
                    const e = this.tracks[r];
                    if (e) {
                      const t = e.buffer;
                      if (t) {
                        const e = _ - t.timestampOffset;
                        Math.abs(e) >= 0.1 &&
                          (this.log(
                            `Updating audio SourceBuffer timestampOffset to ${_} (delta: ${e}) sn: ${l})`
                          ),
                          (t.timestampOffset = _));
                      }
                    }
                  }
                  this.appendExecutor(s, r);
                },
                onStart: () => {},
                onComplete: () => {
                  const e = self.performance.now();
                  (d.executeEnd = d.end = e),
                    0 === u.first && (u.first = e),
                    p && 0 === p.first && (p.first = e);
                  const t = {};
                  this.sourceBuffers.forEach(([e, i]) => {
                    e && (t[e] = K_.getBuffered(i));
                  }),
                    (this.appendErrors[r] = 0),
                    "audio" === r || "video" === r
                      ? (this.appendErrors.audiovideo = 0)
                      : ((this.appendErrors.audio = 0),
                        (this.appendErrors.video = 0)),
                    this.hls.trigger(Am.BUFFER_APPENDED, {
                      type: r,
                      frag: a,
                      part: o,
                      chunkMeta: c,
                      parent: a.type,
                      timeRanges: t
                    });
                },
                onError: e => {
                  var t;
                  const i = {
                    type: Rm.MEDIA_ERROR,
                    parent: a.type,
                    details: ym.BUFFER_APPEND_ERROR,
                    sourceBufferName: r,
                    frag: a,
                    part: o,
                    chunkMeta: c,
                    error: e,
                    err: e,
                    fatal: !1
                  };
                  if (e.code === DOMException.QUOTA_EXCEEDED_ERR)
                    i.details = ym.BUFFER_FULL_ERROR;
                  else if (
                    e.code !== DOMException.INVALID_STATE_ERR ||
                    !this.mediaSourceOpenOrEnded ||
                    (null != (t = this.media) && t.error)
                  )
                    if (e.name === Vv)
                      0 === this.sourceBufferCount
                        ? (i.errorAction = y_(!0))
                        : ++this.appendErrors[r];
                    else {
                      const e = ++this.appendErrors[r];
                      this.warn(
                        `Failed ${e}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${r}" sourceBuffer`
                      ),
                        e >= this.hls.config.appendErrorMaxRetry &&
                          (i.fatal = !0);
                    }
                  else i.errorAction = y_(!0);
                  this.hls.trigger(Am.ERROR, i);
                }
              };
            this.append(T, r, this.isPending(this.tracks[r]));
          }
          getFlushOp(e, t, i) {
            return (
              this.log(`queuing "${e}" remove ${t}-${i}`),
              {
                label: "remove",
                execute: () => {
                  this.removeExecutor(e, t, i);
                },
                onStart: () => {},
                onComplete: () => {
                  this.hls.trigger(Am.BUFFER_FLUSHED, { type: e });
                },
                onError: s => {
                  this.warn(
                    `Failed to remove ${t}-${i} from "${e}" SourceBuffer`,
                    s
                  );
                }
              }
            );
          }
          onBufferFlushing(e, t) {
            const { type: i, startOffset: s, endOffset: r } = t;
            i
              ? this.append(this.getFlushOp(i, s, r), i)
              : this.sourceBuffers.forEach(([e]) => {
                  e && this.append(this.getFlushOp(e, s, r), e);
                });
          }
          onFragParsed(e, t) {
            const { frag: i, part: s } = t,
              r = [],
              n = s ? s.elementaryStreams : i.elementaryStreams;
            n[Xm.AUDIOVIDEO]
              ? r.push("audiovideo")
              : (n[Xm.AUDIO] && r.push("audio"),
                n[Xm.VIDEO] && r.push("video"));
            0 === r.length &&
              this.warn(
                `Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`
              ),
              this.blockBuffers(() => {
                const e = self.performance.now();
                (i.stats.buffering.end = e), s && (s.stats.buffering.end = e);
                const t = s ? s.stats : i.stats;
                this.hls.trigger(Am.FRAG_BUFFERED, {
                  frag: i,
                  part: s,
                  stats: t,
                  id: i.type
                });
              }, r);
          }
          onFragChanged(e, t) {
            this.trimBuffers();
          }
          get bufferedToEnd() {
            return (
              this.sourceBufferCount > 0 &&
              !this.sourceBuffers.some(([e]) => {
                var t, i;
                return (
                  e &&
                  (!(null != (t = this.tracks[e]) && t.ended) ||
                    (null == (i = this.tracks[e]) ? void 0 : i.ending))
                );
              })
            );
          }
          onBufferEos(e, t) {
            var i;
            this.sourceBuffers.forEach(([e]) => {
              if (e) {
                const i = this.tracks[e];
                (t.type && t.type !== e) ||
                  ((i.ending = !0),
                  i.ended ||
                    ((i.ended = !0), this.log(`${e} buffer reached EOS`)));
              }
            });
            const s =
              !1 !== (null == (i = this.overrides) ? void 0 : i.endOfStream);
            this.sourceBufferCount > 0 &&
              !this.sourceBuffers.some(([e]) => {
                var t;
                return e && !(null != (t = this.tracks[e]) && t.ended);
              }) &&
              (s
                ? (this.log("Queueing EOS"),
                  this.blockUntilOpen(() => {
                    this.tracksEnded();
                    const { mediaSource: e } = this;
                    e && "open" === e.readyState
                      ? (this.log("Calling mediaSource.endOfStream()"),
                        e.endOfStream(),
                        this.hls.trigger(Am.BUFFERED_TO_END, void 0))
                      : e &&
                        this.log(
                          `Could not call mediaSource.endOfStream(). mediaSource.readyState: ${e.readyState}`
                        );
                  }))
                : (this.tracksEnded(),
                  this.hls.trigger(Am.BUFFERED_TO_END, void 0)));
          }
          tracksEnded() {
            this.sourceBuffers.forEach(([e]) => {
              if (null !== e) {
                const t = this.tracks[e];
                t && (t.ending = !1);
              }
            });
          }
          onLevelUpdated(e, { details: t }) {
            t.fragments.length && ((this.details = t), this.updateDuration());
          }
          updateDuration() {
            const e = this.getDurationAndRange();
            e && this.blockUntilOpen(() => this.updateMediaSource(e));
          }
          onError(e, t) {
            if (t.details === ym.BUFFER_APPEND_ERROR && t.frag) {
              var i;
              const e = null == (i = t.errorAction) ? void 0 : i.nextAutoLevel;
              Tm(e) && e !== t.frag.level && this.resetAppendErrors();
            }
          }
          resetAppendErrors() {
            this.appendErrors = { audio: 0, video: 0, audiovideo: 0 };
          }
          trimBuffers() {
            const { hls: e, details: t, media: i } = this;
            if (!i || null === t) return;
            if (!this.sourceBufferCount) return;
            const s = e.config,
              r = i.currentTime,
              n = t.levelTargetDuration,
              a =
                t.live && null !== s.liveBackBufferLength
                  ? s.liveBackBufferLength
                  : s.backBufferLength;
            if (Tm(a) && a >= 0) {
              const e = Math.max(a, n),
                t = Math.floor(r / n) * n - e;
              this.flushBackBuffer(r, n, t);
            }
            if (
              Tm(s.frontBufferFlushThreshold) &&
              s.frontBufferFlushThreshold > 0
            ) {
              const e = Math.max(
                  s.maxBufferLength,
                  s.frontBufferFlushThreshold
                ),
                t = Math.max(e, n),
                i = Math.floor(r / n) * n + t;
              this.flushFrontBuffer(r, n, i);
            }
          }
          flushBackBuffer(e, t, i) {
            this.sourceBuffers.forEach(([e, t]) => {
              if (t) {
                const r = K_.getBuffered(t);
                if (r.length > 0 && i > r.start(0)) {
                  var s;
                  this.hls.trigger(Am.BACK_BUFFER_REACHED, { bufferEnd: i });
                  const t = this.tracks[e];
                  if (null != (s = this.details) && s.live)
                    this.hls.trigger(Am.LIVE_BACK_BUFFER_REACHED, {
                      bufferEnd: i
                    });
                  else if (null != t && t.ended)
                    return void this.log(
                      `Cannot flush ${e} back buffer while SourceBuffer is in ended state`
                    );
                  this.hls.trigger(Am.BUFFER_FLUSHING, {
                    startOffset: 0,
                    endOffset: i,
                    type: e
                  });
                }
              }
            });
          }
          flushFrontBuffer(e, t, i) {
            this.sourceBuffers.forEach(([t, s]) => {
              if (s) {
                const r = K_.getBuffered(s),
                  n = r.length;
                if (n < 2) return;
                const a = r.start(n - 1),
                  o = r.end(n - 1);
                if (i > a || (e >= a && e <= o)) return;
                this.hls.trigger(Am.BUFFER_FLUSHING, {
                  startOffset: a,
                  endOffset: 1 / 0,
                  type: t
                });
              }
            });
          }
          getDurationAndRange() {
            var e;
            const { details: t, mediaSource: i } = this;
            if (
              !t ||
              !this.media ||
              "open" !== (null == i ? void 0 : i.readyState)
            )
              return null;
            const s = t.edge;
            if (t.live && this.hls.config.liveDurationInfinity) {
              if (t.fragments.length && t.live && i.setLiveSeekableRange) {
                const e = Math.max(0, t.fragmentStart);
                return { duration: 1 / 0, start: e, end: Math.max(e, s) };
              }
              return { duration: 1 / 0 };
            }
            const r = null == (e = this.overrides) ? void 0 : e.duration;
            if (r) return Tm(r) ? { duration: r } : null;
            const n = this.media.duration;
            return (s > (Tm(i.duration) ? i.duration : 0) && s > n) || !Tm(n)
              ? { duration: s }
              : null;
          }
          updateMediaSource({ duration: e, start: t, end: i }) {
            const s = this.mediaSource;
            this.media &&
              s &&
              "open" === s.readyState &&
              (s.duration !== e &&
                (Tm(e) &&
                  this.log(`Updating MediaSource duration to ${e.toFixed(3)}`),
                (s.duration = e)),
              void 0 !== t &&
                void 0 !== i &&
                (this.log(
                  `MediaSource duration is set to ${s.duration}. Setting seekable range to ${t}-${i}.`
                ),
                s.setLiveSeekableRange(t, i)));
          }
          get tracksReady() {
            const e = this.pendingTrackCount;
            return (
              e > 0 &&
              (e >= this.bufferCodecEventsTotal ||
                this.isPending(this.tracks.audiovideo))
            );
          }
          checkPendingTracks() {
            const {
              bufferCodecEventsTotal: e,
              pendingTrackCount: t,
              tracks: i
            } = this;
            if (
              (this.log(
                `checkPendingTracks (pending: ${t} codec events expected: ${e}) ${i_(
                  i
                )}`
              ),
              this.tracksReady)
            ) {
              var s;
              const e = null == (s = this.transferData) ? void 0 : s.tracks;
              e && Object.keys(e).length
                ? this.attachTransferred()
                : this.createSourceBuffers();
            }
          }
          bufferCreated() {
            if (this.sourceBufferCount) {
              const e = {};
              this.sourceBuffers.forEach(([t, i]) => {
                if (t) {
                  const s = this.tracks[t];
                  e[t] = {
                    buffer: i,
                    container: s.container,
                    codec: s.codec,
                    supplemental: s.supplemental,
                    levelCodec: s.levelCodec,
                    id: s.id,
                    metadata: s.metadata
                  };
                }
              }),
                this.hls.trigger(Am.BUFFER_CREATED, { tracks: e }),
                this.log(
                  `SourceBuffers created. Running queue: ${this.operationQueue}`
                ),
                this.sourceBuffers.forEach(([e]) => {
                  this.executeNext(e);
                });
            } else {
              const e = new Error(
                "could not create source buffer for media codec(s)"
              );
              this.hls.trigger(Am.ERROR, {
                type: Rm.MEDIA_ERROR,
                details: ym.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                fatal: !0,
                error: e,
                reason: e.message
              });
            }
          }
          createSourceBuffers() {
            const { tracks: e, sourceBuffers: t, mediaSource: i } = this;
            if (!i)
              throw new Error(
                "createSourceBuffers called when mediaSource was null"
              );
            for (const r in e) {
              const n = r,
                a = e[n];
              if (this.isPending(a)) {
                const e = this.getTrackCodec(a, n),
                  r = `${a.container};codecs=${e}`;
                (a.codec = e),
                  this.log(
                    `creating sourceBuffer(${r})${
                      this.currentOp(n) ? " Queued" : ""
                    } ${i_(a)}`
                  );
                try {
                  const e = i.addSourceBuffer(r),
                    s = Hv(n),
                    o = [n, e];
                  (t[s] = o), (a.buffer = e);
                } catch (e) {
                  var s;
                  return (
                    this.error(
                      `error while trying to add sourceBuffer: ${e.message}`
                    ),
                    this.shiftAndExecuteNext(n),
                    null == (s = this.operationQueue) || s.removeBlockers(),
                    delete this.tracks[n],
                    void this.hls.trigger(Am.ERROR, {
                      type: Rm.MEDIA_ERROR,
                      details: ym.BUFFER_ADD_CODEC_ERROR,
                      fatal: !1,
                      error: e,
                      sourceBufferName: n,
                      mimeType: r,
                      parent: a.id
                    })
                  );
                }
                this.trackSourceBuffer(n, a);
              }
            }
            this.bufferCreated();
          }
          getTrackCodec(e, t) {
            const i = e.supplemental;
            let s = e.codec;
            i &&
              ("video" === t || "audiovideo" === t) &&
              Lg(i, "video") &&
              (s = (function(e, t) {
                const i = [];
                if (e) {
                  const t = e.split(",");
                  for (let e = 0; e < t.length; e++)
                    wg(t[e], "video") || i.push(t[e]);
                }
                return t && i.push(t), i.join(",");
              })(s, i));
            const r = Bg(s, e.levelCodec);
            return r
              ? "audio" === t.slice(0, 5)
                ? Fg(r, this.appendSource)
                : r
              : "";
          }
          trackSourceBuffer(e, t) {
            const i = t.buffer;
            if (!i) return;
            const s = this.getTrackCodec(t, e);
            (this.tracks[e] = {
              buffer: i,
              codec: s,
              container: t.container,
              levelCodec: t.levelCodec,
              supplemental: t.supplemental,
              metadata: t.metadata,
              id: t.id,
              listeners: []
            }),
              this.removeBufferListeners(e),
              this.addBufferListener(e, "updatestart", this.onSBUpdateStart),
              this.addBufferListener(e, "updateend", this.onSBUpdateEnd),
              this.addBufferListener(e, "error", this.onSBUpdateError),
              this.appendSource &&
                this.addBufferListener(e, "bufferedchange", (e, t) => {
                  const i = t.removedRanges;
                  null != i &&
                    i.length &&
                    this.hls.trigger(Am.BUFFER_FLUSHED, { type: e });
                });
          }
          get mediaSrc() {
            var e, t;
            const i =
              (null == (e = this.media) || null == (t = e.querySelector)
                ? void 0
                : t.call(e, "source")) || this.media;
            return null == i ? void 0 : i.src;
          }
          onSBUpdateStart(e) {
            const t = this.currentOp(e);
            t && t.onStart();
          }
          onSBUpdateEnd(e) {
            var t;
            if (
              "closed" ===
              (null == (t = this.mediaSource) ? void 0 : t.readyState)
            )
              return void this.resetBuffer(e);
            const i = this.currentOp(e);
            i && (i.onComplete(), this.shiftAndExecuteNext(e));
          }
          onSBUpdateError(e, t) {
            var i;
            const s = new Error(
              `${e} SourceBuffer error. MediaSource readyState: ${
                null == (i = this.mediaSource) ? void 0 : i.readyState
              }`
            );
            this.error(`${s}`, t),
              this.hls.trigger(Am.ERROR, {
                type: Rm.MEDIA_ERROR,
                details: ym.BUFFER_APPENDING_ERROR,
                sourceBufferName: e,
                error: s,
                fatal: !1
              });
            const r = this.currentOp(e);
            r && r.onError(s);
          }
          removeExecutor(e, t, i) {
            const { media: s, mediaSource: r } = this,
              n = this.tracks[e],
              a = null == n ? void 0 : n.buffer;
            if (!s || !r || !a)
              return (
                this.warn(
                  `Attempting to remove from the ${e} SourceBuffer, but it does not exist`
                ),
                void this.shiftAndExecuteNext(e)
              );
            const o = Tm(s.duration) ? s.duration : 1 / 0,
              c = Tm(r.duration) ? r.duration : 1 / 0,
              d = Math.max(0, t),
              l = Math.min(i, o, c);
            l > d && (!n.ending || n.ended)
              ? ((n.ended = !1),
                this.log(`Removing [${d},${l}] from the ${e} SourceBuffer`),
                a.remove(d, l))
              : this.shiftAndExecuteNext(e);
          }
          appendExecutor(e, t) {
            const i = this.tracks[t],
              s = null == i ? void 0 : i.buffer;
            if (!s)
              throw new Gv(
                `Attempting to append to the ${t} SourceBuffer, but it does not exist`
              );
            (i.ending = !1), (i.ended = !1), s.appendBuffer(e);
          }
          blockUntilOpen(e) {
            this.isUpdating() || this.isQueued() ? this.blockBuffers(e) : e();
          }
          isUpdating() {
            return this.sourceBuffers.some(([e, t]) => e && t.updating);
          }
          isQueued() {
            return this.sourceBuffers.some(([e]) => e && !!this.currentOp(e));
          }
          isPending(e) {
            return !!e && !e.buffer;
          }
          blockBuffers(e, t = this.sourceBufferTypes) {
            if (!t.length)
              return (
                this.log(
                  "Blocking operation requested, but no SourceBuffers exist"
                ),
                void Promise.resolve().then(e)
              );
            const { operationQueue: i } = this,
              s = t.map(e => this.appendBlocker(e));
            t.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(),
              Promise.all(s).then(s => {
                i === this.operationQueue && (e(), this.stepOperationQueue(t));
              });
          }
          stepOperationQueue(e) {
            e.forEach(e => {
              var t;
              const i = null == (t = this.tracks[e]) ? void 0 : t.buffer;
              i && !i.updating && this.shiftAndExecuteNext(e);
            });
          }
          append(e, t, i) {
            this.operationQueue && this.operationQueue.append(e, t, i);
          }
          appendBlocker(e) {
            if (this.operationQueue)
              return this.operationQueue.appendBlocker(e);
          }
          currentOp(e) {
            return this.operationQueue ? this.operationQueue.current(e) : null;
          }
          executeNext(e) {
            e && this.operationQueue && this.operationQueue.executeNext(e);
          }
          shiftAndExecuteNext(e) {
            this.operationQueue && this.operationQueue.shiftAndExecuteNext(e);
          }
          get pendingTrackCount() {
            return Object.keys(this.tracks).reduce(
              (e, t) => e + (this.isPending(this.tracks[t]) ? 1 : 0),
              0
            );
          }
          get sourceBufferCount() {
            return this.sourceBuffers.reduce((e, [t]) => e + (t ? 1 : 0), 0);
          }
          get sourceBufferTypes() {
            return this.sourceBuffers.map(([e]) => e).filter(e => !!e);
          }
          addBufferListener(e, t, i) {
            const s = this.tracks[e];
            if (!s) return;
            const r = s.buffer;
            if (!r) return;
            const n = i.bind(this, e);
            s.listeners.push({ event: t, listener: n }),
              r.addEventListener(t, n);
          }
          removeBufferListeners(e) {
            const t = this.tracks[e];
            if (!t) return;
            const i = t.buffer;
            i &&
              (t.listeners.forEach(e => {
                i.removeEventListener(e.event, e.listener);
              }),
              (t.listeners.length = 0));
          }
        },
        capLevelController: Kv,
        errorController: class extends Pm {
          constructor(e) {
            super("error-controller", e.logger),
              (this.hls = void 0),
              (this.playlistError = 0),
              (this.penalizedRenditions = {}),
              (this.hls = e),
              this.registerListeners();
          }
          registerListeners() {
            const e = this.hls;
            e.on(Am.ERROR, this.onError, this),
              e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
              e.on(Am.LEVEL_UPDATED, this.onLevelUpdated, this);
          }
          unregisterListeners() {
            const e = this.hls;
            e &&
              (e.off(Am.ERROR, this.onError, this),
              e.off(Am.ERROR, this.onErrorOut, this),
              e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
              e.off(Am.LEVEL_UPDATED, this.onLevelUpdated, this));
          }
          destroy() {
            this.unregisterListeners(),
              (this.hls = null),
              (this.penalizedRenditions = {});
          }
          startLoad(e) {}
          stopLoad() {
            this.playlistError = 0;
          }
          getVariantLevelIndex(e) {
            return (null == e ? void 0 : e.type) === Cm.MAIN
              ? e.level
              : this.hls.loadLevel;
          }
          onManifestLoading() {
            (this.playlistError = 0), (this.penalizedRenditions = {});
          }
          onLevelUpdated() {
            this.playlistError = 0;
          }
          onError(e, t) {
            var i;
            if (t.fatal) return;
            const s = this.hls,
              r = t.context;
            switch (t.details) {
              case ym.FRAG_LOAD_ERROR:
              case ym.FRAG_LOAD_TIMEOUT:
              case ym.KEY_LOAD_ERROR:
              case ym.KEY_LOAD_TIMEOUT:
                return void (t.errorAction = this.getFragRetryOrSwitchAction(
                  t
                ));
              case ym.FRAG_PARSING_ERROR:
                if (null != (i = t.frag) && i.gap)
                  return void (t.errorAction = y_());
              case ym.FRAG_GAP:
              case ym.FRAG_DECRYPT_ERROR:
                return (
                  (t.errorAction = this.getFragRetryOrSwitchAction(t)),
                  void (t.errorAction.action = v_.SendAlternateToPenaltyBox)
                );
              case ym.LEVEL_EMPTY_ERROR:
              case ym.LEVEL_PARSING_ERROR:
                {
                  var n, a;
                  const e = t.parent === Cm.MAIN ? t.level : s.loadLevel;
                  t.details === ym.LEVEL_EMPTY_ERROR &&
                  null != (n = t.context) &&
                  null != (a = n.levelDetails) &&
                  a.live
                    ? (t.errorAction = this.getPlaylistRetryOrSwitchAction(
                        t,
                        e
                      ))
                    : ((t.levelRetry = !1),
                      (t.errorAction = this.getLevelSwitchAction(t, e)));
                }
                return;
              case ym.LEVEL_LOAD_ERROR:
              case ym.LEVEL_LOAD_TIMEOUT:
                return void (
                  "number" == typeof (null == r ? void 0 : r.level) &&
                  (t.errorAction = this.getPlaylistRetryOrSwitchAction(
                    t,
                    r.level
                  ))
                );
              case ym.AUDIO_TRACK_LOAD_ERROR:
              case ym.AUDIO_TRACK_LOAD_TIMEOUT:
              case ym.SUBTITLE_LOAD_ERROR:
              case ym.SUBTITLE_TRACK_LOAD_TIMEOUT:
                if (r) {
                  const e = s.loadLevelObj;
                  if (
                    e &&
                    ((r.type === Im.AUDIO_TRACK &&
                      e.hasAudioGroup(r.groupId)) ||
                      (r.type === Im.SUBTITLE_TRACK &&
                        e.hasSubtitleGroup(r.groupId)))
                  )
                    return (
                      (t.errorAction = this.getPlaylistRetryOrSwitchAction(
                        t,
                        s.loadLevel
                      )),
                      (t.errorAction.action = v_.SendAlternateToPenaltyBox),
                      void (t.errorAction.flags =
                        R_.MoveAllAlternatesMatchingHost)
                    );
                }
                return;
              case ym.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
                {
                  const e = s.loadLevelObj,
                    i = null == e ? void 0 : e.attrs["HDCP-LEVEL"];
                  i
                    ? (t.errorAction = {
                        action: v_.SendAlternateToPenaltyBox,
                        flags: R_.MoveAllAlternatesMatchingHDCP,
                        hdcpLevel: i
                      })
                    : this.keySystemError(t);
                }
                return;
              case ym.BUFFER_ADD_CODEC_ERROR:
              case ym.REMUX_ALLOC_ERROR:
              case ym.BUFFER_APPEND_ERROR:
                var o;
                if (!t.errorAction)
                  t.errorAction = this.getLevelSwitchAction(
                    t,
                    null != (o = t.level) ? o : s.loadLevel
                  );
                return;
              case ym.INTERNAL_EXCEPTION:
              case ym.BUFFER_APPENDING_ERROR:
              case ym.BUFFER_FULL_ERROR:
              case ym.LEVEL_SWITCH_ERROR:
              case ym.BUFFER_STALLED_ERROR:
              case ym.BUFFER_SEEK_OVER_HOLE:
              case ym.BUFFER_NUDGE_ON_STALL:
                return void (t.errorAction = y_());
            }
            t.type === Rm.KEY_SYSTEM_ERROR && this.keySystemError(t);
          }
          keySystemError(e) {
            const t = this.getVariantLevelIndex(e.frag);
            (e.levelRetry = !1),
              (e.errorAction = this.getLevelSwitchAction(e, t));
          }
          getPlaylistRetryOrSwitchAction(e, t) {
            const i = g_(this.hls.config.playlistLoadPolicy, e),
              s = this.playlistError++;
            if (S_(i, s, m_(e), e.response))
              return {
                action: v_.RetryRequest,
                flags: R_.None,
                retryConfig: i,
                retryCount: s
              };
            const r = this.getLevelSwitchAction(e, t);
            return i && ((r.retryConfig = i), (r.retryCount = s)), r;
          }
          getFragRetryOrSwitchAction(e) {
            const t = this.hls,
              i = this.getVariantLevelIndex(e.frag),
              s = t.levels[i],
              { fragLoadPolicy: r, keyLoadPolicy: n } = t.config,
              a = g_(e.details.startsWith("key") ? n : r, e),
              o = t.levels.reduce((e, t) => e + t.fragmentError, 0);
            if (s) {
              e.details !== ym.FRAG_GAP && s.fragmentError++;
              if (S_(a, o, m_(e), e.response))
                return {
                  action: v_.RetryRequest,
                  flags: R_.None,
                  retryConfig: a,
                  retryCount: o
                };
            }
            const c = this.getLevelSwitchAction(e, i);
            return a && ((c.retryConfig = a), (c.retryCount = o)), c;
          }
          getLevelSwitchAction(e, t) {
            const i = this.hls;
            null == t && (t = i.loadLevel);
            const s = this.hls.levels[t];
            if (s) {
              var r, n;
              const t = e.details;
              s.loadError++, t === ym.BUFFER_APPEND_ERROR && s.fragmentError++;
              let c = -1;
              const {
                levels: d,
                loadLevel: l,
                minAutoLevel: h,
                maxAutoLevel: u
              } = i;
              i.autoLevelEnabled || (i.loadLevel = -1);
              const p = null == (r = e.frag) ? void 0 : r.type,
                f =
                  ((p === Cm.AUDIO && t === ym.FRAG_PARSING_ERROR) ||
                    ("audio" === e.sourceBufferName &&
                      (t === ym.BUFFER_ADD_CODEC_ERROR ||
                        t === ym.BUFFER_APPEND_ERROR))) &&
                  d.some(({ audioCodec: e }) => s.audioCodec !== e),
                E =
                  "video" === e.sourceBufferName &&
                  (t === ym.BUFFER_ADD_CODEC_ERROR ||
                    t === ym.BUFFER_APPEND_ERROR) &&
                  d.some(
                    ({ codecSet: e, audioCodec: t }) =>
                      s.codecSet !== e && s.audioCodec === t
                  ),
                { type: m, groupId: g } = null != (n = e.context) ? n : {};
              for (let i = d.length; i--; ) {
                const r = (i + l) % d.length;
                if (r !== l && r >= h && r <= u && 0 === d[r].loadError) {
                  var a, o;
                  const i = d[r];
                  if (t === ym.FRAG_GAP && p === Cm.MAIN && e.frag) {
                    const t = d[r].details;
                    if (t) {
                      const i = u_(e.frag, t.fragments, e.frag.start);
                      if (null != i && i.gap) continue;
                    }
                  } else {
                    if (
                      (m === Im.AUDIO_TRACK && i.hasAudioGroup(g)) ||
                      (m === Im.SUBTITLE_TRACK && i.hasSubtitleGroup(g))
                    )
                      continue;
                    if (
                      (p === Cm.AUDIO &&
                        null != (a = s.audioGroups) &&
                        a.some(e => i.hasAudioGroup(e))) ||
                      (p === Cm.SUBTITLE &&
                        null != (o = s.subtitleGroups) &&
                        o.some(e => i.hasSubtitleGroup(e))) ||
                      (f && s.audioCodec === i.audioCodec) ||
                      (!f && s.audioCodec !== i.audioCodec) ||
                      (E && s.codecSet === i.codecSet)
                    )
                      continue;
                  }
                  c = r;
                  break;
                }
              }
              if (c > -1 && i.loadLevel !== c)
                return (
                  (e.levelRetry = !0),
                  (this.playlistError = 0),
                  {
                    action: v_.SendAlternateToPenaltyBox,
                    flags: R_.None,
                    nextAutoLevel: c
                  }
                );
            }
            return {
              action: v_.SendAlternateToPenaltyBox,
              flags: R_.MoveAllAlternatesMatchingHost
            };
          }
          onErrorOut(e, t) {
            var i;
            switch (null == (i = t.errorAction) ? void 0 : i.action) {
              case v_.DoNothing:
                break;
              case v_.SendAlternateToPenaltyBox:
                this.sendAlternateToPenaltyBox(t),
                  t.errorAction.resolved || t.details === ym.FRAG_GAP
                    ? /MediaSource readyState: ended/.test(t.error.message) &&
                      (this.warn(
                        `MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`
                      ),
                      this.hls.recoverMediaError())
                    : (t.fatal = !0);
            }
            t.fatal && this.hls.stopLoad();
          }
          sendAlternateToPenaltyBox(e) {
            const t = this.hls,
              i = e.errorAction;
            if (!i) return;
            const { flags: s, hdcpLevel: r, nextAutoLevel: n } = i;
            switch (s) {
              case R_.None:
                this.switchLevel(e, n);
                break;
              case R_.MoveAllAlternatesMatchingHDCP:
                r &&
                  ((t.maxHdcpLevel = qg[qg.indexOf(r) - 1]), (i.resolved = !0)),
                  this.warn(
                    `Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`
                  );
            }
            i.resolved || this.switchLevel(e, n);
          }
          switchLevel(e, t) {
            if (
              void 0 !== t &&
              e.errorAction &&
              (this.warn(`switching to level ${t} after ${e.details}`),
              (this.hls.nextAutoLevel = t),
              (e.errorAction.resolved = !0),
              (this.hls.nextLoadLevel = this.hls.nextAutoLevel),
              e.details === ym.BUFFER_ADD_CODEC_ERROR &&
                e.mimeType &&
                "audiovideo" !== e.sourceBufferName)
            ) {
              const t = jg(e.mimeType),
                i = this.hls.levels;
              for (let s = i.length; s--; )
                i[s][`${e.sourceBufferName}Codec`] === t &&
                  this.hls.removeLevel(s);
            }
          }
        },
        fpsController: class {
          constructor(e) {
            (this.hls = void 0),
              (this.isVideoPlaybackQualityAvailable = !1),
              (this.timer = void 0),
              (this.media = null),
              (this.lastTime = void 0),
              (this.lastDroppedFrames = 0),
              (this.lastDecodedFrames = 0),
              (this.streamController = void 0),
              (this.hls = e),
              this.registerListeners();
          }
          setStreamController(e) {
            this.streamController = e;
          }
          registerListeners() {
            this.hls.on(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
              this.hls.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this);
          }
          unregisterListeners() {
            this.hls.off(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
              this.hls.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this);
          }
          destroy() {
            this.timer && clearInterval(this.timer),
              this.unregisterListeners(),
              (this.isVideoPlaybackQualityAvailable = !1),
              (this.media = null);
          }
          onMediaAttaching(e, t) {
            const i = this.hls.config;
            if (i.capLevelOnFPSDrop) {
              const e =
                t.media instanceof self.HTMLVideoElement ? t.media : null;
              (this.media = e),
                e &&
                  "function" == typeof e.getVideoPlaybackQuality &&
                  (this.isVideoPlaybackQualityAvailable = !0),
                self.clearInterval(this.timer),
                (this.timer = self.setInterval(
                  this.checkFPSInterval.bind(this),
                  i.fpsDroppedMonitoringPeriod
                ));
            }
          }
          onMediaDetaching() {
            this.media = null;
          }
          checkFPS(e, t, i) {
            const s = performance.now();
            if (t) {
              if (this.lastTime) {
                const e = s - this.lastTime,
                  r = i - this.lastDroppedFrames,
                  n = t - this.lastDecodedFrames,
                  a = (1e3 * r) / e,
                  o = this.hls;
                if (
                  (o.trigger(Am.FPS_DROP, {
                    currentDropped: r,
                    currentDecoded: n,
                    totalDroppedFrames: i
                  }),
                  a > 0 && r > o.config.fpsDroppedMonitoringThreshold * n)
                ) {
                  let e = o.currentLevel;
                  o.logger.warn(
                    "drop FPS ratio greater than max allowed value for currentLevel: " +
                      e
                  ),
                    e > 0 &&
                      (-1 === o.autoLevelCapping || o.autoLevelCapping >= e) &&
                      ((e -= 1),
                      o.trigger(Am.FPS_DROP_LEVEL_CAPPING, {
                        level: e,
                        droppedLevel: o.currentLevel
                      }),
                      (o.autoLevelCapping = e),
                      this.streamController.nextLevelSwitch());
                }
              }
              (this.lastTime = s),
                (this.lastDroppedFrames = i),
                (this.lastDecodedFrames = t);
            }
          }
          checkFPSInterval() {
            const e = this.media;
            if (e)
              if (this.isVideoPlaybackQualityAvailable) {
                const t = e.getVideoPlaybackQuality();
                this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);
              } else
                this.checkFPS(
                  e,
                  e.webkitDecodedFrameCount,
                  e.webkitDroppedFrameCount
                );
          }
        },
        stretchShortVideoTrack: !1,
        maxAudioFramesDrift: 1,
        forceKeyFrameOnDiscontinuity: !0,
        abrEwmaFastLive: 3,
        abrEwmaSlowLive: 9,
        abrEwmaFastVoD: 3,
        abrEwmaSlowVoD: 9,
        abrEwmaDefaultEstimate: 5e5,
        abrEwmaDefaultEstimateMax: 5e6,
        abrBandWidthFactor: 0.95,
        abrBandWidthUpFactor: 0.7,
        abrMaxWithRealBitrate: !1,
        maxStarvationDelay: 4,
        maxLoadingDelay: 4,
        minAutoBitrate: 0,
        emeEnabled: !1,
        widevineLicenseUrl: void 0,
        drmSystems: {},
        drmSystemOptions: {},
        requestMediaKeySystemAccessFunc: ET,
        testBandwidth: !0,
        progressive: !1,
        lowLatencyMode: !0,
        cmcd: void 0,
        enableDateRangeMetadataCues: !0,
        enableEmsgMetadataCues: !0,
        enableEmsgKLVMetadata: !1,
        enableID3MetadataCues: !0,
        enableInterstitialPlayback: !0,
        interstitialAppendInPlace: !0,
        interstitialLiveLookAhead: 10,
        useMediaCapabilities: !0,
        certLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 8e3,
            maxLoadTimeMs: 2e4,
            timeoutRetry: null,
            errorRetry: null
          }
        },
        keyLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 8e3,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 2e4,
              backoff: "linear"
            },
            errorRetry: {
              maxNumRetry: 8,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 2e4,
              backoff: "linear"
            }
          }
        },
        manifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1 / 0,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3
            }
          }
        },
        playlistLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 2,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3
            }
          }
        },
        fragLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 12e4,
            timeoutRetry: {
              maxNumRetry: 4,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 6,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3
            }
          }
        },
        steeringManifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3
            }
          }
        },
        interstitialAssetListLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 3e4,
            timeoutRetry: {
              maxNumRetry: 0,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 0,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3
            }
          }
        },
        manifestLoadingTimeOut: 1e4,
        manifestLoadingMaxRetry: 1,
        manifestLoadingRetryDelay: 1e3,
        manifestLoadingMaxRetryTimeout: 64e3,
        levelLoadingTimeOut: 1e4,
        levelLoadingMaxRetry: 4,
        levelLoadingRetryDelay: 1e3,
        levelLoadingMaxRetryTimeout: 64e3,
        fragLoadingTimeOut: 2e4,
        fragLoadingMaxRetry: 6,
        fragLoadingRetryDelay: 1e3,
        fragLoadingMaxRetryTimeout: 64e3
      },
      {
        cueHandler: qy,
        enableWebVTT: !0,
        enableIMSC1: !0,
        enableCEA708Captions: !0,
        captionsTextTrack1Label: "English",
        captionsTextTrack1LanguageCode: "en",
        captionsTextTrack2Label: "Spanish",
        captionsTextTrack2LanguageCode: "es",
        captionsTextTrack3Label: "Unknown CC",
        captionsTextTrack3LanguageCode: "",
        captionsTextTrack4Label: "Unknown CC",
        captionsTextTrack4LanguageCode: "",
        renderTextTracksNatively: !0
      }
    ),
    {},
    {
      subtitleStreamController: class extends eS {
        constructor(e, t, i) {
          super(e, t, i, "subtitle-stream-controller", Cm.SUBTITLE),
            (this.currentTrackId = -1),
            (this.tracksBuffered = []),
            (this.mainDetails = null),
            this.registerListeners();
        }
        onHandlerDestroying() {
          this.unregisterListeners(),
            super.onHandlerDestroying(),
            (this.mainDetails = null);
        }
        registerListeners() {
          super.registerListeners();
          const { hls: e } = this;
          e.on(Am.LEVEL_LOADED, this.onLevelLoaded, this),
            e.on(
              Am.SUBTITLE_TRACKS_UPDATED,
              this.onSubtitleTracksUpdated,
              this
            ),
            e.on(Am.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
            e.on(Am.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
            e.on(
              Am.SUBTITLE_FRAG_PROCESSED,
              this.onSubtitleFragProcessed,
              this
            ),
            e.on(Am.BUFFER_FLUSHING, this.onBufferFlushing, this);
        }
        unregisterListeners() {
          super.unregisterListeners();
          const { hls: e } = this;
          e.off(Am.LEVEL_LOADED, this.onLevelLoaded, this),
            e.off(
              Am.SUBTITLE_TRACKS_UPDATED,
              this.onSubtitleTracksUpdated,
              this
            ),
            e.off(Am.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
            e.off(Am.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
            e.off(
              Am.SUBTITLE_FRAG_PROCESSED,
              this.onSubtitleFragProcessed,
              this
            ),
            e.off(Am.BUFFER_FLUSHING, this.onBufferFlushing, this);
        }
        startLoad(e, t) {
          this.stopLoad(),
            (this.state = ZT.IDLE),
            this.setInterval(500),
            (this.nextLoadPosition = this.lastCurrentTime =
              e + this.timelineOffset),
            (this.startPosition = t ? -1 : e),
            this.tick();
        }
        onManifestLoading() {
          super.onManifestLoading(), (this.mainDetails = null);
        }
        onMediaDetaching(e, t) {
          (this.tracksBuffered = []), super.onMediaDetaching(e, t);
        }
        onLevelLoaded(e, t) {
          this.mainDetails = t.details;
        }
        onSubtitleFragProcessed(e, t) {
          const { frag: i, success: s } = t;
          if ((Jm(i) && (this.fragPrevious = i), (this.state = ZT.IDLE), !s))
            return;
          const r = this.tracksBuffered[this.currentTrackId];
          if (!r) return;
          let n;
          const a = i.start;
          for (let e = 0; e < r.length; e++)
            if (a >= r[e].start && a <= r[e].end) {
              n = r[e];
              break;
            }
          const o = i.start + i.duration;
          n ? (n.end = o) : ((n = { start: a, end: o }), r.push(n)),
            this.fragmentTracker.fragBuffered(i),
            this.fragBufferedComplete(i, null),
            this.media && this.tick();
        }
        onBufferFlushing(e, t) {
          const { startOffset: i, endOffset: s } = t;
          if (0 === i && s !== Number.POSITIVE_INFINITY) {
            const e = s - 1;
            if (e <= 0) return;
            (t.endOffsetSubtitles = Math.max(0, e)),
              this.tracksBuffered.forEach(t => {
                for (let i = 0; i < t.length; )
                  if (t[i].end <= e) t.shift();
                  else {
                    if (!(t[i].start < e)) break;
                    (t[i].start = e), i++;
                  }
              }),
              this.fragmentTracker.removeFragmentsInRange(i, e, Cm.SUBTITLE);
          }
        }
        onError(e, t) {
          const i = t.frag;
          (null == i ? void 0 : i.type) === Cm.SUBTITLE &&
            (t.details === ym.FRAG_GAP &&
              this.fragmentTracker.fragBuffered(i, !0),
            this.fragCurrent && this.fragCurrent.abortRequests(),
            this.state !== ZT.STOPPED && (this.state = ZT.IDLE));
        }
        onSubtitleTracksUpdated(e, { subtitleTracks: t }) {
          this.levels && Mv(this.levels, t)
            ? (this.levels = t.map(e => new Zg(e)))
            : ((this.tracksBuffered = []),
              (this.levels = t.map(e => {
                const t = new Zg(e);
                return (this.tracksBuffered[t.id] = []), t;
              })),
              this.fragmentTracker.removeFragmentsInRange(
                0,
                Number.POSITIVE_INFINITY,
                Cm.SUBTITLE
              ),
              (this.fragPrevious = null),
              (this.mediaBuffer = null));
        }
        onSubtitleTrackSwitch(e, t) {
          var i;
          if (
            ((this.currentTrackId = t.id),
            null == (i = this.levels) ||
              !i.length ||
              -1 === this.currentTrackId)
          )
            return void this.clearInterval();
          const s = this.levels[this.currentTrackId];
          null != s && s.details
            ? (this.mediaBuffer = this.mediaBufferTimeRanges)
            : (this.mediaBuffer = null),
            s && this.state !== ZT.STOPPED && this.setInterval(500);
        }
        onSubtitleTrackLoaded(e, t) {
          var i;
          const { currentTrackId: s, levels: r } = this,
            { details: n, id: a } = t;
          if (!r)
            return void this.warn(
              `Subtitle tracks were reset while loading level ${a}`
            );
          const o = r[a];
          if (a >= r.length || !o) return;
          this.log(
            `Subtitle track ${a} loaded [${n.startSN},${n.endSN}]${
              n.lastPartSn ? `[part-${n.lastPartSn}-${n.lastPartIndex}]` : ""
            },duration:${n.totalduration}`
          ),
            (this.mediaBuffer = this.mediaBufferTimeRanges);
          let c = 0;
          if (n.live || (null != (i = o.details) && i.live)) {
            const e = this.mainDetails;
            if (n.deltaUpdateFailed || !e) return;
            const t = e.fragments[0];
            var d;
            if (o.details)
              (c = this.alignPlaylists(
                n,
                o.details,
                null == (d = this.levelLastLoaded) ? void 0 : d.details
              )),
                0 === c && t && ((c = t.start), jT(n, c));
            else
              n.hasProgramDateTime && e.hasProgramDateTime
                ? (JT(n, e), (c = n.fragmentStart))
                : t && ((c = t.start), jT(n, c));
          }
          if (
            ((o.details = n),
            (this.levelLastLoaded = o),
            a === s &&
              (this.hls.trigger(Am.SUBTITLE_TRACK_UPDATED, {
                details: n,
                id: a,
                groupId: t.groupId
              }),
              this.tick(),
              n.live &&
                !this.fragCurrent &&
                this.media &&
                this.state === ZT.IDLE))
          ) {
            u_(null, n.fragments, this.media.currentTime, 0) ||
              (this.warn("Subtitle playlist not aligned with playback"),
              (o.details = void 0));
          }
        }
        _handleFragmentLoadComplete(e) {
          const { frag: t, payload: i } = e,
            s = t.decryptdata,
            r = this.hls;
          if (
            !this.fragContextChanged(t) &&
            i &&
            i.byteLength > 0 &&
            null != s &&
            s.key &&
            s.iv &&
            iT(s.method)
          ) {
            const e = performance.now();
            this.decrypter
              .decrypt(
                new Uint8Array(i),
                s.key.buffer,
                s.iv.buffer,
                sT(s.method)
              )
              .catch(e => {
                throw (r.trigger(Am.ERROR, {
                  type: Rm.MEDIA_ERROR,
                  details: ym.FRAG_DECRYPT_ERROR,
                  fatal: !1,
                  error: e,
                  reason: e.message,
                  frag: t
                }),
                e);
              })
              .then(i => {
                const s = performance.now();
                r.trigger(Am.FRAG_DECRYPTED, {
                  frag: t,
                  payload: i,
                  stats: { tstart: e, tdecrypt: s }
                });
              })
              .catch(e => {
                this.warn(`${e.name}: ${e.message}`), (this.state = ZT.IDLE);
              });
          }
        }
        doTick() {
          if (this.media) {
            if (this.state === ZT.IDLE) {
              const { currentTrackId: e, levels: t } = this,
                i = null == t ? void 0 : t[e];
              if (!i || !t.length || !i.details) return;
              if (this.waitForLive(i)) return;
              const { config: s } = this,
                r = this.getLoadPosition(),
                n = K_.bufferedInfo(
                  this.tracksBuffered[this.currentTrackId] || [],
                  r,
                  s.maxBufferHole
                ),
                { end: a, len: o } = n,
                c = i.details;
              if (o > this.hls.maxBufferLength + c.levelTargetDuration) return;
              const d = c.fragments,
                l = d.length,
                h = c.edge;
              let u = null;
              const p = this.fragPrevious;
              if (a < h) {
                const e = s.maxFragLookUpTolerance,
                  t = a > h - e ? 0 : e;
                (u = u_(p, d, Math.max(d[0].start, a), t)),
                  !u && p && p.start < d[0].start && (u = d[0]);
              } else u = d[l - 1];
              if (((u = this.filterReplacedPrimary(u, i.details)), !u)) return;
              const f = d[u.sn - c.startSN - 1];
              if (
                (f &&
                  f.cc === u.cc &&
                  this.fragmentTracker.getState(f) === A_ &&
                  (u = f),
                this.fragmentTracker.getState(u) === A_)
              ) {
                const e = this.mapToInitFragWhenRequired(u);
                e && this.loadFragment(e, i, a);
              }
            }
          } else this.state = ZT.IDLE;
        }
        loadFragment(e, t, i) {
          Jm(e) ? super.loadFragment(e, t, i) : this._loadInitSegment(e, t);
        }
        get mediaBufferTimeRanges() {
          return new JR(this.tracksBuffered[this.currentTrackId] || []);
        }
      },
      subtitleTrackController: class extends kv {
        constructor(e) {
          super(e, "subtitle-track-controller"),
            (this.media = null),
            (this.tracks = []),
            (this.groupIds = null),
            (this.tracksInGroup = []),
            (this.trackId = -1),
            (this.currentTrack = null),
            (this.selectDefaultTrack = !0),
            (this.queuedDefaultTrack = -1),
            (this.useTextTrackPolling = !1),
            (this.subtitlePollingInterval = -1),
            (this._subtitleDisplay = !0),
            (this.asyncPollTrackChange = () => this.pollTrackChange(0)),
            (this.onTextTracksChanged = () => {
              if (
                (this.useTextTrackPolling ||
                  self.clearInterval(this.subtitlePollingInterval),
                !this.media || !this.hls.config.renderTextTracksNatively)
              )
                return;
              let e = null;
              const t = MR(this.media.textTracks);
              for (let i = 0; i < t.length; i++)
                if ("hidden" === t[i].mode) e = t[i];
                else if ("showing" === t[i].mode) {
                  e = t[i];
                  break;
                }
              const i = this.findTrackForTextTrack(e);
              this.subtitleTrack !== i && this.setSubtitleTrack(i);
            }),
            this.registerListeners();
        }
        destroy() {
          this.unregisterListeners(),
            (this.tracks.length = 0),
            (this.tracksInGroup.length = 0),
            (this.currentTrack = null),
            (this.onTextTracksChanged = this.asyncPollTrackChange = null),
            super.destroy();
        }
        get subtitleDisplay() {
          return this._subtitleDisplay;
        }
        set subtitleDisplay(e) {
          (this._subtitleDisplay = e),
            this.trackId > -1 && this.toggleTrackModes();
        }
        registerListeners() {
          const { hls: e } = this;
          e.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
            e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
            e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.on(Am.MANIFEST_PARSED, this.onManifestParsed, this),
            e.on(Am.LEVEL_LOADING, this.onLevelLoading, this),
            e.on(Am.LEVEL_SWITCHING, this.onLevelSwitching, this),
            e.on(Am.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
            e.on(Am.ERROR, this.onError, this);
        }
        unregisterListeners() {
          const { hls: e } = this;
          e.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
            e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
            e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.off(Am.MANIFEST_PARSED, this.onManifestParsed, this),
            e.off(Am.LEVEL_LOADING, this.onLevelLoading, this),
            e.off(Am.LEVEL_SWITCHING, this.onLevelSwitching, this),
            e.off(Am.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
            e.off(Am.ERROR, this.onError, this);
        }
        onMediaAttached(e, t) {
          (this.media = t.media),
            this.media &&
              (this.queuedDefaultTrack > -1 &&
                ((this.subtitleTrack = this.queuedDefaultTrack),
                (this.queuedDefaultTrack = -1)),
              (this.useTextTrackPolling = !(
                this.media.textTracks && "onchange" in this.media.textTracks
              )),
              this.useTextTrackPolling
                ? this.pollTrackChange(500)
                : this.media.textTracks.addEventListener(
                    "change",
                    this.asyncPollTrackChange
                  ));
        }
        pollTrackChange(e) {
          self.clearInterval(this.subtitlePollingInterval),
            (this.subtitlePollingInterval = self.setInterval(
              this.onTextTracksChanged,
              e
            ));
        }
        onMediaDetaching(e, t) {
          const i = this.media;
          if (!i) return;
          const s = !!t.transferMedia;
          if (
            (self.clearInterval(this.subtitlePollingInterval),
            this.useTextTrackPolling ||
              i.textTracks.removeEventListener(
                "change",
                this.asyncPollTrackChange
              ),
            this.trackId > -1 && (this.queuedDefaultTrack = this.trackId),
            (this.subtitleTrack = -1),
            (this.media = null),
            s)
          )
            return;
          MR(i.textTracks).forEach(e => {
            PR(e);
          });
        }
        onManifestLoading() {
          (this.tracks = []),
            (this.groupIds = null),
            (this.tracksInGroup = []),
            (this.trackId = -1),
            (this.currentTrack = null),
            (this.selectDefaultTrack = !0);
        }
        onManifestParsed(e, t) {
          this.tracks = t.subtitleTracks;
        }
        onSubtitleTrackLoaded(e, t) {
          const { id: i, groupId: s, details: r } = t,
            n = this.tracksInGroup[i];
          if (!n || n.groupId !== s)
            return void this.warn(
              `Subtitle track with id:${i} and group:${s} not found in active group ${
                null == n ? void 0 : n.groupId
              }`
            );
          const a = n.details;
          (n.details = t.details),
            this.log(
              `Subtitle track ${i} "${n.name}" lang:${n.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`
            ),
            i === this.trackId && this.playlistLoaded(i, t, a);
        }
        onLevelLoading(e, t) {
          this.switchLevel(t.level);
        }
        onLevelSwitching(e, t) {
          this.switchLevel(t.level);
        }
        switchLevel(e) {
          const t = this.hls.levels[e];
          if (!t) return;
          const i = t.subtitleGroups || null,
            s = this.groupIds;
          let r = this.currentTrack;
          if (
            !i ||
            (null == s ? void 0 : s.length) !==
              (null == i ? void 0 : i.length) ||
            (null != i &&
              i.some(e => -1 === (null == s ? void 0 : s.indexOf(e))))
          ) {
            (this.groupIds = i),
              (this.trackId = -1),
              (this.currentTrack = null);
            const e = this.tracks.filter(
              e => !i || -1 !== i.indexOf(e.groupId)
            );
            if (e.length)
              this.selectDefaultTrack &&
                !e.some(e => e.default) &&
                (this.selectDefaultTrack = !1),
                e.forEach((e, t) => {
                  e.id = t;
                });
            else if (!r && !this.tracksInGroup.length) return;
            this.tracksInGroup = e;
            const t = this.hls.config.subtitlePreference;
            if (!r && t) {
              this.selectDefaultTrack = !1;
              const i = a_(t, e);
              if (i > -1) r = e[i];
              else {
                const e = a_(t, this.tracks);
                r = this.tracks[e];
              }
            }
            let s = this.findTrackId(r);
            -1 === s && r && (s = this.findTrackId(null));
            const n = { subtitleTracks: e };
            this.log(
              `Updating subtitle tracks, ${e.length} track(s) found in "${
                null == i ? void 0 : i.join(",")
              }" group-id`
            ),
              this.hls.trigger(Am.SUBTITLE_TRACKS_UPDATED, n),
              -1 !== s && -1 === this.trackId && this.setSubtitleTrack(s);
          }
        }
        findTrackId(e) {
          const t = this.tracksInGroup,
            i = this.selectDefaultTrack;
          for (let s = 0; s < t.length; s++) {
            const r = t[s];
            if ((!i || r.default) && (i || e) && (!e || o_(r, e))) return s;
          }
          if (e) {
            for (let i = 0; i < t.length; i++) {
              const s = t[i];
              if (
                Uv(e.attrs, s.attrs, [
                  "LANGUAGE",
                  "ASSOC-LANGUAGE",
                  "CHARACTERISTICS"
                ])
              )
                return i;
            }
            for (let i = 0; i < t.length; i++) {
              const s = t[i];
              if (Uv(e.attrs, s.attrs, ["LANGUAGE"])) return i;
            }
          }
          return -1;
        }
        findTrackForTextTrack(e) {
          if (e) {
            const t = this.tracksInGroup;
            for (let i = 0; i < t.length; i++) {
              if (xv(t[i], e)) return i;
            }
          }
          return -1;
        }
        onError(e, t) {
          !t.fatal &&
            t.context &&
            (t.context.type !== Im.SUBTITLE_TRACK ||
              t.context.id !== this.trackId ||
              (this.groupIds &&
                -1 === this.groupIds.indexOf(t.context.groupId)) ||
              this.checkRetry(t));
        }
        get allSubtitleTracks() {
          return this.tracks;
        }
        get subtitleTracks() {
          return this.tracksInGroup;
        }
        get subtitleTrack() {
          return this.trackId;
        }
        set subtitleTrack(e) {
          (this.selectDefaultTrack = !1), this.setSubtitleTrack(e);
        }
        setSubtitleOption(e) {
          if (((this.hls.config.subtitlePreference = e), e)) {
            if (-1 === e.id) return this.setSubtitleTrack(-1), null;
            const t = this.allSubtitleTracks;
            if (((this.selectDefaultTrack = !1), t.length)) {
              const i = this.currentTrack;
              if (i && o_(e, i)) return i;
              const s = a_(e, this.tracksInGroup);
              if (s > -1) {
                const e = this.tracksInGroup[s];
                return this.setSubtitleTrack(s), e;
              }
              if (i) return null;
              {
                const i = a_(e, t);
                if (i > -1) return t[i];
              }
            }
          }
          return null;
        }
        loadPlaylist(e) {
          super.loadPlaylist(),
            this.shouldLoadPlaylist(this.currentTrack) &&
              this.scheduleLoading(this.currentTrack, e);
        }
        loadingPlaylist(e, t) {
          super.loadingPlaylist(e, t);
          const i = e.id,
            s = e.groupId,
            r = this.getUrlWithDirectives(e.url, t),
            n = e.details,
            a = null == n ? void 0 : n.age;
          this.log(
            `Loading subtitle ${i} "${e.name}" lang:${e.lang} group:${s}${
              void 0 !== (null == t ? void 0 : t.msn)
                ? " at sn " + t.msn + " part " + t.part
                : ""
            }${
              a && n.live
                ? " age " + a.toFixed(1) + ((n.type && " " + n.type) || "")
                : ""
            } ${r}`
          ),
            this.hls.trigger(Am.SUBTITLE_TRACK_LOADING, {
              url: r,
              id: i,
              groupId: s,
              deliveryDirectives: t || null,
              track: e
            });
        }
        toggleTrackModes() {
          const { media: e } = this;
          if (!e) return;
          const t = MR(e.textTracks),
            i = this.currentTrack;
          let s;
          if (
            (i &&
              ((s = t.filter(e => xv(i, e))[0]),
              s ||
                this.warn(
                  `Unable to find subtitle TextTrack with name "${i.name}" and language "${i.lang}"`
                )),
            [].slice.call(t).forEach(e => {
              "disabled" !== e.mode && e !== s && (e.mode = "disabled");
            }),
            s)
          ) {
            const e = this.subtitleDisplay ? "showing" : "hidden";
            s.mode !== e && (s.mode = e);
          }
        }
        setSubtitleTrack(e) {
          const t = this.tracksInGroup;
          if (!this.media) return void (this.queuedDefaultTrack = e);
          if (e < -1 || e >= t.length || !Tm(e))
            return void this.warn(`Invalid subtitle track id: ${e}`);
          this.selectDefaultTrack = !1;
          const i = this.currentTrack,
            s = t[e] || null;
          if (
            ((this.trackId = e),
            (this.currentTrack = s),
            this.toggleTrackModes(),
            !s)
          )
            return void this.hls.trigger(Am.SUBTITLE_TRACK_SWITCH, { id: e });
          const r = !!s.details && !s.details.live;
          if (e === this.trackId && s === i && r) return;
          this.log(
            `Switching to subtitle-track ${e}` +
              (s ? ` "${s.name}" lang:${s.lang} group:${s.groupId}` : "")
          );
          const { id: n, groupId: a = "", name: o, type: c, url: d } = s;
          this.hls.trigger(Am.SUBTITLE_TRACK_SWITCH, {
            id: n,
            groupId: a,
            name: o,
            type: c,
            url: d
          });
          const l = this.switchParams(
            s.url,
            null == i ? void 0 : i.details,
            s.details
          );
          this.loadPlaylist(l);
        }
      },
      timelineController: class {
        constructor(e) {
          (this.hls = void 0),
            (this.media = null),
            (this.config = void 0),
            (this.enabled = !0),
            (this.Cues = void 0),
            (this.textTracks = []),
            (this.tracks = []),
            (this.initPTS = []),
            (this.unparsedVttFrags = []),
            (this.captionsTracks = {}),
            (this.nonNativeCaptionsTracks = {}),
            (this.cea608Parser1 = void 0),
            (this.cea608Parser2 = void 0),
            (this.lastCc = -1),
            (this.lastSn = -1),
            (this.lastPartIndex = -1),
            (this.prevCC = -1),
            (this.vttCCs = {
              ccOffset: 0,
              presentationOffset: 0,
              0: { start: 0, prevCC: -1, new: !0 }
            }),
            (this.captionsProperties = void 0),
            (this.hls = e),
            (this.config = e.config),
            (this.Cues = e.config.cueHandler),
            (this.captionsProperties = {
              textTrack1: {
                label: this.config.captionsTextTrack1Label,
                languageCode: this.config.captionsTextTrack1LanguageCode
              },
              textTrack2: {
                label: this.config.captionsTextTrack2Label,
                languageCode: this.config.captionsTextTrack2LanguageCode
              },
              textTrack3: {
                label: this.config.captionsTextTrack3Label,
                languageCode: this.config.captionsTextTrack3LanguageCode
              },
              textTrack4: {
                label: this.config.captionsTextTrack4Label,
                languageCode: this.config.captionsTextTrack4LanguageCode
              }
            }),
            e.on(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
            e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
            e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.on(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
            e.on(
              Am.SUBTITLE_TRACKS_UPDATED,
              this.onSubtitleTracksUpdated,
              this
            ),
            e.on(Am.FRAG_LOADING, this.onFragLoading, this),
            e.on(Am.FRAG_LOADED, this.onFragLoaded, this),
            e.on(Am.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
            e.on(Am.FRAG_DECRYPTED, this.onFragDecrypted, this),
            e.on(Am.INIT_PTS_FOUND, this.onInitPtsFound, this),
            e.on(
              Am.SUBTITLE_TRACKS_CLEARED,
              this.onSubtitleTracksCleared,
              this
            ),
            e.on(Am.BUFFER_FLUSHING, this.onBufferFlushing, this);
        }
        destroy() {
          const { hls: e } = this;
          e.off(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
            e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
            e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.off(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
            e.off(
              Am.SUBTITLE_TRACKS_UPDATED,
              this.onSubtitleTracksUpdated,
              this
            ),
            e.off(Am.FRAG_LOADING, this.onFragLoading, this),
            e.off(Am.FRAG_LOADED, this.onFragLoaded, this),
            e.off(Am.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
            e.off(Am.FRAG_DECRYPTED, this.onFragDecrypted, this),
            e.off(Am.INIT_PTS_FOUND, this.onInitPtsFound, this),
            e.off(
              Am.SUBTITLE_TRACKS_CLEARED,
              this.onSubtitleTracksCleared,
              this
            ),
            e.off(Am.BUFFER_FLUSHING, this.onBufferFlushing, this),
            (this.hls = this.config = this.media = null),
            (this.cea608Parser1 = this.cea608Parser2 = void 0);
        }
        initCea608Parsers() {
          const e = new Ky(this, "textTrack1"),
            t = new Ky(this, "textTrack2"),
            i = new Ky(this, "textTrack3"),
            s = new Ky(this, "textTrack4");
          (this.cea608Parser1 = new fy(1, e, t)),
            (this.cea608Parser2 = new fy(3, i, s));
        }
        addCues(e, t, i, s, r) {
          let n = !1;
          for (let e = r.length; e--; ) {
            const s = r[e],
              l =
                ((a = s[0]),
                (o = s[1]),
                (c = t),
                (d = i),
                Math.min(o, d) - Math.max(a, c));
            if (
              l >= 0 &&
              ((s[0] = Math.min(s[0], t)),
              (s[1] = Math.max(s[1], i)),
              (n = !0),
              l / (i - t) > 0.5)
            )
              return;
          }
          var a, o, c, d;
          if ((n || r.push([t, i]), this.config.renderTextTracksNatively)) {
            const r = this.captionsTracks[e];
            this.Cues.newCue(r, t, i, s);
          } else {
            const r = this.Cues.newCue(null, t, i, s);
            this.hls.trigger(Am.CUES_PARSED, {
              type: "captions",
              cues: r,
              track: e
            });
          }
        }
        onInitPtsFound(e, { frag: t, id: i, initPTS: s, timescale: r }) {
          const { unparsedVttFrags: n } = this;
          i === Cm.MAIN && (this.initPTS[t.cc] = { baseTime: s, timescale: r }),
            n.length &&
              ((this.unparsedVttFrags = []),
              n.forEach(e => {
                this.onFragLoaded(Am.FRAG_LOADED, e);
              }));
        }
        getExistingTrack(e, t) {
          const { media: i } = this;
          if (i)
            for (let s = 0; s < i.textTracks.length; s++) {
              const r = i.textTracks[s];
              if (
                Yy(r, {
                  name: e,
                  lang: t,
                  characteristics:
                    "transcribes-spoken-dialog,describes-music-and-sound"
                })
              )
                return r;
            }
          return null;
        }
        createCaptionsTrack(e) {
          this.config.renderTextTracksNatively
            ? this.createNativeTrack(e)
            : this.createNonNativeTrack(e);
        }
        createNativeTrack(e) {
          if (this.captionsTracks[e]) return;
          const { captionsProperties: t, captionsTracks: i, media: s } = this,
            { label: r, languageCode: n } = t[e],
            a = this.getExistingTrack(r, n);
          if (a) (i[e] = a), PR(i[e]), LR(i[e], s);
          else {
            const t = this.createTextTrack("captions", r, n);
            t && ((t[e] = !0), (i[e] = t));
          }
        }
        createNonNativeTrack(e) {
          if (this.nonNativeCaptionsTracks[e]) return;
          const t = this.captionsProperties[e];
          if (!t) return;
          const i = {
            _id: e,
            label: t.label,
            kind: "captions",
            default: !!t.media && !!t.media.default,
            closedCaptions: t.media
          };
          (this.nonNativeCaptionsTracks[e] = i),
            this.hls.trigger(Am.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [i] });
        }
        createTextTrack(e, t, i) {
          const s = this.media;
          if (s) return s.addTextTrack(e, t, i);
        }
        onMediaAttaching(e, t) {
          (this.media = t.media), t.mediaSource || this._cleanTracks();
        }
        onMediaDetaching(e, t) {
          const i = !!t.transferMedia;
          if (((this.media = null), i)) return;
          const { captionsTracks: s } = this;
          Object.keys(s).forEach(e => {
            PR(s[e]), delete s[e];
          }),
            (this.nonNativeCaptionsTracks = {});
        }
        onManifestLoading() {
          (this.lastCc = -1),
            (this.lastSn = -1),
            (this.lastPartIndex = -1),
            (this.prevCC = -1),
            (this.vttCCs = {
              ccOffset: 0,
              presentationOffset: 0,
              0: { start: 0, prevCC: -1, new: !0 }
            }),
            this._cleanTracks(),
            (this.tracks = []),
            (this.captionsTracks = {}),
            (this.nonNativeCaptionsTracks = {}),
            (this.textTracks = []),
            (this.unparsedVttFrags = []),
            (this.initPTS = []),
            this.cea608Parser1 &&
              this.cea608Parser2 &&
              (this.cea608Parser1.reset(), this.cea608Parser2.reset());
        }
        _cleanTracks() {
          const { media: e } = this;
          if (!e) return;
          const t = e.textTracks;
          if (t) for (let e = 0; e < t.length; e++) PR(t[e]);
        }
        onSubtitleTracksUpdated(e, t) {
          const i = t.subtitleTracks || [],
            s = i.some(e => e.textCodec === Py);
          if (this.config.enableWebVTT || (s && this.config.enableIMSC1)) {
            if (Mv(this.tracks, i)) return void (this.tracks = i);
            if (
              ((this.textTracks = []),
              (this.tracks = i),
              this.config.renderTextTracksNatively)
            ) {
              const e = this.media,
                t = e ? MR(e.textTracks) : null;
              if (
                (this.tracks.forEach((e, i) => {
                  let s;
                  if (t) {
                    let i = null;
                    for (let s = 0; s < t.length; s++)
                      if (t[s] && Yy(t[s], e)) {
                        (i = t[s]), (t[s] = null);
                        break;
                      }
                    i && (s = i);
                  }
                  if (s) PR(s);
                  else {
                    const t = Wy(e);
                    (s = this.createTextTrack(t, e.name, e.lang)),
                      s && (s.mode = "disabled");
                  }
                  s && this.textTracks.push(s);
                }),
                null != t && t.length)
              ) {
                const e = t.filter(e => null !== e).map(e => e.label);
                e.length &&
                  this.hls.logger.warn(
                    `Media element contains unused subtitle tracks: ${e.join(
                      ", "
                    )}. Replace media element for each source to clear TextTracks and captions menu.`
                  );
              }
            } else if (this.tracks.length) {
              const e = this.tracks.map(e => ({
                label: e.name,
                kind: e.type.toLowerCase(),
                default: e.default,
                subtitleTrack: e
              }));
              this.hls.trigger(Am.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: e });
            }
          }
        }
        onManifestLoaded(e, t) {
          this.config.enableCEA708Captions &&
            t.captions &&
            t.captions.forEach(e => {
              const t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId);
              if (!t) return;
              const i = `textTrack${t[1]}`,
                s = this.captionsProperties[i];
              s &&
                ((s.label = e.name),
                e.lang && (s.languageCode = e.lang),
                (s.media = e));
            });
        }
        closedCaptionsForLevel(e) {
          const t = this.hls.levels[e.level];
          return null == t ? void 0 : t.attrs["CLOSED-CAPTIONS"];
        }
        onFragLoading(e, t) {
          if (this.enabled && t.frag.type === Cm.MAIN) {
            var i, s;
            const { cea608Parser1: e, cea608Parser2: r, lastSn: n } = this,
              { cc: a, sn: o } = t.frag,
              c =
                null != (i = null == (s = t.part) ? void 0 : s.index) ? i : -1;
            e &&
              r &&
              (o !== n + 1 ||
                (o === n && c !== this.lastPartIndex + 1) ||
                a !== this.lastCc) &&
              (e.reset(), r.reset()),
              (this.lastCc = a),
              (this.lastSn = o),
              (this.lastPartIndex = c);
          }
        }
        onFragLoaded(e, t) {
          const { frag: i, payload: s } = t;
          if (i.type === Cm.SUBTITLE)
            if (s.byteLength) {
              const e = i.decryptdata,
                r = "stats" in t;
              if (null == e || !e.encrypted || r) {
                const e = this.tracks[i.level],
                  r = this.vttCCs;
                r[i.cc] ||
                  ((r[i.cc] = { start: i.start, prevCC: this.prevCC, new: !0 }),
                  (this.prevCC = i.cc)),
                  e && e.textCodec === Py
                    ? this._parseIMSC1(i, s)
                    : this._parseVTTs(t);
              }
            } else
              this.hls.trigger(Am.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: i,
                error: new Error("Empty subtitle payload")
              });
        }
        _parseIMSC1(e, t) {
          const i = this.hls;
          xy(
            t,
            this.initPTS[e.cc],
            t => {
              this._appendCues(t, e.level),
                i.trigger(Am.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e });
            },
            t => {
              i.logger.log(`Failed to parse IMSC1: ${t}`),
                i.trigger(Am.SUBTITLE_FRAG_PROCESSED, {
                  success: !1,
                  frag: e,
                  error: t
                });
            }
          );
        }
        _parseVTTs(e) {
          var t;
          const { frag: i, payload: s } = e,
            { initPTS: r, unparsedVttFrags: n } = this,
            a = r.length - 1;
          if (!r[i.cc] && -1 === a) return void n.push(e);
          const o = this.hls;
          Ny(
            null != (t = i.initSegment) && t.data
              ? Sg(i.initSegment.data, new Uint8Array(s)).buffer
              : s,
            this.initPTS[i.cc],
            this.vttCCs,
            i.cc,
            i.start,
            e => {
              this._appendCues(e, i.level),
                o.trigger(Am.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: i });
            },
            t => {
              const r = "Missing initPTS for VTT MPEGTS" === t.message;
              r ? n.push(e) : this._fallbackToIMSC1(i, s),
                o.logger.log(`Failed to parse VTT cue: ${t}`),
                (r && a > i.cc) ||
                  o.trigger(Am.SUBTITLE_FRAG_PROCESSED, {
                    success: !1,
                    frag: i,
                    error: t
                  });
            }
          );
        }
        _fallbackToIMSC1(e, t) {
          const i = this.tracks[e.level];
          i.textCodec ||
            xy(
              t,
              this.initPTS[e.cc],
              () => {
                (i.textCodec = Py), this._parseIMSC1(e, t);
              },
              () => {
                i.textCodec = "wvtt";
              }
            );
        }
        _appendCues(e, t) {
          const i = this.hls;
          if (this.config.renderTextTracksNatively) {
            const i = this.textTracks[t];
            if (!i || "disabled" === i.mode) return;
            e.forEach(e => NR(i, e));
          } else {
            const s = this.tracks[t];
            if (!s) return;
            const r = s.default ? "default" : "subtitles" + t;
            i.trigger(Am.CUES_PARSED, { type: "subtitles", cues: e, track: r });
          }
        }
        onFragDecrypted(e, t) {
          const { frag: i } = t;
          i.type === Cm.SUBTITLE && this.onFragLoaded(Am.FRAG_LOADED, t);
        }
        onSubtitleTracksCleared() {
          (this.tracks = []), (this.captionsTracks = {});
        }
        onFragParsingUserdata(e, t) {
          if (!this.enabled || !this.config.enableCEA708Captions) return;
          const { frag: i, samples: s } = t;
          if (i.type !== Cm.MAIN || "NONE" !== this.closedCaptionsForLevel(i))
            for (let e = 0; e < s.length; e++) {
              const t = s[e].bytes;
              if (t) {
                this.cea608Parser1 || this.initCea608Parsers();
                const i = this.extractCea608Data(t);
                this.cea608Parser1.addData(s[e].pts, i[0]),
                  this.cea608Parser2.addData(s[e].pts, i[1]);
              }
            }
        }
        onBufferFlushing(
          e,
          { startOffset: t, endOffset: i, endOffsetSubtitles: s, type: r }
        ) {
          const { media: n } = this;
          if (n && !(n.currentTime < i)) {
            if (!r || "video" === r) {
              const { captionsTracks: e } = this;
              Object.keys(e).forEach(s => kR(e[s], t, i));
            }
            if (
              this.config.renderTextTracksNatively &&
              0 === t &&
              void 0 !== s
            ) {
              const { textTracks: e } = this;
              Object.keys(e).forEach(i => kR(e[i], t, s));
            }
          }
        }
        extractCea608Data(e) {
          const t = [[], []],
            i = 31 & e[0];
          let s = 2;
          for (let r = 0; r < i; r++) {
            const i = e[s++],
              r = 127 & e[s++],
              n = 127 & e[s++];
            if (0 === r && 0 === n) continue;
            if (0 != (4 & i)) {
              const e = 3 & i;
              (0 !== e && 1 !== e) || (t[e].push(r), t[e].push(n));
            }
          }
          return t;
        }
      },
      audioStreamController: class extends eS {
        constructor(e, t, i) {
          super(e, t, i, "audio-stream-controller", Cm.AUDIO),
            (this.mainAnchor = null),
            (this.mainFragLoading = null),
            (this.audioOnly = !1),
            (this.bufferedTrack = null),
            (this.switchingTrack = null),
            (this.trackId = -1),
            (this.waitingData = null),
            (this.mainDetails = null),
            (this.flushing = !1),
            (this.bufferFlushed = !1),
            (this.cachedTrackLoadedData = null),
            this.registerListeners();
        }
        onHandlerDestroying() {
          this.unregisterListeners(),
            super.onHandlerDestroying(),
            this.resetItem();
        }
        resetItem() {
          this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;
        }
        registerListeners() {
          super.registerListeners();
          const { hls: e } = this;
          e.on(Am.LEVEL_LOADED, this.onLevelLoaded, this),
            e.on(Am.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
            e.on(Am.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
            e.on(Am.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
            e.on(Am.BUFFER_RESET, this.onBufferReset, this),
            e.on(Am.BUFFER_CREATED, this.onBufferCreated, this),
            e.on(Am.BUFFER_FLUSHING, this.onBufferFlushing, this),
            e.on(Am.BUFFER_FLUSHED, this.onBufferFlushed, this),
            e.on(Am.INIT_PTS_FOUND, this.onInitPtsFound, this),
            e.on(Am.FRAG_LOADING, this.onFragLoading, this),
            e.on(Am.FRAG_BUFFERED, this.onFragBuffered, this);
        }
        unregisterListeners() {
          const { hls: e } = this;
          e &&
            (super.unregisterListeners(),
            e.off(Am.LEVEL_LOADED, this.onLevelLoaded, this),
            e.off(Am.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
            e.off(Am.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
            e.off(Am.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
            e.off(Am.BUFFER_RESET, this.onBufferReset, this),
            e.off(Am.BUFFER_CREATED, this.onBufferCreated, this),
            e.off(Am.BUFFER_FLUSHING, this.onBufferFlushing, this),
            e.off(Am.BUFFER_FLUSHED, this.onBufferFlushed, this),
            e.off(Am.INIT_PTS_FOUND, this.onInitPtsFound, this),
            e.off(Am.FRAG_LOADING, this.onFragLoading, this),
            e.off(Am.FRAG_BUFFERED, this.onFragBuffered, this));
        }
        onInitPtsFound(e, { frag: t, id: i, initPTS: s, timescale: r }) {
          if (i === Cm.MAIN) {
            const e = t.cc,
              i = this.fragCurrent;
            if (
              ((this.initPTS[e] = { baseTime: s, timescale: r }),
              this.log(`InitPTS for cc: ${e} found from main: ${s}/${r}`),
              (this.mainAnchor = t),
              this.state === ZT.WAITING_INIT_PTS)
            ) {
              const i = this.waitingData;
              ((!i && !this.loadingParts) || (i && i.frag.cc !== e)) &&
                (this.nextLoadPosition = this.findSyncFrag(t).start),
                this.tick();
            } else
              !this.hls.hasEnoughToStart && i && i.cc !== e
                ? ((this.startFragRequested = !1),
                  (this.nextLoadPosition = this.findSyncFrag(t).start),
                  i.abortRequests(),
                  this.resetLoadingState())
                : this.state === ZT.IDLE && this.tick();
          }
        }
        findSyncFrag(e) {
          const t = this.getLevelDetails(),
            i = e.cc;
          return (
            (function(e, t, i) {
              if (e && e.startCC <= t && e.endCC >= t) {
                const s = i.start,
                  r = i.end;
                let n = e.fragments;
                if (!i.relurl) {
                  const { fragmentHint: t } = e;
                  t && (n = n.concat(t));
                }
                return h_.search(n, e =>
                  e.cc < t || e.end <= s ? 1 : e.cc > t || e.start >= r ? -1 : 0
                );
              }
              return null;
            })(t, i, e) ||
            (t && E_(t.fragments, i)) ||
            e
          );
        }
        startLoad(e, t) {
          if (!this.levels)
            return (this.startPosition = e), void (this.state = ZT.STOPPED);
          const i = this.lastCurrentTime;
          this.stopLoad(),
            this.setInterval(100),
            i > 0 && -1 === e
              ? (this.log(
                  `Override startPosition with lastCurrentTime @${i.toFixed(3)}`
                ),
                (e = i),
                (this.state = ZT.IDLE))
              : (this.state = ZT.WAITING_TRACK),
            (this.nextLoadPosition = this.lastCurrentTime =
              e + this.timelineOffset),
            (this.startPosition = t ? -1 : e),
            this.tick();
        }
        doTick() {
          switch (this.state) {
            case ZT.IDLE:
              this.doTickIdle();
              break;
            case ZT.WAITING_TRACK: {
              const { levels: e, trackId: t } = this,
                i = null == e ? void 0 : e[t],
                s = null == i ? void 0 : i.details;
              if (s && !this.waitForLive(i)) {
                if (this.waitForCdnTuneIn(s)) break;
                this.state = ZT.WAITING_INIT_PTS;
              }
              break;
            }
            case ZT.FRAG_LOADING_WAITING_RETRY: {
              var e;
              const t = performance.now(),
                i = this.retryDate;
              if (!i || t >= i || (null != (e = this.media) && e.seeking)) {
                const { levels: e, trackId: t } = this;
                this.log("RetryDate reached, switch back to IDLE state"),
                  this.resetStartWhenNotLoaded(
                    (null == e ? void 0 : e[t]) || null
                  ),
                  (this.state = ZT.IDLE);
              }
              break;
            }
            case ZT.WAITING_INIT_PTS: {
              const e = this.waitingData;
              if (e) {
                const { frag: t, part: i, cache: s, complete: r } = e,
                  n = this.mainAnchor;
                if (void 0 !== this.initPTS[t.cc]) {
                  (this.waitingData = null), (this.state = ZT.FRAG_LOADING);
                  const e = {
                    frag: t,
                    part: i,
                    payload: s.flush().buffer,
                    networkDetails: null
                  };
                  this._handleFragmentLoadProgress(e),
                    r && super._handleFragmentLoadComplete(e);
                } else
                  n &&
                    n.cc !== e.frag.cc &&
                    (this.log(
                      `Waiting fragment cc (${t.cc}) cancelled because video is at cc ${n.cc}`
                    ),
                    (this.nextLoadPosition = this.findSyncFrag(n).start),
                    this.clearWaitingFragment());
              } else this.state = ZT.IDLE;
            }
          }
          this.onTickEnd();
        }
        clearWaitingFragment() {
          const e = this.waitingData;
          e &&
            (this.hls.hasEnoughToStart || (this.startFragRequested = !1),
            this.fragmentTracker.removeFragment(e.frag),
            (this.waitingData = null),
            this.state !== ZT.STOPPED && (this.state = ZT.IDLE));
        }
        resetLoadingState() {
          this.clearWaitingFragment(), super.resetLoadingState();
        }
        onTickEnd() {
          const { media: e } = this;
          null != e && e.readyState && (this.lastCurrentTime = e.currentTime);
        }
        doTickIdle() {
          var e;
          const { hls: t, levels: i, media: s, trackId: r } = this,
            n = t.config;
          if (
            !this.buffering ||
            (!s &&
              !this.primaryPrefetch &&
              (this.startFragRequested || !n.startFragPrefetch)) ||
            null == i ||
            !i[r]
          )
            return;
          const a = i[r],
            o = a.details;
          if (!o || this.waitForLive(a) || this.waitForCdnTuneIn(o))
            return (
              (this.state = ZT.WAITING_TRACK),
              void (this.startFragRequested = !1)
            );
          const c = this.mediaBuffer ? this.mediaBuffer : this.media;
          this.bufferFlushed &&
            c &&
            ((this.bufferFlushed = !1),
            this.afterBufferFlushed(c, Xm.AUDIO, Cm.AUDIO));
          const d = this.getFwdBufferInfo(c, Cm.AUDIO);
          if (null === d) return;
          if (!this.switchingTrack && this._streamEnded(d, o))
            return (
              t.trigger(Am.BUFFER_EOS, { type: "audio" }),
              void (this.state = ZT.ENDED)
            );
          const l = d.len,
            h = t.maxBufferLength,
            u = o.fragments,
            p = u[0].start,
            f = this.getLoadPosition(),
            E = this.flushing ? f : d.end;
          if (this.switchingTrack && s) {
            const e = f;
            o.PTSKnown &&
              e < p &&
              (d.end > p || d.nextStart) &&
              (this.log(
                "Alt audio track ahead of main track, seek to start of alt audio track"
              ),
              (s.currentTime = p + 0.05));
          }
          if (l >= h && !this.switchingTrack && E < u[u.length - 1].start)
            return;
          let m = this.getNextFragment(E, o);
          if (
            (m &&
              this.isLoopLoading(m, E) &&
              (m = this.getNextFragmentLoopLoading(m, o, d, Cm.MAIN, h)),
            !m)
          )
            return void (this.bufferFlushed = !0);
          let g =
            (null == (e = this.mainFragLoading) ? void 0 : e.frag) || null;
          if (
            !this.audioOnly &&
            this.startFragRequested &&
            g &&
            Jm(m) &&
            !m.endList &&
            (!o.live ||
              (!this.loadingParts && E < this.hls.liveSyncPosition)) &&
            (this.fragmentTracker.getState(g) === b_ &&
              (this.mainFragLoading = g = null),
            g && Jm(g))
          ) {
            if (m.start > g.end) {
              const e = this.fragmentTracker.getFragAtPos(E, Cm.MAIN);
              e &&
                e.end > g.end &&
                ((g = e),
                (this.mainFragLoading = { frag: e, targetBufferTime: null }));
            }
            if (m.start > g.end) return;
          }
          this.loadFragment(m, a, E);
        }
        onMediaDetaching(e, t) {
          (this.bufferFlushed = this.flushing = !1),
            super.onMediaDetaching(e, t);
        }
        onAudioTracksUpdated(e, { audioTracks: t }) {
          this.resetTransmuxer(), (this.levels = t.map(e => new Zg(e)));
        }
        onAudioTrackSwitching(e, t) {
          const i = !!t.url;
          this.trackId = t.id;
          const { fragCurrent: s } = this;
          s && (s.abortRequests(), this.removeUnbufferedFrags(s.start)),
            this.resetLoadingState(),
            i
              ? ((this.switchingTrack = t),
                this.flushAudioIfNeeded(t),
                this.state !== ZT.STOPPED &&
                  (this.setInterval(100), (this.state = ZT.IDLE), this.tick()))
              : (this.resetTransmuxer(),
                (this.switchingTrack = null),
                (this.bufferedTrack = t),
                this.clearInterval());
        }
        onManifestLoading() {
          super.onManifestLoading(),
            (this.bufferFlushed = this.flushing = this.audioOnly = !1),
            this.resetItem(),
            (this.trackId = -1);
        }
        onLevelLoaded(e, t) {
          this.mainDetails = t.details;
          const i = this.cachedTrackLoadedData;
          i &&
            ((this.cachedTrackLoadedData = null),
            this.onAudioTrackLoaded(Am.AUDIO_TRACK_LOADED, i));
        }
        onAudioTrackLoaded(e, t) {
          var i;
          const { levels: s } = this,
            { details: r, id: n, groupId: a, track: o } = t;
          if (!s)
            return void this.warn(
              `Audio tracks reset while loading track ${n} "${o.name}" of "${a}"`
            );
          const c = this.mainDetails;
          if (!c || r.endCC > c.endCC || c.expired)
            return (
              (this.cachedTrackLoadedData = t),
              void (
                this.state !== ZT.STOPPED && (this.state = ZT.WAITING_TRACK)
              )
            );
          (this.cachedTrackLoadedData = null),
            this.log(
              `Audio track ${n} "${o.name}" of "${a}" loaded [${r.startSN},${
                r.endSN
              }]${
                r.lastPartSn ? `[part-${r.lastPartSn}-${r.lastPartIndex}]` : ""
              },duration:${r.totalduration}`
            );
          const d = s[n];
          let l = 0;
          if (r.live || (null != (i = d.details) && i.live)) {
            if ((this.checkLiveUpdate(r), r.deltaUpdateFailed)) return;
            var h;
            if (d.details)
              l = this.alignPlaylists(
                r,
                d.details,
                null == (h = this.levelLastLoaded) ? void 0 : h.details
              );
            r.alignedSliding ||
              (zT(r, c), r.alignedSliding || JT(r, c), (l = r.fragmentStart));
          }
          (d.details = r),
            (this.levelLastLoaded = d),
            this.startFragRequested || this.setStartPosition(c, l),
            this.hls.trigger(Am.AUDIO_TRACK_UPDATED, {
              details: r,
              id: n,
              groupId: t.groupId
            }),
            this.state !== ZT.WAITING_TRACK ||
              this.waitForCdnTuneIn(r) ||
              (this.state = ZT.IDLE),
            this.tick();
        }
        _handleFragmentLoadProgress(e) {
          var t;
          const i = e.frag,
            { part: s, payload: r } = e,
            { config: n, trackId: a, levels: o } = this;
          if (!o)
            return void this.warn(
              `Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`
            );
          const c = o[a];
          if (!c)
            return void this.warn(
              "Audio track is undefined on fragment load progress"
            );
          const d = c.details;
          if (!d)
            return (
              this.warn(
                "Audio track details undefined on fragment load progress"
              ),
              void this.removeUnbufferedFrags(i.start)
            );
          const l = n.defaultAudioCodec || c.audioCodec || "mp4a.40.2";
          let h = this.transmuxer;
          h ||
            (h = this.transmuxer = new Pv(
              this.hls,
              Cm.AUDIO,
              this._handleTransmuxComplete.bind(this),
              this._handleTransmuxerFlush.bind(this)
            ));
          const u = this.initPTS[i.cc],
            p = null == (t = i.initSegment) ? void 0 : t.data;
          if (void 0 !== u) {
            const e = !1,
              t = s ? s.index : -1,
              n = -1 !== t,
              a = new j_(i.level, i.sn, i.stats.chunkCount, r.byteLength, t, n);
            h.push(r, p, l, "", i, s, d.totalduration, e, a, u);
          } else {
            this.log(
              `Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${d.startSN} ,${d.endSN}],track ${a}`
            );
            const { cache: e } = (this.waitingData = this.waitingData || {
              frag: i,
              part: s,
              cache: new iS(),
              complete: !1
            });
            e.push(new Uint8Array(r)),
              this.state !== ZT.STOPPED && (this.state = ZT.WAITING_INIT_PTS);
          }
        }
        _handleFragmentLoadComplete(e) {
          this.waitingData
            ? (this.waitingData.complete = !0)
            : super._handleFragmentLoadComplete(e);
        }
        onBufferReset() {
          this.mediaBuffer = null;
        }
        onBufferCreated(e, t) {
          this.bufferFlushed = this.flushing = !1;
          const i = t.tracks.audio;
          i && (this.mediaBuffer = i.buffer || null);
        }
        onFragLoading(e, t) {
          !this.audioOnly &&
            t.frag.type === Cm.MAIN &&
            Jm(t.frag) &&
            ((this.mainFragLoading = t), this.state === ZT.IDLE && this.tick());
        }
        onFragBuffered(e, t) {
          const { frag: i, part: s } = t;
          if (i.type === Cm.AUDIO)
            if (this.fragContextChanged(i))
              this.warn(
                `Fragment ${i.sn}${s ? " p: " + s.index : ""} of level ${
                  i.level
                } finished buffering, but was aborted. state: ${
                  this.state
                }, audioSwitch: ${
                  this.switchingTrack ? this.switchingTrack.name : "false"
                }`
              );
            else {
              if (Jm(i)) {
                this.fragPrevious = i;
                const e = this.switchingTrack;
                e &&
                  ((this.bufferedTrack = e),
                  (this.switchingTrack = null),
                  this.hls.trigger(Am.AUDIO_TRACK_SWITCHED, Nm({}, e)));
              }
              this.fragBufferedComplete(i, s), this.media && this.tick();
            }
          else
            this.audioOnly ||
              i.type !== Cm.MAIN ||
              i.elementaryStreams.video ||
              i.elementaryStreams.audiovideo ||
              ((this.audioOnly = !0), (this.mainFragLoading = null));
        }
        onError(e, t) {
          var i;
          if (t.fatal) this.state = ZT.ERROR;
          else
            switch (t.details) {
              case ym.FRAG_GAP:
              case ym.FRAG_PARSING_ERROR:
              case ym.FRAG_DECRYPT_ERROR:
              case ym.FRAG_LOAD_ERROR:
              case ym.FRAG_LOAD_TIMEOUT:
              case ym.KEY_LOAD_ERROR:
              case ym.KEY_LOAD_TIMEOUT:
                this.onFragmentOrKeyLoadError(Cm.AUDIO, t);
                break;
              case ym.AUDIO_TRACK_LOAD_ERROR:
              case ym.AUDIO_TRACK_LOAD_TIMEOUT:
              case ym.LEVEL_PARSING_ERROR:
                t.levelRetry ||
                  this.state !== ZT.WAITING_TRACK ||
                  (null == (i = t.context) ? void 0 : i.type) !==
                    Im.AUDIO_TRACK ||
                  (this.state = ZT.IDLE);
                break;
              case ym.BUFFER_ADD_CODEC_ERROR:
              case ym.BUFFER_APPEND_ERROR:
                if ("audio" !== t.parent) return;
                this.resetLoadingState();
                break;
              case ym.BUFFER_FULL_ERROR:
                if ("audio" !== t.parent) return;
                this.reduceLengthAndFlushBuffer(t) &&
                  ((this.bufferedTrack = null),
                  super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
                break;
              case ym.INTERNAL_EXCEPTION:
                this.recoverWorkerError(t);
            }
        }
        onBufferFlushing(e, { type: t }) {
          t !== Xm.VIDEO && (this.flushing = !0);
        }
        onBufferFlushed(e, { type: t }) {
          if (t !== Xm.VIDEO) {
            (this.flushing = !1),
              (this.bufferFlushed = !0),
              this.state === ZT.ENDED && (this.state = ZT.IDLE);
            const e = this.mediaBuffer || this.media;
            e && (this.afterBufferFlushed(e, t, Cm.AUDIO), this.tick());
          }
        }
        _handleTransmuxComplete(e) {
          var t;
          const i = "audio",
            { hls: s } = this,
            { remuxResult: r, chunkMeta: n } = e,
            a = this.getCurrentContext(n);
          if (!a) return void this.resetWhenMissingContext(n);
          const { frag: o, part: c, level: d } = a,
            { details: l } = d,
            { audio: h, text: u, id3: p, initSegment: f } = r;
          if (!this.fragContextChanged(o) && l) {
            if (
              ((this.state = ZT.PARSING),
              this.switchingTrack &&
                h &&
                this.completeAudioSwitch(this.switchingTrack),
              null != f && f.tracks)
            ) {
              const e = o.initSegment || o;
              this._bufferInitSegment(d, f.tracks, e, n),
                s.trigger(Am.FRAG_PARSING_INIT_SEGMENT, {
                  frag: e,
                  id: i,
                  tracks: f.tracks
                });
            }
            if (h) {
              const { startPTS: e, endPTS: t, startDTS: i, endDTS: s } = h;
              c &&
                (c.elementaryStreams[Xm.AUDIO] = {
                  startPTS: e,
                  endPTS: t,
                  startDTS: i,
                  endDTS: s
                }),
                o.setElementaryStreamInfo(Xm.AUDIO, e, t, i, s),
                this.bufferFragmentData(h, o, c, n);
            }
            if (null != p && null != (t = p.samples) && t.length) {
              const e = wm({ id: i, frag: o, details: l }, p);
              s.trigger(Am.FRAG_PARSING_METADATA, e);
            }
            if (u) {
              const e = wm({ id: i, frag: o, details: l }, u);
              s.trigger(Am.FRAG_PARSING_USERDATA, e);
            }
          } else this.fragmentTracker.removeFragment(o);
        }
        _bufferInitSegment(e, t, i, s) {
          if (this.state !== ZT.PARSING) return;
          if (
            (t.video && delete t.video,
            t.audiovideo && delete t.audiovideo,
            !t.audio)
          )
            return;
          const r = t.audio;
          r.id = Cm.AUDIO;
          const n = e.audioCodec;
          this.log(
            `Init audio buffer, container:${r.container}, codecs[level/parsed]=[${n}/${r.codec}]`
          ),
            n && 1 === n.split(",").length && (r.levelCodec = n),
            this.hls.trigger(Am.BUFFER_CODECS, t);
          const a = r.initSegment;
          if (null != a && a.byteLength) {
            const e = {
              type: "audio",
              frag: i,
              part: null,
              chunkMeta: s,
              parent: i.type,
              data: a
            };
            this.hls.trigger(Am.BUFFER_APPENDING, e);
          }
          this.tickImmediate();
        }
        loadFragment(e, t, i) {
          const s = this.fragmentTracker.getState(e);
          var r;
          if (this.switchingTrack || s === A_ || s === C_)
            if (Jm(e))
              if (null != (r = t.details) && r.live && !this.initPTS[e.cc]) {
                this.log(
                  `Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`
                ),
                  (this.state = ZT.WAITING_INIT_PTS);
                const i = this.mainDetails;
                i &&
                  i.fragmentStart !== t.details.fragmentStart &&
                  JT(t.details, i);
              } else super.loadFragment(e, t, i);
            else this._loadInitSegment(e, t);
          else this.clearTrackerIfNeeded(e);
        }
        flushAudioIfNeeded(e) {
          if (this.media && this.bufferedTrack) {
            const {
              name: t,
              lang: i,
              assocLang: s,
              characteristics: r,
              audioCodec: n,
              channels: a
            } = this.bufferedTrack;
            o_(
              {
                name: t,
                lang: i,
                assocLang: s,
                characteristics: r,
                audioCodec: n,
                channels: a
              },
              e,
              c_
            ) ||
              (l_(e.url, this.hls)
                ? (this.log("Switching audio track : flushing all audio"),
                  super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"),
                  (this.bufferedTrack = null))
                : (this.bufferedTrack = e));
          }
        }
        completeAudioSwitch(e) {
          const { hls: t } = this;
          this.flushAudioIfNeeded(e),
            (this.bufferedTrack = e),
            (this.switchingTrack = null),
            t.trigger(Am.AUDIO_TRACK_SWITCHED, Nm({}, e));
        }
      },
      audioTrackController: class extends kv {
        constructor(e) {
          super(e, "audio-track-controller"),
            (this.tracks = []),
            (this.groupIds = null),
            (this.tracksInGroup = []),
            (this.trackId = -1),
            (this.currentTrack = null),
            (this.selectDefaultTrack = !0),
            this.registerListeners();
        }
        registerListeners() {
          const { hls: e } = this;
          e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.on(Am.MANIFEST_PARSED, this.onManifestParsed, this),
            e.on(Am.LEVEL_LOADING, this.onLevelLoading, this),
            e.on(Am.LEVEL_SWITCHING, this.onLevelSwitching, this),
            e.on(Am.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
            e.on(Am.ERROR, this.onError, this);
        }
        unregisterListeners() {
          const { hls: e } = this;
          e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.off(Am.MANIFEST_PARSED, this.onManifestParsed, this),
            e.off(Am.LEVEL_LOADING, this.onLevelLoading, this),
            e.off(Am.LEVEL_SWITCHING, this.onLevelSwitching, this),
            e.off(Am.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
            e.off(Am.ERROR, this.onError, this);
        }
        destroy() {
          this.unregisterListeners(),
            (this.tracks.length = 0),
            (this.tracksInGroup.length = 0),
            (this.currentTrack = null),
            super.destroy();
        }
        onManifestLoading() {
          (this.tracks = []),
            (this.tracksInGroup = []),
            (this.groupIds = null),
            (this.currentTrack = null),
            (this.trackId = -1),
            (this.selectDefaultTrack = !0);
        }
        onManifestParsed(e, t) {
          this.tracks = t.audioTracks || [];
        }
        onAudioTrackLoaded(e, t) {
          const { id: i, groupId: s, details: r } = t,
            n = this.tracksInGroup[i];
          if (!n || n.groupId !== s)
            return void this.warn(
              `Audio track with id:${i} and group:${s} not found in active group ${
                null == n ? void 0 : n.groupId
              }`
            );
          const a = n.details;
          (n.details = t.details),
            this.log(
              `Audio track ${i} "${n.name}" lang:${n.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`
            ),
            i === this.trackId && this.playlistLoaded(i, t, a);
        }
        onLevelLoading(e, t) {
          this.switchLevel(t.level);
        }
        onLevelSwitching(e, t) {
          this.switchLevel(t.level);
        }
        switchLevel(e) {
          const t = this.hls.levels[e];
          if (!t) return;
          const i = t.audioGroups || null,
            s = this.groupIds;
          let r = this.currentTrack;
          if (
            !i ||
            (null == s ? void 0 : s.length) !==
              (null == i ? void 0 : i.length) ||
            (null != i &&
              i.some(e => -1 === (null == s ? void 0 : s.indexOf(e))))
          ) {
            (this.groupIds = i),
              (this.trackId = -1),
              (this.currentTrack = null);
            const e = this.tracks.filter(
              e => !i || -1 !== i.indexOf(e.groupId)
            );
            if (e.length)
              this.selectDefaultTrack &&
                !e.some(e => e.default) &&
                (this.selectDefaultTrack = !1),
                e.forEach((e, t) => {
                  e.id = t;
                });
            else if (!r && !this.tracksInGroup.length) return;
            this.tracksInGroup = e;
            const t = this.hls.config.audioPreference;
            if (!r && t) {
              const i = a_(t, e, c_);
              if (i > -1) r = e[i];
              else {
                const e = a_(t, this.tracks);
                r = this.tracks[e];
              }
            }
            let s = this.findTrackId(r);
            -1 === s && r && (s = this.findTrackId(null));
            const a = { audioTracks: e };
            this.log(
              `Updating audio tracks, ${e.length} track(s) found in group(s): ${
                null == i ? void 0 : i.join(",")
              }`
            ),
              this.hls.trigger(Am.AUDIO_TRACKS_UPDATED, a);
            const o = this.trackId;
            if (-1 !== s && -1 === o) this.setAudioTrack(s);
            else if (e.length && -1 === o) {
              var n;
              const t = new Error(
                `No audio track selected for current audio group-ID(s): ${
                  null == (n = this.groupIds) ? void 0 : n.join(",")
                } track count: ${e.length}`
              );
              this.warn(t.message),
                this.hls.trigger(Am.ERROR, {
                  type: Rm.MEDIA_ERROR,
                  details: ym.AUDIO_TRACK_LOAD_ERROR,
                  fatal: !0,
                  error: t
                });
            }
          }
        }
        onError(e, t) {
          !t.fatal &&
            t.context &&
            (t.context.type !== Im.AUDIO_TRACK ||
              t.context.id !== this.trackId ||
              (this.groupIds &&
                -1 === this.groupIds.indexOf(t.context.groupId)) ||
              this.checkRetry(t));
        }
        get allAudioTracks() {
          return this.tracks;
        }
        get audioTracks() {
          return this.tracksInGroup;
        }
        get audioTrack() {
          return this.trackId;
        }
        set audioTrack(e) {
          (this.selectDefaultTrack = !1), this.setAudioTrack(e);
        }
        setAudioOption(e) {
          const t = this.hls;
          if (((t.config.audioPreference = e), e)) {
            const i = this.allAudioTracks;
            if (((this.selectDefaultTrack = !1), i.length)) {
              const s = this.currentTrack;
              if (s && o_(e, s, c_)) return s;
              const r = a_(e, this.tracksInGroup, c_);
              if (r > -1) {
                const e = this.tracksInGroup[r];
                return this.setAudioTrack(r), e;
              }
              if (s) {
                let s = t.loadLevel;
                -1 === s && (s = t.firstAutoLevel);
                const r = (function(e, t, i, s, r) {
                  const n = t[s],
                    a = t.reduce((e, t, i) => {
                      const s = t.uri;
                      return (e[s] || (e[s] = [])).push(i), e;
                    }, {})[n.uri];
                  a.length > 1 && (s = Math.max.apply(Math, a));
                  const o = n.videoRange,
                    c = n.frameRate,
                    d = n.codecSet.substring(0, 4),
                    l = d_(t, s, t => {
                      if (
                        t.videoRange !== o ||
                        t.frameRate !== c ||
                        t.codecSet.substring(0, 4) !== d
                      )
                        return !1;
                      const s = t.audioGroups,
                        n = i.filter(e => !s || -1 !== s.indexOf(e.groupId));
                      return a_(e, n, r) > -1;
                    });
                  return l > -1
                    ? l
                    : d_(t, s, t => {
                        const s = t.audioGroups,
                          n = i.filter(e => !s || -1 !== s.indexOf(e.groupId));
                        return a_(e, n, r) > -1;
                      });
                })(e, t.levels, i, s, c_);
                if (-1 === r) return null;
                t.nextLoadLevel = r;
              }
              if (e.channels || e.audioCodec) {
                const t = a_(e, i);
                if (t > -1) return i[t];
              }
            }
          }
          return null;
        }
        setAudioTrack(e) {
          const t = this.tracksInGroup;
          if (e < 0 || e >= t.length)
            return void this.warn(`Invalid audio track id: ${e}`);
          this.selectDefaultTrack = !1;
          const i = this.currentTrack,
            s = t[e],
            r = s.details && !s.details.live;
          if (e === this.trackId && s === i && r) return;
          if (
            (this.log(
              `Switching to audio-track ${e} "${s.name}" lang:${s.lang} group:${s.groupId} channels:${s.channels}`
            ),
            (this.trackId = e),
            (this.currentTrack = s),
            this.hls.trigger(Am.AUDIO_TRACK_SWITCHING, Nm({}, s)),
            r)
          )
            return;
          const n = this.switchParams(
            s.url,
            null == i ? void 0 : i.details,
            s.details
          );
          this.loadPlaylist(n);
        }
        findTrackId(e) {
          const t = this.tracksInGroup;
          for (let i = 0; i < t.length; i++) {
            const s = t[i];
            if ((!this.selectDefaultTrack || s.default) && (!e || o_(e, s, c_)))
              return i;
          }
          if (e) {
            const {
              name: i,
              lang: s,
              assocLang: r,
              characteristics: n,
              audioCodec: a,
              channels: o
            } = e;
            for (let e = 0; e < t.length; e++) {
              if (
                o_(
                  {
                    name: i,
                    lang: s,
                    assocLang: r,
                    characteristics: n,
                    audioCodec: a,
                    channels: o
                  },
                  t[e],
                  c_
                )
              )
                return e;
            }
            for (let i = 0; i < t.length; i++) {
              const s = t[i];
              if (
                Uv(e.attrs, s.attrs, [
                  "LANGUAGE",
                  "ASSOC-LANGUAGE",
                  "CHARACTERISTICS"
                ])
              )
                return i;
            }
            for (let i = 0; i < t.length; i++) {
              const s = t[i];
              if (Uv(e.attrs, s.attrs, ["LANGUAGE"])) return i;
            }
          }
          return -1;
        }
        loadPlaylist(e) {
          super.loadPlaylist();
          const t = this.currentTrack;
          this.shouldLoadPlaylist(t) &&
            l_(t.url, this.hls) &&
            this.scheduleLoading(t, e);
        }
        loadingPlaylist(e, t) {
          super.loadingPlaylist(e, t);
          const i = e.id,
            s = e.groupId,
            r = this.getUrlWithDirectives(e.url, t),
            n = e.details,
            a = null == n ? void 0 : n.age;
          this.log(
            `Loading audio-track ${i} "${e.name}" lang:${e.lang} group:${s}${
              void 0 !== (null == t ? void 0 : t.msn)
                ? " at sn " + t.msn + " part " + t.part
                : ""
            }${
              a && n.live
                ? " age " + a.toFixed(1) + ((n.type && " " + n.type) || "")
                : ""
            } ${r}`
          ),
            this.hls.trigger(Am.AUDIO_TRACK_LOADING, {
              url: r,
              id: i,
              groupId: s,
              deliveryDirectives: t || null,
              track: e
            });
        }
      },
      emeController: DR,
      cmcdController: class {
        constructor(e) {
          (this.hls = void 0),
            (this.config = void 0),
            (this.media = void 0),
            (this.sid = void 0),
            (this.cid = void 0),
            (this.useHeaders = !1),
            (this.includeKeys = void 0),
            (this.initialized = !1),
            (this.starved = !1),
            (this.buffering = !0),
            (this.audioBuffer = void 0),
            (this.videoBuffer = void 0),
            (this.onWaiting = () => {
              this.initialized && (this.starved = !0), (this.buffering = !0);
            }),
            (this.onPlaying = () => {
              this.initialized || (this.initialized = !0),
                (this.buffering = !1);
            }),
            (this.applyPlaylistData = e => {
              try {
                this.apply(e, { ot: Wv.MANIFEST, su: !this.initialized });
              } catch (e) {
                this.hls.logger.warn(
                  "Could not generate manifest CMCD data.",
                  e
                );
              }
            }),
            (this.applyFragmentData = e => {
              try {
                const { frag: t, part: i } = e,
                  s = this.hls.levels[t.level],
                  r = this.getObjectType(t),
                  n = { d: 1e3 * (i || t).duration, ot: r };
                (r !== Wv.VIDEO && r !== Wv.AUDIO && r != Wv.MUXED) ||
                  ((n.br = s.bitrate / 1e3),
                  (n.tb = this.getTopBandwidth(r) / 1e3),
                  (n.bl = this.getBufferLength(r)));
                const a = i ? this.getNextPart(i) : this.getNextFrag(t);
                null != a && a.url && a.url !== t.url && (n.nor = a.url),
                  this.apply(e, n);
              } catch (e) {
                this.hls.logger.warn(
                  "Could not generate segment CMCD data.",
                  e
                );
              }
            }),
            (this.hls = e);
          const t = (this.config = e.config),
            { cmcd: i } = t;
          null != i &&
            ((t.pLoader = this.createPlaylistLoader()),
            (t.fLoader = this.createFragmentLoader()),
            (this.sid = i.sessionId || e.sessionId),
            (this.cid = i.contentId),
            (this.useHeaders = !0 === i.useHeaders),
            (this.includeKeys = i.includeKeys),
            this.registerListeners());
        }
        registerListeners() {
          const e = this.hls;
          e.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
            e.on(Am.MEDIA_DETACHED, this.onMediaDetached, this),
            e.on(Am.BUFFER_CREATED, this.onBufferCreated, this);
        }
        unregisterListeners() {
          const e = this.hls;
          e.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
            e.off(Am.MEDIA_DETACHED, this.onMediaDetached, this),
            e.off(Am.BUFFER_CREATED, this.onBufferCreated, this);
        }
        destroy() {
          this.unregisterListeners(),
            this.onMediaDetached(),
            (this.hls = this.config = this.audioBuffer = this.videoBuffer = null),
            (this.onWaiting = this.onPlaying = this.media = null);
        }
        onMediaAttached(e, t) {
          (this.media = t.media),
            this.media.addEventListener("waiting", this.onWaiting),
            this.media.addEventListener("playing", this.onPlaying);
        }
        onMediaDetached() {
          this.media &&
            (this.media.removeEventListener("waiting", this.onWaiting),
            this.media.removeEventListener("playing", this.onPlaying),
            (this.media = null));
        }
        onBufferCreated(e, t) {
          var i, s;
          (this.audioBuffer = null == (i = t.tracks.audio) ? void 0 : i.buffer),
            (this.videoBuffer =
              null == (s = t.tracks.video) ? void 0 : s.buffer);
        }
        createData() {
          var e;
          return {
            v: 1,
            sf: Yv.HLS,
            sid: this.sid,
            cid: this.cid,
            pr: null == (e = this.media) ? void 0 : e.playbackRate,
            mtp: this.hls.bandwidthEstimate / 1e3
          };
        }
        apply(e, t = {}) {
          wm(t, this.createData());
          const i = t.ot === Wv.INIT || t.ot === Wv.VIDEO || t.ot === Wv.MUXED;
          this.starved && i && ((t.bs = !0), (t.su = !0), (this.starved = !1)),
            null == t.su && (t.su = this.buffering);
          const { includeKeys: s } = this;
          s &&
            (t = Object.keys(t).reduce(
              (e, i) => (s.includes(i) && (e[i] = t[i]), e),
              {}
            ));
          const r = { baseUrl: e.url };
          this.useHeaders
            ? (e.headers || (e.headers = {}), yR(e.headers, t, r))
            : (e.url = CR(e.url, t, r));
        }
        getNextFrag(e) {
          var t;
          const i = null == (t = this.hls.levels[e.level]) ? void 0 : t.details;
          if (i) {
            const t = e.sn - i.startSN;
            return i.fragments[t + 1];
          }
        }
        getNextPart(e) {
          var t, i;
          const { index: s, fragment: r } = e,
            n =
              null == (t = this.hls.levels[r.level]) || null == (i = t.details)
                ? void 0
                : i.partList;
          if (n) {
            const { sn: e } = r;
            for (let t = n.length - 1; t >= 0; t--) {
              const i = n[t];
              if (i.index === s && i.fragment.sn === e) return n[t + 1];
            }
          }
        }
        getObjectType(e) {
          const { type: t } = e;
          return "subtitle" === t
            ? Wv.TIMED_TEXT
            : "initSegment" === e.sn
            ? Wv.INIT
            : "audio" === t
            ? Wv.AUDIO
            : "main" === t
            ? this.hls.audioTracks.length
              ? Wv.VIDEO
              : Wv.MUXED
            : void 0;
        }
        getTopBandwidth(e) {
          let t,
            i = 0;
          const s = this.hls;
          if (e === Wv.AUDIO) t = s.audioTracks;
          else {
            const e = s.maxAutoLevel,
              i = e > -1 ? e + 1 : s.levels.length;
            t = s.levels.slice(0, i);
          }
          for (const e of t) e.bitrate > i && (i = e.bitrate);
          return i > 0 ? i : NaN;
        }
        getBufferLength(e) {
          const t = this.media,
            i = e === Wv.AUDIO ? this.audioBuffer : this.videoBuffer;
          if (!i || !t) return NaN;
          return (
            1e3 * K_.bufferInfo(i, t.currentTime, this.config.maxBufferHole).len
          );
        }
        createPlaylistLoader() {
          const { pLoader: e } = this.config,
            t = this.applyPlaylistData,
            i = e || this.config.loader;
          return class {
            constructor(e) {
              (this.loader = void 0), (this.loader = new i(e));
            }
            get stats() {
              return this.loader.stats;
            }
            get context() {
              return this.loader.context;
            }
            destroy() {
              this.loader.destroy();
            }
            abort() {
              this.loader.abort();
            }
            load(e, i, s) {
              t(e), this.loader.load(e, i, s);
            }
          };
        }
        createFragmentLoader() {
          const { fLoader: e } = this.config,
            t = this.applyFragmentData,
            i = e || this.config.loader;
          return class {
            constructor(e) {
              (this.loader = void 0), (this.loader = new i(e));
            }
            get stats() {
              return this.loader.stats;
            }
            get context() {
              return this.loader.context;
            }
            destroy() {
              this.loader.destroy();
            }
            abort() {
              this.loader.abort();
            }
            load(e, i, s) {
              t(e), this.loader.load(e, i, s);
            }
          };
        }
      },
      contentSteeringController: class extends Pm {
        constructor(e) {
          super("content-steering", e.logger),
            (this.hls = void 0),
            (this.loader = null),
            (this.uri = null),
            (this.pathwayId = "."),
            (this._pathwayPriority = null),
            (this.timeToLoad = 300),
            (this.reloadTimer = -1),
            (this.updated = 0),
            (this.started = !1),
            (this.enabled = !0),
            (this.levels = null),
            (this.audioTracks = null),
            (this.subtitleTracks = null),
            (this.penalizedPathways = {}),
            (this.hls = e),
            this.registerListeners();
        }
        registerListeners() {
          const e = this.hls;
          e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.on(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
            e.on(Am.MANIFEST_PARSED, this.onManifestParsed, this),
            e.on(Am.ERROR, this.onError, this);
        }
        unregisterListeners() {
          const e = this.hls;
          e &&
            (e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.off(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
            e.off(Am.MANIFEST_PARSED, this.onManifestParsed, this),
            e.off(Am.ERROR, this.onError, this));
        }
        pathways() {
          return (this.levels || []).reduce(
            (e, t) => (-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e),
            []
          );
        }
        get pathwayPriority() {
          return this._pathwayPriority;
        }
        set pathwayPriority(e) {
          this.updatePathwayPriority(e);
        }
        startLoad() {
          if (
            ((this.started = !0), this.clearTimeout(), this.enabled && this.uri)
          ) {
            if (this.updated) {
              const e =
                1e3 * this.timeToLoad - (performance.now() - this.updated);
              if (e > 0) return void this.scheduleRefresh(this.uri, e);
            }
            this.loadSteeringManifest(this.uri);
          }
        }
        stopLoad() {
          (this.started = !1),
            this.loader && (this.loader.destroy(), (this.loader = null)),
            this.clearTimeout();
        }
        clearTimeout() {
          -1 !== this.reloadTimer &&
            (self.clearTimeout(this.reloadTimer), (this.reloadTimer = -1));
        }
        destroy() {
          this.unregisterListeners(),
            this.stopLoad(),
            (this.hls = null),
            (this.levels = this.audioTracks = this.subtitleTracks = null);
        }
        removeLevel(e) {
          const t = this.levels;
          t && (this.levels = t.filter(t => t !== e));
        }
        onManifestLoading() {
          this.stopLoad(),
            (this.enabled = !0),
            (this.timeToLoad = 300),
            (this.updated = 0),
            (this.uri = null),
            (this.pathwayId = "."),
            (this.levels = this.audioTracks = this.subtitleTracks = null);
        }
        onManifestLoaded(e, t) {
          const { contentSteering: i } = t;
          null !== i &&
            ((this.pathwayId = i.pathwayId),
            (this.uri = i.uri),
            this.started && this.startLoad());
        }
        onManifestParsed(e, t) {
          (this.audioTracks = t.audioTracks),
            (this.subtitleTracks = t.subtitleTracks);
        }
        onError(e, t) {
          const { errorAction: i } = t;
          if (
            (null == i ? void 0 : i.action) === v_.SendAlternateToPenaltyBox &&
            i.flags === R_.MoveAllAlternatesMatchingHost
          ) {
            const e = this.levels;
            let s = this._pathwayPriority,
              r = this.pathwayId;
            if (t.context) {
              const { groupId: i, pathwayId: s, type: n } = t.context;
              i && e ? (r = this.getPathwayForGroupId(i, n, r)) : s && (r = s);
            }
            r in this.penalizedPathways ||
              (this.penalizedPathways[r] = performance.now()),
              !s && e && (s = this.pathways()),
              s &&
                s.length > 1 &&
                (this.updatePathwayPriority(s),
                (i.resolved = this.pathwayId !== r)),
              i.resolved ||
                this.warn(
                  `Could not resolve ${t.details} ("${
                    t.error.message
                  }") with content-steering for Pathway: ${r} levels: ${
                    e ? e.length : e
                  } priorities: ${i_(s)} penalized: ${i_(
                    this.penalizedPathways
                  )}`
                );
          }
        }
        filterParsedLevels(e) {
          this.levels = e;
          let t = this.getLevelsForPathway(this.pathwayId);
          if (0 === t.length) {
            const i = e[0].pathwayId;
            this.log(
              `No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`
            ),
              (t = this.getLevelsForPathway(i)),
              (this.pathwayId = i);
          }
          return (
            t.length !== e.length &&
              this.log(
                `Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`
              ),
            t
          );
        }
        getLevelsForPathway(e) {
          return null === this.levels
            ? []
            : this.levels.filter(t => e === t.pathwayId);
        }
        updatePathwayPriority(e) {
          let t;
          this._pathwayPriority = e;
          const i = this.penalizedPathways,
            s = performance.now();
          Object.keys(i).forEach(e => {
            s - i[e] > 3e5 && delete i[e];
          });
          for (let s = 0; s < e.length; s++) {
            const r = e[s];
            if (r in i) continue;
            if (r === this.pathwayId) return;
            const n = this.hls.nextLoadLevel,
              a = this.hls.levels[n];
            if (((t = this.getLevelsForPathway(r)), t.length > 0)) {
              this.log(`Setting Pathway to "${r}"`),
                (this.pathwayId = r),
                YT(t),
                this.hls.trigger(Am.LEVELS_UPDATED, { levels: t });
              const e = this.hls.levels[n];
              a &&
                e &&
                this.levels &&
                (e.attrs["STABLE-VARIANT-ID"] !==
                  a.attrs["STABLE-VARIANT-ID"] &&
                  e.bitrate !== a.bitrate &&
                  this.log(
                    `Unstable Pathways change from bitrate ${a.bitrate} to ${e.bitrate}`
                  ),
                (this.hls.nextLoadLevel = n));
              break;
            }
          }
        }
        getPathwayForGroupId(e, t, i) {
          const s = this.getLevelsForPathway(i).concat(this.levels || []);
          for (let i = 0; i < s.length; i++)
            if (
              (t === Im.AUDIO_TRACK && s[i].hasAudioGroup(e)) ||
              (t === Im.SUBTITLE_TRACK && s[i].hasSubtitleGroup(e))
            )
              return s[i].pathwayId;
          return i;
        }
        clonePathways(e) {
          const t = this.levels;
          if (!t) return;
          const i = {},
            s = {};
          e.forEach(e => {
            const { ID: r, "BASE-ID": n, "URI-REPLACEMENT": a } = e;
            if (t.some(e => e.pathwayId === r)) return;
            const o = this.getLevelsForPathway(n).map(e => {
              const t = new Q_(e.attrs);
              t["PATHWAY-ID"] = r;
              const n = t.AUDIO && `${t.AUDIO}_clone_${r}`,
                o = t.SUBTITLES && `${t.SUBTITLES}_clone_${r}`;
              n && ((i[t.AUDIO] = n), (t.AUDIO = n)),
                o && ((s[t.SUBTITLES] = o), (t.SUBTITLES = o));
              const c = OR(
                  e.uri,
                  t["STABLE-VARIANT-ID"],
                  "PER-VARIANT-URIS",
                  a
                ),
                d = new Zg({
                  attrs: t,
                  audioCodec: e.audioCodec,
                  bitrate: e.bitrate,
                  height: e.height,
                  name: e.name,
                  url: c,
                  videoCodec: e.videoCodec,
                  width: e.width
                });
              if (e.audioGroups)
                for (let t = 1; t < e.audioGroups.length; t++)
                  d.addGroupId("audio", `${e.audioGroups[t]}_clone_${r}`);
              if (e.subtitleGroups)
                for (let t = 1; t < e.subtitleGroups.length; t++)
                  d.addGroupId("text", `${e.subtitleGroups[t]}_clone_${r}`);
              return d;
            });
            t.push(...o),
              bR(this.audioTracks, i, a, r),
              bR(this.subtitleTracks, s, a, r);
          });
        }
        loadSteeringManifest(e) {
          const t = this.hls.config,
            i = t.loader;
          let s;
          this.loader && this.loader.destroy(), (this.loader = new i(t));
          try {
            s = new self.URL(e);
          } catch (t) {
            return (
              (this.enabled = !1),
              void this.log(`Failed to parse Steering Manifest URI: ${e}`)
            );
          }
          if ("data:" !== s.protocol) {
            const e =
              0 | (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate);
            s.searchParams.set("_HLS_pathway", this.pathwayId),
              s.searchParams.set("_HLS_throughput", "" + e);
          }
          const r = { responseType: "json", url: s.href },
            n = t.steeringManifestLoadPolicy.default,
            a = n.errorRetry || n.timeoutRetry || {},
            o = {
              loadPolicy: n,
              timeout: n.maxLoadTimeMs,
              maxRetry: a.maxNumRetry || 0,
              retryDelay: a.retryDelayMs || 0,
              maxRetryDelay: a.maxRetryDelayMs || 0
            },
            c = {
              onSuccess: (e, t, i, r) => {
                this.log(`Loaded steering manifest: "${s}"`);
                const n = e.data;
                if (1 !== (null == n ? void 0 : n.VERSION))
                  return void this.log(
                    `Steering VERSION ${n.VERSION} not supported!`
                  );
                (this.updated = performance.now()), (this.timeToLoad = n.TTL);
                const {
                  "RELOAD-URI": a,
                  "PATHWAY-CLONES": o,
                  "PATHWAY-PRIORITY": c
                } = n;
                if (a)
                  try {
                    this.uri = new self.URL(a, s).href;
                  } catch (e) {
                    return (
                      (this.enabled = !1),
                      void this.log(
                        `Failed to parse Steering Manifest RELOAD-URI: ${a}`
                      )
                    );
                  }
                this.scheduleRefresh(this.uri || i.url),
                  o && this.clonePathways(o);
                const d = { steeringManifest: n, url: s.toString() };
                this.hls.trigger(Am.STEERING_MANIFEST_LOADED, d),
                  c && this.updatePathwayPriority(c);
              },
              onError: (e, t, i, s) => {
                if (
                  (this.log(
                    `Error loading steering manifest: ${e.code} ${e.text} (${t.url})`
                  ),
                  this.stopLoad(),
                  410 === e.code)
                )
                  return (
                    (this.enabled = !1),
                    void this.log(
                      `Steering manifest ${t.url} no longer available`
                    )
                  );
                let r = 1e3 * this.timeToLoad;
                if (429 !== e.code) this.scheduleRefresh(this.uri || t.url, r);
                else {
                  const e = this.loader;
                  if (
                    "function" ==
                    typeof (null == e ? void 0 : e.getResponseHeader)
                  ) {
                    const t = e.getResponseHeader("Retry-After");
                    t && (r = 1e3 * parseFloat(t));
                  }
                  this.log(`Steering manifest ${t.url} rate limited`);
                }
              },
              onTimeout: (e, t, i) => {
                this.log(`Timeout loading steering manifest (${t.url})`),
                  this.scheduleRefresh(this.uri || t.url);
              }
            };
          this.log(`Requesting steering manifest: ${s}`),
            this.loader.load(r, o, c);
        }
        scheduleRefresh(e, t = 1e3 * this.timeToLoad) {
          this.clearTimeout(),
            (this.reloadTimer = self.setTimeout(() => {
              var t;
              const i = null == (t = this.hls) ? void 0 : t.media;
              !i || i.ended
                ? this.scheduleRefresh(e, 1e3 * this.timeToLoad)
                : this.loadSteeringManifest(e);
            }, t));
        }
      },
      interstitialsController: class extends Pm {
        constructor(e, t) {
          super("interstitials", e.logger),
            (this.HlsPlayerClass = void 0),
            (this.hls = void 0),
            (this.assetListLoader = void 0),
            (this.mediaSelection = null),
            (this.altSelection = null),
            (this.media = null),
            (this.detachedData = null),
            (this.requiredTracks = null),
            (this.manager = null),
            (this.playerQueue = []),
            (this.bufferedPos = -1),
            (this.timelinePos = -1),
            (this.schedule = void 0),
            (this.playingItem = null),
            (this.bufferingItem = null),
            (this.waitingItem = null),
            (this.endedItem = null),
            (this.playingAsset = null),
            (this.endedAsset = null),
            (this.bufferingAsset = null),
            (this.shouldPlay = !1),
            (this.onPlay = () => {
              this.shouldPlay = !0;
            }),
            (this.onPause = () => {
              this.shouldPlay = !1;
            }),
            (this.onSeeking = () => {
              const e = this.currentTime;
              if (void 0 === e || this.playbackDisabled) return;
              const t = e - this.timelinePos;
              if (Math.abs(t) < 1 / 7056e5) return;
              const i = t <= -0.01;
              (this.timelinePos = e), (this.bufferedPos = e);
              const s = this.playingItem;
              if (!s) return void this.checkBuffer();
              if (i) {
                this.schedule.resetErrorsInRange(e, e - t) &&
                  this.updateSchedule();
              }
              if ((this.checkBuffer(), (i && e < s.start) || e >= s.end)) {
                var r;
                const e = this.schedule.findItemIndexAtTime(this.timelinePos);
                if (
                  (!this.isInterstitial(s) &&
                    null != (r = this.media) &&
                    r.paused &&
                    (this.shouldPlay = !1),
                  !i)
                ) {
                  const t = this.findItemIndex(s);
                  if (e > t) {
                    const i = this.schedule.findJumpRestrictedIndex(t + 1, e);
                    if (i > t) return void this.setSchedulePosition(i);
                  }
                }
                return void this.setSchedulePosition(e);
              }
              const n = this.playingAsset;
              if (!n) {
                if (this.playingLastItem && this.isInterstitial(s)) {
                  const t = s.event.assetList[0];
                  t &&
                    ((this.endedItem = this.playingItem),
                    (this.playingItem = null),
                    this.setScheduleToAssetAtTime(e, t));
                }
                return;
              }
              const a = n.timelineStart,
                o = n.duration || 0;
              ((i && e < a) || e >= a + o) &&
                this.setScheduleToAssetAtTime(e, n);
            }),
            (this.onTimeupdate = () => {
              const e = this.currentTime;
              if (void 0 === e || this.playbackDisabled) return;
              if (!(e > this.timelinePos)) return;
              (this.timelinePos = e),
                e > this.bufferedPos && this.checkBuffer();
              const t = this.playingItem;
              if (!t || this.playingLastItem) return;
              if (e >= t.end) {
                this.timelinePos = t.end;
                const e = this.findItemIndex(t);
                this.setSchedulePosition(e + 1);
              }
              const i = this.playingAsset;
              if (!i) return;
              e >= i.timelineStart + (i.duration || 0) &&
                this.setScheduleToAssetAtTime(e, i);
            }),
            (this.onScheduleUpdate = (e, t) => {
              const i = this.schedule,
                s = this.playingItem,
                r = i.events || [],
                n = i.items || [],
                a = i.durations,
                o = e.map(e => e.identifier),
                c = !(!r.length && !o.length);
              if (
                (c &&
                  this.log(
                    `INTERSTITIALS_UPDATED (${
                      r.length
                    }): ${r}\nSchedule: ${n.map(e => YR(e))}`
                  ),
                o.length && this.log(`Removed events ${o}`),
                this.playerQueue.forEach(e => {
                  if (e.interstitial.appendInPlace) {
                    const t = e.assetItem.timelineStart,
                      i = e.timelineOffset - t;
                    if (i)
                      try {
                        e.timelineOffset = t;
                      } catch (s) {
                        Math.abs(i) > xR &&
                          this.warn(
                            `${s} ("${e.assetId}" ${e.timelineOffset}->${t})`
                          );
                      }
                  }
                }),
                s)
              ) {
                const e = this.updateItem(s, this.timelinePos);
                this.itemsMatch(s, e) &&
                  ((this.playingItem = e),
                  (this.waitingItem = this.endedItem = null));
              } else
                (this.waitingItem = this.updateItem(this.waitingItem)),
                  (this.endedItem = this.updateItem(this.endedItem));
              const d = this.bufferingItem;
              if (d) {
                const e = this.updateItem(d, this.bufferedPos);
                this.itemsMatch(d, e)
                  ? (this.bufferingItem = e)
                  : d.event &&
                    ((this.bufferingItem = this.playingItem),
                    this.clearInterstitial(d.event, null));
              }
              if (
                (e.forEach(e => {
                  e.assetList.forEach(e => {
                    this.clearAssetPlayer(e.identifier, null);
                  });
                }),
                c || t)
              ) {
                if (
                  (this.hls.trigger(Am.INTERSTITIALS_UPDATED, {
                    events: r.slice(0),
                    schedule: n.slice(0),
                    durations: a,
                    removedIds: o
                  }),
                  this.isInterstitial(s) && o.includes(s.event.identifier))
                )
                  return (
                    this.warn(
                      `Interstitial "${s.event.identifier}" removed while playing`
                    ),
                    void this.primaryFallback(s.event)
                  );
                this.checkBuffer();
              }
            }),
            (this.hls = e),
            (this.HlsPlayerClass = t),
            (this.assetListLoader = new $R(e)),
            (this.schedule = new WR(this.onScheduleUpdate, e.logger)),
            this.registerListeners();
        }
        registerListeners() {
          const e = this.hls;
          e.on(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
            e.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
            e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
            e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.on(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
            e.on(Am.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
            e.on(Am.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this),
            e.on(Am.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
            e.on(Am.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this),
            e.on(Am.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this),
            e.on(Am.ASSET_LIST_LOADED, this.onAssetListLoaded, this),
            e.on(Am.BUFFER_APPENDED, this.onBufferAppended, this),
            e.on(Am.BUFFER_FLUSHED, this.onBufferFlushed, this),
            e.on(Am.BUFFERED_TO_END, this.onBufferedToEnd, this),
            e.on(Am.MEDIA_ENDED, this.onMediaEnded, this),
            e.on(Am.ERROR, this.onError, this),
            e.on(Am.DESTROYING, this.onDestroying, this);
        }
        unregisterListeners() {
          const e = this.hls;
          e &&
            (e.off(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
            e.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
            e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
            e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
            e.off(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
            e.off(Am.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
            e.off(Am.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this),
            e.off(Am.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
            e.off(Am.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this),
            e.off(Am.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this),
            e.off(Am.ASSET_LIST_LOADED, this.onAssetListLoaded, this),
            e.off(Am.BUFFER_CODECS, this.onBufferCodecs, this),
            e.off(Am.BUFFER_APPENDED, this.onBufferAppended, this),
            e.off(Am.BUFFER_FLUSHED, this.onBufferFlushed, this),
            e.off(Am.BUFFERED_TO_END, this.onBufferedToEnd, this),
            e.off(Am.MEDIA_ENDED, this.onMediaEnded, this),
            e.off(Am.ERROR, this.onError, this),
            e.off(Am.DESTROYING, this.onDestroying, this));
        }
        startLoad() {
          this.resumeBuffering();
        }
        stopLoad() {
          this.pauseBuffering();
        }
        resumeBuffering() {
          var e;
          null == (e = this.getBufferingPlayer()) || e.resumeBuffering();
        }
        pauseBuffering() {
          var e;
          null == (e = this.getBufferingPlayer()) || e.pauseBuffering();
        }
        destroy() {
          this.unregisterListeners(),
            this.stopLoad(),
            this.assetListLoader && this.assetListLoader.destroy(),
            this.emptyPlayerQueue(),
            this.clearScheduleState(),
            this.schedule && this.schedule.destroy(),
            (this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.manager = null),
            (this.hls = this.HlsPlayerClass = this.schedule = this.log = null),
            (this.assetListLoader = null),
            (this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null),
            (this.onScheduleUpdate = null);
        }
        onDestroying() {
          const e = this.primaryMedia || this.media;
          e && this.removeMediaListeners(e);
        }
        removeMediaListeners(e) {
          XR(e, "play", this.onPlay),
            XR(e, "pause", this.onPause),
            XR(e, "seeking", this.onSeeking),
            XR(e, "timeupdate", this.onTimeupdate);
        }
        onMediaAttaching(e, t) {
          const i = (this.media = t.media);
          qR(i, "seeking", this.onSeeking),
            qR(i, "timeupdate", this.onTimeupdate),
            qR(i, "play", this.onPlay),
            qR(i, "pause", this.onPause);
        }
        onMediaAttached(e, t) {
          const i = this.effectivePlayingItem,
            s = this.detachedData;
          if (((this.detachedData = null), null === i)) this.checkStart();
          else if (!s) {
            this.clearScheduleState();
            const e = this.findItemIndex(i);
            this.setSchedulePosition(e);
          }
        }
        clearScheduleState() {
          this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;
        }
        onMediaDetaching(e, t) {
          const i = !!t.transferMedia,
            s = this.media;
          if (
            ((this.media = null),
            !i && (s && this.removeMediaListeners(s), this.detachedData))
          ) {
            const e = this.getBufferingPlayer();
            e &&
              ((this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null),
              e.detachMedia()),
              (this.shouldPlay = !1);
          }
        }
        get interstitialsManager() {
          if (!this.manager) {
            if (!this.hls) return null;
            const e = this,
              t = () => e.bufferingItem || e.waitingItem,
              i = t => (t ? e.getAssetPlayer(t.identifier) : t),
              s = (t, s, r, a, o) => {
                if (t) {
                  let c = t[s].start;
                  const d = t.event;
                  if (d) {
                    if ("playout" === s || d.timelineOccupancy !== FR.Point) {
                      const e = i(r);
                      (null == e ? void 0 : e.interstitial) === d &&
                        (c += e.assetItem.startOffset + e[o]);
                    }
                  } else {
                    c += ("bufferedPos" === a ? n() : e[a]) - t.start;
                  }
                  return c;
                }
                return 0;
              },
              r = (t, i) => {
                if (0 !== t && "primary" !== i && e.schedule.length) {
                  var s;
                  const r = e.schedule.findItemIndexAtTime(t),
                    n = null == (s = e.schedule.items) ? void 0 : s[r];
                  if (n) {
                    return t + (n[i].start - n.start);
                  }
                }
                return t;
              },
              n = () => {
                const t = e.bufferedPos;
                return t === Number.MAX_VALUE ? a("primary") : Math.max(t, 0);
              },
              a = t => {
                var i;
                return null != (i = e.primaryDetails) && i.live
                  ? e.primaryDetails.edge
                  : e.schedule.durations[t];
              },
              o = (t, r) => {
                var n, a;
                const o = e.effectivePlayingItem;
                if (null != o && null != (n = o.event) && n.restrictions.skip)
                  return;
                e.log(`seek to ${t} "${r}"`);
                const c = e.effectivePlayingItem,
                  d = e.schedule.findItemIndexAtTime(t, r),
                  l = null == (a = e.schedule.items) ? void 0 : a[d],
                  h = e.getBufferingPlayer(),
                  u = null == h ? void 0 : h.interstitial,
                  p = null == u ? void 0 : u.appendInPlace,
                  f = c && e.itemsMatch(c, l);
                if (c && (p || f)) {
                  const n = i(e.playingAsset),
                    a = (null == n ? void 0 : n.media) || e.primaryMedia;
                  if (a) {
                    const i =
                        "primary" === r
                          ? a.currentTime
                          : s(
                              c,
                              r,
                              e.playingAsset,
                              "timelinePos",
                              "currentTime"
                            ),
                      o = t - i,
                      d = (p ? i : a.currentTime) + o;
                    if (d >= 0 && (!n || p || d <= n.duration))
                      return void (a.currentTime = d);
                  }
                }
                if (l) {
                  let i = t;
                  if ("primary" !== r) {
                    const e = t - l[r].start;
                    i = l.start + e;
                  }
                  const s = !e.isInterstitial(l);
                  if (
                    (e.isInterstitial(c) && !c.event.appendInPlace) ||
                    (!s && !l.event.appendInPlace)
                  ) {
                    if (c) {
                      const n = e.findItemIndex(c);
                      if (d > n) {
                        const t = e.schedule.findJumpRestrictedIndex(n + 1, d);
                        if (t > n) return void e.setSchedulePosition(t);
                      }
                      let a = 0;
                      if (s) (e.timelinePos = i), e.checkBuffer();
                      else {
                        var E;
                        const e =
                          null == l || null == (E = l.event)
                            ? void 0
                            : E.assetList;
                        if (e) {
                          const i = t - (l[r] || l).start;
                          for (let t = e.length; t--; ) {
                            const s = e[t];
                            if (
                              s.duration &&
                              i >= s.startOffset &&
                              i < s.startOffset + s.duration
                            ) {
                              a = t;
                              break;
                            }
                          }
                        }
                      }
                      e.setSchedulePosition(d, a);
                    }
                  } else {
                    const t =
                      e.media || (p ? (null == h ? void 0 : h.media) : null);
                    t && (t.currentTime = i);
                  }
                }
              },
              c = () => {
                const i = e.effectivePlayingItem;
                if (e.isInterstitial(i)) return i;
                const s = t();
                return e.isInterstitial(s) ? s : null;
              },
              d = {
                get currentTime() {
                  const t = c(),
                    i = e.effectivePlayingItem;
                  return i && i === t
                    ? s(
                        i,
                        "playout",
                        e.effectivePlayingAsset,
                        "timelinePos",
                        "currentTime"
                      ) - i.playout.start
                    : 0;
                },
                set currentTime(t) {
                  const i = c(),
                    s = e.effectivePlayingItem;
                  s && s === i && o(t + s.playout.start, "playout");
                },
                get duration() {
                  const e = c();
                  return e ? e.playout.end - e.playout.start : 0;
                },
                get assetPlayers() {
                  var t;
                  const i = null == (t = c()) ? void 0 : t.event.assetList;
                  return i ? i.map(t => e.getAssetPlayer(t.identifier)) : [];
                },
                get playingIndex() {
                  var t;
                  const i = null == (t = c()) ? void 0 : t.event;
                  return i && e.effectivePlayingAsset
                    ? i.findAssetIndex(e.effectivePlayingAsset)
                    : -1;
                },
                get scheduleItem() {
                  return c();
                }
              };
            this.manager = {
              get events() {
                var t, i;
                return (
                  (null == (t = e.schedule) || null == (i = t.events)
                    ? void 0
                    : i.slice(0)) || []
                );
              },
              get schedule() {
                var t, i;
                return (
                  (null == (t = e.schedule) || null == (i = t.items)
                    ? void 0
                    : i.slice(0)) || []
                );
              },
              get interstitialPlayer() {
                return c() ? d : null;
              },
              get playerQueue() {
                return e.playerQueue.slice(0);
              },
              get bufferingAsset() {
                return e.bufferingAsset;
              },
              get bufferingItem() {
                return t();
              },
              get bufferingIndex() {
                const i = t();
                return e.findItemIndex(i);
              },
              get playingAsset() {
                return e.effectivePlayingAsset;
              },
              get playingItem() {
                return e.effectivePlayingItem;
              },
              get playingIndex() {
                const t = e.effectivePlayingItem;
                return e.findItemIndex(t);
              },
              primary: {
                get bufferedEnd() {
                  return n();
                },
                get currentTime() {
                  const t = e.timelinePos;
                  return t > 0 ? t : 0;
                },
                set currentTime(e) {
                  o(e, "primary");
                },
                get duration() {
                  return a("primary");
                },
                get seekableStart() {
                  var t;
                  return (
                    (null == (t = e.primaryDetails)
                      ? void 0
                      : t.fragmentStart) || 0
                  );
                }
              },
              integrated: {
                get bufferedEnd() {
                  return s(
                    t(),
                    "integrated",
                    e.bufferingAsset,
                    "bufferedPos",
                    "bufferedEnd"
                  );
                },
                get currentTime() {
                  return s(
                    e.effectivePlayingItem,
                    "integrated",
                    e.effectivePlayingAsset,
                    "timelinePos",
                    "currentTime"
                  );
                },
                set currentTime(e) {
                  o(e, "integrated");
                },
                get duration() {
                  return a("integrated");
                },
                get seekableStart() {
                  var t;
                  return r(
                    (null == (t = e.primaryDetails)
                      ? void 0
                      : t.fragmentStart) || 0,
                    "integrated"
                  );
                }
              },
              skip: () => {
                const t = e.effectivePlayingItem,
                  i = null == t ? void 0 : t.event;
                if (i && !i.restrictions.skip) {
                  const s = e.findItemIndex(t);
                  if (i.appendInPlace) {
                    const e = t.playout.start + t.event.duration;
                    o(e + 0.001, "playout");
                  } else e.advanceAfterAssetEnded(i, s, 1 / 0);
                }
              }
            };
          }
          return this.manager;
        }
        get effectivePlayingItem() {
          return this.waitingItem || this.playingItem || this.endedItem;
        }
        get effectivePlayingAsset() {
          return this.playingAsset || this.endedAsset;
        }
        get playingLastItem() {
          var e;
          const t = this.playingItem,
            i = null == (e = this.schedule) ? void 0 : e.items;
          return (
            !!(this.playbackStarted && t && i) &&
            this.findItemIndex(t) === i.length - 1
          );
        }
        get playbackStarted() {
          return null !== this.effectivePlayingItem;
        }
        get currentTime() {
          var e, t, i;
          if (null === this.mediaSelection) return;
          const s = this.waitingItem || this.playingItem;
          if (this.isInterstitial(s) && !s.event.appendInPlace) return;
          let r = this.media;
          !r &&
            null != (e = this.bufferingItem) &&
            null != (t = e.event) &&
            t.appendInPlace &&
            (r = this.primaryMedia);
          const n = null == (i = r) ? void 0 : i.currentTime;
          return void 0 !== n && Tm(n) ? n : void 0;
        }
        get primaryMedia() {
          var e;
          return (
            this.media ||
            (null == (e = this.detachedData) ? void 0 : e.media) ||
            null
          );
        }
        isInterstitial(e) {
          return !(null == e || !e.event);
        }
        retreiveMediaSource(e, t) {
          const i = this.getAssetPlayer(e);
          i && this.transferMediaFromPlayer(i, t);
        }
        transferMediaFromPlayer(e, t) {
          const i = e.interstitial.appendInPlace,
            s = e.media;
          if (i && s === this.primaryMedia) {
            if (
              ((this.bufferingAsset = null),
              (!t || (this.isInterstitial(t) && !t.event.appendInPlace)) &&
                t &&
                s)
            )
              return void (this.detachedData = { media: s });
            const i = e.transferMedia();
            this.log(`transfer MediaSource from ${e} ${i_(i)}`),
              (this.detachedData = i);
          } else t && s && (this.shouldPlay || (this.shouldPlay = !s.paused));
        }
        transferMediaTo(e, t) {
          var i, s;
          if (e.media === t) return;
          let r = null;
          const n = this.hls,
            a = e !== n,
            o = a && e.interstitial.appendInPlace,
            c = null == (i = this.detachedData) ? void 0 : i.mediaSource;
          let d;
          if (n.media)
            o && ((r = n.transferMedia()), (this.detachedData = r)),
              (d = "Primary");
          else if (c) {
            const e = this.getBufferingPlayer();
            e
              ? ((r = e.transferMedia()), (d = `${e}`))
              : (d = "detached MediaSource");
          } else d = "detached media";
          if (!r)
            if (c)
              (r = this.detachedData),
                this.log(`using detachedData: MediaSource ${i_(r)}`);
            else if (!this.detachedData || n.media === t) {
              const e = this.playerQueue;
              e.length > 1 &&
                e.forEach(e => {
                  if (a && e.interstitial.appendInPlace !== o) {
                    const t = e.interstitial;
                    this.clearInterstitial(e.interstitial, null),
                      (t.appendInPlace = !1),
                      t.appendInPlace &&
                        this.warn(
                          `Could not change append strategy for queued assets ${t}`
                        );
                  }
                }),
                this.hls.detachMedia(),
                (this.detachedData = { media: t });
            }
          const l =
              r &&
              "mediaSource" in r &&
              "closed" !==
                (null == (s = r.mediaSource) ? void 0 : s.readyState),
            h = l && r ? r : t;
          if (
            (this.log(
              `${l ? "transfering MediaSource" : "attaching media"} to ${
                a ? e : "Primary"
              } from ${d}`
            ),
            h === r)
          ) {
            const t = a && e.assetId === this.schedule.assetIdAtEnd;
            h.overrides = {
              duration: this.schedule.duration,
              endOfStream: !a || t,
              cueRemoval: !a
            };
          }
          e.attachMedia(h);
        }
        onInterstitialCueEnter() {
          this.onTimeupdate();
        }
        checkStart() {
          const e = this.schedule,
            t = e.events;
          if (!t || this.playbackDisabled || !this.media) return;
          -1 === this.bufferedPos && (this.bufferedPos = 0);
          const i = this.timelinePos,
            s = this.effectivePlayingItem;
          if (-1 === i) {
            const i = this.hls.startPosition;
            if (((this.timelinePos = i), t.length && t[0].cue.pre)) {
              const i = e.findEventIndex(t[0].identifier);
              this.setSchedulePosition(i);
            } else if (i >= 0 || !this.primaryLive) {
              const t = (this.timelinePos = i > 0 ? i : 0),
                s = e.findItemIndexAtTime(t);
              this.setSchedulePosition(s);
            }
          } else if (s && !this.playingItem) {
            const t = e.findItemIndex(s);
            this.setSchedulePosition(t);
          }
        }
        advanceAfterAssetEnded(e, t, i) {
          const s = i + 1;
          if (e.isAssetPastPlayoutLimit(s) || e.assetList[s].error) {
            const i = this.schedule.items;
            if (i) {
              const s = t + 1;
              if (s >= i.length) return void this.setSchedulePosition(-1);
              const r = e.resumeTime;
              this.timelinePos < r &&
                ((this.timelinePos = r), this.checkBuffer()),
                this.setSchedulePosition(s);
            }
          } else this.setSchedulePosition(t, s);
        }
        setScheduleToAssetAtTime(e, t) {
          const i = this.schedule,
            s = t.parentIdentifier,
            r = i.getEvent(s);
          if (r) {
            const t = i.findEventIndex(s),
              n = i.findAssetIndex(r, e);
            this.setSchedulePosition(t, n);
          }
        }
        setSchedulePosition(e, t) {
          const i = this.schedule.items;
          if (!i || this.playbackDisabled) return;
          this.log(`setSchedulePosition ${e}, ${t}`);
          const s = e >= 0 ? i[e] : null,
            r = this.playingItem,
            n = this.playingLastItem;
          if (this.isInterstitial(r)) {
            var a;
            const c = r.event,
              d = this.playingAsset,
              l = null == d ? void 0 : d.identifier,
              h = l ? this.getAssetPlayer(l) : null;
            if (
              h &&
              l &&
              (!this.eventItemsMatch(r, s) ||
                (void 0 !== t &&
                  l !== (null == (a = c.assetList) ? void 0 : a[t].identifier)))
            ) {
              var o;
              const t = c.findAssetIndex(d);
              this.log(
                `INTERSTITIAL_ASSET_ENDED ${t + 1}/${c.assetList.length} ${HR(
                  d
                )}`
              ),
                (this.endedAsset = d),
                (this.playingAsset = null),
                this.hls.trigger(Am.INTERSTITIAL_ASSET_ENDED, {
                  asset: d,
                  assetListIndex: t,
                  event: c,
                  schedule: i.slice(0),
                  scheduleIndex: e,
                  player: h
                }),
                this.retreiveMediaSource(l, s),
                !h.media ||
                  (null != (o = this.detachedData) && o.mediaSource) ||
                  h.detachMedia();
            }
            if (
              !this.eventItemsMatch(r, s) &&
              ((this.endedItem = r),
              (this.playingItem = null),
              this.log(`INTERSTITIAL_ENDED ${c} ${YR(r)}`),
              (c.hasPlayed = !0),
              this.hls.trigger(Am.INTERSTITIAL_ENDED, {
                event: c,
                schedule: i.slice(0),
                scheduleIndex: e
              }),
              c.cue.once)
            ) {
              this.updateSchedule();
              const e = this.schedule.items;
              if (s && e) {
                const i = this.schedule.findItemIndex(s);
                this.advanceSchedule(i, e, t, r, n);
              }
              return;
            }
          }
          this.advanceSchedule(e, i, t, r, n);
        }
        advanceSchedule(e, t, i, s, r) {
          const n = e >= 0 ? t[e] : null,
            a = this.primaryMedia,
            o = this.playerQueue;
          if (
            (o.length &&
              o.forEach(t => {
                const i = t.interstitial,
                  s = this.schedule.findEventIndex(i.identifier);
                (s < e || s > e + 1) && this.clearInterstitial(i, n);
              }),
            this.isInterstitial(n))
          ) {
            this.timelinePos = Math.min(
              Math.max(this.timelinePos, n.start),
              n.end
            );
            const r = n.event;
            void 0 === i &&
              (i = this.schedule.findAssetIndex(r, this.timelinePos));
            const o = this.waitingItem;
            this.assetsBuffered(n, a) || this.setBufferingItem(n);
            let c = this.preloadAssets(r, i);
            if (
              (this.eventItemsMatch(n, o || s) ||
                ((this.waitingItem = n),
                this.log(
                  `INTERSTITIAL_STARTED ${YR(n)} ${
                    r.appendInPlace ? "append in place" : ""
                  }`
                ),
                this.hls.trigger(Am.INTERSTITIAL_STARTED, {
                  event: r,
                  schedule: t.slice(0),
                  scheduleIndex: e
                })),
              !r.assetListLoaded)
            )
              return void this.log(
                `Waiting for ASSET-LIST to complete loading ${r}`
              );
            if (
              (r.assetListLoader &&
                (r.assetListLoader.destroy(), (r.assetListLoader = void 0)),
              !a)
            )
              return void this.log(
                `Waiting for attachMedia to start Interstitial ${r}`
              );
            (this.waitingItem = this.endedItem = null), (this.playingItem = n);
            const d = r.assetList[i];
            if (!d) {
              const s = t[e + 1],
                n = this.media;
              return (
                s &&
                  n &&
                  !this.isInterstitial(s) &&
                  n.currentTime < s.start &&
                  (n.currentTime = this.timelinePos = s.start),
                void this.advanceAfterAssetEnded(r, e, i || 0)
              );
            }
            if (
              (c || (c = this.getAssetPlayer(d.identifier)),
              null === c || c.destroyed)
            ) {
              const e = r.assetList.length;
              this.warn(`asset ${i + 1}/${e} player destroyed ${r}`),
                (c = this.createAssetPlayer(r, d, i));
            }
            if (
              !this.eventItemsMatch(n, this.bufferingItem) &&
              r.appendInPlace &&
              this.isAssetBuffered(d)
            )
              return;
            this.startAssetPlayer(c, i, t, e, a),
              this.shouldPlay && zR(c.media);
          } else
            null !== n
              ? (this.resumePrimary(n, e, s),
                this.shouldPlay && zR(this.hls.media))
              : r &&
                this.isInterstitial(s) &&
                ((this.endedItem = null),
                (this.playingItem = s),
                s.event.appendInPlace ||
                  this.attachPrimary(this.schedule.durations.primary, null));
        }
        get playbackDisabled() {
          return !1 === this.hls.config.enableInterstitialPlayback;
        }
        get primaryDetails() {
          var e, t;
          return null == (e = this.mediaSelection) || null == (t = e.main)
            ? void 0
            : t.details;
        }
        get primaryLive() {
          var e;
          return !(null == (e = this.primaryDetails) || !e.live);
        }
        resumePrimary(e, t, i) {
          var s;
          if (
            ((this.playingItem = e),
            (this.playingAsset = this.endedAsset = null),
            (this.waitingItem = this.endedItem = null),
            this.bufferedToItem(e),
            this.log(`resuming ${YR(e)}`),
            null == (s = this.detachedData) || !s.mediaSource)
          ) {
            let i = this.timelinePos;
            (i < e.start || i >= e.end) &&
              ((i = this.getPrimaryResumption(e, t)), (this.timelinePos = i)),
              this.attachPrimary(i, e);
          }
          if (!i) return;
          const r = this.schedule.items;
          r &&
            (this.log(`resumed ${YR(e)}`),
            this.hls.trigger(Am.INTERSTITIALS_PRIMARY_RESUMED, {
              schedule: r.slice(0),
              scheduleIndex: t
            }),
            this.checkBuffer());
        }
        getPrimaryResumption(e, t) {
          const i = e.start;
          if (this.primaryLive) {
            const e = this.primaryDetails;
            if (0 === t) return this.hls.startPosition;
            if (e && (i < e.fragmentStart || i > e.edge))
              return this.hls.liveSyncPosition || -1;
          }
          return i;
        }
        isAssetBuffered(e) {
          const t = this.getAssetPlayer(e.identifier);
          if (null != t && t.hls) return t.hls.bufferedToEnd;
          return (
            K_.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >=
            e.timelineStart + (e.duration || 0)
          );
        }
        attachPrimary(e, t, i) {
          t
            ? this.setBufferingItem(t)
            : (this.bufferingItem = this.playingItem),
            (this.bufferingAsset = null);
          const s = this.primaryMedia;
          if (!s) return;
          const r = this.hls;
          r.media
            ? this.checkBuffer()
            : (this.transferMediaTo(r, s),
              i && this.startLoadingPrimaryAt(e, i)),
            i || ((this.timelinePos = e), this.startLoadingPrimaryAt(e, i));
        }
        startLoadingPrimaryAt(e, t) {
          var i;
          const s = this.hls;
          !s.loadingEnabled ||
          !s.media ||
          Math.abs(
            ((null == (i = s.mainForwardBufferInfo) ? void 0 : i.start) ||
              s.media.currentTime) - e
          ) > 0.5
            ? s.startLoad(e, t)
            : s.bufferingEnabled || s.resumeBuffering();
        }
        onManifestLoading() {
          this.stopLoad(),
            this.schedule.reset(),
            this.emptyPlayerQueue(),
            this.clearScheduleState(),
            (this.shouldPlay = !1),
            (this.bufferedPos = this.timelinePos = -1),
            (this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null),
            this.hls.off(Am.BUFFER_CODECS, this.onBufferCodecs, this),
            this.hls.on(Am.BUFFER_CODECS, this.onBufferCodecs, this);
        }
        onLevelUpdated(e, t) {
          if (-1 === t.level) return;
          const i = this.hls.levels[t.level],
            s = Nm(
              Nm({}, this.mediaSelection || this.altSelection),
              {},
              { main: i }
            );
          (this.mediaSelection = s),
            this.schedule.parseInterstitialDateRanges(
              s,
              this.hls.config.interstitialAppendInPlace
            ),
            !this.effectivePlayingItem &&
              this.schedule.items &&
              this.checkStart();
        }
        onAudioTrackUpdated(e, t) {
          const i = this.hls.audioTracks[t.id],
            s = this.mediaSelection;
          if (!s)
            return void (this.altSelection = Nm(
              Nm({}, this.altSelection),
              {},
              { audio: i }
            ));
          const r = Nm(Nm({}, s), {}, { audio: i });
          this.mediaSelection = r;
        }
        onSubtitleTrackUpdated(e, t) {
          const i = this.hls.subtitleTracks[t.id],
            s = this.mediaSelection;
          if (!s)
            return void (this.altSelection = Nm(
              Nm({}, this.altSelection),
              {},
              { subtitles: i }
            ));
          const r = Nm(Nm({}, s), {}, { subtitles: i });
          this.mediaSelection = r;
        }
        onAudioTrackSwitching(e, t) {
          const i = n_(t);
          this.playerQueue.forEach(
            e => e.hls.setAudioOption(t) || e.hls.setAudioOption(i)
          );
        }
        onSubtitleTrackSwitch(e, t) {
          const i = n_(t);
          this.playerQueue.forEach(
            e =>
              e.hls.setSubtitleOption(t) ||
              (-1 !== t.id && e.hls.setSubtitleOption(i))
          );
        }
        onBufferCodecs(e, t) {
          const i = t.tracks;
          i && (this.requiredTracks = i);
        }
        onBufferAppended(e, t) {
          this.checkBuffer();
        }
        onBufferFlushed(e, t) {
          const i = this.playingItem;
          if (
            i &&
            !this.itemsMatch(i, this.bufferingItem) &&
            !this.isInterstitial(i)
          ) {
            const e = this.timelinePos;
            (this.bufferedPos = e), this.checkBuffer();
          }
        }
        onBufferedToEnd(e) {
          const t = this.schedule.events;
          if (this.bufferedPos < Number.MAX_VALUE && t) {
            for (let e = 0; e < t.length; e++) {
              const s = t[e];
              if (s.cue.post) {
                var i;
                const e = this.schedule.findEventIndex(s.identifier),
                  t = null == (i = this.schedule.items) ? void 0 : i[e];
                this.isInterstitial(t) &&
                  this.eventItemsMatch(t, this.bufferingItem) &&
                  this.bufferedToItem(t, 0);
                break;
              }
            }
            this.bufferedPos = Number.MAX_VALUE;
          }
        }
        onMediaEnded(e) {
          const t = this.playingItem;
          if (!this.playingLastItem && t) {
            const e = this.findItemIndex(t);
            this.setSchedulePosition(e + 1);
          } else this.shouldPlay = !1;
        }
        updateItem(e, t) {
          const i = this.schedule.items;
          if (e && i) {
            return i[this.findItemIndex(e, t)] || null;
          }
          return null;
        }
        itemsMatch(e, t) {
          return (
            !!t &&
            (e === t ||
              (e.event && t.event && this.eventItemsMatch(e, t)) ||
              (!e.event &&
                !t.event &&
                this.findItemIndex(e) === this.findItemIndex(t)))
          );
        }
        eventItemsMatch(e, t) {
          var i;
          return (
            !!t &&
            (e === t ||
              e.event.identifier ===
                (null == (i = t.event) ? void 0 : i.identifier))
          );
        }
        findItemIndex(e, t) {
          return e ? this.schedule.findItemIndex(e, t) : -1;
        }
        updateSchedule() {
          const e = this.mediaSelection;
          e && this.schedule.updateSchedule(e, []);
        }
        checkBuffer(e) {
          const t = this.schedule.items;
          if (!t) return;
          const i = K_.bufferInfo(this.primaryMedia, this.timelinePos, 0);
          e && (this.bufferedPos = this.timelinePos),
            e || (e = i.len < 1),
            this.updateBufferedPos(i.end, t, e);
        }
        updateBufferedPos(e, t, i) {
          const s = this.schedule,
            r = this.bufferingItem;
          if (this.bufferedPos > e) return;
          if (1 === t.length && this.itemsMatch(t[0], r))
            return void (this.bufferedPos = e);
          const n = this.playingItem,
            a = this.findItemIndex(n);
          let o = s.findItemIndexAtTime(e);
          if (this.bufferedPos < e) {
            var c, d;
            const i = this.findItemIndex(r),
              s = Math.min(i + 1, t.length - 1),
              n = t[s];
            if (
              (((-1 === o && r && e >= r.end) ||
                (null != (c = n.event) &&
                  c.appendInPlace &&
                  e + 0.01 >= n.start)) &&
                (o = s),
              s - a > 1 &&
                !1 ===
                  (null == r || null == (d = r.event)
                    ? void 0
                    : d.appendInPlace))
            )
              return;
            if (((this.bufferedPos = e), o > i && o > a))
              this.bufferedToItem(n);
            else {
              const t = this.primaryDetails;
              this.primaryLive &&
                t &&
                e > t.edge - t.targetduration &&
                n.start < t.edge + this.hls.config.interstitialLiveLookAhead &&
                this.isInterstitial(n) &&
                this.preloadAssets(n.event, 0);
            }
          } else
            i &&
              n &&
              !this.itemsMatch(n, r) &&
              (o === a
                ? this.bufferedToItem(n)
                : o === a + 1 && this.bufferedToItem(t[o]));
        }
        assetsBuffered(e, t) {
          return (
            0 !== e.event.assetList.length &&
            !e.event.assetList.some(e => {
              const i = this.getAssetPlayer(e.identifier);
              return !(null != i && i.bufferedInPlaceToEnd(t));
            })
          );
        }
        setBufferingItem(e) {
          const t = this.bufferingItem,
            i = this.schedule;
          if (this.itemsMatch(e, t))
            this.bufferingItem !== e && (this.bufferingItem = e);
          else {
            const { items: s, events: r } = i;
            if (!s || !r) return t;
            const n = this.isInterstitial(e),
              a = this.getBufferingPlayer();
            if (
              ((this.bufferingItem = e),
              (this.bufferedPos = Math.max(
                e.start,
                Math.min(e.end, this.timelinePos)
              )),
              !this.playbackDisabled)
            ) {
              const i = a ? a.remaining : t ? t.end - this.timelinePos : 0;
              this.log(
                `buffered to boundary ${YR(e)}` +
                  (t ? ` (${i.toFixed(2)} remaining)` : "")
              ),
                n
                  ? e.event.assetList.forEach(e => {
                      const t = this.getAssetPlayer(e.identifier);
                      t && t.resumeBuffering();
                    })
                  : (this.hls.resumeBuffering(),
                    this.playerQueue.forEach(e => e.pauseBuffering()));
            }
            this.hls.trigger(Am.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
              events: r.slice(0),
              schedule: s.slice(0),
              bufferingIndex: this.findItemIndex(e),
              playingIndex: this.findItemIndex(this.playingItem)
            });
          }
          return t;
        }
        bufferedToItem(e, t = 0) {
          const i = this.setBufferingItem(e);
          if (!this.playbackDisabled)
            if (this.isInterstitial(e)) this.bufferedToEvent(e, t);
            else if (null !== i) {
              this.bufferingAsset = null;
              const t = this.detachedData;
              if (t)
                if (t.mediaSource) {
                  const t = !0;
                  this.attachPrimary(e.start, e, t);
                } else this.preloadPrimary(e);
              else this.preloadPrimary(e);
            }
        }
        preloadPrimary(e) {
          const t = this.findItemIndex(e),
            i = this.getPrimaryResumption(e, t);
          this.startLoadingPrimaryAt(i);
        }
        bufferedToEvent(e, t) {
          const i = e.event,
            s = 0 === i.assetList.length && !i.assetListLoader,
            r = i.cue.once;
          if (s || !r) {
            const e = this.preloadAssets(i, t);
            if (null != e && e.interstitial.appendInPlace) {
              const s = i.assetList[t],
                r = this.primaryMedia;
              s && r && this.bufferAssetPlayer(e, r);
            }
          }
        }
        preloadAssets(e, t) {
          const i = e.assetUrl,
            s = e.assetList.length,
            r = 0 === s && !e.assetListLoader,
            n = e.cue.once;
          if (r) {
            const r = e.timelineStart;
            if (e.appendInPlace) {
              var a;
              const t = this.playingItem;
              this.isInterstitial(t) ||
                (null == t || null == (a = t.nextEvent)
                  ? void 0
                  : a.identifier) !== e.identifier ||
                this.flushFrontBuffer(r + 0.25);
            }
            let n,
              o = 0;
            if (
              (!this.playingItem &&
                this.primaryLive &&
                ((o = this.hls.startPosition),
                -1 === o && (o = this.hls.liveSyncPosition || 0)),
              o && !e.cue.pre && !e.cue.post)
            ) {
              const e = o - r;
              e > 0 && (n = Math.round(1e3 * e) / 1e3);
            }
            if (
              (this.log(
                `Load interstitial asset ${t + 1}/${i ? 1 : s} ${e}${
                  n ? ` live-start: ${o} start-offset: ${n}` : ""
                }`
              ),
              i)
            )
              return this.createAsset(e, 0, 0, r, e.duration, i);
            const c = this.assetListLoader.loadAssetList(e, n);
            c && (e.assetListLoader = c);
          } else if (!n && s) {
            for (let i = t; i < s; i++) {
              const t = e.assetList[i],
                s = this.getAssetPlayerQueueIndex(t.identifier);
              (-1 !== s && !this.playerQueue[s].destroyed) ||
                t.error ||
                this.createAssetPlayer(e, t, i);
            }
            return this.getAssetPlayer(e.assetList[t].identifier);
          }
          return null;
        }
        flushFrontBuffer(e) {
          const t = this.requiredTracks;
          if (!t) return;
          this.log(`Removing front buffer starting at ${e}`);
          Object.keys(t).forEach(t => {
            this.hls.trigger(Am.BUFFER_FLUSHING, {
              startOffset: e,
              endOffset: 1 / 0,
              type: t
            });
          });
        }
        getAssetPlayerQueueIndex(e) {
          const t = this.playerQueue;
          for (let i = 0; i < t.length; i++) if (e === t[i].assetId) return i;
          return -1;
        }
        getAssetPlayer(e) {
          const t = this.getAssetPlayerQueueIndex(e);
          return this.playerQueue[t] || null;
        }
        getBufferingPlayer() {
          const { playerQueue: e, primaryMedia: t } = this;
          if (t)
            for (let i = 0; i < e.length; i++)
              if (e[i].media === t) return e[i];
          return null;
        }
        createAsset(e, t, i, s, r, n) {
          const a = {
            parentIdentifier: e.identifier,
            identifier: BR(e, n, t),
            duration: r,
            startOffset: i,
            timelineStart: s,
            uri: n
          };
          return this.createAssetPlayer(e, a, t);
        }
        createAssetPlayer(e, t, i) {
          this.log(`create HLSAssetPlayer for ${HR(t)}`);
          const s = this.hls,
            r = s.userConfig;
          let n = r.videoPreference;
          const a = s.loadLevelObj || s.levels[s.currentLevel];
          (n || a) &&
            ((n = wm({}, n)),
            a.videoCodec && (n.videoCodec = a.videoCodec),
            a.videoRange && (n.allowedVideoRanges = [a.videoRange]));
          const o = s.audioTracks[s.audioTrack],
            c = s.subtitleTracks[s.subtitleTrack];
          let d = 0;
          if (this.primaryLive || e.appendInPlace) {
            const e = this.timelinePos - t.timelineStart;
            if (e > 1) {
              const i = t.duration;
              i && e < i && (d = e);
            }
          }
          const l = t.identifier,
            h = Nm(
              Nm({}, r),
              {},
              {
                autoStartLoad: !0,
                startFragPrefetch: !0,
                primarySessionId: s.sessionId,
                assetPlayerId: l,
                abrEwmaDefaultEstimate: s.bandwidthEstimate,
                interstitialsController: void 0,
                startPosition: d,
                liveDurationInfinity: !1,
                testBandwidth: !1,
                videoPreference: n,
                audioPreference: o || r.audioPreference,
                subtitlePreference: c || r.subtitlePreference
              }
            );
          e.appendInPlace &&
            ((e.appendInPlaceStarted = !0),
            t.timelineStart && (h.timelineOffset = t.timelineStart));
          const u = h.cmcd;
          null != u &&
            u.sessionId &&
            u.contentId &&
            (h.cmcd = wm({}, u, { contentId: UR(t.uri) })),
            this.getAssetPlayer(l) &&
              this.warn(`Duplicate date range identifier ${e} and asset ${l}`);
          const p = new KR(this.HlsPlayerClass, h, e, t);
          this.playerQueue.push(p), (e.assetList[i] = t);
          const f = s => {
            if (s.live) {
              const t = new Error(`Interstitials MUST be VOD assets ${e}`),
                s = {
                  fatal: !0,
                  type: Rm.OTHER_ERROR,
                  details: ym.INTERSTITIAL_ASSET_ITEM_ERROR,
                  error: t
                };
              return void this.handleAssetItemError(
                s,
                e,
                this.schedule.findEventIndex(e.identifier),
                i,
                t.message
              );
            }
            const r = s.edge - s.fragmentStart,
              n = t.duration;
            (null === n || r > n) &&
              (this.log(
                `Interstitial asset "${l}" duration change ${n} > ${r}`
              ),
              (t.duration = r),
              this.updateSchedule());
          };
          p.on(Am.LEVEL_UPDATED, (e, { details: t }) => f(t)),
            p.on(Am.LEVEL_PTS_UPDATED, (e, { details: t }) => f(t));
          const E = (e, t) => {
            const i = this.getAssetPlayer(l);
            if (i && t.tracks) {
              i.off(Am.BUFFER_CODECS, E), (i.tracks = t.tracks);
              const e = this.primaryMedia;
              this.bufferingAsset === i.assetItem &&
                e &&
                !i.media &&
                this.bufferAssetPlayer(i, e);
            }
          };
          p.on(Am.BUFFER_CODECS, E);
          const m = () => {
            var i;
            const s = this.getAssetPlayer(l);
            if ((this.log(`buffered to end of asset ${s}`), !s)) return;
            const r = this.schedule.findEventIndex(e.identifier),
              n = e.findAssetIndex(t),
              a = n + 1,
              o = null == (i = this.schedule.items) ? void 0 : i[r];
            if (this.isInterstitial(o))
              if (
                -1 === n ||
                e.isAssetPastPlayoutLimit(a) ||
                e.assetList[a].error
              ) {
                var c;
                const e = null == (c = this.schedule.items) ? void 0 : c[r + 1];
                e && this.bufferedToItem(e);
              } else this.bufferedToItem(o, a);
          };
          p.on(Am.BUFFERED_TO_END, m);
          const g = t => () => {
            if (!this.getAssetPlayer(l)) return;
            this.shouldPlay = !0;
            const i = this.schedule.findEventIndex(e.identifier);
            this.advanceAfterAssetEnded(e, i, t);
          };
          return (
            p.once(Am.MEDIA_ENDED, g(i)),
            p.once(Am.PLAYOUT_LIMIT_REACHED, g(1 / 0)),
            p.on(Am.ERROR, (t, s) => {
              const r = this.getAssetPlayer(l);
              if (s.details !== ym.BUFFER_STALLED_ERROR)
                this.handleAssetItemError(
                  s,
                  e,
                  this.schedule.findEventIndex(e.identifier),
                  i,
                  `Asset player error ${s.error} ${e}`
                );
              else if (null != r && r.media) {
                const t = r.currentTime,
                  i = r.duration - t;
                t && e.appendInPlace && i / r.media.playbackRate < 0.5
                  ? (this.log(
                      `Advancing buffer past end of asset ${l} ${e} at ${r.media.currentTime}`
                    ),
                    m())
                  : (this.warn(
                      `Stalled at ${t} of ${t + i} in asset ${l} ${e}`
                    ),
                    this.onTimeupdate(),
                    this.checkBuffer(!0));
              }
            }),
            p.on(Am.DESTROYING, () => {
              if (!this.getAssetPlayer(l)) return;
              const t = new Error(`Asset player destroyed unexpectedly ${l}`),
                s = {
                  fatal: !0,
                  type: Rm.OTHER_ERROR,
                  details: ym.INTERSTITIAL_ASSET_ITEM_ERROR,
                  error: t
                };
              this.handleAssetItemError(
                s,
                e,
                this.schedule.findEventIndex(e.identifier),
                i,
                t.message
              );
            }),
            this.hls.trigger(Am.INTERSTITIAL_ASSET_PLAYER_CREATED, {
              asset: t,
              assetListIndex: i,
              event: e,
              player: p
            }),
            p
          );
        }
        clearInterstitial(e, t) {
          e.assetList.forEach(e => {
            this.clearAssetPlayer(e.identifier, t);
          }),
            e.reset();
        }
        clearAssetPlayer(e, t) {
          const i = this.getAssetPlayerQueueIndex(e);
          if (-1 !== i) {
            this.log(`clearAssetPlayer "${e}" toSegment: ${t ? YR(t) : t}`);
            const s = this.playerQueue[i];
            this.transferMediaFromPlayer(s, t),
              this.playerQueue.splice(i, 1),
              s.destroy();
          }
        }
        emptyPlayerQueue() {
          let e;
          for (; (e = this.playerQueue.pop()); ) e.destroy();
          this.playerQueue = [];
        }
        startAssetPlayer(e, t, i, s, r) {
          const { interstitial: n, assetItem: a, assetId: o } = e,
            c = n.assetList.length,
            d = this.playingAsset;
          (this.endedAsset = null),
            (this.playingAsset = a),
            (d && d.identifier === o) ||
              (d && (this.clearAssetPlayer(d.identifier, i[s]), delete d.error),
              this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${c} ${e}`),
              this.hls.trigger(Am.INTERSTITIAL_ASSET_STARTED, {
                asset: a,
                assetListIndex: t,
                event: n,
                schedule: i.slice(0),
                scheduleIndex: s,
                player: e
              })),
            this.bufferAssetPlayer(e, r);
        }
        bufferAssetPlayer(e, t) {
          var i, s;
          const { interstitial: r, assetItem: n, assetId: a } = e,
            o = this.schedule.findEventIndex(r.identifier),
            c = null == (i = this.schedule.items) ? void 0 : i[o];
          if (!c) return;
          this.setBufferingItem(c), (this.bufferingAsset = n);
          const d = this.getBufferingPlayer();
          if (d === e) return;
          const l = r.appendInPlace;
          if (l && !1 === (null == d ? void 0 : d.interstitial.appendInPlace))
            return;
          const h =
            (null == d ? void 0 : d.tracks) ||
            (null == (s = this.detachedData) ? void 0 : s.tracks) ||
            this.requiredTracks;
          if (l && n !== this.playingAsset) {
            if (!e.tracks) return;
            if (h && !Gm(h, e.tracks)) {
              const t = new Error(
                  `Asset "${a}" SourceBuffer tracks ('${Object.keys(
                    e.tracks
                  )}') are not compatible with primary content tracks ('${Object.keys(
                    h
                  )}')`
                ),
                i = {
                  fatal: !0,
                  type: Rm.OTHER_ERROR,
                  details: ym.INTERSTITIAL_ASSET_ITEM_ERROR,
                  error: t
                },
                s = r.findAssetIndex(n);
              return void this.handleAssetItemError(i, r, o, s, t.message);
            }
          }
          this.transferMediaTo(e, t);
        }
        handleAssetItemError(e, t, i, s, r) {
          if (e.details === ym.BUFFER_STALLED_ERROR) return;
          const n = t.assetList[s] || null;
          let a = null;
          if (n) {
            const e = this.getAssetPlayerQueueIndex(n.identifier);
            a = this.playerQueue[e] || null;
          }
          const o = this.schedule.items,
            c = wm({}, e, {
              fatal: !1,
              errorAction: y_(!0),
              asset: n,
              assetListIndex: s,
              event: t,
              schedule: o,
              scheduleIndex: i,
              player: a
            });
          if (
            (this.warn(`Asset item error: ${e.error}`),
            this.hls.trigger(Am.INTERSTITIAL_ASSET_ERROR, c),
            !e.fatal)
          )
            return;
          const d = new Error(r);
          n &&
            (this.playingAsset !== n &&
              this.clearAssetPlayer(n.identifier, null),
            (n.error = d)),
            t.assetList.some(e => !e.error)
              ? t.appendInPlace && (t.error = d)
              : (t.error = d),
            this.primaryFallback(t);
        }
        primaryFallback(e) {
          const t = e.timelineStart,
            i = this.effectivePlayingItem;
          if ((this.updateSchedule(), i)) {
            this.log(
              `Fallback to primary from event "${
                e.identifier
              }" start: ${t} pos: ${this.timelinePos} playing: ${
                i ? YR(i) : "<none>"
              } error: ${e.error}`
            ),
              e.appendInPlace &&
                (this.attachPrimary(t, null), this.flushFrontBuffer(t));
            let s = this.timelinePos;
            -1 === s && (s = this.hls.startPosition);
            const r = this.updateItem(i, s);
            if (this.itemsMatch(i, r)) this.clearInterstitial(e, null);
            else {
              const e = this.schedule.findItemIndexAtTime(s);
              this.setSchedulePosition(e);
            }
          } else this.checkStart();
        }
        onAssetListLoaded(e, t) {
          var i;
          const s = t.event,
            r = s.identifier,
            n = t.assetListResponse.ASSETS;
          if (!this.schedule.hasEvent(r)) return;
          const a = s.timelineStart,
            o = s.duration;
          let c = 0;
          n.forEach((e, t) => {
            const i = parseFloat(e.DURATION);
            this.createAsset(s, t, c, a + c, i, e.URI), (c += i);
          }),
            (s.duration = c),
            this.log(`Loaded asset-list with duration: ${c} (was: ${o}) ${s}`);
          const d = this.waitingItem,
            l = (null == d ? void 0 : d.event.identifier) === r;
          this.updateSchedule();
          const h = null == (i = this.bufferingItem) ? void 0 : i.event;
          if (l) {
            var u;
            const e = this.schedule.findEventIndex(r),
              t = null == (u = this.schedule.items) ? void 0 : u[e];
            if (t) {
              if (!this.playingItem && this.timelinePos > t.end) {
                if (this.schedule.findItemIndexAtTime(this.timelinePos) !== e)
                  return (
                    (s.error = new Error(
                      `Interstitial no longer within playback range ${this.timelinePos} ${s}`
                    )),
                    void this.primaryFallback(s)
                  );
              }
              this.setBufferingItem(t);
            }
            this.setSchedulePosition(e);
          } else if (
            (null == h ? void 0 : h.identifier) === r &&
            h.appendInPlace
          ) {
            const e = s.assetList[0],
              t = this.getAssetPlayer(e.identifier),
              i = this.primaryMedia;
            e && t && i && this.bufferAssetPlayer(t, i);
          }
        }
        onError(e, t) {
          switch (t.details) {
            case ym.ASSET_LIST_PARSING_ERROR:
            case ym.ASSET_LIST_LOAD_ERROR:
            case ym.ASSET_LIST_LOAD_TIMEOUT: {
              const e = t.interstitial;
              e && this.primaryFallback(e);
              break;
            }
            case ym.BUFFER_STALLED_ERROR:
              this.onTimeupdate(), this.checkBuffer(!0);
          }
        }
      }
    }
  );
  function iA(e) {
    return e && "object" == typeof e
      ? Array.isArray(e)
        ? e.map(iA)
        : Object.keys(e).reduce((t, i) => ((t[i] = iA(e[i])), t), {})
      : e;
  }
  function sA(e, t) {
    const i = e.loader;
    if (i !== zy && i !== eA)
      t.log(
        "[config]: Custom loader detected, cannot enable progressive streaming"
      ),
        (e.progressive = !1);
    else {
      (function() {
        if (
          self.fetch &&
          self.AbortController &&
          self.ReadableStream &&
          self.Request
        )
          try {
            return new self.ReadableStream({}), !0;
          } catch (e) {}
        return !1;
      })() &&
        ((e.loader = zy),
        (e.progressive = !0),
        (e.enableSoftwareAES = !0),
        t.log("[config]: Progressive streaming enabled, using FetchLoader"));
    }
  }
  class rA extends G_ {
    constructor(e, t) {
      super("gap-controller", e.logger),
        (this.hls = null),
        (this.fragmentTracker = null),
        (this.media = null),
        (this.mediaSource = void 0),
        (this.nudgeRetry = 0),
        (this.stallReported = !1),
        (this.stalled = null),
        (this.moved = !1),
        (this.seeking = !1),
        (this.buffered = {}),
        (this.lastCurrentTime = 0),
        (this.ended = 0),
        (this.waiting = 0),
        (this.onMediaPlaying = () => {
          (this.ended = 0), (this.waiting = 0);
        }),
        (this.onMediaWaiting = () => {
          var e;
          (null != (e = this.media) && e.seeking) ||
            ((this.waiting = self.performance.now()), this.tick());
        }),
        (this.onMediaEnded = () => {
          var e;
          this.hls &&
            ((this.ended =
              (null == (e = this.media) ? void 0 : e.currentTime) || 1),
            this.hls.trigger(Am.MEDIA_ENDED, { stalled: !1 }));
        }),
        (this.hls = e),
        (this.fragmentTracker = t),
        this.registerListeners();
    }
    registerListeners() {
      const { hls: e } = this;
      e &&
        (e.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Am.BUFFER_APPENDED, this.onBufferAppended, this));
    }
    unregisterListeners() {
      const { hls: e } = this;
      e &&
        (e.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Am.BUFFER_APPENDED, this.onBufferAppended, this));
    }
    destroy() {
      super.destroy(),
        this.unregisterListeners(),
        (this.media = this.hls = this.fragmentTracker = null),
        (this.mediaSource = void 0);
    }
    onMediaAttached(e, t) {
      this.setInterval(100), (this.mediaSource = t.mediaSource);
      const i = (this.media = t.media);
      qR(i, "playing", this.onMediaPlaying),
        qR(i, "waiting", this.onMediaWaiting),
        qR(i, "ended", this.onMediaEnded);
    }
    onMediaDetaching(e, t) {
      this.clearInterval();
      const { media: i } = this;
      i &&
        (XR(i, "playing", this.onMediaPlaying),
        XR(i, "waiting", this.onMediaWaiting),
        XR(i, "ended", this.onMediaEnded),
        (this.media = null)),
        (this.mediaSource = void 0);
    }
    onBufferAppended(e, t) {
      this.buffered = t.timeRanges;
    }
    get hasBuffered() {
      return Object.keys(this.buffered).length > 0;
    }
    tick() {
      var e;
      if (null == (e = this.media) || !e.readyState || !this.hasBuffered)
        return;
      const t = this.media.currentTime;
      this.poll(t, this.lastCurrentTime), (this.lastCurrentTime = t);
    }
    poll(e, t) {
      var i, s;
      const r = null == (i = this.hls) ? void 0 : i.config;
      if (!r) return;
      const { media: n, stalled: a } = this;
      if (!n) return;
      const { seeking: o } = n,
        c = this.seeking && !o,
        d = !this.seeking && o,
        l = (n.paused && !o) || n.ended || 0 === n.playbackRate;
      if (((this.seeking = o), e !== t))
        return (
          t && (this.ended = 0),
          (this.moved = !0),
          o ||
            ((this.nudgeRetry = 0),
            r.nudgeOnVideoHole && !l && e > t && this.nudgeOnVideoHole(e, t)),
          void (0 === this.waiting && this.stallResolved(e))
        );
      if (d || c) return void (c && this.stallResolved(e));
      if (l)
        return (
          (this.nudgeRetry = 0),
          this.stallResolved(e),
          void (
            !this.ended &&
            n.ended &&
            this.hls &&
            ((this.ended = e || 1),
            this.hls.trigger(Am.MEDIA_ENDED, { stalled: !1 }))
          )
        );
      if (!K_.getBuffered(n).length) return void (this.nudgeRetry = 0);
      const h = K_.bufferInfo(n, e, 0),
        u = h.nextStart || 0,
        p = this.fragmentTracker;
      if (o && p && this.hls) {
        const t = nA(this.hls.inFlightFragments, e),
          i = h.len > 2,
          s = !u || t || (u - e > 2 && !p.getPartialFragment(e));
        if (i || s) return;
        this.moved = !1;
      }
      const f = null == (s = this.hls) ? void 0 : s.latestLevelDetails;
      if (!this.moved && null !== this.stalled && p) {
        if (!(h.len > 0) && !u) return;
        const t = Math.max(u, h.start || 0) - e,
          i = !(null == f || !f.live) ? 2 * f.targetduration : 2,
          s = p.getPartialFragment(e);
        if (t > 0 && (t <= i || s))
          return void (n.paused || this._trySkipBufferHole(s));
      }
      const E = r.detectStallWithCurrentTimeMs,
        m = self.performance.now(),
        g = this.waiting;
      if (null === a) return void (this.stalled = g > 0 && m - g < E ? g : m);
      const _ = m - a;
      if (!o && (_ >= E || g) && this.hls) {
        var T;
        if (
          "ended" ===
            (null == (T = this.mediaSource) ? void 0 : T.readyState) &&
          (null == f || !f.live) &&
          Math.abs(e - ((null == f ? void 0 : f.edge) || 0)) < 1
        ) {
          if (this.ended) return;
          return (
            (this.ended = e || 1),
            void this.hls.trigger(Am.MEDIA_ENDED, { stalled: !0 })
          );
        }
        if ((this._reportStall(h), !this.media || !this.hls)) return;
      }
      const S = K_.bufferInfo(n, e, r.maxBufferHole);
      this._tryFixBufferStall(S, _);
    }
    stallResolved(e) {
      const t = this.stalled;
      if (t && this.hls && ((this.stalled = null), this.stallReported)) {
        const i = self.performance.now() - t;
        this.log(`playback not stuck anymore @${e}, after ${Math.round(i)}ms`),
          (this.stallReported = !1),
          (this.waiting = 0),
          this.hls.trigger(Am.STALL_RESOLVED, {});
      }
    }
    nudgeOnVideoHole(e, t) {
      var i;
      const s = this.buffered.video;
      if (
        this.hls &&
        this.media &&
        this.fragmentTracker &&
        null != (i = this.buffered.audio) &&
        i.length &&
        s &&
        s.length > 1 &&
        e > s.end(0)
      ) {
        const i = K_.bufferedInfo(
          K_.timeRangesToArray(this.buffered.audio),
          e,
          0
        );
        if (i.len > 1 && t >= i.start) {
          const i = K_.timeRangesToArray(s),
            r = K_.bufferedInfo(i, t, 0).bufferedIndex;
          if (r > -1 && r < i.length - 1) {
            const t = K_.bufferedInfo(i, e, 0).bufferedIndex,
              s = i[r].end,
              n = i[r + 1].start;
            if ((-1 === t || t > r) && n - s < 1 && e - s < 2) {
              const i = new Error(
                `nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${s} -> ${n} buffered index: ${t}`
              );
              this.warn(i.message), (this.media.currentTime += 1e-6);
              const r = this.fragmentTracker.getPartialFragment(e) || void 0,
                a = K_.bufferInfo(this.media, e, 0);
              this.hls.trigger(Am.ERROR, {
                type: Rm.MEDIA_ERROR,
                details: ym.BUFFER_SEEK_OVER_HOLE,
                fatal: !1,
                error: i,
                reason: i.message,
                frag: r,
                buffer: a.len,
                bufferInfo: a
              });
            }
          }
        }
      }
    }
    _tryFixBufferStall(e, t) {
      var i, s;
      const { fragmentTracker: r, media: n } = this,
        a = null == (i = this.hls) ? void 0 : i.config;
      if (!n || !r || !a) return;
      const o = n.currentTime,
        c = null == (s = this.hls) ? void 0 : s.latestLevelDetails,
        d = r.getPartialFragment(o);
      if (d || (null != c && c.live && o < c.fragmentStart)) {
        if (this._trySkipBufferHole(d) || !this.media) return;
      }
      const l = e.buffered;
      ((l && l.length > 1 && e.len > a.maxBufferHole) ||
        (e.nextStart && e.nextStart - o < a.maxBufferHole)) &&
        (t > 1e3 * a.highBufferWatchdogPeriod || this.waiting) &&
        (this.warn("Trying to nudge playhead over buffer-hole"),
        this._tryNudgeBuffer(e));
    }
    _reportStall(e) {
      const { hls: t, media: i, stallReported: s, stalled: r } = this;
      if (!s && null !== r && i && t) {
        this.stallReported = !0;
        const s = new Error(
          `Playback stalling at @${i.currentTime} due to low buffer (${i_(e)})`
        );
        this.warn(s.message),
          t.trigger(Am.ERROR, {
            type: Rm.MEDIA_ERROR,
            details: ym.BUFFER_STALLED_ERROR,
            fatal: !1,
            error: s,
            buffer: e.len,
            bufferInfo: e,
            stalled: { start: r }
          });
      }
    }
    _trySkipBufferHole(e) {
      var t;
      const { fragmentTracker: i, media: s } = this,
        r = null == (t = this.hls) ? void 0 : t.config;
      if (!s || !i || !r) return 0;
      const n = s.currentTime,
        a = K_.bufferInfo(s, n, 0),
        o = n < a.start ? a.start : a.nextStart;
      if (o && this.hls) {
        const t = a.len <= r.maxBufferHole,
          d = a.len > 0 && a.len < 1 && s.readyState < 3,
          l = o - n;
        if (l > 0 && (t || d)) {
          if (l > r.maxBufferHole) {
            let t = !1;
            if (0 === n) {
              const e = i.getAppendedFrag(0, Cm.MAIN);
              e && o < e.end && (t = !0);
            }
            if (!t) {
              const t = e || i.getAppendedFrag(n, Cm.MAIN);
              if (t) {
                var c;
                if (null == (c = this.hls.loadLevelObj) || !c.details) return 0;
                if (nA(this.hls.inFlightFragments, o)) return 0;
                let e = !1,
                  s = t.end;
                for (; s < o; ) {
                  const t = i.getPartialFragment(s);
                  if (!t) {
                    e = !0;
                    break;
                  }
                  s += t.duration;
                }
                if (e) return 0;
              }
            }
          }
          const t = Math.max(o + 0.05, n + 0.1);
          if (
            (this.warn(
              `skipping hole, adjusting currentTime from ${n} to ${t}`
            ),
            (this.moved = !0),
            (s.currentTime = t),
            null == e || !e.gap)
          ) {
            const i = new Error(
              `fragment loaded with buffer holes, seeking from ${n} to ${t}`
            );
            this.hls.trigger(Am.ERROR, {
              type: Rm.MEDIA_ERROR,
              details: ym.BUFFER_SEEK_OVER_HOLE,
              fatal: !1,
              error: i,
              reason: i.message,
              frag: e || void 0,
              buffer: a.len,
              bufferInfo: a
            });
          }
          return t;
        }
      }
      return 0;
    }
    _tryNudgeBuffer(e) {
      const { hls: t, media: i, nudgeRetry: s } = this,
        r = null == t ? void 0 : t.config;
      if (!i || !r) return 0;
      const n = i.currentTime;
      if ((this.nudgeRetry++, s < r.nudgeMaxRetry)) {
        const a = n + (s + 1) * r.nudgeOffset,
          o = new Error(`Nudging 'currentTime' from ${n} to ${a}`);
        this.warn(o.message),
          (i.currentTime = a),
          t.trigger(Am.ERROR, {
            type: Rm.MEDIA_ERROR,
            details: ym.BUFFER_NUDGE_ON_STALL,
            error: o,
            fatal: !1,
            buffer: e.len,
            bufferInfo: e
          });
      } else {
        const i = new Error(
          `Playhead still not moving while enough data buffered @${n} after ${r.nudgeMaxRetry} nudges`
        );
        this.error(i.message),
          t.trigger(Am.ERROR, {
            type: Rm.MEDIA_ERROR,
            details: ym.BUFFER_STALLED_ERROR,
            error: i,
            fatal: !0,
            buffer: e.len,
            bufferInfo: e
          });
      }
    }
  }
  function nA(e, t) {
    const i = aA(e.main);
    if (i && i.start <= t) return i;
    const s = aA(e.audio);
    return s && s.start <= t ? s : null;
  }
  function aA(e) {
    if (!e) return null;
    switch (e.state) {
      case ZT.IDLE:
      case ZT.STOPPED:
      case ZT.ENDED:
      case ZT.ERROR:
        return null;
    }
    return e.frag;
  }
  function oA() {
    if ("undefined" != typeof self) return self.VTTCue || self.TextTrackCue;
  }
  function cA(e, t, i, s, r) {
    let n = new e(t, i, "");
    try {
      (n.value = s), r && (n.type = r);
    } catch (a) {
      n = new e(t, i, i_(r ? Nm({ type: r }, s) : s));
    }
    return n;
  }
  const dA = (() => {
    const e = oA();
    try {
      e && new e(0, Number.POSITIVE_INFINITY, "");
    } catch (e) {
      return Number.MAX_VALUE;
    }
    return Number.POSITIVE_INFINITY;
  })();
  class lA {
    constructor(e) {
      (this.hls = void 0),
        (this.id3Track = null),
        (this.media = null),
        (this.dateRangeCuesAppended = {}),
        (this.removeCues = !0),
        (this.onEventCueEnter = () => {
          this.hls && this.hls.trigger(Am.EVENT_CUE_ENTER, {});
        }),
        (this.hls = e),
        this._registerListeners();
    }
    destroy() {
      this._unregisterListeners(),
        (this.id3Track = null),
        (this.media = null),
        (this.dateRangeCuesAppended = {}),
        (this.hls = this.onEventCueEnter = null);
    }
    _registerListeners() {
      const { hls: e } = this;
      e.on(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Am.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
        e.on(Am.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(Am.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
    }
    _unregisterListeners() {
      const { hls: e } = this;
      e.off(Am.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Am.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
        e.off(Am.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(Am.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
    }
    onMediaAttaching(e, t) {
      var i;
      (this.media = t.media),
        !1 === (null == (i = t.overrides) ? void 0 : i.cueRemoval) &&
          (this.removeCues = !1);
    }
    onMediaAttached() {
      const e = this.hls.latestLevelDetails;
      e && this.updateDateRangeCues(e);
    }
    onMediaDetaching(e, t) {
      this.media = null;
      !!t.transferMedia ||
        (this.id3Track &&
          (this.removeCues && PR(this.id3Track, this.onEventCueEnter),
          (this.id3Track = null)),
        (this.dateRangeCuesAppended = {}));
    }
    onManifestLoading() {
      this.dateRangeCuesAppended = {};
    }
    createTrack(e) {
      const t = this.getID3Track(e.textTracks);
      return (t.mode = "hidden"), t;
    }
    getID3Track(e) {
      if (this.media) {
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if ("metadata" === i.kind && "id3" === i.label)
            return LR(i, this.media), i;
        }
        return this.media.addTextTrack("metadata", "id3");
      }
    }
    onFragParsingMetadata(e, t) {
      if (!this.media) return;
      const {
        hls: {
          config: { enableEmsgMetadataCues: i, enableID3MetadataCues: s }
        }
      } = this;
      if (!i && !s) return;
      const { samples: r } = t;
      this.id3Track || (this.id3Track = this.createTrack(this.media));
      const n = oA();
      if (n)
        for (let e = 0; e < r.length; e++) {
          const t = r[e].type;
          if ((t === PS.emsg && !i) || !s) continue;
          const a = DS(r[e].data);
          if (a) {
            const i = r[e].pts;
            let s = i + r[e].duration;
            s > dA && (s = dA);
            s - i <= 0 && (s = i + 0.25);
            for (let e = 0; e < a.length; e++) {
              const r = a[e];
              if (!wS(r)) {
                this.updateId3CueEnds(i, t);
                const e = cA(n, i, s, r, t);
                e && this.id3Track.addCue(e);
              }
            }
          }
        }
    }
    updateId3CueEnds(e, t) {
      var i;
      const s = null == (i = this.id3Track) ? void 0 : i.cues;
      if (s)
        for (let i = s.length; i--; ) {
          const r = s[i];
          r.type === t &&
            r.startTime < e &&
            r.endTime === dA &&
            (r.endTime = e);
        }
    }
    onBufferFlushing(e, { startOffset: t, endOffset: i, type: s }) {
      const { id3Track: r, hls: n } = this;
      if (!n) return;
      const {
        config: { enableEmsgMetadataCues: a, enableID3MetadataCues: o }
      } = n;
      if (r && (a || o)) {
        let e;
        (e =
          "audio" === s
            ? e => e.type === PS.audioId3 && o
            : "video" === s
            ? e => e.type === PS.emsg && a
            : e => (e.type === PS.audioId3 && o) || (e.type === PS.emsg && a)),
          kR(r, t, i, e);
      }
    }
    onLevelUpdated(e, { details: t }) {
      this.updateDateRangeCues(t, !0);
    }
    onLevelPtsUpdated(e, t) {
      Math.abs(t.drift) > 0.01 && this.updateDateRangeCues(t.details);
    }
    updateDateRangeCues(e, t) {
      if (
        !this.media ||
        !e.hasProgramDateTime ||
        !this.hls.config.enableDateRangeMetadataCues
      )
        return;
      const { id3Track: i } = this,
        { dateRanges: s } = e,
        r = Object.keys(s);
      let n = this.dateRangeCuesAppended;
      var a;
      if (i && t)
        if (null != (a = i.cues) && a.length) {
          const e = Object.keys(n).filter(e => !r.includes(e));
          for (let t = e.length; t--; ) {
            const s = e[t],
              r = n[s].cues;
            delete n[s],
              Object.keys(r).forEach(e => {
                try {
                  const t = r[e];
                  t.removeEventListener("enter", this.onEventCueEnter),
                    i.removeCue(t);
                } catch (e) {}
              });
          }
        } else n = this.dateRangeCuesAppended = {};
      const o = e.fragments[e.fragments.length - 1];
      if (0 === r.length || !Tm(null == o ? void 0 : o.programDateTime)) return;
      this.id3Track || (this.id3Track = this.createTrack(this.media));
      const c = oA();
      for (let e = 0; e < r.length; e++) {
        const t = r[e],
          i = s[t],
          a = i.startTime,
          o = n[t],
          h = (null == o ? void 0 : o.cues) || {};
        let u = (null == o ? void 0 : o.durationKnown) || !1,
          p = dA;
        const { duration: f, endDate: E } = i;
        if (E && null !== f) (p = a + f), (u = !0);
        else if (i.endOnNext && !u) {
          const e = r.reduce((e, t) => {
            if (t !== i.id) {
              const r = s[t];
              if (
                r.class === i.class &&
                r.startDate > i.startDate &&
                (!e || i.startDate < e.startDate)
              )
                return r;
            }
            return e;
          }, null);
          e && ((p = e.startTime), (u = !0));
        }
        const m = Object.keys(i.attr);
        for (let e = 0; e < m.length; e++) {
          const s = m[e];
          if (
            "ID" === (l = s) ||
            "CLASS" === l ||
            "CUE" === l ||
            "START-DATE" === l ||
            "DURATION" === l ||
            "END-DATE" === l ||
            "END-ON-NEXT" === l
          )
            continue;
          const r = h[s];
          if (r)
            u && !o.durationKnown
              ? (r.endTime = p)
              : Math.abs(r.startTime - a) > 0.01 &&
                ((r.startTime = a), (r.endTime = p));
          else if (c) {
            let e = i.attr[s];
            Z_(s) &&
              ((d = e),
              (e = Uint8Array.from(
                d
                  .replace(/^0x/, "")
                  .replace(/([\da-fA-F]{2}) ?/g, "0x$1 ")
                  .replace(/ +$/, "")
                  .split(" ")
              ).buffer));
            const r = cA(c, a, p, { key: s, data: e }, PS.dateRange);
            r &&
              ((r.id = t),
              this.id3Track.addCue(r),
              (h[s] = r),
              this.hls.config.interstitialsController &&
                (("X-ASSET-LIST" !== s && "X-ASSET-URL" !== s) ||
                  r.addEventListener("enter", this.onEventCueEnter)));
          }
        }
        n[t] = { cues: h, dateRange: i, durationKnown: u };
      }
      var d, l;
    }
  }
  class hA {
    constructor(e) {
      (this.hls = void 0),
        (this.config = void 0),
        (this.media = null),
        (this.currentTime = 0),
        (this.stallCount = 0),
        (this._latency = null),
        (this._targetLatencyUpdated = !1),
        (this.onTimeupdate = () => {
          const { media: e } = this,
            t = this.levelDetails;
          if (!e || !t) return;
          this.currentTime = e.currentTime;
          const i = this.computeLatency();
          if (null === i) return;
          this._latency = i;
          const { lowLatencyMode: s, maxLiveSyncPlaybackRate: r } = this.config;
          if (!s || 1 === r || !t.live) return;
          const n = this.targetLatency;
          if (null === n) return;
          const a = i - n;
          if (
            a < Math.min(this.maxLatency, n + t.targetduration) &&
            a > 0.05 &&
            this.forwardBufferLength > 1
          ) {
            const t = Math.min(2, Math.max(1, r)),
              i =
                Math.round(
                  (2 / (1 + Math.exp(-0.75 * a - this.edgeStalled))) * 20
                ) / 20,
              s = Math.min(t, Math.max(1, i));
            this.changeMediaPlaybackRate(e, s);
          } else
            1 !== e.playbackRate &&
              0 !== e.playbackRate &&
              this.changeMediaPlaybackRate(e, 1);
        }),
        (this.hls = e),
        (this.config = e.config),
        this.registerListeners();
    }
    get levelDetails() {
      var e;
      return (null == (e = this.hls) ? void 0 : e.latestLevelDetails) || null;
    }
    get latency() {
      return this._latency || 0;
    }
    get maxLatency() {
      const { config: e } = this;
      if (void 0 !== e.liveMaxLatencyDuration) return e.liveMaxLatencyDuration;
      const t = this.levelDetails;
      return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;
    }
    get targetLatency() {
      const e = this.levelDetails;
      if (null === e || null === this.hls) return null;
      const { holdBack: t, partHoldBack: i, targetduration: s } = e,
        {
          liveSyncDuration: r,
          liveSyncDurationCount: n,
          lowLatencyMode: a
        } = this.config,
        o = this.hls.userConfig;
      let c = (a && i) || t;
      (this._targetLatencyUpdated ||
        o.liveSyncDuration ||
        o.liveSyncDurationCount ||
        0 === c) &&
        (c = void 0 !== r ? r : n * s);
      const d = s;
      return (
        c + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, d)
      );
    }
    set targetLatency(e) {
      (this.stallCount = 0),
        (this.config.liveSyncDuration = e),
        (this._targetLatencyUpdated = !0);
    }
    get liveSyncPosition() {
      const e = this.estimateLiveEdge(),
        t = this.targetLatency;
      if (null === e || null === t) return null;
      const i = this.levelDetails;
      if (null === i) return null;
      const s = i.edge,
        r = e - t - this.edgeStalled,
        n = s - i.totalduration,
        a =
          s -
          ((this.config.lowLatencyMode && i.partTarget) || i.targetduration);
      return Math.min(Math.max(n, r), a);
    }
    get drift() {
      const e = this.levelDetails;
      return null === e ? 1 : e.drift;
    }
    get edgeStalled() {
      const e = this.levelDetails;
      if (null === e) return 0;
      const t =
        3 * ((this.config.lowLatencyMode && e.partTarget) || e.targetduration);
      return Math.max(e.age - t, 0);
    }
    get forwardBufferLength() {
      const { media: e } = this,
        t = this.levelDetails;
      if (!e || !t) return 0;
      const i = e.buffered.length;
      return (i ? e.buffered.end(i - 1) : t.edge) - this.currentTime;
    }
    destroy() {
      this.unregisterListeners(), this.onMediaDetaching(), (this.hls = null);
    }
    registerListeners() {
      const { hls: e } = this;
      e &&
        (e.on(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(Am.ERROR, this.onError, this));
    }
    unregisterListeners() {
      const { hls: e } = this;
      e &&
        (e.off(Am.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(Am.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Am.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(Am.ERROR, this.onError, this));
    }
    onMediaAttached(e, t) {
      (this.media = t.media),
        this.media.addEventListener("timeupdate", this.onTimeupdate);
    }
    onMediaDetaching() {
      this.media &&
        (this.media.removeEventListener("timeupdate", this.onTimeupdate),
        (this.media = null));
    }
    onManifestLoading() {
      (this._latency = null), (this.stallCount = 0);
    }
    onLevelUpdated(e, { details: t }) {
      t.advanced && this.onTimeupdate(),
        !t.live &&
          this.media &&
          this.media.removeEventListener("timeupdate", this.onTimeupdate);
    }
    onError(e, t) {
      var i;
      t.details === ym.BUFFER_STALLED_ERROR &&
        (this.stallCount++,
        this.hls &&
          null != (i = this.levelDetails) &&
          i.live &&
          this.hls.logger.warn(
            "[latency-controller]: Stall detected, adjusting target latency"
          ));
    }
    changeMediaPlaybackRate(e, t) {
      var i, s;
      e.playbackRate !== t &&
        (null == (i = this.hls) ||
          i.logger.debug(
            `[latency-controller]: latency=${this.latency.toFixed(
              3
            )}, targetLatency=${
              null == (s = this.targetLatency) ? void 0 : s.toFixed(3)
            }, forwardBufferLength=${this.forwardBufferLength.toFixed(
              3
            )}: adjusting playback rate from ${e.playbackRate} to ${t}`
          ),
        (e.playbackRate = t));
    }
    estimateLiveEdge() {
      const e = this.levelDetails;
      return null === e ? null : e.edge + e.age;
    }
    computeLatency() {
      const e = this.estimateLiveEdge();
      return null === e ? null : e - this.currentTime;
    }
  }
  class uA extends kv {
    constructor(e, t) {
      super(e, "level-controller"),
        (this._levels = []),
        (this._firstLevel = -1),
        (this._maxAutoLevel = -1),
        (this._startLevel = void 0),
        (this.currentLevel = null),
        (this.currentLevelIndex = -1),
        (this.manualLevelIndex = -1),
        (this.steering = void 0),
        (this.onParsedComplete = void 0),
        (this.steering = t),
        this._registerListeners();
    }
    _registerListeners() {
      const { hls: e } = this;
      e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(Am.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(Am.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(Am.ERROR, this.onError, this);
    }
    _unregisterListeners() {
      const { hls: e } = this;
      e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Am.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(Am.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(Am.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(Am.ERROR, this.onError, this);
    }
    destroy() {
      this._unregisterListeners(),
        (this.steering = null),
        this.resetLevels(),
        super.destroy();
    }
    stopLoad() {
      this._levels.forEach(e => {
        (e.loadError = 0), (e.fragmentError = 0);
      }),
        super.stopLoad();
    }
    resetLevels() {
      (this._startLevel = void 0),
        (this.manualLevelIndex = -1),
        (this.currentLevelIndex = -1),
        (this.currentLevel = null),
        (this._levels = []),
        (this._maxAutoLevel = -1);
    }
    onManifestLoading(e, t) {
      this.resetLevels();
    }
    onManifestLoaded(e, t) {
      const i = this.hls.config.preferManagedMediaSource,
        s = [],
        r = {},
        n = {};
      let a = !1,
        o = !1,
        c = !1;
      t.levels.forEach(e => {
        var t;
        const d = e.attrs;
        let { audioCodec: l, videoCodec: h } = e;
        l && (e.audioCodec = l = Fg(l, i) || void 0),
          0 === (null == (t = h) ? void 0 : t.indexOf("avc1")) &&
            (h = e.videoCodec = (function(e) {
              const t = e.split(",");
              for (let e = 0; e < t.length; e++) {
                const i = t[e].split(".");
                if (i.length > 2) {
                  let s = i.shift() + ".";
                  (s += parseInt(i.shift()).toString(16)),
                    (s += ("000" + parseInt(i.shift()).toString(16)).slice(-4)),
                    (t[e] = s);
                }
              }
              return t.join(",");
            })(h));
        const { width: u, height: p, unknownCodecs: f } = e;
        let E = f ? f.length : 0;
        if (f)
          for (let t = E; t--; ) {
            const i = f[t];
            this.isAudioSupported(i)
              ? ((e.audioCodec = l = l ? `${l},${i}` : i),
                E--,
                (Dg.audio[l.substring(0, 4)] = 2))
              : this.isVideoSupported(i) &&
                ((e.videoCodec = h = h ? `${h},${i}` : i),
                E--,
                (Dg.video[h.substring(0, 4)] = 2));
          }
        if (
          (a || (a = !(!u || !p)),
          o || (o = !!h),
          c || (c = !!l),
          E ||
            (l && !this.isAudioSupported(l)) ||
            (h && !this.isVideoSupported(h)))
        )
          return void this.log(
            `Some or all CODECS not supported "${d.CODECS}"`
          );
        const {
            CODECS: m,
            "FRAME-RATE": g,
            "HDCP-LEVEL": _,
            "PATHWAY-ID": T,
            RESOLUTION: S,
            "VIDEO-RANGE": v
          } = d,
          R = `${`${T || "."}-`}${e.bitrate}-${S}-${g}-${m}-${v}-${_}`;
        if (r[R])
          if (r[R].uri === e.url || e.attrs["PATHWAY-ID"])
            r[R].addGroupId("audio", d.AUDIO),
              r[R].addGroupId("text", d.SUBTITLES);
          else {
            const t = (n[R] += 1);
            e.attrs["PATHWAY-ID"] = new Array(t + 1).join(".");
            const i = this.createLevel(e);
            (r[R] = i), s.push(i);
          }
        else {
          const t = this.createLevel(e);
          (r[R] = t), (n[R] = 1), s.push(t);
        }
      }),
        this.filterAndSortMediaOptions(s, t, a, o, c);
    }
    createLevel(e) {
      const t = new Zg(e),
        i = e.supplemental;
      if (null != i && i.videoCodec && !this.isVideoSupported(i.videoCodec)) {
        const e = new Error(
          `SUPPLEMENTAL-CODECS not supported "${i.videoCodec}"`
        );
        this.log(e.message), (t.supportedResult = Kg(e, []));
      }
      return t;
    }
    isAudioSupported(e) {
      return Lg(e, "audio", this.hls.config.preferManagedMediaSource);
    }
    isVideoSupported(e) {
      return Lg(e, "video", this.hls.config.preferManagedMediaSource);
    }
    filterAndSortMediaOptions(e, t, i, s, r) {
      let n = [],
        a = [],
        o = e;
      if (
        ((i || s) &&
          r &&
          (o = o.filter(
            ({ videoCodec: e, videoRange: t, width: i, height: s }) => {
              return (!!e || !(!i || !s)) && !!(r = t) && Xg.indexOf(r) > -1;
              var r;
            }
          )),
        0 === o.length)
      )
        return void Promise.resolve().then(() => {
          if (this.hls) {
            let e = "no level with compatible codecs found in manifest",
              i = e;
            t.levels.length &&
              ((i = `one or more CODECS in variant not supported: ${i_(
                t.levels
                  .map(e => e.attrs.CODECS)
                  .filter((e, t, i) => i.indexOf(e) === t)
              )}`),
              this.warn(i),
              (e += ` (${i})`));
            const s = new Error(e);
            this.hls.trigger(Am.ERROR, {
              type: Rm.MEDIA_ERROR,
              details: ym.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
              fatal: !0,
              url: t.url,
              error: s,
              reason: i
            });
          }
        });
      t.audioTracks &&
        ((n = t.audioTracks.filter(
          e => !e.audioCodec || this.isAudioSupported(e.audioCodec)
        )),
        pA(n)),
        t.subtitles && ((a = t.subtitles), pA(a));
      const c = o.slice(0);
      o.sort((e, t) => {
        if (e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"])
          return (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "")
            ? 1
            : -1;
        if (i && e.height !== t.height) return e.height - t.height;
        if (e.frameRate !== t.frameRate) return e.frameRate - t.frameRate;
        if (e.videoRange !== t.videoRange)
          return Xg.indexOf(e.videoRange) - Xg.indexOf(t.videoRange);
        if (e.videoCodec !== t.videoCodec) {
          const i = kg(e.videoCodec),
            s = kg(t.videoCodec);
          if (i !== s) return s - i;
        }
        if (e.uri === t.uri && e.codecSet !== t.codecSet) {
          const i = Mg(e.codecSet),
            s = Mg(t.codecSet);
          if (i !== s) return s - i;
        }
        return e.averageBitrate !== t.averageBitrate
          ? e.averageBitrate - t.averageBitrate
          : 0;
      });
      let d = c[0];
      if (
        this.steering &&
        ((o = this.steering.filterParsedLevels(o)), o.length !== c.length)
      )
        for (let e = 0; e < c.length; e++)
          if (c[e].pathwayId === o[0].pathwayId) {
            d = c[e];
            break;
          }
      this._levels = o;
      for (let e = 0; e < o.length; e++)
        if (o[e] === d) {
          var l;
          this._firstLevel = e;
          const t = d.bitrate,
            i = this.hls.bandwidthEstimate;
          if (
            (this.log(
              `manifest loaded, ${o.length} level(s) found, first bitrate: ${t}`
            ),
            void 0 ===
              (null == (l = this.hls.userConfig)
                ? void 0
                : l.abrEwmaDefaultEstimate))
          ) {
            const e = Math.min(t, this.hls.config.abrEwmaDefaultEstimateMax);
            e > i &&
              i === this.hls.abrEwmaDefaultEstimate &&
              (this.hls.bandwidthEstimate = e);
          }
          break;
        }
      const h = r && !s,
        u = {
          levels: o,
          audioTracks: n,
          subtitleTracks: a,
          sessionData: t.sessionData,
          sessionKeys: t.sessionKeys,
          firstLevel: this._firstLevel,
          stats: t.stats,
          audio: r,
          video: s,
          altAudio: !h && n.some(e => !!e.url)
        };
      this.hls.trigger(Am.MANIFEST_PARSED, u);
    }
    get levels() {
      return 0 === this._levels.length ? null : this._levels;
    }
    get loadLevelObj() {
      return this.currentLevel;
    }
    get level() {
      return this.currentLevelIndex;
    }
    set level(e) {
      const t = this._levels;
      if (0 === t.length) return;
      if (e < 0 || e >= t.length) {
        const i = new Error("invalid level idx"),
          s = e < 0;
        if (
          (this.hls.trigger(Am.ERROR, {
            type: Rm.OTHER_ERROR,
            details: ym.LEVEL_SWITCH_ERROR,
            level: e,
            fatal: s,
            error: i,
            reason: i.message
          }),
          s)
        )
          return;
        e = Math.min(e, t.length - 1);
      }
      const i = this.currentLevelIndex,
        s = this.currentLevel,
        r = s ? s.attrs["PATHWAY-ID"] : void 0,
        n = t[e],
        a = n.attrs["PATHWAY-ID"];
      if (
        ((this.currentLevelIndex = e),
        (this.currentLevel = n),
        i === e && s && r === a)
      )
        return;
      this.log(
        `Switching to level ${e} (${n.height ? n.height + "p " : ""}${
          n.videoRange ? n.videoRange + " " : ""
        }${n.codecSet ? n.codecSet + " " : ""}@${n.bitrate})${
          a ? " with Pathway " + a : ""
        } from level ${i}${r ? " with Pathway " + r : ""}`
      );
      const o = {
        level: e,
        attrs: n.attrs,
        details: n.details,
        bitrate: n.bitrate,
        averageBitrate: n.averageBitrate,
        maxBitrate: n.maxBitrate,
        realBitrate: n.realBitrate,
        width: n.width,
        height: n.height,
        codecSet: n.codecSet,
        audioCodec: n.audioCodec,
        videoCodec: n.videoCodec,
        audioGroups: n.audioGroups,
        subtitleGroups: n.subtitleGroups,
        loaded: n.loaded,
        loadError: n.loadError,
        fragmentError: n.fragmentError,
        name: n.name,
        id: n.id,
        uri: n.uri,
        url: n.url,
        urlId: 0,
        audioGroupIds: n.audioGroupIds,
        textGroupIds: n.textGroupIds
      };
      this.hls.trigger(Am.LEVEL_SWITCHING, o);
      const c = n.details;
      if (!c || c.live) {
        const e = this.switchParams(n.uri, null == s ? void 0 : s.details, c);
        this.loadPlaylist(e);
      }
    }
    get manualLevel() {
      return this.manualLevelIndex;
    }
    set manualLevel(e) {
      (this.manualLevelIndex = e),
        void 0 === this._startLevel && (this._startLevel = e),
        -1 !== e && (this.level = e);
    }
    get firstLevel() {
      return this._firstLevel;
    }
    set firstLevel(e) {
      this._firstLevel = e;
    }
    get startLevel() {
      if (void 0 === this._startLevel) {
        const e = this.hls.config.startLevel;
        return void 0 !== e ? e : this.hls.firstAutoLevel;
      }
      return this._startLevel;
    }
    set startLevel(e) {
      this._startLevel = e;
    }
    get pathways() {
      return this.steering ? this.steering.pathways() : [];
    }
    get pathwayPriority() {
      return this.steering ? this.steering.pathwayPriority : null;
    }
    set pathwayPriority(e) {
      if (this.steering) {
        const t = this.steering.pathways(),
          i = e.filter(e => -1 !== t.indexOf(e));
        if (e.length < 1)
          return void this.warn(
            `pathwayPriority ${e} should contain at least one pathway from list: ${t}`
          );
        this.steering.pathwayPriority = i;
      }
    }
    onError(e, t) {
      !t.fatal &&
        t.context &&
        t.context.type === Im.LEVEL &&
        t.context.level === this.level &&
        this.checkRetry(t);
    }
    onFragBuffered(e, { frag: t }) {
      if (void 0 !== t && t.type === Cm.MAIN) {
        const e = t.elementaryStreams;
        if (!Object.keys(e).some(t => !!e[t])) return;
        const i = this._levels[t.level];
        null != i &&
          i.loadError &&
          (this.log(
            `Resetting level error count of ${i.loadError} on frag buffered`
          ),
          (i.loadError = 0));
      }
    }
    onLevelLoaded(e, t) {
      var i;
      const { level: s, details: r } = t,
        n = t.levelInfo;
      var a;
      if (!n)
        return (
          this.warn(`Invalid level index ${s}`),
          void (
            null != (a = t.deliveryDirectives) &&
            a.skip &&
            (r.deltaUpdateFailed = !0)
          )
        );
      if (n === this.currentLevel || t.withoutMultiVariant) {
        0 === n.fragmentError && (n.loadError = 0);
        let e = n.details;
        e === t.details && e.advanced && (e = void 0),
          this.playlistLoaded(s, t, e);
      } else null != (i = t.deliveryDirectives) && i.skip && (r.deltaUpdateFailed = !0);
    }
    loadPlaylist(e) {
      super.loadPlaylist(),
        this.shouldLoadPlaylist(this.currentLevel) &&
          this.scheduleLoading(this.currentLevel, e);
    }
    loadingPlaylist(e, t) {
      super.loadingPlaylist(e, t);
      const i = this.getUrlWithDirectives(e.uri, t),
        s = this.currentLevelIndex,
        r = e.attrs["PATHWAY-ID"],
        n = e.details,
        a = null == n ? void 0 : n.age;
      this.log(
        `Loading level index ${s}${
          void 0 !== (null == t ? void 0 : t.msn)
            ? " at sn " + t.msn + " part " + t.part
            : ""
        }${r ? " Pathway " + r : ""}${
          a && n.live
            ? " age " + a.toFixed(1) + ((n.type && " " + n.type) || "")
            : ""
        } ${i}`
      ),
        this.hls.trigger(Am.LEVEL_LOADING, {
          url: i,
          level: s,
          levelInfo: e,
          pathwayId: e.attrs["PATHWAY-ID"],
          id: 0,
          deliveryDirectives: t || null
        });
    }
    get nextLoadLevel() {
      return -1 !== this.manualLevelIndex
        ? this.manualLevelIndex
        : this.hls.nextAutoLevel;
    }
    set nextLoadLevel(e) {
      (this.level = e),
        -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e);
    }
    removeLevel(e) {
      var t;
      if (1 === this._levels.length) return;
      const i = this._levels.filter(
        (t, i) =>
          i !== e ||
          (this.steering && this.steering.removeLevel(t),
          t === this.currentLevel &&
            ((this.currentLevel = null),
            (this.currentLevelIndex = -1),
            t.details && t.details.fragments.forEach(e => (e.level = -1))),
          !1)
      );
      YT(i),
        (this._levels = i),
        this.currentLevelIndex > -1 &&
          null != (t = this.currentLevel) &&
          t.details &&
          (this.currentLevelIndex = this.currentLevel.details.fragments[0].level),
        this.manualLevelIndex > -1 &&
          (this.manualLevelIndex = this.currentLevelIndex);
      const s = i.length - 1;
      (this._firstLevel = Math.min(this._firstLevel, s)),
        this._startLevel && (this._startLevel = Math.min(this._startLevel, s)),
        this.hls.trigger(Am.LEVELS_UPDATED, { levels: i });
    }
    onLevelsUpdated(e, { levels: t }) {
      this._levels = t;
    }
    checkMaxAutoUpdated() {
      const {
        autoLevelCapping: e,
        maxAutoLevel: t,
        maxHdcpLevel: i
      } = this.hls;
      this._maxAutoLevel !== t &&
        ((this._maxAutoLevel = t),
        this.hls.trigger(Am.MAX_AUTO_LEVEL_UPDATED, {
          autoLevelCapping: e,
          levels: this.levels,
          maxAutoLevel: t,
          minAutoLevel: this.hls.minAutoLevel,
          maxHdcpLevel: i
        }));
    }
  }
  function pA(e) {
    const t = {};
    e.forEach(e => {
      const i = e.groupId || "";
      (e.id = t[i] = t[i] || 0), t[i]++;
    });
  }
  function fA() {
    return self.SourceBuffer || self.WebKitSourceBuffer;
  }
  function EA() {
    if (!Vm()) return !1;
    const e = fA();
    return (
      !e ||
      (e.prototype &&
        "function" == typeof e.prototype.appendBuffer &&
        "function" == typeof e.prototype.remove)
    );
  }
  class mA extends eS {
    constructor(e, t, i) {
      super(e, t, i, "stream-controller", Cm.MAIN),
        (this.audioCodecSwap = !1),
        (this.level = -1),
        (this._forceStartLoad = !1),
        (this._hasEnoughToStart = !1),
        (this.altAudio = 0),
        (this.audioOnly = !1),
        (this.fragPlaying = null),
        (this.fragLastKbps = 0),
        (this.couldBacktrack = !1),
        (this.backtrackFragment = null),
        (this.audioCodecSwitch = !1),
        (this.videoBuffer = null),
        (this.onMediaPlaying = () => {
          this.tick();
        }),
        (this.onMediaSeeked = () => {
          const e = this.media,
            t = e ? e.currentTime : null;
          if (null === t || !Tm(t)) return;
          if (
            (this.log(`Media seeked to ${t.toFixed(3)}`),
            !this.getBufferedFrag(t))
          )
            return;
          const i = this.getFwdBufferInfoAtPos(e, t, Cm.MAIN, 0);
          null !== i && 0 !== i.len
            ? this.tick()
            : this.warn(
                `Main forward buffer length at ${t} on "seeked" event ${
                  i ? i.len : "empty"
                })`
              );
        }),
        this.registerListeners();
    }
    registerListeners() {
      super.registerListeners();
      const { hls: e } = this;
      e.on(Am.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(Am.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(Am.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(
          Am.FRAG_LOAD_EMERGENCY_ABORTED,
          this.onFragLoadEmergencyAborted,
          this
        ),
        e.on(Am.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.on(Am.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
        e.on(Am.BUFFER_CREATED, this.onBufferCreated, this),
        e.on(Am.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.on(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(Am.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    unregisterListeners() {
      super.unregisterListeners();
      const { hls: e } = this;
      e.off(Am.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(Am.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(
          Am.FRAG_LOAD_EMERGENCY_ABORTED,
          this.onFragLoadEmergencyAborted,
          this
        ),
        e.off(Am.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.off(Am.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
        e.off(Am.BUFFER_CREATED, this.onBufferCreated, this),
        e.off(Am.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.off(Am.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(Am.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    onHandlerDestroying() {
      (this.onMediaPlaying = this.onMediaSeeked = null),
        this.unregisterListeners(),
        super.onHandlerDestroying();
    }
    startLoad(e, t) {
      if (this.levels) {
        const { lastCurrentTime: i, hls: s } = this;
        if (
          (this.stopLoad(),
          this.setInterval(100),
          (this.level = -1),
          !this.startFragRequested)
        ) {
          let e = s.startLevel;
          -1 === e &&
            (s.config.testBandwidth && this.levels.length > 1
              ? ((e = 0), (this.bitrateTest = !0))
              : (e = s.firstAutoLevel)),
            (s.nextLoadLevel = e),
            (this.level = s.loadLevel),
            (this._hasEnoughToStart = !!t);
        }
        i > 0 &&
          -1 === e &&
          !t &&
          (this.log(
            `Override startPosition with lastCurrentTime @${i.toFixed(3)}`
          ),
          (e = i)),
          (this.state = ZT.IDLE),
          (this.nextLoadPosition = this.lastCurrentTime =
            e + this.timelineOffset),
          (this.startPosition = t ? -1 : e),
          this.tick();
      } else (this._forceStartLoad = !0), (this.state = ZT.STOPPED);
    }
    stopLoad() {
      (this._forceStartLoad = !1), super.stopLoad();
    }
    doTick() {
      switch (this.state) {
        case ZT.WAITING_LEVEL: {
          const { levels: e, level: t } = this,
            i = null == e ? void 0 : e[t],
            s = null == i ? void 0 : i.details;
          if (
            s &&
            (!s.live || (this.levelLastLoaded === i && !this.waitForLive(i)))
          ) {
            if (this.waitForCdnTuneIn(s)) break;
            this.state = ZT.IDLE;
            break;
          }
          if (this.hls.nextLoadLevel !== this.level) {
            this.state = ZT.IDLE;
            break;
          }
          break;
        }
        case ZT.FRAG_LOADING_WAITING_RETRY: {
          var e;
          const t = self.performance.now(),
            i = this.retryDate;
          if (!i || t >= i || (null != (e = this.media) && e.seeking)) {
            const { levels: e, level: t } = this,
              i = null == e ? void 0 : e[t];
            this.resetStartWhenNotLoaded(i || null), (this.state = ZT.IDLE);
          }
        }
      }
      this.state === ZT.IDLE && this.doTickIdle(), this.onTickEnd();
    }
    onTickEnd() {
      var e;
      super.onTickEnd(),
        null != (e = this.media) &&
          e.readyState &&
          !1 === this.media.seeking &&
          (this.lastCurrentTime = this.media.currentTime),
        this.checkFragmentChanged();
    }
    doTickIdle() {
      const { hls: e, levelLastLoaded: t, levels: i, media: s } = this;
      if (
        null === t ||
        (!s &&
          !this.primaryPrefetch &&
          (this.startFragRequested || !e.config.startFragPrefetch))
      )
        return;
      if (this.altAudio && this.audioOnly) return;
      const r = this.buffering ? e.nextLoadLevel : e.loadLevel;
      if (null == i || !i[r]) return;
      const n = i[r],
        a = this.getMainFwdBufferInfo();
      if (null === a) return;
      const o = this.getLevelDetails();
      if (o && this._streamEnded(a, o)) {
        const e = {};
        return (
          2 === this.altAudio && (e.type = "video"),
          this.hls.trigger(Am.BUFFER_EOS, e),
          void (this.state = ZT.ENDED)
        );
      }
      if (!this.buffering) return;
      e.loadLevel !== r &&
        -1 === e.manualLevel &&
        this.log(`Adapting to level ${r} from level ${this.level}`),
        (this.level = e.nextLoadLevel = r);
      const c = n.details;
      if (!c || this.state === ZT.WAITING_LEVEL || this.waitForLive(n))
        return (
          (this.level = r),
          (this.state = ZT.WAITING_LEVEL),
          void (this.startFragRequested = !1)
        );
      const d = a.len,
        l = this.getMaxBufferLength(n.maxBitrate);
      if (d >= l) return;
      this.backtrackFragment &&
        this.backtrackFragment.start > a.end &&
        (this.backtrackFragment = null);
      const h = this.backtrackFragment ? this.backtrackFragment.start : a.end;
      let u = this.getNextFragment(h, c);
      if (
        this.couldBacktrack &&
        !this.fragPrevious &&
        u &&
        Jm(u) &&
        this.fragmentTracker.getState(u) !== b_
      ) {
        var p;
        const e = (null != (p = this.backtrackFragment) ? p : u).sn - c.startSN,
          t = c.fragments[e - 1];
        t && u.cc === t.cc && ((u = t), this.fragmentTracker.removeFragment(t));
      } else this.backtrackFragment && a.len && (this.backtrackFragment = null);
      if (u && this.isLoopLoading(u, h)) {
        if (!u.gap) {
          const e = this.audioOnly && !this.altAudio ? Xm.AUDIO : Xm.VIDEO,
            t =
              (e === Xm.VIDEO ? this.videoBuffer : this.mediaBuffer) ||
              this.media;
          t && this.afterBufferFlushed(t, e, Cm.MAIN);
        }
        u = this.getNextFragmentLoopLoading(u, c, a, Cm.MAIN, l);
      }
      u &&
        (!u.initSegment ||
          u.initSegment.data ||
          this.bitrateTest ||
          (u = u.initSegment),
        this.loadFragment(u, n, h));
    }
    loadFragment(e, t, i) {
      const s = this.fragmentTracker.getState(e);
      s === A_ || s === C_
        ? Jm(e)
          ? this.bitrateTest
            ? (this.log(
                `Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`
              ),
              this._loadBitrateTestFrag(e, t))
            : super.loadFragment(e, t, i)
          : this._loadInitSegment(e, t)
        : this.clearTrackerIfNeeded(e);
    }
    getBufferedFrag(e) {
      return this.fragmentTracker.getBufferedFrag(e, Cm.MAIN);
    }
    followingBufferedFrag(e) {
      return e ? this.getBufferedFrag(e.end + 0.5) : null;
    }
    immediateLevelSwitch() {
      this.abortCurrentFrag(),
        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }
    nextLevelSwitch() {
      const { levels: e, media: t } = this;
      if (null != t && t.readyState) {
        let i;
        const s = this.getAppendedFrag(t.currentTime);
        s && s.start > 1 && this.flushMainBuffer(0, s.start - 1);
        const r = this.getLevelDetails();
        if (null != r && r.live) {
          const e = this.getMainFwdBufferInfo();
          if (!e || e.len < 2 * r.targetduration) return;
        }
        if (!t.paused && e) {
          const t = e[this.hls.nextLoadLevel],
            s = this.fragLastKbps;
          i =
            s && this.fragCurrent
              ? (this.fragCurrent.duration * t.maxBitrate) / (1e3 * s) + 1
              : 0;
        } else i = 0;
        const n = this.getBufferedFrag(t.currentTime + i);
        if (n) {
          const e = this.followingBufferedFrag(n);
          if (e) {
            this.abortCurrentFrag();
            const t = e.maxStartPTS ? e.maxStartPTS : e.start,
              i = e.duration,
              s = Math.max(
                n.end,
                t +
                  Math.min(
                    Math.max(
                      i - this.config.maxFragLookUpTolerance,
                      i * (this.couldBacktrack ? 0.5 : 0.125)
                    ),
                    i * (this.couldBacktrack ? 0.75 : 0.25)
                  )
              );
            this.flushMainBuffer(s, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
    abortCurrentFrag() {
      const e = this.fragCurrent;
      switch (
        ((this.fragCurrent = null),
        (this.backtrackFragment = null),
        e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)),
        this.state)
      ) {
        case ZT.KEY_LOADING:
        case ZT.FRAG_LOADING:
        case ZT.FRAG_LOADING_WAITING_RETRY:
        case ZT.PARSING:
        case ZT.PARSED:
          this.state = ZT.IDLE;
      }
      this.nextLoadPosition = this.getLoadPosition();
    }
    flushMainBuffer(e, t) {
      super.flushMainBuffer(e, t, 2 === this.altAudio ? "video" : null);
    }
    onMediaAttached(e, t) {
      super.onMediaAttached(e, t);
      const i = t.media;
      qR(i, "playing", this.onMediaPlaying),
        qR(i, "seeked", this.onMediaSeeked);
    }
    onMediaDetaching(e, t) {
      const { media: i } = this;
      i &&
        (XR(i, "playing", this.onMediaPlaying),
        XR(i, "seeked", this.onMediaSeeked)),
        (this.videoBuffer = null),
        (this.fragPlaying = null),
        super.onMediaDetaching(e, t);
      !!t.transferMedia || (this._hasEnoughToStart = !1);
    }
    onManifestLoading() {
      super.onManifestLoading(),
        this.log("Trigger BUFFER_RESET"),
        this.hls.trigger(Am.BUFFER_RESET, void 0),
        (this.couldBacktrack = !1),
        (this.fragLastKbps = 0),
        (this.fragPlaying = this.backtrackFragment = null),
        (this.altAudio = 0),
        (this.audioOnly = !1);
    }
    onManifestParsed(e, t) {
      let i = !1,
        s = !1;
      t.levels.forEach(e => {
        const t = e.audioCodec;
        t &&
          ((i = i || -1 !== t.indexOf("mp4a.40.2")),
          (s = s || -1 !== t.indexOf("mp4a.40.5")));
      }),
        (this.audioCodecSwitch =
          i &&
          s &&
          !(function() {
            var e;
            const t = fA();
            return (
              "function" ==
              typeof (null == t || null == (e = t.prototype)
                ? void 0
                : e.changeType)
            );
          })()),
        this.audioCodecSwitch &&
          this.log(
            "Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"
          ),
        (this.levels = t.levels),
        (this.startFragRequested = !1);
    }
    onLevelLoading(e, t) {
      const { levels: i } = this;
      if (!i || this.state !== ZT.IDLE) return;
      const s = t.levelInfo;
      (!s.details ||
        (s.details.live && (this.levelLastLoaded !== s || s.details.expired)) ||
        this.waitForCdnTuneIn(s.details)) &&
        (this.state = ZT.WAITING_LEVEL);
    }
    onLevelLoaded(e, t) {
      var i;
      const { levels: s, startFragRequested: r } = this,
        n = t.level,
        a = t.details,
        o = a.totalduration;
      if (!s)
        return void this.warn(`Levels were reset while loading level ${n}`);
      this.log(
        `Level ${n} loaded [${a.startSN},${a.endSN}]${
          a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""
        }, cc [${a.startCC}, ${a.endCC}] duration:${o}`
      );
      const c = t.levelInfo,
        d = this.fragCurrent;
      !d ||
        (this.state !== ZT.FRAG_LOADING &&
          this.state !== ZT.FRAG_LOADING_WAITING_RETRY) ||
        (d.level !== t.level && d.loader && this.abortCurrentFrag());
      let l = 0;
      if (a.live || (null != (i = c.details) && i.live)) {
        var h;
        if ((this.checkLiveUpdate(a), a.deltaUpdateFailed)) return;
        l = this.alignPlaylists(
          a,
          c.details,
          null == (h = this.levelLastLoaded) ? void 0 : h.details
        );
      }
      if (
        ((c.details = a),
        (this.levelLastLoaded = c),
        r || this.setStartPosition(a, l),
        this.hls.trigger(Am.LEVEL_UPDATED, { details: a, level: n }),
        this.state === ZT.WAITING_LEVEL)
      ) {
        if (this.waitForCdnTuneIn(a)) return;
        this.state = ZT.IDLE;
      }
      r && a.live && this.synchronizeToLiveEdge(a), this.tick();
    }
    synchronizeToLiveEdge(e) {
      const { config: t, media: i } = this;
      if (!i) return;
      const s = this.hls.liveSyncPosition,
        r = this.getLoadPosition(),
        n = e.fragmentStart,
        a = e.edge,
        o = r >= n - t.maxFragLookUpTolerance && r <= a;
      if (null !== s && i.duration > s && (r < s || !o)) {
        const n =
          void 0 !== t.liveMaxLatencyDuration
            ? t.liveMaxLatencyDuration
            : t.liveMaxLatencyDurationCount * e.targetduration;
        ((!o && i.readyState < 4) || r < a - n) &&
          (this._hasEnoughToStart || (this.nextLoadPosition = s),
          i.readyState &&
            (this.warn(
              `Playback: ${r.toFixed(
                3
              )} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${s.toFixed(
                3
              )}`
            ),
            (i.currentTime = s)));
      }
    }
    _handleFragmentLoadProgress(e) {
      var t;
      const i = e.frag,
        { part: s, payload: r } = e,
        { levels: n } = this;
      if (!n)
        return void this.warn(
          `Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`
        );
      const a = n[i.level];
      if (!a) return void this.warn(`Level ${i.level} not found on progress`);
      const o = a.details;
      if (!o)
        return (
          this.warn(
            `Dropping fragment ${i.sn} of level ${i.level} after level details were reset`
          ),
          void this.fragmentTracker.removeFragment(i)
        );
      const c = a.videoCodec,
        d = o.PTSKnown || !o.live,
        l = null == (t = i.initSegment) ? void 0 : t.data,
        h = this._getAudioCodec(a),
        u = (this.transmuxer =
          this.transmuxer ||
          new Pv(
            this.hls,
            Cm.MAIN,
            this._handleTransmuxComplete.bind(this),
            this._handleTransmuxerFlush.bind(this)
          )),
        p = s ? s.index : -1,
        f = -1 !== p,
        E = new j_(i.level, i.sn, i.stats.chunkCount, r.byteLength, p, f),
        m = this.initPTS[i.cc];
      u.push(r, l, h, c, i, s, o.totalduration, d, E, m);
    }
    onAudioTrackSwitching(e, t) {
      const i = this.hls,
        s = 2 === this.altAudio;
      if (l_(t.url, i)) this.altAudio = 1;
      else {
        if (this.mediaBuffer !== this.media) {
          this.log(
            "Switching on main audio, use media.buffered to schedule main fragment loading"
          ),
            (this.mediaBuffer = this.media);
          const e = this.fragCurrent;
          e &&
            (this.log(
              "Switching to main audio track, cancel main fragment load"
            ),
            e.abortRequests(),
            this.fragmentTracker.removeFragment(e)),
            this.resetTransmuxer(),
            this.resetLoadingState();
        } else this.audioOnly && this.resetTransmuxer();
        if (s)
          return (
            this.fragmentTracker.removeAllFragments(),
            i.once(Am.BUFFER_FLUSHED, () => {
              var e;
              null == (e = this.hls) || e.trigger(Am.AUDIO_TRACK_SWITCHED, t);
            }),
            void i.trigger(Am.BUFFER_FLUSHING, {
              startOffset: 0,
              endOffset: Number.POSITIVE_INFINITY,
              type: null
            })
          );
        i.trigger(Am.AUDIO_TRACK_SWITCHED, t);
      }
    }
    onAudioTrackSwitched(e, t) {
      const i = l_(t.url, this.hls);
      if (i) {
        const e = this.videoBuffer;
        e &&
          this.mediaBuffer !== e &&
          (this.log(
            "Switching on alternate audio, use video.buffered to schedule main fragment loading"
          ),
          (this.mediaBuffer = e));
      }
      (this.altAudio = i ? 2 : 0), this.tick();
    }
    onBufferCreated(e, t) {
      const i = t.tracks;
      let s,
        r,
        n = !1;
      for (const e in i) {
        const t = i[e];
        if ("main" === t.id) {
          if (((r = e), (s = t), "video" === e)) {
            const t = i[e];
            t && (this.videoBuffer = t.buffer);
          }
        } else n = !0;
      }
      n && s
        ? (this.log(
            `Alternate track found, use ${r}.buffered to schedule main fragment loading`
          ),
          (this.mediaBuffer = s.buffer))
        : (this.mediaBuffer = this.media);
    }
    onFragBuffered(e, t) {
      const { frag: i, part: s } = t,
        r = i.type === Cm.MAIN;
      if (r) {
        if (this.fragContextChanged(i))
          return (
            this.warn(
              `Fragment ${i.sn}${s ? " p: " + s.index : ""} of level ${
                i.level
              } finished buffering, but was aborted. state: ${this.state}`
            ),
            void (this.state === ZT.PARSED && (this.state = ZT.IDLE))
          );
        const e = s ? s.stats : i.stats;
        (this.fragLastKbps = Math.round(
          (8 * e.total) / (e.buffering.end - e.loading.first)
        )),
          Jm(i) && (this.fragPrevious = i),
          this.fragBufferedComplete(i, s);
      }
      const n = this.media;
      n &&
        (!this._hasEnoughToStart &&
          K_.getBuffered(n).length &&
          ((this._hasEnoughToStart = !0), this.seekToStartPos()),
        r && this.tick());
    }
    get hasEnoughToStart() {
      return this._hasEnoughToStart;
    }
    onError(e, t) {
      var i;
      if (t.fatal) this.state = ZT.ERROR;
      else
        switch (t.details) {
          case ym.FRAG_GAP:
          case ym.FRAG_PARSING_ERROR:
          case ym.FRAG_DECRYPT_ERROR:
          case ym.FRAG_LOAD_ERROR:
          case ym.FRAG_LOAD_TIMEOUT:
          case ym.KEY_LOAD_ERROR:
          case ym.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(Cm.MAIN, t);
            break;
          case ym.LEVEL_LOAD_ERROR:
          case ym.LEVEL_LOAD_TIMEOUT:
          case ym.LEVEL_PARSING_ERROR:
            t.levelRetry ||
              this.state !== ZT.WAITING_LEVEL ||
              (null == (i = t.context) ? void 0 : i.type) !== Im.LEVEL ||
              (this.state = ZT.IDLE);
            break;
          case ym.BUFFER_ADD_CODEC_ERROR:
          case ym.BUFFER_APPEND_ERROR:
            if ("main" !== t.parent) return;
            this.resetLoadingState();
            break;
          case ym.BUFFER_FULL_ERROR:
            if ("main" !== t.parent) return;
            this.reduceLengthAndFlushBuffer(t) &&
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            break;
          case ym.INTERNAL_EXCEPTION:
            this.recoverWorkerError(t);
        }
    }
    onFragLoadEmergencyAborted() {
      (this.state = ZT.IDLE),
        this._hasEnoughToStart ||
          ((this.startFragRequested = !1),
          (this.nextLoadPosition = this.lastCurrentTime)),
        this.tickImmediate();
    }
    onBufferFlushed(e, { type: t }) {
      if (t !== Xm.AUDIO || !this.altAudio) {
        const e =
          (t === Xm.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        e && (this.afterBufferFlushed(e, t, Cm.MAIN), this.tick());
      }
    }
    onLevelsUpdated(e, t) {
      this.level > -1 &&
        this.fragCurrent &&
        ((this.level = this.fragCurrent.level),
        -1 === this.level && this.resetWhenMissingContext(this.fragCurrent)),
        (this.levels = t.levels);
    }
    swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
    seekToStartPos() {
      const { media: e } = this;
      if (!e) return;
      const t = e.currentTime;
      let i = this.startPosition;
      if (i >= 0 && t < i) {
        if (e.seeking)
          return void this.log(
            `could not seek to ${i}, already seeking at ${t}`
          );
        const s = this.timelineOffset;
        s && i && (i += s);
        const r = this.getLevelDetails(),
          n = K_.getBuffered(e),
          a = n.length ? n.start(0) : 0,
          o = a - i,
          c = Math.max(
            this.config.maxBufferHole,
            this.config.maxFragLookUpTolerance
          );
        o > 0 &&
          (o < c ||
            (this.loadingParts &&
              o < 2 * ((null == r ? void 0 : r.partTarget) || 0))) &&
          (this.log(`adjusting start position by ${o} to match buffer start`),
          (i += o),
          (this.startPosition = i)),
          t < i &&
            (this.log(
              `seek to target start position ${i} from current time ${t} buffer start ${a}`
            ),
            (e.currentTime = i));
      }
    }
    _getAudioCodec(e) {
      let t = this.config.defaultAudioCodec || e.audioCodec;
      return (
        this.audioCodecSwap &&
          t &&
          (this.log("Swapping audio codec"),
          (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5")),
        t
      );
    }
    _loadBitrateTestFrag(e, t) {
      (e.bitrateTest = !0),
        this._doFragLoad(e, t).then(e => {
          const { hls: i } = this,
            s = null == e ? void 0 : e.frag;
          if (!s || this.fragContextChanged(s)) return;
          (t.fragmentError = 0),
            (this.state = ZT.IDLE),
            (this.startFragRequested = !1),
            (this.bitrateTest = !1);
          const r = s.stats;
          (r.parsing.start = r.parsing.end = r.buffering.start = r.buffering.end = self.performance.now()),
            i.trigger(Am.FRAG_LOADED, e),
            (s.bitrateTest = !1);
        });
    }
    _handleTransmuxComplete(e) {
      var t;
      const i = this.playlistType,
        { hls: s } = this,
        { remuxResult: r, chunkMeta: n } = e,
        a = this.getCurrentContext(n);
      if (!a) return void this.resetWhenMissingContext(n);
      const { frag: o, part: c, level: d } = a,
        { video: l, text: h, id3: u, initSegment: p } = r,
        { details: f } = d,
        E = this.altAudio ? void 0 : r.audio;
      if (this.fragContextChanged(o)) this.fragmentTracker.removeFragment(o);
      else {
        if (((this.state = ZT.PARSING), p)) {
          if (null != p && p.tracks) {
            const e = o.initSegment || o;
            this._bufferInitSegment(d, p.tracks, e, n),
              s.trigger(Am.FRAG_PARSING_INIT_SEGMENT, {
                frag: e,
                id: i,
                tracks: p.tracks
              });
          }
          const e = p.initPTS,
            t = p.timescale;
          Tm(e) &&
            ((this.initPTS[o.cc] = { baseTime: e, timescale: t }),
            s.trigger(Am.INIT_PTS_FOUND, {
              frag: o,
              id: i,
              initPTS: e,
              timescale: t
            }));
        }
        if (l && f) {
          const e = f.fragments[o.sn - 1 - f.startSN],
            t = o.sn === f.startSN,
            i = !e || o.cc > e.cc;
          if (!1 !== r.independent) {
            const { startPTS: e, endPTS: s, startDTS: r, endDTS: a } = l;
            if (c)
              c.elementaryStreams[l.type] = {
                startPTS: e,
                endPTS: s,
                startDTS: r,
                endDTS: a
              };
            else if (
              (l.firstKeyFrame &&
                l.independent &&
                1 === n.id &&
                !i &&
                (this.couldBacktrack = !0),
              l.dropped && l.independent)
            ) {
              const r = this.getMainFwdBufferInfo(),
                n =
                  (r ? r.end : this.getLoadPosition()) +
                  this.config.maxBufferHole,
                c = l.firstKeyFramePTS ? l.firstKeyFramePTS : e;
              if (!t && n < c - this.config.maxBufferHole && !i)
                return void this.backtrack(o);
              i && (o.gap = !0),
                o.setElementaryStreamInfo(l.type, o.start, s, o.start, a, !0);
            } else t && e - (f.appliedTimelineOffset || 0) > 2 && (o.gap = !0);
            o.setElementaryStreamInfo(l.type, e, s, r, a),
              this.backtrackFragment && (this.backtrackFragment = o),
              this.bufferFragmentData(l, o, c, n, t || i);
          } else {
            if (!t && !i) return void this.backtrack(o);
            o.gap = !0;
          }
        }
        if (E) {
          const { startPTS: e, endPTS: t, startDTS: i, endDTS: s } = E;
          c &&
            (c.elementaryStreams[Xm.AUDIO] = {
              startPTS: e,
              endPTS: t,
              startDTS: i,
              endDTS: s
            }),
            o.setElementaryStreamInfo(Xm.AUDIO, e, t, i, s),
            this.bufferFragmentData(E, o, c, n);
        }
        if (f && null != u && null != (t = u.samples) && t.length) {
          const e = { id: i, frag: o, details: f, samples: u.samples };
          s.trigger(Am.FRAG_PARSING_METADATA, e);
        }
        if (f && h) {
          const e = { id: i, frag: o, details: f, samples: h.samples };
          s.trigger(Am.FRAG_PARSING_USERDATA, e);
        }
      }
    }
    _bufferInitSegment(e, t, i, s) {
      if (this.state !== ZT.PARSING) return;
      (this.audioOnly = !!t.audio && !t.video),
        this.altAudio && !this.audioOnly && delete t.audio;
      const { audio: r, video: n, audiovideo: a } = t;
      if (r) {
        let i = Bg(r.codec, e.audioCodec);
        "mp4a" === i && (i = "mp4a.40.5");
        const s = navigator.userAgent.toLowerCase();
        if (this.audioCodecSwitch) {
          i && (i = -1 !== i.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5");
          const e = r.metadata;
          e &&
            "channelCount" in e &&
            1 !== (e.channelCount || 1) &&
            -1 === s.indexOf("firefox") &&
            (i = "mp4a.40.5");
        }
        i &&
          -1 !== i.indexOf("mp4a.40.5") &&
          -1 !== s.indexOf("android") &&
          "audio/mpeg" !== r.container &&
          ((i = "mp4a.40.2"), this.log(`Android: force audio codec to ${i}`)),
          e.audioCodec &&
            e.audioCodec !== i &&
            this.log(
              `Swapping manifest audio codec "${e.audioCodec}" for "${i}"`
            ),
          (r.levelCodec = i),
          (r.id = Cm.MAIN),
          this.log(
            `Init audio buffer, container:${
              r.container
            }, codecs[selected/level/parsed]=[${i || ""}/${e.audioCodec ||
              ""}/${r.codec}]`
          ),
          delete t.audiovideo;
      }
      if (n) {
        (n.levelCodec = e.videoCodec), (n.id = Cm.MAIN);
        const i = n.codec;
        if (4 === (null == i ? void 0 : i.length))
          switch (i) {
            case "hvc1":
            case "hev1":
              n.codec = "hvc1.1.6.L120.90";
              break;
            case "av01":
              n.codec = "av01.0.04M.08";
              break;
            case "avc1":
              n.codec = "avc1.42e01e";
          }
        this.log(
          `Init video buffer, container:${
            n.container
          }, codecs[level/parsed]=[${e.videoCodec || ""}/${i}]${
            n.codec !== i ? " parsed-corrected=" + n.codec : ""
          }${n.supplemental ? " supplemental=" + n.supplemental : ""}`
        ),
          delete t.audiovideo;
      }
      a &&
        (this.log(
          `Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.codecs}/${a.codec}]`
        ),
        delete t.video,
        delete t.audio);
      const o = Object.keys(t);
      if (o.length) {
        if ((this.hls.trigger(Am.BUFFER_CODECS, t), !this.hls)) return;
        o.forEach(e => {
          const r = t[e].initSegment;
          null != r &&
            r.byteLength &&
            this.hls.trigger(Am.BUFFER_APPENDING, {
              type: e,
              data: r,
              frag: i,
              part: null,
              chunkMeta: s,
              parent: i.type
            });
        });
      }
      this.tickImmediate();
    }
    getMainFwdBufferInfo() {
      const e =
        this.mediaBuffer && 2 === this.altAudio ? this.mediaBuffer : this.media;
      return this.getFwdBufferInfo(e, Cm.MAIN);
    }
    get maxBufferLength() {
      const { levels: e, level: t } = this,
        i = null == e ? void 0 : e[t];
      return i
        ? this.getMaxBufferLength(i.maxBitrate)
        : this.config.maxBufferLength;
    }
    backtrack(e) {
      (this.couldBacktrack = !0),
        (this.backtrackFragment = e),
        this.resetTransmuxer(),
        this.flushBufferGap(e),
        this.fragmentTracker.removeFragment(e),
        (this.fragPrevious = null),
        (this.nextLoadPosition = e.start),
        (this.state = ZT.IDLE);
    }
    checkFragmentChanged() {
      const e = this.media;
      let t = null;
      if (e && e.readyState > 1 && !1 === e.seeking) {
        const i = e.currentTime;
        if (
          (K_.isBuffered(e, i)
            ? (t = this.getAppendedFrag(i))
            : K_.isBuffered(e, i + 0.1) && (t = this.getAppendedFrag(i + 0.1)),
          t)
        ) {
          this.backtrackFragment = null;
          const e = this.fragPlaying,
            i = t.level;
          (e && t.sn === e.sn && e.level === i) ||
            ((this.fragPlaying = t),
            this.hls.trigger(Am.FRAG_CHANGED, { frag: t }),
            (e && e.level === i) ||
              this.hls.trigger(Am.LEVEL_SWITCHED, { level: i }));
        }
      }
    }
    get nextLevel() {
      const e = this.nextBufferedFrag;
      return e ? e.level : -1;
    }
    get currentFrag() {
      var e;
      if (this.fragPlaying) return this.fragPlaying;
      const t =
        (null == (e = this.media) ? void 0 : e.currentTime) ||
        this.lastCurrentTime;
      return Tm(t) ? this.getAppendedFrag(t) : null;
    }
    get currentProgramDateTime() {
      var e;
      const t =
        (null == (e = this.media) ? void 0 : e.currentTime) ||
        this.lastCurrentTime;
      if (Tm(t)) {
        const e = this.getLevelDetails(),
          i = this.currentFrag || (e ? u_(null, e.fragments, t) : null);
        if (i) {
          const e = i.programDateTime;
          if (null !== e) {
            const s = e + 1e3 * (t - i.start);
            return new Date(s);
          }
        }
      }
      return null;
    }
    get currentLevel() {
      const e = this.currentFrag;
      return e ? e.level : -1;
    }
    get nextBufferedFrag() {
      const e = this.currentFrag;
      return e ? this.followingBufferedFrag(e) : null;
    }
    get forceStartLoad() {
      return this._forceStartLoad;
    }
  }
  class gA {
    constructor(e) {
      (this.config = void 0),
        (this.keyUriToKeyInfo = {}),
        (this.emeController = null),
        (this.config = e);
    }
    abort(e) {
      for (const i in this.keyUriToKeyInfo) {
        const s = this.keyUriToKeyInfo[i].loader;
        if (s) {
          var t;
          if (e && e !== (null == (t = s.context) ? void 0 : t.frag.type))
            return;
          s.abort();
        }
      }
    }
    detach() {
      for (const e in this.keyUriToKeyInfo) {
        const t = this.keyUriToKeyInfo[e];
        (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) &&
          delete this.keyUriToKeyInfo[e];
      }
    }
    destroy() {
      this.detach();
      for (const e in this.keyUriToKeyInfo) {
        const t = this.keyUriToKeyInfo[e].loader;
        t && t.destroy();
      }
      this.keyUriToKeyInfo = {};
    }
    createKeyLoadError(e, t = ym.KEY_LOAD_ERROR, i, s, r) {
      return new V_({
        type: Rm.NETWORK_ERROR,
        details: t,
        fatal: !1,
        frag: e,
        response: r,
        error: i,
        networkDetails: s
      });
    }
    loadClear(e, t) {
      if (this.emeController && this.config.emeEnabled) {
        const { sn: i, cc: s } = e;
        for (let e = 0; e < t.length; e++) {
          const r = t[e];
          if (
            s <= r.cc &&
            ("initSegment" === i || "initSegment" === r.sn || i < r.sn)
          ) {
            this.emeController.selectKeySystemFormat(r).then(e => {
              r.setKeyFormat(e);
            });
            break;
          }
        }
      }
    }
    load(e) {
      return !e.decryptdata &&
        e.encrypted &&
        this.emeController &&
        this.config.emeEnabled
        ? this.emeController
            .selectKeySystemFormat(e)
            .then(t => this.loadInternal(e, t))
        : this.loadInternal(e);
    }
    loadInternal(e, t) {
      var i, s;
      t && e.setKeyFormat(t);
      const r = e.decryptdata;
      if (!r) {
        const i = new Error(
          t
            ? `Expected frag.decryptdata to be defined after setting format ${t}`
            : "Missing decryption data on fragment in onKeyLoading"
        );
        return Promise.reject(this.createKeyLoadError(e, ym.KEY_LOAD_ERROR, i));
      }
      const n = r.uri;
      if (!n)
        return Promise.reject(
          this.createKeyLoadError(
            e,
            ym.KEY_LOAD_ERROR,
            new Error(`Invalid key URI: "${n}"`)
          )
        );
      let a = this.keyUriToKeyInfo[n];
      if (null != (i = a) && i.decryptdata.key)
        return (
          (r.key = a.decryptdata.key), Promise.resolve({ frag: e, keyInfo: a })
        );
      var o;
      if (null != (s = a) && s.keyLoadPromise)
        switch (null == (o = a.mediaKeySessionContext) ? void 0 : o.keyStatus) {
          case void 0:
          case "status-pending":
          case "usable":
          case "usable-in-future":
            return a.keyLoadPromise.then(
              t => (
                (r.key = t.keyInfo.decryptdata.key), { frag: e, keyInfo: a }
              )
            );
        }
      switch (
        ((a = this.keyUriToKeyInfo[n] = {
          decryptdata: r,
          keyLoadPromise: null,
          loader: null,
          mediaKeySessionContext: null
        }),
        r.method)
      ) {
        case "ISO-23001-7":
        case "SAMPLE-AES":
        case "SAMPLE-AES-CENC":
        case "SAMPLE-AES-CTR":
          return "identity" === r.keyFormat
            ? this.loadKeyHTTP(a, e)
            : this.loadKeyEME(a, e);
        case "AES-128":
        case "AES-256":
        case "AES-256-CTR":
          return this.loadKeyHTTP(a, e);
        default:
          return Promise.reject(
            this.createKeyLoadError(
              e,
              ym.KEY_LOAD_ERROR,
              new Error(`Key supplied with unsupported METHOD: "${r.method}"`)
            )
          );
      }
    }
    loadKeyEME(e, t) {
      const i = { frag: t, keyInfo: e };
      if (this.emeController && this.config.emeEnabled) {
        const t = this.emeController.loadKey(i);
        if (t)
          return (e.keyLoadPromise = t.then(
            t => ((e.mediaKeySessionContext = t), i)
          )).catch(t => {
            throw ((e.keyLoadPromise = null), t);
          });
      }
      return Promise.resolve(i);
    }
    loadKeyHTTP(e, t) {
      const i = this.config,
        s = new (0, i.loader)(i);
      return (
        (t.keyLoader = e.loader = s),
        (e.keyLoadPromise = new Promise((r, n) => {
          const a = {
              keyInfo: e,
              frag: t,
              responseType: "arraybuffer",
              url: e.decryptdata.uri
            },
            o = i.keyLoadPolicy.default,
            c = {
              loadPolicy: o,
              timeout: o.maxLoadTimeMs,
              maxRetry: 0,
              retryDelay: 0,
              maxRetryDelay: 0
            },
            d = {
              onSuccess: (e, t, i, s) => {
                const { frag: a, keyInfo: o, url: c } = i;
                if (!a.decryptdata || o !== this.keyUriToKeyInfo[c])
                  return n(
                    this.createKeyLoadError(
                      a,
                      ym.KEY_LOAD_ERROR,
                      new Error("after key load, decryptdata unset or changed"),
                      s
                    )
                  );
                (o.decryptdata.key = a.decryptdata.key = new Uint8Array(
                  e.data
                )),
                  (a.keyLoader = null),
                  (o.loader = null),
                  r({ frag: a, keyInfo: o });
              },
              onError: (e, i, s, r) => {
                this.resetLoader(i),
                  n(
                    this.createKeyLoadError(
                      t,
                      ym.KEY_LOAD_ERROR,
                      new Error(`HTTP Error ${e.code} loading key ${e.text}`),
                      s,
                      Nm({ url: a.url, data: void 0 }, e)
                    )
                  );
              },
              onTimeout: (e, i, s) => {
                this.resetLoader(i),
                  n(
                    this.createKeyLoadError(
                      t,
                      ym.KEY_LOAD_TIMEOUT,
                      new Error("key loading timed out"),
                      s
                    )
                  );
              },
              onAbort: (e, i, s) => {
                this.resetLoader(i),
                  n(
                    this.createKeyLoadError(
                      t,
                      ym.INTERNAL_ABORTED,
                      new Error("key loading aborted"),
                      s
                    )
                  );
              }
            };
          s.load(a, c, d);
        }))
      );
    }
    resetLoader(e) {
      const { frag: t, keyInfo: i, url: s } = e,
        r = i.loader;
      t.keyLoader === r && ((t.keyLoader = null), (i.loader = null)),
        delete this.keyUriToKeyInfo[s],
        r && r.destroy();
    }
  }
  function _A(e) {
    const { type: t } = e;
    switch (t) {
      case Im.AUDIO_TRACK:
        return Cm.AUDIO;
      case Im.SUBTITLE_TRACK:
        return Cm.SUBTITLE;
      default:
        return Cm.MAIN;
    }
  }
  function TA(e, t) {
    let i = e.url;
    return (void 0 !== i && 0 !== i.indexOf("data:")) || (i = t.url), i;
  }
  class SA {
    constructor(e) {
      (this.hls = void 0),
        (this.loaders = Object.create(null)),
        (this.variableList = null),
        (this.onManifestLoaded = this.checkAutostartLoad),
        (this.hls = e),
        this.registerListeners();
    }
    startLoad(e) {}
    stopLoad() {
      this.destroyInternalLoaders();
    }
    registerListeners() {
      const { hls: e } = this;
      e.on(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Am.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(Am.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
        e.on(Am.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this),
        e.on(Am.LEVELS_UPDATED, this.onLevelsUpdated, this);
    }
    unregisterListeners() {
      const { hls: e } = this;
      e.off(Am.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Am.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(Am.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
        e.off(Am.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this),
        e.off(Am.LEVELS_UPDATED, this.onLevelsUpdated, this);
    }
    createInternalLoader(e) {
      const t = this.hls.config,
        i = t.pLoader,
        s = t.loader,
        r = new (i || s)(t);
      return (this.loaders[e.type] = r), r;
    }
    getInternalLoader(e) {
      return this.loaders[e.type];
    }
    resetInternalLoader(e) {
      this.loaders[e] && delete this.loaders[e];
    }
    destroyInternalLoaders() {
      for (const e in this.loaders) {
        const t = this.loaders[e];
        t && t.destroy(), this.resetInternalLoader(e);
      }
    }
    destroy() {
      (this.variableList = null),
        this.unregisterListeners(),
        this.destroyInternalLoaders();
    }
    onManifestLoading(e, t) {
      const { url: i } = t;
      (this.variableList = null),
        this.load({
          id: null,
          level: 0,
          responseType: "text",
          type: Im.MANIFEST,
          url: i,
          deliveryDirectives: null,
          levelOrTrack: null
        });
    }
    onLevelLoading(e, t) {
      const {
        id: i,
        level: s,
        pathwayId: r,
        url: n,
        deliveryDirectives: a,
        levelInfo: o
      } = t;
      this.load({
        id: i,
        level: s,
        pathwayId: r,
        responseType: "text",
        type: Im.LEVEL,
        url: n,
        deliveryDirectives: a,
        levelOrTrack: o
      });
    }
    onAudioTrackLoading(e, t) {
      const { id: i, groupId: s, url: r, deliveryDirectives: n, track: a } = t;
      this.load({
        id: i,
        groupId: s,
        level: null,
        responseType: "text",
        type: Im.AUDIO_TRACK,
        url: r,
        deliveryDirectives: n,
        levelOrTrack: a
      });
    }
    onSubtitleTrackLoading(e, t) {
      const { id: i, groupId: s, url: r, deliveryDirectives: n, track: a } = t;
      this.load({
        id: i,
        groupId: s,
        level: null,
        responseType: "text",
        type: Im.SUBTITLE_TRACK,
        url: r,
        deliveryDirectives: n,
        levelOrTrack: a
      });
    }
    onLevelsUpdated(e, t) {
      const i = this.loaders[Im.LEVEL];
      if (i) {
        const e = i.context;
        e &&
          !t.levels.some(t => t === e.levelOrTrack) &&
          (i.abort(), delete this.loaders[Im.LEVEL]);
      }
    }
    load(e) {
      var t;
      const i = this.hls.config;
      let s,
        r = this.getInternalLoader(e);
      if (r) {
        const t = this.hls.logger,
          i = r.context;
        if (
          i &&
          i.levelOrTrack === e.levelOrTrack &&
          (i.url === e.url || (i.deliveryDirectives && !e.deliveryDirectives))
        )
          return void (i.url === e.url
            ? t.log(`[playlist-loader]: ignore ${e.url} ongoing request`)
            : t.log(`[playlist-loader]: ignore ${e.url} in favor of ${i.url}`));
        t.log(
          `[playlist-loader]: aborting previous loader for type: ${e.type}`
        ),
          r.abort();
      }
      if (
        ((s =
          e.type === Im.MANIFEST
            ? i.manifestLoadPolicy.default
            : wm({}, i.playlistLoadPolicy.default, {
                timeoutRetry: null,
                errorRetry: null
              })),
        (r = this.createInternalLoader(e)),
        Tm(null == (t = e.deliveryDirectives) ? void 0 : t.part))
      ) {
        let t;
        if (
          (e.type === Im.LEVEL && null !== e.level
            ? (t = this.hls.levels[e.level].details)
            : e.type === Im.AUDIO_TRACK && null !== e.id
            ? (t = this.hls.audioTracks[e.id].details)
            : e.type === Im.SUBTITLE_TRACK &&
              null !== e.id &&
              (t = this.hls.subtitleTracks[e.id].details),
          t)
        ) {
          const e = t.partTarget,
            i = t.targetduration;
          if (e && i) {
            const t = 1e3 * Math.max(3 * e, 0.8 * i);
            s = wm({}, s, {
              maxTimeToFirstByteMs: Math.min(t, s.maxTimeToFirstByteMs),
              maxLoadTimeMs: Math.min(t, s.maxTimeToFirstByteMs)
            });
          }
        }
      }
      const n = s.errorRetry || s.timeoutRetry || {},
        a = {
          loadPolicy: s,
          timeout: s.maxLoadTimeMs,
          maxRetry: n.maxNumRetry || 0,
          retryDelay: n.retryDelayMs || 0,
          maxRetryDelay: n.maxRetryDelayMs || 0
        },
        o = {
          onSuccess: (e, t, i, s) => {
            const r = this.getInternalLoader(i);
            this.resetInternalLoader(i.type);
            const n = e.data;
            0 === n.indexOf("#EXTM3U")
              ? ((t.parsing.start = performance.now()),
                IT.isMediaPlaylist(n) || i.type !== Im.MANIFEST
                  ? this.handleTrackOrLevelPlaylist(e, t, i, s || null, r)
                  : this.handleMasterPlaylist(e, t, i, s))
              : this.handleManifestParsingError(
                  e,
                  i,
                  new Error("no EXTM3U delimiter"),
                  s || null,
                  t
                );
          },
          onError: (e, t, i, s) => {
            this.handleNetworkError(t, i, !1, e, s);
          },
          onTimeout: (e, t, i) => {
            this.handleNetworkError(t, i, !0, void 0, e);
          }
        };
      r.load(e, a, o);
    }
    checkAutostartLoad() {
      if (!this.hls) return;
      const {
        config: { autoStartLoad: e, startPosition: t },
        forceStartLoad: i
      } = this.hls;
      (e || i) &&
        (this.hls.logger.log(
          `${e ? "auto" : "force"} startLoad with configured startPosition ${t}`
        ),
        this.hls.startLoad(t));
    }
    handleMasterPlaylist(e, t, i, s) {
      const r = this.hls,
        n = e.data,
        a = TA(e, i),
        o = IT.parseMasterPlaylist(n, a);
      if (o.playlistParsingError)
        return void this.handleManifestParsingError(
          e,
          i,
          o.playlistParsingError,
          s,
          t
        );
      const {
        contentSteering: c,
        levels: d,
        sessionData: l,
        sessionKeys: h,
        startTimeOffset: u,
        variableList: p
      } = o;
      this.variableList = p;
      const {
        AUDIO: f = [],
        SUBTITLES: E,
        "CLOSED-CAPTIONS": m
      } = IT.parseMasterPlaylistMedia(n, a, o);
      if (f.length) {
        f.some(e => !e.url) ||
          !d[0].audioCodec ||
          d[0].attrs.AUDIO ||
          (this.hls.logger.log(
            "[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"
          ),
          f.unshift({
            type: "main",
            name: "main",
            groupId: "main",
            default: !1,
            autoselect: !1,
            forced: !1,
            id: -1,
            attrs: new Q_({}),
            bitrate: 0,
            url: ""
          }));
      }
      r.trigger(Am.MANIFEST_LOADED, {
        levels: d,
        audioTracks: f,
        subtitles: E,
        captions: m,
        contentSteering: c,
        url: a,
        stats: t,
        networkDetails: s,
        sessionData: l,
        sessionKeys: h,
        startTimeOffset: u,
        variableList: p
      });
    }
    handleTrackOrLevelPlaylist(e, t, i, s, r) {
      const n = this.hls,
        { id: a, level: o, type: c } = i,
        d = TA(e, i),
        l = Tm(o) ? o : Tm(a) ? a : 0,
        h = _A(i),
        u = IT.parseLevelPlaylist(e.data, d, l, h, 0, this.variableList);
      if (c === Im.MANIFEST) {
        const e = {
          attrs: new Q_({}),
          bitrate: 0,
          details: u,
          name: "",
          url: d
        };
        (u.requestScheduled = t.loading.start + HT(u, 0)),
          n.trigger(Am.MANIFEST_LOADED, {
            levels: [e],
            audioTracks: [],
            url: d,
            stats: t,
            networkDetails: s,
            sessionData: null,
            sessionKeys: null,
            contentSteering: null,
            startTimeOffset: null,
            variableList: null
          });
      }
      (t.parsing.end = performance.now()),
        (i.levelDetails = u),
        this.handlePlaylistLoaded(u, e, t, i, s, r);
    }
    handleManifestParsingError(e, t, i, s, r) {
      this.hls.trigger(Am.ERROR, {
        type: Rm.NETWORK_ERROR,
        details: ym.MANIFEST_PARSING_ERROR,
        fatal: t.type === Im.MANIFEST,
        url: e.url,
        err: i,
        error: i,
        reason: i.message,
        response: e,
        context: t,
        networkDetails: s,
        stats: r
      });
    }
    handleNetworkError(e, t, i = !1, s, r) {
      let n = `A network ${
        i ? "timeout" : "error" + (s ? " (status " + s.code + ")" : "")
      } occurred while loading ${e.type}`;
      e.type === Im.LEVEL
        ? (n += `: ${e.level} id: ${e.id}`)
        : (e.type !== Im.AUDIO_TRACK && e.type !== Im.SUBTITLE_TRACK) ||
          (n += ` id: ${e.id} group-id: "${e.groupId}"`);
      const a = new Error(n);
      this.hls.logger.warn(`[playlist-loader]: ${n}`);
      let o = ym.UNKNOWN,
        c = !1;
      const d = this.getInternalLoader(e);
      switch (e.type) {
        case Im.MANIFEST:
          (o = i ? ym.MANIFEST_LOAD_TIMEOUT : ym.MANIFEST_LOAD_ERROR), (c = !0);
          break;
        case Im.LEVEL:
          (o = i ? ym.LEVEL_LOAD_TIMEOUT : ym.LEVEL_LOAD_ERROR), (c = !1);
          break;
        case Im.AUDIO_TRACK:
          (o = i ? ym.AUDIO_TRACK_LOAD_TIMEOUT : ym.AUDIO_TRACK_LOAD_ERROR),
            (c = !1);
          break;
        case Im.SUBTITLE_TRACK:
          (o = i ? ym.SUBTITLE_TRACK_LOAD_TIMEOUT : ym.SUBTITLE_LOAD_ERROR),
            (c = !1);
      }
      d && this.resetInternalLoader(e.type);
      const l = {
        type: Rm.NETWORK_ERROR,
        details: o,
        fatal: c,
        url: e.url,
        loader: d,
        context: e,
        error: a,
        networkDetails: t,
        stats: r
      };
      if (s) {
        const i = (null == t ? void 0 : t.url) || e.url;
        l.response = Nm({ url: i, data: void 0 }, s);
      }
      this.hls.trigger(Am.ERROR, l);
    }
    handlePlaylistLoaded(e, t, i, s, r, n) {
      const a = this.hls,
        { type: o, level: c, id: d, groupId: l, deliveryDirectives: h } = s,
        u = TA(t, s),
        p = _A(s),
        f = "number" == typeof s.level && p === Cm.MAIN ? c : void 0;
      if (!e.fragments.length) {
        const n = (e.playlistParsingError = new Error(
          "No Segments found in Playlist"
        ));
        return void a.trigger(Am.ERROR, {
          type: Rm.NETWORK_ERROR,
          details: ym.LEVEL_EMPTY_ERROR,
          fatal: !1,
          url: u,
          error: n,
          reason: n.message,
          response: t,
          context: s,
          level: f,
          parent: p,
          networkDetails: r,
          stats: i
        });
      }
      e.targetduration ||
        (e.playlistParsingError = new Error("Missing Target Duration"));
      const E = e.playlistParsingError;
      if (E) {
        if ((this.hls.logger.warn(E), !a.config.ignorePlaylistParsingErrors))
          return void a.trigger(Am.ERROR, {
            type: Rm.NETWORK_ERROR,
            details: ym.LEVEL_PARSING_ERROR,
            fatal: !1,
            url: u,
            error: E,
            reason: E.message,
            response: t,
            context: s,
            level: f,
            parent: p,
            networkDetails: r,
            stats: i
          });
        e.playlistParsingError = null;
      }
      switch (
        (e.live &&
          n &&
          (n.getCacheAge && (e.ageHeader = n.getCacheAge() || 0),
          (n.getCacheAge && !isNaN(e.ageHeader)) || (e.ageHeader = 0)),
        o)
      ) {
        case Im.MANIFEST:
        case Im.LEVEL:
          a.trigger(Am.LEVEL_LOADED, {
            details: e,
            levelInfo: s.levelOrTrack || a.levels[0],
            level: f || 0,
            id: d || 0,
            stats: i,
            networkDetails: r,
            deliveryDirectives: h,
            withoutMultiVariant: o === Im.MANIFEST
          });
          break;
        case Im.AUDIO_TRACK:
          a.trigger(Am.AUDIO_TRACK_LOADED, {
            details: e,
            track: s.levelOrTrack,
            id: d || 0,
            groupId: l || "",
            stats: i,
            networkDetails: r,
            deliveryDirectives: h
          });
          break;
        case Im.SUBTITLE_TRACK:
          a.trigger(Am.SUBTITLE_TRACK_LOADED, {
            details: e,
            track: s.levelOrTrack,
            id: d || 0,
            groupId: l || "",
            stats: i,
            networkDetails: r,
            deliveryDirectives: h
          });
      }
    }
  }
  class vA {
    static get version() {
      return oS;
    }
    static isMSESupported() {
      return EA();
    }
    static isSupported() {
      return (function() {
        if (!EA()) return !1;
        const e = Vm();
        return (
          "function" == typeof (null == e ? void 0 : e.isTypeSupported) &&
          (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(t =>
            e.isTypeSupported(Pg(t, "video"))
          ) ||
            ["mp4a.40.2", "fLaC"].some(t => e.isTypeSupported(Pg(t, "audio"))))
        );
      })();
    }
    static getMediaSource() {
      return Vm();
    }
    static get Events() {
      return Am;
    }
    static get MetadataSchema() {
      return PS;
    }
    static get ErrorTypes() {
      return Rm;
    }
    static get ErrorDetails() {
      return ym;
    }
    static get DefaultConfig() {
      return vA.defaultConfig ? vA.defaultConfig : tA;
    }
    static set DefaultConfig(e) {
      vA.defaultConfig = e;
    }
    constructor(e = {}) {
      (this.config = void 0),
        (this.userConfig = void 0),
        (this.logger = void 0),
        (this.coreComponents = void 0),
        (this.networkControllers = void 0),
        (this._emitter = new aS()),
        (this._autoLevelCapping = -1),
        (this._maxHdcpLevel = null),
        (this.abrController = void 0),
        (this.bufferController = void 0),
        (this.capLevelController = void 0),
        (this.latencyController = void 0),
        (this.levelController = void 0),
        (this.streamController = void 0),
        (this.audioStreamController = void 0),
        (this.subtititleStreamController = void 0),
        (this.audioTrackController = void 0),
        (this.subtitleTrackController = void 0),
        (this.interstitialsController = void 0),
        (this.gapController = void 0),
        (this.emeController = void 0),
        (this.cmcdController = void 0),
        (this._media = null),
        (this._url = null),
        (this._sessionId = void 0),
        (this.triggeringException = void 0),
        (this.started = !1);
      const t = (this.logger = (function(e, t, i) {
          const s = Um();
          if (
            ("object" == typeof console && !0 === e) ||
            "object" == typeof e
          ) {
            const r = ["debug", "log", "info", "warn", "error"];
            r.forEach(t => {
              s[t] = xm(t, e, i);
            });
            try {
              s.log(`Debug logs enabled for "${t}" in hls.js version 1.6.0`);
            } catch (e) {
              return Um();
            }
            r.forEach(t => {
              Fm[t] = xm(t, e);
            });
          } else wm(Fm, s);
          return s;
        })(e.debug || !1, "Hls instance", e.assetPlayerId)),
        i = (this.config = (function(e, t, i) {
          if (
            (t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) &&
            (t.liveSyncDuration || t.liveMaxLatencyDuration)
          )
            throw new Error(
              "Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"
            );
          if (
            void 0 !== t.liveMaxLatencyDurationCount &&
            (void 0 === t.liveSyncDurationCount ||
              t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)
          )
            throw new Error(
              'Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'
            );
          if (
            void 0 !== t.liveMaxLatencyDuration &&
            (void 0 === t.liveSyncDuration ||
              t.liveMaxLatencyDuration <= t.liveSyncDuration)
          )
            throw new Error(
              'Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'
            );
          const s = iA(e),
            r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
          return (
            ["manifest", "level", "frag"].forEach(e => {
              const n = `${"level" === e ? "playlist" : e}LoadPolicy`,
                a = void 0 === t[n],
                o = [];
              r.forEach(i => {
                const r = `${e}Loading${i}`,
                  c = t[r];
                if (void 0 !== c && a) {
                  o.push(r);
                  const e = s[n].default;
                  switch (((t[n] = { default: e }), i)) {
                    case "TimeOut":
                      (e.maxLoadTimeMs = c), (e.maxTimeToFirstByteMs = c);
                      break;
                    case "MaxRetry":
                      (e.errorRetry.maxNumRetry = c),
                        (e.timeoutRetry.maxNumRetry = c);
                      break;
                    case "RetryDelay":
                      (e.errorRetry.retryDelayMs = c),
                        (e.timeoutRetry.retryDelayMs = c);
                      break;
                    case "MaxRetryTimeout":
                      (e.errorRetry.maxRetryDelayMs = c),
                        (e.timeoutRetry.maxRetryDelayMs = c);
                  }
                }
              }),
                o.length &&
                  i.warn(
                    `hls.js config: "${o.join(
                      '", "'
                    )}" setting(s) are deprecated, use "${n}": ${i_(t[n])}`
                  );
            }),
            Nm(Nm({}, s), t)
          );
        })(vA.DefaultConfig, e, t));
      (this.userConfig = e), i.progressive && sA(i, t);
      const {
          abrController: s,
          bufferController: r,
          capLevelController: n,
          errorController: a,
          fpsController: o
        } = i,
        c = new a(this),
        d = (this.abrController = new s(this)),
        l = new O_(this),
        h = i.interstitialsController,
        u = h ? (this.interstitialsController = new h(this, vA)) : null,
        p = (this.bufferController = new r(this, l)),
        f = (this.capLevelController = new n(this)),
        E = new o(this),
        m = new SA(this),
        g = i.contentSteeringController,
        _ = g ? new g(this) : null,
        T = (this.levelController = new uA(this, _)),
        S = new lA(this),
        v = new gA(this.config),
        R = (this.streamController = new mA(this, l, v)),
        y = (this.gapController = new rA(this, l));
      f.setStreamController(R), E.setStreamController(R);
      const A = [m, T, R];
      u && A.splice(1, 0, u),
        _ && A.splice(1, 0, _),
        (this.networkControllers = A);
      const I = [d, p, y, f, E, S, l];
      this.audioTrackController = this.createController(
        i.audioTrackController,
        A
      );
      const C = i.audioStreamController;
      C && A.push((this.audioStreamController = new C(this, l, v))),
        (this.subtitleTrackController = this.createController(
          i.subtitleTrackController,
          A
        ));
      const b = i.subtitleStreamController;
      b && A.push((this.subtititleStreamController = new b(this, l, v))),
        this.createController(i.timelineController, I),
        (v.emeController = this.emeController = this.createController(
          i.emeController,
          I
        )),
        (this.cmcdController = this.createController(i.cmcdController, I)),
        (this.latencyController = this.createController(hA, I)),
        (this.coreComponents = I),
        A.push(c);
      const O = c.onErrorOut;
      "function" == typeof O && this.on(Am.ERROR, O, c),
        this.on(Am.MANIFEST_LOADED, m.onManifestLoaded, m);
    }
    createController(e, t) {
      if (e) {
        const i = new e(this);
        return t && t.push(i), i;
      }
      return null;
    }
    on(e, t, i = this) {
      this._emitter.on(e, t, i);
    }
    once(e, t, i = this) {
      this._emitter.once(e, t, i);
    }
    removeAllListeners(e) {
      this._emitter.removeAllListeners(e);
    }
    off(e, t, i = this, s) {
      this._emitter.off(e, t, i, s);
    }
    listeners(e) {
      return this._emitter.listeners(e);
    }
    emit(e, t, i) {
      return this._emitter.emit(e, t, i);
    }
    trigger(e, t) {
      if (this.config.debug) return this.emit(e, e, t);
      try {
        return this.emit(e, e, t);
      } catch (t) {
        if (
          (this.logger.error(
            "An internal error happened while handling event " +
              e +
              '. Error message: "' +
              t.message +
              '". Here is a stacktrace:',
            t
          ),
          !this.triggeringException)
        ) {
          this.triggeringException = !0;
          const i = e === Am.ERROR;
          this.trigger(Am.ERROR, {
            type: Rm.OTHER_ERROR,
            details: ym.INTERNAL_EXCEPTION,
            fatal: i,
            event: e,
            error: t
          }),
            (this.triggeringException = !1);
        }
      }
      return !1;
    }
    listenerCount(e) {
      return this._emitter.listenerCount(e);
    }
    destroy() {
      this.logger.log("destroy"),
        this.trigger(Am.DESTROYING, void 0),
        this.detachMedia(),
        this.removeAllListeners(),
        (this._autoLevelCapping = -1),
        (this._url = null),
        this.networkControllers.forEach(e => e.destroy()),
        (this.networkControllers.length = 0),
        this.coreComponents.forEach(e => e.destroy()),
        (this.coreComponents.length = 0);
      const e = this.config;
      (e.xhrSetup = e.fetchSetup = void 0), (this.userConfig = null);
    }
    attachMedia(e) {
      if (!e || ("media" in e && !e.media)) {
        const t = new Error(`attachMedia failed: invalid argument (${e})`);
        return void this.trigger(Am.ERROR, {
          type: Rm.OTHER_ERROR,
          details: ym.ATTACH_MEDIA_ERROR,
          fatal: !0,
          error: t
        });
      }
      this.logger.log("attachMedia"),
        this._media &&
          (this.logger.warn("media must be detached before attaching"),
          this.detachMedia());
      const t = "media" in e,
        i = t ? e.media : e,
        s = t ? e : { media: i };
      (this._media = i), this.trigger(Am.MEDIA_ATTACHING, s);
    }
    detachMedia() {
      this.logger.log("detachMedia"),
        this.trigger(Am.MEDIA_DETACHING, {}),
        (this._media = null);
    }
    transferMedia() {
      this._media = null;
      const e = this.bufferController.transferMedia();
      return this.trigger(Am.MEDIA_DETACHING, { transferMedia: e }), e;
    }
    loadSource(e) {
      this.stopLoad();
      const t = this.media,
        i = this._url,
        s = (this._url = $m.buildAbsoluteURL(self.location.href, e, {
          alwaysNormalize: !0
        }));
      (this._autoLevelCapping = -1),
        (this._maxHdcpLevel = null),
        this.logger.log(`loadSource:${s}`),
        t &&
          i &&
          (i !== s || this.bufferController.hasSourceTypes()) &&
          (this.detachMedia(), this.attachMedia(t)),
        this.trigger(Am.MANIFEST_LOADING, { url: e });
    }
    get url() {
      return this._url;
    }
    get hasEnoughToStart() {
      return this.streamController.hasEnoughToStart;
    }
    get startPosition() {
      return this.streamController.startPositionValue;
    }
    startLoad(e = -1, t) {
      this.logger.log(`startLoad(${e + (t ? ", <skip seek to start>" : "")})`),
        (this.started = !0),
        this.resumeBuffering();
      for (
        let i = 0;
        i < this.networkControllers.length &&
        (this.networkControllers[i].startLoad(e, t),
        this.started && this.networkControllers);
        i++
      );
    }
    stopLoad() {
      this.logger.log("stopLoad"), (this.started = !1);
      for (
        let e = 0;
        e < this.networkControllers.length &&
        (this.networkControllers[e].stopLoad(),
        !this.started && this.networkControllers);
        e++
      );
    }
    get loadingEnabled() {
      return this.started;
    }
    get bufferingEnabled() {
      return this.streamController.bufferingEnabled;
    }
    resumeBuffering() {
      this.bufferingEnabled ||
        (this.logger.log("resume buffering"),
        this.networkControllers.forEach(e => {
          e.resumeBuffering && e.resumeBuffering();
        }));
    }
    pauseBuffering() {
      this.bufferingEnabled &&
        (this.logger.log("pause buffering"),
        this.networkControllers.forEach(e => {
          e.pauseBuffering && e.pauseBuffering();
        }));
    }
    get inFlightFragments() {
      const e = { [Cm.MAIN]: this.streamController.inFlightFrag };
      return (
        this.audioStreamController &&
          (e[Cm.AUDIO] = this.audioStreamController.inFlightFrag),
        this.subtititleStreamController &&
          (e[Cm.SUBTITLE] = this.subtititleStreamController.inFlightFrag),
        e
      );
    }
    swapAudioCodec() {
      this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
    }
    recoverMediaError() {
      this.logger.log("recoverMediaError");
      const e = this._media,
        t = null == e ? void 0 : e.currentTime;
      this.detachMedia(), e && (this.attachMedia(e), t && this.startLoad(t));
    }
    removeLevel(e) {
      this.levelController.removeLevel(e);
    }
    get sessionId() {
      let e = this._sessionId;
      return (
        e ||
          (e = this._sessionId = (function() {
            try {
              return crypto.randomUUID();
            } catch (e) {
              try {
                const e = URL.createObjectURL(new Blob()),
                  t = e.toString();
                return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1);
              } catch (e) {
                let t = new Date().getTime();
                const i = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
                  /[xy]/g,
                  e => {
                    const i = (t + 16 * Math.random()) % 16 | 0;
                    return (
                      (t = Math.floor(t / 16)),
                      ("x" == e ? i : (3 & i) | 8).toString(16)
                    );
                  }
                );
                return i;
              }
            }
          })()),
        e
      );
    }
    get levels() {
      const e = this.levelController.levels;
      return e || [];
    }
    get latestLevelDetails() {
      return this.streamController.getLevelDetails() || null;
    }
    get loadLevelObj() {
      return this.levelController.loadLevelObj;
    }
    get currentLevel() {
      return this.streamController.currentLevel;
    }
    set currentLevel(e) {
      this.logger.log(`set currentLevel:${e}`),
        (this.levelController.manualLevel = e),
        this.streamController.immediateLevelSwitch();
    }
    get nextLevel() {
      return this.streamController.nextLevel;
    }
    set nextLevel(e) {
      this.logger.log(`set nextLevel:${e}`),
        (this.levelController.manualLevel = e),
        this.streamController.nextLevelSwitch();
    }
    get loadLevel() {
      return this.levelController.level;
    }
    set loadLevel(e) {
      this.logger.log(`set loadLevel:${e}`),
        (this.levelController.manualLevel = e);
    }
    get nextLoadLevel() {
      return this.levelController.nextLoadLevel;
    }
    set nextLoadLevel(e) {
      this.levelController.nextLoadLevel = e;
    }
    get firstLevel() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }
    set firstLevel(e) {
      this.logger.log(`set firstLevel:${e}`),
        (this.levelController.firstLevel = e);
    }
    get startLevel() {
      const e = this.levelController.startLevel;
      return -1 === e && this.abrController.forcedAutoLevel > -1
        ? this.abrController.forcedAutoLevel
        : e;
    }
    set startLevel(e) {
      this.logger.log(`set startLevel:${e}`),
        -1 !== e && (e = Math.max(e, this.minAutoLevel)),
        (this.levelController.startLevel = e);
    }
    get capLevelToPlayerSize() {
      return this.config.capLevelToPlayerSize;
    }
    set capLevelToPlayerSize(e) {
      const t = !!e;
      t !== this.config.capLevelToPlayerSize &&
        (t
          ? this.capLevelController.startCapping()
          : (this.capLevelController.stopCapping(),
            (this.autoLevelCapping = -1),
            this.streamController.nextLevelSwitch()),
        (this.config.capLevelToPlayerSize = t));
    }
    get autoLevelCapping() {
      return this._autoLevelCapping;
    }
    get bandwidthEstimate() {
      const { bwEstimator: e } = this.abrController;
      return e ? e.getEstimate() : NaN;
    }
    set bandwidthEstimate(e) {
      this.abrController.resetEstimator(e);
    }
    get abrEwmaDefaultEstimate() {
      const { bwEstimator: e } = this.abrController;
      return e ? e.defaultEstimate : NaN;
    }
    get ttfbEstimate() {
      const { bwEstimator: e } = this.abrController;
      return e ? e.getEstimateTTFB() : NaN;
    }
    set autoLevelCapping(e) {
      this._autoLevelCapping !== e &&
        (this.logger.log(`set autoLevelCapping:${e}`),
        (this._autoLevelCapping = e),
        this.levelController.checkMaxAutoUpdated());
    }
    get maxHdcpLevel() {
      return this._maxHdcpLevel;
    }
    set maxHdcpLevel(e) {
      (function(e) {
        return qg.indexOf(e) > -1;
      })(e) &&
        this._maxHdcpLevel !== e &&
        ((this._maxHdcpLevel = e), this.levelController.checkMaxAutoUpdated());
    }
    get autoLevelEnabled() {
      return -1 === this.levelController.manualLevel;
    }
    get manualLevel() {
      return this.levelController.manualLevel;
    }
    get minAutoLevel() {
      const {
        levels: e,
        config: { minAutoBitrate: t }
      } = this;
      if (!e) return 0;
      const i = e.length;
      for (let s = 0; s < i; s++) if (e[s].maxBitrate >= t) return s;
      return 0;
    }
    get maxAutoLevel() {
      const { levels: e, autoLevelCapping: t, maxHdcpLevel: i } = this;
      let s;
      if (((s = -1 === t && null != e && e.length ? e.length - 1 : t), i))
        for (let t = s; t--; ) {
          const s = e[t].attrs["HDCP-LEVEL"];
          if (s && s <= i) return t;
        }
      return s;
    }
    get firstAutoLevel() {
      return this.abrController.firstAutoLevel;
    }
    get nextAutoLevel() {
      return this.abrController.nextAutoLevel;
    }
    set nextAutoLevel(e) {
      this.abrController.nextAutoLevel = e;
    }
    get playingDate() {
      return this.streamController.currentProgramDateTime;
    }
    get mainForwardBufferInfo() {
      return this.streamController.getMainFwdBufferInfo();
    }
    get maxBufferLength() {
      return this.streamController.maxBufferLength;
    }
    setAudioOption(e) {
      var t;
      return (
        (null == (t = this.audioTrackController)
          ? void 0
          : t.setAudioOption(e)) || null
      );
    }
    setSubtitleOption(e) {
      var t;
      return (
        (null == (t = this.subtitleTrackController)
          ? void 0
          : t.setSubtitleOption(e)) || null
      );
    }
    get allAudioTracks() {
      const e = this.audioTrackController;
      return e ? e.allAudioTracks : [];
    }
    get audioTracks() {
      const e = this.audioTrackController;
      return e ? e.audioTracks : [];
    }
    get audioTrack() {
      const e = this.audioTrackController;
      return e ? e.audioTrack : -1;
    }
    set audioTrack(e) {
      const t = this.audioTrackController;
      t && (t.audioTrack = e);
    }
    get allSubtitleTracks() {
      const e = this.subtitleTrackController;
      return e ? e.allSubtitleTracks : [];
    }
    get subtitleTracks() {
      const e = this.subtitleTrackController;
      return e ? e.subtitleTracks : [];
    }
    get subtitleTrack() {
      const e = this.subtitleTrackController;
      return e ? e.subtitleTrack : -1;
    }
    get media() {
      return this._media;
    }
    set subtitleTrack(e) {
      const t = this.subtitleTrackController;
      t && (t.subtitleTrack = e);
    }
    get subtitleDisplay() {
      const e = this.subtitleTrackController;
      return !!e && e.subtitleDisplay;
    }
    set subtitleDisplay(e) {
      const t = this.subtitleTrackController;
      t && (t.subtitleDisplay = e);
    }
    get lowLatencyMode() {
      return this.config.lowLatencyMode;
    }
    set lowLatencyMode(e) {
      this.config.lowLatencyMode = e;
    }
    get liveSyncPosition() {
      return this.latencyController.liveSyncPosition;
    }
    get latency() {
      return this.latencyController.latency;
    }
    get maxLatency() {
      return this.latencyController.maxLatency;
    }
    get targetLatency() {
      return this.latencyController.targetLatency;
    }
    set targetLatency(e) {
      this.latencyController.targetLatency = e;
    }
    get drift() {
      return this.latencyController.drift;
    }
    get forceStartLoad() {
      return this.streamController.forceStartLoad;
    }
    get pathways() {
      return this.levelController.pathways;
    }
    get pathwayPriority() {
      return this.levelController.pathwayPriority;
    }
    set pathwayPriority(e) {
      this.levelController.pathwayPriority = e;
    }
    get bufferedToEnd() {
      var e;
      return !(null == (e = this.bufferController) || !e.bufferedToEnd);
    }
    get interstitialsManager() {
      var e;
      return (
        (null == (e = this.interstitialsController)
          ? void 0
          : e.interstitialsManager) || null
      );
    }
    getMediaDecodingInfo(e, t = this.allAudioTracks) {
      return $g(e, r_(t), navigator.mediaCapabilities);
    }
  }
  var RA, yA, AA, IA, CA, bA;
  (vA.defaultConfig = void 0),
    (function(e) {
      (e.ERROR = "error"),
        (e.READY_FOR_PLAY = "ready_for_play"),
        (e.UNRECOVERABLE_ERROR = "unrecoverable_error"),
        (e.AUTOPLAY_PREVENTED = "autoplay_was_prevented");
    })(RA || (RA = {})),
    (e.RtcSourceEvent = void 0),
    ((yA = e.RtcSourceEvent || (e.RtcSourceEvent = {})).NETWORK_QUALITY =
      "network_quality"),
    (yA.STATE_CHANGED = "state_changed"),
    (yA.VIDEO_STATE_CHANGED = "video_state_changed"),
    (yA.AUDIO_STATE_CHANGED = "audio_state_changed"),
    (yA.HOST_CHANGED = "host_changed"),
    (yA.USER_STATE_CHANGED = "user_state_changed"),
    (e.RtcSourceState = void 0),
    ((AA = e.RtcSourceState || (e.RtcSourceState = {})).CREATING = "creating"),
    (AA.CREATED = "created"),
    (AA.CONNECTING = "connecting"),
    (AA.CONNECTED = "connected"),
    (AA.CONNECT_FAILED = "connect-failed"),
    (AA.DESTROYED = "destroyed"),
    (e.RtcUserState = void 0),
    ((IA = e.RtcUserState || (e.RtcUserState = {})).JOINED = "joined"),
    (IA.LEFT = "left"),
    (IA.UNPUBLISHED = "unpublished"),
    (IA.PUBLISHED = "published"),
    (e.RtcMediaState = void 0),
    ((CA = e.RtcMediaState || (e.RtcMediaState = {})).PLAYING = "playing"),
    (CA.PAUSED = "paused"),
    (CA.STOPPED = "stopped"),
    (CA.EMPTY = "empty"),
    (e.MediaSource = void 0),
    ((bA = e.MediaSource || (e.MediaSource = {})).HLS = "hls"),
    (bA.RTC = "rtc");
  var OA = { exports: {} };
  !(function(e, t) {
    !(function(i, s) {
      var r = "function",
        n = "undefined",
        a = "object",
        o = "string",
        c = "major",
        d = "model",
        l = "name",
        h = "type",
        u = "vendor",
        p = "version",
        f = "architecture",
        E = "console",
        m = "mobile",
        g = "tablet",
        _ = "smarttv",
        T = "wearable",
        S = "embedded",
        v = "Amazon",
        R = "Apple",
        y = "ASUS",
        A = "BlackBerry",
        I = "Browser",
        C = "Chrome",
        b = "Firefox",
        O = "Google",
        D = "Huawei",
        w = "LG",
        L = "Microsoft",
        N = "Motorola",
        P = "Opera",
        k = "Samsung",
        M = "Sharp",
        U = "Sony",
        x = "Xiaomi",
        F = "Zebra",
        B = "Facebook",
        V = "Chromium OS",
        G = "Mac OS",
        j = function(e) {
          for (var t = {}, i = 0; i < e.length; i++)
            t[e[i].toUpperCase()] = e[i];
          return t;
        },
        H = function(e, t) {
          return typeof e === o && -1 !== K(t).indexOf(K(e));
        },
        K = function(e) {
          return e.toLowerCase();
        },
        W = function(e, t) {
          if (typeof e === o)
            return (
              (e = e.replace(/^\s\s*/, "")),
              typeof t === n ? e : e.substring(0, 350)
            );
        },
        Y = function(e, t) {
          for (var i, n, o, c, d, l, h = 0; h < t.length && !d; ) {
            var u = t[h],
              p = t[h + 1];
            for (i = n = 0; i < u.length && !d && u[i]; )
              if ((d = u[i++].exec(e)))
                for (o = 0; o < p.length; o++)
                  (l = d[++n]),
                    typeof (c = p[o]) === a && c.length > 0
                      ? 2 === c.length
                        ? typeof c[1] == r
                          ? (this[c[0]] = c[1].call(this, l))
                          : (this[c[0]] = c[1])
                        : 3 === c.length
                        ? typeof c[1] !== r || (c[1].exec && c[1].test)
                          ? (this[c[0]] = l ? l.replace(c[1], c[2]) : s)
                          : (this[c[0]] = l ? c[1].call(this, l, c[2]) : s)
                        : 4 === c.length &&
                          (this[c[0]] = l
                            ? c[3].call(this, l.replace(c[1], c[2]))
                            : s)
                      : (this[c] = l || s);
            h += 2;
          }
        },
        $ = function(e, t) {
          for (var i in t)
            if (typeof t[i] === a && t[i].length > 0) {
              for (var r = 0; r < t[i].length; r++)
                if (H(t[i][r], e)) return "?" === i ? s : i;
            } else if (H(t[i], e)) return "?" === i ? s : i;
          return e;
        },
        q = {
          ME: "4.90",
          "NT 3.11": "NT3.51",
          "NT 4.0": "NT4.0",
          2e3: "NT 5.0",
          XP: ["NT 5.1", "NT 5.2"],
          Vista: "NT 6.0",
          7: "NT 6.1",
          8: "NT 6.2",
          8.1: "NT 6.3",
          10: ["NT 6.4", "NT 10.0"],
          RT: "ARM"
        },
        X = {
          browser: [
            [/\b(?:crmo|crios)\/([\w\.]+)/i],
            [p, [l, "Chrome"]],
            [/edg(?:e|ios|a)?\/([\w\.]+)/i],
            [p, [l, "Edge"]],
            [
              /(opera mini)\/([-\w\.]+)/i,
              /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
              /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            ],
            [l, p],
            [/opios[\/ ]+([\w\.]+)/i],
            [p, [l, P + " Mini"]],
            [/\bopr\/([\w\.]+)/i],
            [p, [l, P]],
            [
              /(kindle)\/([\w\.]+)/i,
              /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
              /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
              /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
              /(?:ms|\()(ie) ([\w\.]+)/i,
              /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
              /(weibo)__([\d\.]+)/i
            ],
            [l, p],
            [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
            [p, [l, "UC" + I]],
            [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i],
            [p, [l, "WeChat(Win) Desktop"]],
            [/micromessenger\/([\w\.]+)/i],
            [p, [l, "WeChat"]],
            [/konqueror\/([\w\.]+)/i],
            [p, [l, "Konqueror"]],
            [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
            [p, [l, "IE"]],
            [/yabrowser\/([\w\.]+)/i],
            [p, [l, "Yandex"]],
            [/(avast|avg)\/([\w\.]+)/i],
            [[l, /(.+)/, "$1 Secure " + I], p],
            [/\bfocus\/([\w\.]+)/i],
            [p, [l, b + " Focus"]],
            [/\bopt\/([\w\.]+)/i],
            [p, [l, P + " Touch"]],
            [/coc_coc\w+\/([\w\.]+)/i],
            [p, [l, "Coc Coc"]],
            [/dolfin\/([\w\.]+)/i],
            [p, [l, "Dolphin"]],
            [/coast\/([\w\.]+)/i],
            [p, [l, P + " Coast"]],
            [/miuibrowser\/([\w\.]+)/i],
            [p, [l, "MIUI " + I]],
            [/fxios\/([-\w\.]+)/i],
            [p, [l, b]],
            [/\bqihu|(qi?ho?o?|360)browser/i],
            [[l, "360 " + I]],
            [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
            [[l, /(.+)/, "$1 " + I], p],
            [/(comodo_dragon)\/([\w\.]+)/i],
            [[l, /_/g, " "], p],
            [
              /(electron)\/([\w\.]+) safari/i,
              /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
              /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i
            ],
            [l, p],
            [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i],
            [l],
            [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
            [[l, B], p],
            [
              /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
              /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
              /safari (line)\/([\w\.]+)/i,
              /\b(line)\/([\w\.]+)\/iab/i,
              /(chromium|instagram)[\/ ]([-\w\.]+)/i
            ],
            [l, p],
            [/\bgsa\/([\w\.]+) .*safari\//i],
            [p, [l, "GSA"]],
            [/headlesschrome(?:\/([\w\.]+)| )/i],
            [p, [l, C + " Headless"]],
            [/ wv\).+(chrome)\/([\w\.]+)/i],
            [[l, C + " WebView"], p],
            [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
            [p, [l, "Android " + I]],
            [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
            [l, p],
            [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
            [p, [l, "Mobile Safari"]],
            [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
            [p, l],
            [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
            [
              l,
              [
                p,
                $,
                {
                  "1.0": "/8",
                  1.2: "/1",
                  1.3: "/3",
                  "2.0": "/412",
                  "2.0.2": "/416",
                  "2.0.3": "/417",
                  "2.0.4": "/419",
                  "?": "/"
                }
              ]
            ],
            [/(webkit|khtml)\/([\w\.]+)/i],
            [l, p],
            [/(navigator|netscape\d?)\/([-\w\.]+)/i],
            [[l, "Netscape"], p],
            [/mobile vr; rv:([\w\.]+)\).+firefox/i],
            [p, [l, b + " Reality"]],
            [
              /ekiohf.+(flow)\/([\w\.]+)/i,
              /(swiftfox)/i,
              /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
              /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
              /(firefox)\/([\w\.]+)/i,
              /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
              /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
              /(links) \(([\w\.]+)/i,
              /panasonic;(viera)/i
            ],
            [l, p],
            [/(cobalt)\/([\w\.]+)/i],
            [l, [p, /master.|lts./, ""]]
          ],
          cpu: [
            [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
            [[f, "amd64"]],
            [/(ia32(?=;))/i],
            [[f, K]],
            [/((?:i[346]|x)86)[;\)]/i],
            [[f, "ia32"]],
            [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
            [[f, "arm64"]],
            [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
            [[f, "armhf"]],
            [/windows (ce|mobile); ppc;/i],
            [[f, "arm"]],
            [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
            [[f, /ower/, "", K]],
            [/(sun4\w)[;\)]/i],
            [[f, "sparc"]],
            [
              /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            ],
            [[f, K]]
          ],
          device: [
            [
              /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ],
            [d, [u, k], [h, g]],
            [
              /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
              /samsung[- ]([-\w]+)/i,
              /sec-(sgh\w+)/i
            ],
            [d, [u, k], [h, m]],
            [/\((ip(?:hone|od)[\w ]*);/i],
            [d, [u, R], [h, m]],
            [
              /\((ipad);[-\w\),; ]+apple/i,
              /applecoremedia\/[\w\.]+ \((ipad)/i,
              /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ],
            [d, [u, R], [h, g]],
            [/(macintosh);/i],
            [d, [u, R]],
            [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
            [d, [u, M], [h, m]],
            [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
            [d, [u, D], [h, g]],
            [
              /(?:huawei|honor)([-\w ]+)[;\)]/i,
              /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ],
            [d, [u, D], [h, m]],
            [
              /\b(poco[\w ]+)(?: bui|\))/i,
              /\b; (\w+) build\/hm\1/i,
              /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
              /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
              /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
            ],
            [
              [d, /_/g, " "],
              [u, x],
              [h, m]
            ],
            [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
            [
              [d, /_/g, " "],
              [u, x],
              [h, g]
            ],
            [
              /; (\w+) bui.+ oppo/i,
              /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ],
            [d, [u, "OPPO"], [h, m]],
            [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
            [d, [u, "Vivo"], [h, m]],
            [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
            [d, [u, "Realme"], [h, m]],
            [
              /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
              /\bmot(?:orola)?[- ](\w*)/i,
              /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ],
            [d, [u, N], [h, m]],
            [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
            [d, [u, N], [h, g]],
            [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
            [d, [u, w], [h, g]],
            [
              /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
              /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
              /\blg-?([\d\w]+) bui/i
            ],
            [d, [u, w], [h, m]],
            [
              /(ideatab[-\w ]+)/i,
              /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ],
            [d, [u, "Lenovo"], [h, g]],
            [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i],
            [
              [d, /_/g, " "],
              [u, "Nokia"],
              [h, m]
            ],
            [/(pixel c)\b/i],
            [d, [u, O], [h, g]],
            [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
            [d, [u, O], [h, m]],
            [
              /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ],
            [d, [u, U], [h, m]],
            [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
            [
              [d, "Xperia Tablet"],
              [u, U],
              [h, g]
            ],
            [
              / (kb2005|in20[12]5|be20[12][59])\b/i,
              /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ],
            [d, [u, "OnePlus"], [h, m]],
            [
              /(alexa)webm/i,
              /(kf[a-z]{2}wi)( bui|\))/i,
              /(kf[a-z]+)( bui|\)).+silk\//i
            ],
            [d, [u, v], [h, g]],
            [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
            [
              [d, /(.+)/g, "Fire Phone $1"],
              [u, v],
              [h, m]
            ],
            [/(playbook);[-\w\),; ]+(rim)/i],
            [d, u, [h, g]],
            [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
            [d, [u, A], [h, m]],
            [
              /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ],
            [d, [u, y], [h, g]],
            [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
            [d, [u, y], [h, m]],
            [/(nexus 9)/i],
            [d, [u, "HTC"], [h, g]],
            [
              /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
              /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
              /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            ],
            [u, [d, /_/g, " "], [h, m]],
            [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
            [d, [u, "Acer"], [h, g]],
            [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
            [d, [u, "Meizu"], [h, m]],
            [
              /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
              /(hp) ([\w ]+\w)/i,
              /(asus)-?(\w+)/i,
              /(microsoft); (lumia[\w ]+)/i,
              /(lenovo)[-_ ]?([-\w]+)/i,
              /(jolla)/i,
              /(oppo) ?([\w ]+) bui/i
            ],
            [u, d, [h, m]],
            [
              /(kobo)\s(ereader|touch)/i,
              /(archos) (gamepad2?)/i,
              /(hp).+(touchpad(?!.+tablet)|tablet)/i,
              /(kindle)\/([\w\.]+)/i,
              /(nook)[\w ]+build\/(\w+)/i,
              /(dell) (strea[kpr\d ]*[\dko])/i,
              /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
              /(trinity)[- ]*(t\d{3}) bui/i,
              /(gigaset)[- ]+(q\w{1,9}) bui/i,
              /(vodafone) ([\w ]+)(?:\)| bui)/i
            ],
            [u, d, [h, g]],
            [/(surface duo)/i],
            [d, [u, L], [h, g]],
            [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
            [d, [u, "Fairphone"], [h, m]],
            [/(u304aa)/i],
            [d, [u, "AT&T"], [h, m]],
            [/\bsie-(\w*)/i],
            [d, [u, "Siemens"], [h, m]],
            [/\b(rct\w+) b/i],
            [d, [u, "RCA"], [h, g]],
            [/\b(venue[\d ]{2,7}) b/i],
            [d, [u, "Dell"], [h, g]],
            [/\b(q(?:mv|ta)\w+) b/i],
            [d, [u, "Verizon"], [h, g]],
            [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
            [d, [u, "Barnes & Noble"], [h, g]],
            [/\b(tm\d{3}\w+) b/i],
            [d, [u, "NuVision"], [h, g]],
            [/\b(k88) b/i],
            [d, [u, "ZTE"], [h, g]],
            [/\b(nx\d{3}j) b/i],
            [d, [u, "ZTE"], [h, m]],
            [/\b(gen\d{3}) b.+49h/i],
            [d, [u, "Swiss"], [h, m]],
            [/\b(zur\d{3}) b/i],
            [d, [u, "Swiss"], [h, g]],
            [/\b((zeki)?tb.*\b) b/i],
            [d, [u, "Zeki"], [h, g]],
            [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
            [[u, "Dragon Touch"], d, [h, g]],
            [/\b(ns-?\w{0,9}) b/i],
            [d, [u, "Insignia"], [h, g]],
            [/\b((nxa|next)-?\w{0,9}) b/i],
            [d, [u, "NextBook"], [h, g]],
            [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
            [[u, "Voice"], d, [h, m]],
            [/\b(lvtel\-)?(v1[12]) b/i],
            [[u, "LvTel"], d, [h, m]],
            [/\b(ph-1) /i],
            [d, [u, "Essential"], [h, m]],
            [/\b(v(100md|700na|7011|917g).*\b) b/i],
            [d, [u, "Envizen"], [h, g]],
            [/\b(trio[-\w\. ]+) b/i],
            [d, [u, "MachSpeed"], [h, g]],
            [/\btu_(1491) b/i],
            [d, [u, "Rotor"], [h, g]],
            [/(shield[\w ]+) b/i],
            [d, [u, "Nvidia"], [h, g]],
            [/(sprint) (\w+)/i],
            [u, d, [h, m]],
            [/(kin\.[onetw]{3})/i],
            [
              [d, /\./g, " "],
              [u, L],
              [h, m]
            ],
            [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
            [d, [u, F], [h, g]],
            [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
            [d, [u, F], [h, m]],
            [/smart-tv.+(samsung)/i],
            [u, [h, _]],
            [/hbbtv.+maple;(\d+)/i],
            [
              [d, /^/, "SmartTV"],
              [u, k],
              [h, _]
            ],
            [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
            [
              [u, w],
              [h, _]
            ],
            [/(apple) ?tv/i],
            [u, [d, R + " TV"], [h, _]],
            [/crkey/i],
            [
              [d, C + "cast"],
              [u, O],
              [h, _]
            ],
            [/droid.+aft(\w)( bui|\))/i],
            [d, [u, v], [h, _]],
            [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
            [d, [u, M], [h, _]],
            [/(bravia[\w ]+)( bui|\))/i],
            [d, [u, U], [h, _]],
            [/(mitv-\w{5}) bui/i],
            [d, [u, x], [h, _]],
            [/Hbbtv.*(technisat) (.*);/i],
            [u, d, [h, _]],
            [
              /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
              /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            ],
            [
              [u, W],
              [d, W],
              [h, _]
            ],
            [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
            [[h, _]],
            [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
            [u, d, [h, E]],
            [/droid.+; (shield) bui/i],
            [d, [u, "Nvidia"], [h, E]],
            [/(playstation [345portablevi]+)/i],
            [d, [u, U], [h, E]],
            [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
            [d, [u, L], [h, E]],
            [/((pebble))app/i],
            [u, d, [h, T]],
            [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],
            [d, [u, R], [h, T]],
            [/droid.+; (glass) \d/i],
            [d, [u, O], [h, T]],
            [/droid.+; (wt63?0{2,3})\)/i],
            [d, [u, F], [h, T]],
            [/(quest( 2| pro)?)/i],
            [d, [u, B], [h, T]],
            [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
            [u, [h, S]],
            [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
            [d, [h, m]],
            [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
            [d, [h, g]],
            [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
            [[h, g]],
            [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],
            [[h, m]],
            [/(android[-\w\. ]{0,9});.+buil/i],
            [d, [u, "Generic"]]
          ],
          engine: [
            [/windows.+ edge\/([\w\.]+)/i],
            [p, [l, "EdgeHTML"]],
            [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
            [p, [l, "Blink"]],
            [
              /(presto)\/([\w\.]+)/i,
              /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
              /ekioh(flow)\/([\w\.]+)/i,
              /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
              /(icab)[\/ ]([23]\.[\d\.]+)/i
            ],
            [l, p],
            [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
            [p, l]
          ],
          os: [
            [/microsoft (windows) (vista|xp)/i],
            [l, p],
            [
              /(windows) nt 6\.2; (arm)/i,
              /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
              /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
            ],
            [l, [p, $, q]],
            [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
            [
              [l, "Windows"],
              [p, $, q]
            ],
            [
              /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
              /cfnetwork\/.+darwin/i
            ],
            [
              [p, /_/g, "."],
              [l, "iOS"]
            ],
            [
              /(mac os x) ?([\w\. ]*)/i,
              /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            ],
            [
              [l, G],
              [p, /_/g, "."]
            ],
            [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
            [p, l],
            [
              /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
              /(blackberry)\w*\/([\w\.]*)/i,
              /(tizen|kaios)[\/ ]([\w\.]+)/i,
              /\((series40);/i
            ],
            [l, p],
            [/\(bb(10);/i],
            [p, [l, A]],
            [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
            [p, [l, "Symbian"]],
            [
              /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            ],
            [p, [l, b + " OS"]],
            [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
            [p, [l, "webOS"]],
            [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],
            [p, [l, "watchOS"]],
            [/crkey\/([\d\.]+)/i],
            [p, [l, C + "cast"]],
            [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],
            [[l, V], p],
            [
              /panasonic;(viera)/i,
              /(netrange)mmh/i,
              /(nettv)\/(\d+\.[\w\.]+)/i,
              /(nintendo|playstation) ([wids345portablevuch]+)/i,
              /(xbox); +xbox ([^\);]+)/i,
              /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
              /(mint)[\/\(\) ]?(\w*)/i,
              /(mageia|vectorlinux)[; ]/i,
              /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
              /(hurd|linux) ?([\w\.]*)/i,
              /(gnu) ?([\w\.]*)/i,
              /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
              /(haiku) (\w+)/i
            ],
            [l, p],
            [/(sunos) ?([\w\.\d]*)/i],
            [[l, "Solaris"], p],
            [
              /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
              /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
              /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
              /(unix) ?([\w\.]*)/i
            ],
            [l, p]
          ]
        },
        z = function(e, t) {
          if ((typeof e === a && ((t = e), (e = s)), !(this instanceof z)))
            return new z(e, t).getResult();
          var E = typeof i !== n && i.navigator ? i.navigator : s,
            _ = e || (E && E.userAgent ? E.userAgent : ""),
            T = E && E.userAgentData ? E.userAgentData : s,
            S = t
              ? (function(e, t) {
                  var i = {};
                  for (var s in e)
                    t[s] && t[s].length % 2 == 0
                      ? (i[s] = t[s].concat(e[s]))
                      : (i[s] = e[s]);
                  return i;
                })(X, t)
              : X;
          return (
            (this.getBrowser = function() {
              var e = {};
              return (
                (e[l] = s),
                (e[p] = s),
                Y.call(e, _, S.browser),
                (e[c] = (function(e) {
                  return typeof e === o
                    ? e.replace(/[^\d\.]/g, "").split(".")[0]
                    : s;
                })(e[p])),
                E && E.brave && typeof E.brave.isBrave == r && (e[l] = "Brave"),
                e
              );
            }),
            (this.getCPU = function() {
              var e = {};
              return (e[f] = s), Y.call(e, _, S.cpu), e;
            }),
            (this.getDevice = function() {
              var e = {};
              return (
                (e[u] = s),
                (e[d] = s),
                (e[h] = s),
                Y.call(e, _, S.device),
                !e[h] && T && T.mobile && (e[h] = m),
                "Macintosh" == e[d] &&
                  E &&
                  typeof E.standalone !== n &&
                  E.maxTouchPoints &&
                  E.maxTouchPoints > 2 &&
                  ((e[d] = "iPad"), (e[h] = g)),
                e
              );
            }),
            (this.getEngine = function() {
              var e = {};
              return (e[l] = s), (e[p] = s), Y.call(e, _, S.engine), e;
            }),
            (this.getOS = function() {
              var e = {};
              return (
                (e[l] = s),
                (e[p] = s),
                Y.call(e, _, S.os),
                !e[l] &&
                  T &&
                  "Unknown" != T.platform &&
                  (e[l] = T.platform
                    .replace(/chrome os/i, V)
                    .replace(/macos/i, G)),
                e
              );
            }),
            (this.getResult = function() {
              return {
                ua: this.getUA(),
                browser: this.getBrowser(),
                engine: this.getEngine(),
                os: this.getOS(),
                device: this.getDevice(),
                cpu: this.getCPU()
              };
            }),
            (this.getUA = function() {
              return _;
            }),
            (this.setUA = function(e) {
              return (
                (_ = typeof e === o && e.length > 350 ? W(e, 350) : e), this
              );
            }),
            this.setUA(_),
            this
          );
        };
      (z.VERSION = "0.7.34"),
        (z.BROWSER = j([l, p, c])),
        (z.CPU = j([f])),
        (z.DEVICE = j([d, u, h, E, m, _, g, T, S])),
        (z.ENGINE = z.OS = j([l, p])),
        e.exports && (t = e.exports = z),
        (t.UAParser = z);
      var J = typeof i !== n && (i.jQuery || i.Zepto);
      if (J && !J.ua) {
        var Q = new z();
        (J.ua = Q.getResult()),
          (J.ua.get = function() {
            return Q.getUA();
          }),
          (J.ua.set = function(e) {
            Q.setUA(e);
            var t = Q.getResult();
            for (var i in t) J.ua[i] = t[i];
          });
      }
    })("object" == typeof window ? window : i);
  })(OA, OA.exports);
  var DA = s(OA.exports),
    wA = Bi,
    LA = et,
    NA = W,
    PA = pn,
    kA = ft("iterator"),
    MA = Object,
    UA = function(e) {
      if (NA(e)) return !1;
      var t = MA(e);
      return void 0 !== t[kA] || "@@iterator" in t || LA(PA, wA(t));
    },
    xA = s(UA),
    FA = p;
  wi({ global: !0, forced: FA.globalThis !== FA }, { globalThis: FA });
  var BA = s(p),
    VA = id.clear;
  wi(
    { global: !0, bind: !0, enumerable: !0, forced: p.clearImmediate !== VA },
    { clearImmediate: VA }
  );
  var GA = p,
    jA = _,
    HA = b,
    KA = Vo,
    WA = ce,
    YA = Cc,
    $A = Oc,
    qA = GA.Function,
    XA =
      /MSIE .\./.test(WA) ||
      ("BUN" === KA &&
        (function() {
          var e = GA.Bun.version.split(".");
          return (
            e.length < 3 ||
            ("0" === e[0] && (e[1] < 3 || ("3" === e[1] && "0" === e[2])))
          );
        })()),
    zA = wi,
    JA = p,
    QA = id.set,
    ZA = function(e, t) {
      var i = t ? 2 : 1;
      return XA
        ? function(s, r) {
            var n = $A(arguments.length, 1) > i,
              a = HA(s) ? s : qA(s),
              o = n ? YA(arguments, i) : [],
              c = n
                ? function() {
                    jA(a, this, o);
                  }
                : a;
            return t ? e(c, r) : e(c);
          }
        : e;
    },
    eI = JA.setImmediate ? ZA(QA, !1) : QA;
  zA(
    { global: !0, bind: !0, enumerable: !0, forced: JA.setImmediate !== eI },
    { setImmediate: eI }
  );
  var tI = s(ee.setImmediate),
    iI = p,
    sI = Nd,
    rI = Le,
    nI = Oc,
    aI = D;
  wi(
    {
      global: !0,
      enumerable: !0,
      dontCallGetSet: !0,
      forced: r(function() {
        return (
          aI &&
          1 !==
            Object.getOwnPropertyDescriptor(iI, "queueMicrotask").value.length
        );
      })
    },
    {
      queueMicrotask: function(e) {
        nI(arguments.length, 1), sI(rI(e));
      }
    }
  );
  var oI = s(ee.queueMicrotask);
  function cI(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  }
  const { toString: dI } = Object.prototype,
    { getPrototypeOf: lI } = Object,
    hI =
      ((uI = Object.create(null)),
      e => {
        const t = dI.call(e);
        return uI[t] || (uI[t] = t.slice(8, -1).toLowerCase());
      });
  var uI;
  const pI = e => ((e = e.toLowerCase()), t => hI(t) === e),
    fI = e => t => typeof t === e,
    { isArray: EI } = Array,
    mI = fI("undefined");
  const gI = pI("ArrayBuffer");
  const _I = fI("string"),
    TI = fI("function"),
    SI = fI("number"),
    vI = e => null !== e && "object" == typeof e,
    RI = e => {
      if ("object" !== hI(e)) return !1;
      const t = lI(e);
      return !(
        (null !== t &&
          t !== Object.prototype &&
          null !== Object.getPrototypeOf(t)) ||
        Symbol.toStringTag in e ||
        xA(e)
      );
    },
    yI = pI("Date"),
    AI = pI("File"),
    II = pI("Blob"),
    CI = pI("FileList"),
    bI = pI("URLSearchParams"),
    [OI, DI, wI, LI] = ["ReadableStream", "Request", "Response", "Headers"].map(
      pI
    );
  function NI(e, t) {
    let i,
      s,
      { allOwnKeys: r = !1 } =
        arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (null != e)
      if (("object" != typeof e && (e = [e]), EI(e)))
        for (i = 0, s = e.length; i < s; i++) t.call(null, e[i], i, e);
      else {
        const s = r ? Object.getOwnPropertyNames(e) : Object.keys(e),
          n = s.length;
        let a;
        for (i = 0; i < n; i++) (a = s[i]), t.call(null, e[a], a, e);
      }
  }
  function PI(e, t) {
    t = t.toLowerCase();
    const i = Object.keys(e);
    let s,
      r = i.length;
    for (; r-- > 0; ) if (((s = i[r]), t === s.toLowerCase())) return s;
    return null;
  }
  const kI =
      void 0 !== BA
        ? BA
        : "undefined" != typeof self
        ? self
        : "undefined" != typeof window
        ? window
        : global,
    MI = e => !mI(e) && e !== kI;
  const UI =
    ((xI = "undefined" != typeof Uint8Array && lI(Uint8Array)),
    e => xI && e instanceof xI);
  var xI;
  const FI = pI("HTMLFormElement"),
    BI = (e => {
      let { hasOwnProperty: t } = e;
      return (e, i) => t.call(e, i);
    })(Object.prototype),
    VI = pI("RegExp"),
    GI = (e, t) => {
      const i = Object.getOwnPropertyDescriptors(e),
        s = {};
      NI(i, (i, r) => {
        let n;
        !1 !== (n = t(i, r, e)) && (s[r] = n || i);
      }),
        Object.defineProperties(e, s);
    },
    jI = "abcdefghijklmnopqrstuvwxyz",
    HI = "0123456789",
    KI = { DIGIT: HI, ALPHA: jI, ALPHA_DIGIT: jI + jI.toUpperCase() + HI };
  const WI = pI("AsyncFunction"),
    YI =
      (($I = "function" == typeof tI),
      (qI = TI(kI.postMessage)),
      $I
        ? tI
        : qI
        ? ((XI = "axios@".concat(Math.random())),
          (zI = []),
          kI.addEventListener(
            "message",
            e => {
              let { source: t, data: i } = e;
              t === kI && i === XI && zI.length && zI.shift()();
            },
            !1
          ),
          e => {
            zI.push(e), kI.postMessage(XI, "*");
          })
        : e => setTimeout(e));
  var $I, qI, XI, zI;
  const JI =
    void 0 !== oI
      ? oI.bind(kI)
      : ("undefined" != typeof process && process.nextTick) || YI;
  var QI = {
    isArray: EI,
    isArrayBuffer: gI,
    isBuffer: function(e) {
      return (
        null !== e &&
        !mI(e) &&
        null !== e.constructor &&
        !mI(e.constructor) &&
        TI(e.constructor.isBuffer) &&
        e.constructor.isBuffer(e)
      );
    },
    isFormData: e => {
      let t;
      return (
        e &&
        (("function" == typeof FormData && e instanceof FormData) ||
          (TI(e.append) &&
            ("formdata" === (t = hI(e)) ||
              ("object" === t &&
                TI(e.toString) &&
                "[object FormData]" === e.toString()))))
      );
    },
    isArrayBufferView: function(e) {
      let t;
      return (
        (t =
          "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
            ? ArrayBuffer.isView(e)
            : e && e.buffer && gI(e.buffer)),
        t
      );
    },
    isString: _I,
    isNumber: SI,
    isBoolean: e => !0 === e || !1 === e,
    isObject: vI,
    isPlainObject: RI,
    isReadableStream: OI,
    isRequest: DI,
    isResponse: wI,
    isHeaders: LI,
    isUndefined: mI,
    isDate: yI,
    isFile: AI,
    isBlob: II,
    isRegExp: VI,
    isFunction: TI,
    isStream: e => vI(e) && TI(e.pipe),
    isURLSearchParams: bI,
    isTypedArray: UI,
    isFileList: CI,
    forEach: NI,
    merge: function e() {
      const { caseless: t } = (MI(this) && this) || {},
        i = {},
        s = (s, r) => {
          const n = (t && PI(i, r)) || r;
          RI(i[n]) && RI(s)
            ? (i[n] = e(i[n], s))
            : RI(s)
            ? (i[n] = e({}, s))
            : EI(s)
            ? (i[n] = s.slice())
            : (i[n] = s);
        };
      for (let e = 0, t = arguments.length; e < t; e++)
        arguments[e] && NI(arguments[e], s);
      return i;
    },
    extend: function(e, t, i) {
      let { allOwnKeys: s } =
        arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
      return (
        NI(
          t,
          (t, s) => {
            i && TI(t) ? (e[s] = cI(t, i)) : (e[s] = t);
          },
          { allOwnKeys: s }
        ),
        e
      );
    },
    trim: e =>
      ms(e)
        ? ms(e).call(e)
        : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
    stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
    inherits: (e, t, i, s) => {
      (e.prototype = Object.create(t.prototype, s)),
        (e.prototype.constructor = e),
        Object.defineProperty(e, "super", { value: t.prototype }),
        i && Object.assign(e.prototype, i);
    },
    toFlatObject: (e, t, i, s) => {
      let r, n, a;
      const o = {};
      if (((t = t || {}), null == e)) return t;
      do {
        for (r = Object.getOwnPropertyNames(e), n = r.length; n-- > 0; )
          (a = r[n]),
            (s && !s(a, e, t)) || o[a] || ((t[a] = e[a]), (o[a] = !0));
        e = !1 !== i && lI(e);
      } while (e && (!i || i(e, t)) && e !== Object.prototype);
      return t;
    },
    kindOf: hI,
    kindOfTest: pI,
    endsWith: (e, t, i) => {
      (e = String(e)),
        (void 0 === i || i > e.length) && (i = e.length),
        (i -= t.length);
      const s = e.indexOf(t, i);
      return -1 !== s && s === i;
    },
    toArray: e => {
      if (!e) return null;
      if (EI(e)) return e;
      let t = e.length;
      if (!SI(t)) return null;
      const i = new Array(t);
      for (; t-- > 0; ) i[t] = e[t];
      return i;
    },
    forEachEntry: (e, t) => {
      const i = (e && e[Symbol.iterator]).call(e);
      let s;
      for (; (s = i.next()) && !s.done; ) {
        const i = s.value;
        t.call(e, i[0], i[1]);
      }
    },
    matchAll: (e, t) => {
      let i;
      const s = [];
      for (; null !== (i = e.exec(t)); ) s.push(i);
      return s;
    },
    isHTMLForm: FI,
    hasOwnProperty: BI,
    hasOwnProp: BI,
    reduceDescriptors: GI,
    freezeMethods: e => {
      GI(e, (t, i) => {
        if (TI(e) && -1 !== ["arguments", "caller", "callee"].indexOf(i))
          return !1;
        const s = e[i];
        TI(s) &&
          ((t.enumerable = !1),
          "writable" in t
            ? (t.writable = !1)
            : t.set ||
              (t.set = () => {
                throw Error("Can not rewrite read-only method '" + i + "'");
              }));
      });
    },
    toObjectSet: (e, t) => {
      const i = {},
        s = e => {
          e.forEach(e => {
            i[e] = !0;
          });
        };
      return EI(e) ? s(e) : s(String(e).split(t)), i;
    },
    toCamelCase: e =>
      e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e, t, i) {
        return t.toUpperCase() + i;
      }),
    noop: () => {},
    toFiniteNumber: (e, t) => (null != e && Number.isFinite((e = +e)) ? e : t),
    findKey: PI,
    global: kI,
    isContextDefined: MI,
    ALPHABET: KI,
    generateString: function() {
      let e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16,
        t =
          arguments.length > 1 && void 0 !== arguments[1]
            ? arguments[1]
            : KI.ALPHA_DIGIT,
        i = "";
      const { length: s } = t;
      for (; e--; ) i += t[(Math.random() * s) | 0];
      return i;
    },
    isSpecCompliantForm: function(e) {
      return !!(
        e &&
        TI(e.append) &&
        "FormData" === e[Symbol.toStringTag] &&
        e[Symbol.iterator]
      );
    },
    toJSONObject: e => {
      const t = new Array(10),
        i = (e, s) => {
          if (vI(e)) {
            if (t.indexOf(e) >= 0) return;
            if (!("toJSON" in e)) {
              t[s] = e;
              const r = EI(e) ? [] : {};
              return (
                NI(e, (e, t) => {
                  const n = i(e, s + 1);
                  !mI(n) && (r[t] = n);
                }),
                (t[s] = void 0),
                r
              );
            }
          }
          return e;
        };
      return i(e, 0);
    },
    isAsyncFn: WI,
    isThenable: e => e && (vI(e) || TI(e)) && TI(e.then) && TI(e.catch),
    setImmediate: YI,
    asap: JI
  };
  function ZI(e, t, i, s, r) {
    Error.call(this),
      Error.captureStackTrace
        ? Error.captureStackTrace(this, this.constructor)
        : (this.stack = new Error().stack),
      (this.message = e),
      (this.name = "AxiosError"),
      t && (this.code = t),
      i && (this.config = i),
      s && (this.request = s),
      r && ((this.response = r), (this.status = r.status ? r.status : null));
  }
  QI.inherits(ZI, Error, {
    toJSON: function() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: QI.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const eC = ZI.prototype,
    tC = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
  ].forEach(e => {
    tC[e] = { value: e };
  }),
    Object.defineProperties(ZI, tC),
    Object.defineProperty(eC, "isAxiosError", { value: !0 }),
    (ZI.from = (e, t, i, s, r, n) => {
      const a = Object.create(eC);
      return (
        QI.toFlatObject(
          e,
          a,
          function(e) {
            return e !== Error.prototype;
          },
          e => "isAxiosError" !== e
        ),
        ZI.call(a, e.message, t, i, s, r),
        (a.cause = e),
        (a.name = e.name),
        n && Object.assign(a, n),
        a
      );
    });
  function iC(e) {
    return QI.isPlainObject(e) || QI.isArray(e);
  }
  function sC(e) {
    return QI.endsWith(e, "[]") ? e.slice(0, -2) : e;
  }
  function rC(e, t, i) {
    return e
      ? e
          .concat(t)
          .map(function(e, t) {
            return (e = sC(e)), !i && t ? "[" + e + "]" : e;
          })
          .join(i ? "." : "")
      : t;
  }
  const nC = QI.toFlatObject(QI, {}, null, function(e) {
    return /^is[A-Z]/.test(e);
  });
  function aC(e, t, i) {
    if (!QI.isObject(e)) throw new TypeError("target must be an object");
    t = t || new FormData();
    const s = (i = QI.toFlatObject(
        i,
        { metaTokens: !0, dots: !1, indexes: !1 },
        !1,
        function(e, t) {
          return !QI.isUndefined(t[e]);
        }
      )).metaTokens,
      r = i.visitor || d,
      n = i.dots,
      a = i.indexes,
      o =
        (i.Blob || ("undefined" != typeof Blob && Blob)) &&
        QI.isSpecCompliantForm(t);
    if (!QI.isFunction(r)) throw new TypeError("visitor must be a function");
    function c(e) {
      if (null === e) return "";
      if (QI.isDate(e)) return e.toISOString();
      if (!o && QI.isBlob(e))
        throw new ZI("Blob is not supported. Use a Buffer instead.");
      return QI.isArrayBuffer(e) || QI.isTypedArray(e)
        ? o && "function" == typeof Blob
          ? new Blob([e])
          : Buffer.from(e)
        : e;
    }
    function d(e, i, r) {
      let o = e;
      if (e && !r && "object" == typeof e)
        if (QI.endsWith(i, "{}"))
          (i = s ? i : i.slice(0, -2)), (e = JSON.stringify(e));
        else if (
          (QI.isArray(e) &&
            (function(e) {
              return QI.isArray(e) && !e.some(iC);
            })(e)) ||
          ((QI.isFileList(e) || QI.endsWith(i, "[]")) && (o = QI.toArray(e)))
        )
          return (
            (i = sC(i)),
            o.forEach(function(e, s) {
              !QI.isUndefined(e) &&
                null !== e &&
                t.append(
                  !0 === a ? rC([i], s, n) : null === a ? i : i + "[]",
                  c(e)
                );
            }),
            !1
          );
      return !!iC(e) || (t.append(rC(r, i, n), c(e)), !1);
    }
    const l = [],
      h = Object.assign(nC, {
        defaultVisitor: d,
        convertValue: c,
        isVisitable: iC
      });
    if (!QI.isObject(e)) throw new TypeError("data must be an object");
    return (
      (function e(i, s) {
        if (!QI.isUndefined(i)) {
          if (-1 !== l.indexOf(i))
            throw Error("Circular reference detected in " + s.join("."));
          l.push(i),
            QI.forEach(i, function(i, n) {
              !0 ===
                (!(QI.isUndefined(i) || null === i) &&
                  r.call(t, i, QI.isString(n) ? ms(n).call(n) : n, s, h)) &&
                e(i, s ? s.concat(n) : [n]);
            }),
            l.pop();
        }
      })(e),
      t
    );
  }
  function oC(e) {
    const t = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(e) {
      return t[e];
    });
  }
  function cC(e, t) {
    (this._pairs = []), e && aC(e, this, t);
  }
  const dC = cC.prototype;
  function lC(e) {
    return encodeURIComponent(e)
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%20/g, "+")
      .replace(/%5B/gi, "[")
      .replace(/%5D/gi, "]");
  }
  function hC(e, t, i) {
    if (!t) return e;
    const s = (i && i.encode) || lC;
    QI.isFunction(i) && (i = { serialize: i });
    const r = i && i.serialize;
    let n;
    if (
      ((n = r
        ? r(t, i)
        : QI.isURLSearchParams(t)
        ? t.toString()
        : new cC(t, i).toString(s)),
      n)
    ) {
      const t = e.indexOf("#");
      -1 !== t && (e = e.slice(0, t)),
        (e += (-1 === e.indexOf("?") ? "?" : "&") + n);
    }
    return e;
  }
  (dC.append = function(e, t) {
    this._pairs.push([e, t]);
  }),
    (dC.toString = function(e) {
      const t = e
        ? function(t) {
            return e.call(this, t, oC);
          }
        : oC;
      return this._pairs
        .map(function(e) {
          return t(e[0]) + "=" + t(e[1]);
        }, "")
        .join("&");
    });
  var uC = class {
      constructor() {
        this.handlers = [];
      }
      use(e, t, i) {
        return (
          this.handlers.push({
            fulfilled: e,
            rejected: t,
            synchronous: !!i && i.synchronous,
            runWhen: i ? i.runWhen : null
          }),
          this.handlers.length - 1
        );
      }
      eject(e) {
        this.handlers[e] && (this.handlers[e] = null);
      }
      clear() {
        this.handlers && (this.handlers = []);
      }
      forEach(e) {
        QI.forEach(this.handlers, function(t) {
          null !== t && e(t);
        });
      }
    },
    pC = {
      silentJSONParsing: !0,
      forcedJSONParsing: !0,
      clarifyTimeoutError: !1
    },
    fC = wi,
    EC = l,
    mC = Xs,
    gC = RangeError,
    _C = String.fromCharCode,
    TC = String.fromCodePoint,
    SC = EC([].join);
  fC(
    { target: "String", stat: !0, arity: 1, forced: !!TC && 1 !== TC.length },
    {
      fromCodePoint: function(e) {
        for (var t, i = [], s = arguments.length, r = 0; s > r; ) {
          if (((t = +arguments[r++]), mC(t, 1114111) !== t))
            throw new gC(t + " is not a valid code point");
          i[r] =
            t < 65536
              ? _C(t)
              : _C(55296 + ((t -= 65536) >> 10), (t % 1024) + 56320);
        }
        return SC(i, "");
      }
    }
  );
  var vC = r,
    RC = ft("iterator"),
    yC = !vC(function() {
      var e = new URL("b?a=1&b=2&c=3", "https://a"),
        t = e.searchParams,
        i = new URLSearchParams("a=1&a=2&b=3"),
        s = "";
      return (
        (e.pathname = "c%20d"),
        t.forEach(function(e, i) {
          t.delete("b"), (s += i + e);
        }),
        i.delete("a", 2),
        i.delete("b", void 0),
        !e.toJSON ||
          !i.has("a", 1) ||
          i.has("a", 2) ||
          !i.has("a", void 0) ||
          i.has("b") ||
          (!t.size && true) ||
          !t.sort ||
          "https://a/c%20d?a=1&c=3" !== e.href ||
          "3" !== t.get("c") ||
          "a=1" !== String(new URLSearchParams("?a=1")) ||
          !t[RC] ||
          "a" !== new URL("https://a@b").username ||
          "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") ||
          "xn--e1aybc" !== new URL("https://ÑÐµÑÑ").host ||
          "#%D0%B1" !== new URL("https://a#Ð±").hash ||
          "a1c3" !== s ||
          "x" !== new URL("https://x", void 0).host
      );
    }),
    AC = Ua,
    IC = Cc,
    CC = Math.floor,
    bC = function(e, t) {
      var i = e.length;
      if (i < 8)
        for (var s, r, n = 1; n < i; ) {
          for (r = n, s = e[n]; r && t(e[r - 1], s) > 0; ) e[r] = e[--r];
          r !== n++ && (e[r] = s);
        }
      else
        for (
          var a = CC(i / 2),
            o = bC(IC(e, 0, a), t),
            c = bC(IC(e, a), t),
            d = o.length,
            l = c.length,
            h = 0,
            u = 0;
          h < d || u < l;

        )
          e[h + u] =
            h < d && u < l
              ? t(o[h], c[u]) <= 0
                ? o[h++]
                : c[u++]
              : h < d
              ? o[h++]
              : c[u++];
      return e;
    },
    OC = wi,
    DC = p,
    wC = ad,
    LC = ne,
    NC = N,
    PC = l,
    kC = D,
    MC = yC,
    UC = Ua,
    xC = Ho,
    FC = function(e, t, i) {
      for (var s in t)
        i && i.unsafe && e[s] ? (e[s] = t[s]) : AC(e, s, t[s], i);
      return e;
    },
    BC = to,
    VC = co,
    GC = ka,
    jC = zo,
    HC = b,
    KC = et,
    WC = Qt,
    YC = Bi,
    $C = ri,
    qC = Z,
    XC = ji,
    zC = Qr,
    JC = B,
    QC = wn,
    ZC = yn,
    eb = bo,
    tb = Oc,
    ib = bC,
    sb = ft("iterator"),
    rb = "URLSearchParams",
    nb = rb + "Iterator",
    ab = GC.set,
    ob = GC.getterFor(rb),
    cb = GC.getterFor(nb),
    db = wC("fetch"),
    lb = wC("Request"),
    hb = wC("Headers"),
    ub = lb && lb.prototype,
    pb = hb && hb.prototype,
    fb = DC.TypeError,
    Eb = DC.encodeURIComponent,
    mb = String.fromCharCode,
    gb = LC("String", "fromCodePoint"),
    _b = parseInt,
    Tb = PC("".charAt),
    Sb = PC([].join),
    vb = PC([].push),
    Rb = PC("".replace),
    yb = PC([].shift),
    Ab = PC([].splice),
    Ib = PC("".split),
    Cb = PC("".slice),
    bb = PC(/./.exec),
    Ob = /\+/g,
    Db = /^[0-9a-f]+$/i,
    wb = function(e, t) {
      var i = Cb(e, t, t + 2);
      return bb(Db, i) ? _b(i, 16) : NaN;
    },
    Lb = function(e) {
      for (var t = 0, i = 128; i > 0 && 0 != (e & i); i >>= 1) t++;
      return t;
    },
    Nb = function(e) {
      var t = null;
      switch (e.length) {
        case 1:
          t = e[0];
          break;
        case 2:
          t = ((31 & e[0]) << 6) | (63 & e[1]);
          break;
        case 3:
          t = ((15 & e[0]) << 12) | ((63 & e[1]) << 6) | (63 & e[2]);
          break;
        case 4:
          t =
            ((7 & e[0]) << 18) |
            ((63 & e[1]) << 12) |
            ((63 & e[2]) << 6) |
            (63 & e[3]);
      }
      return t > 1114111 ? null : t;
    },
    Pb = function(e) {
      for (var t = (e = Rb(e, Ob, " ")).length, i = "", s = 0; s < t; ) {
        var r = Tb(e, s);
        if ("%" === r) {
          if ("%" === Tb(e, s + 1) || s + 3 > t) {
            (i += "%"), s++;
            continue;
          }
          var n = wb(e, s + 1);
          if (n != n) {
            (i += r), s++;
            continue;
          }
          s += 2;
          var a = Lb(n);
          if (0 === a) r = mb(n);
          else {
            if (1 === a || a > 4) {
              (i += "ï¿½"), s++;
              continue;
            }
            for (
              var o = [n], c = 1;
              c < a && !(++s + 3 > t || "%" !== Tb(e, s));

            ) {
              var d = wb(e, s + 1);
              if (d != d) {
                s += 3;
                break;
              }
              if (d > 191 || d < 128) break;
              vb(o, d), (s += 2), c++;
            }
            if (o.length !== a) {
              i += "ï¿½";
              continue;
            }
            var l = Nb(o);
            null === l ? (i += "ï¿½") : (r = gb(l));
          }
        }
        (i += r), s++;
      }
      return i;
    },
    kb = /[!'()~]|%20/g,
    Mb = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+"
    },
    Ub = function(e) {
      return Mb[e];
    },
    xb = function(e) {
      return Rb(Eb(e), kb, Ub);
    },
    Fb = VC(
      function(e, t) {
        ab(this, { type: nb, target: ob(e).entries, index: 0, kind: t });
      },
      rb,
      function() {
        var e = cb(this),
          t = e.target,
          i = e.index++;
        if (!t || i >= t.length) return (e.target = null), eb(void 0, !0);
        var s = t[i];
        switch (e.kind) {
          case "keys":
            return eb(s.key, !1);
          case "values":
            return eb(s.value, !1);
        }
        return eb([s.key, s.value], !1);
      },
      !0
    ),
    Bb = function(e) {
      (this.entries = []),
        (this.url = null),
        void 0 !== e &&
          (qC(e)
            ? this.parseObject(e)
            : this.parseQuery(
                "string" == typeof e ? ("?" === Tb(e, 0) ? Cb(e, 1) : e) : XC(e)
              ));
    };
  Bb.prototype = {
    type: rb,
    bindURL: function(e) {
      (this.url = e), this.update();
    },
    parseObject: function(e) {
      var t,
        i,
        s,
        r,
        n,
        a,
        o,
        c = this.entries,
        d = ZC(e);
      if (d)
        for (i = (t = QC(e, d)).next; !(s = NC(i, t)).done; ) {
          if (
            ((n = (r = QC($C(s.value))).next),
            (a = NC(n, r)).done || (o = NC(n, r)).done || !NC(n, r).done)
          )
            throw new fb("Expected sequence with length 2");
          vb(c, { key: XC(a.value), value: XC(o.value) });
        }
      else for (var l in e) KC(e, l) && vb(c, { key: l, value: XC(e[l]) });
    },
    parseQuery: function(e) {
      if (e)
        for (var t, i, s = this.entries, r = Ib(e, "&"), n = 0; n < r.length; )
          (t = r[n++]).length &&
            ((i = Ib(t, "=")),
            vb(s, { key: Pb(yb(i)), value: Pb(Sb(i, "=")) }));
    },
    serialize: function() {
      for (var e, t = this.entries, i = [], s = 0; s < t.length; )
        (e = t[s++]), vb(i, xb(e.key) + "=" + xb(e.value));
      return Sb(i, "&");
    },
    update: function() {
      (this.entries.length = 0), this.parseQuery(this.url.query);
    },
    updateURL: function() {
      this.url && this.url.update();
    }
  };
  var Vb = function() {
      jC(this, Gb);
      var e = ab(this, new Bb(arguments.length > 0 ? arguments[0] : void 0));
      kC || (this.size = e.entries.length);
    },
    Gb = Vb.prototype;
  if (
    (FC(
      Gb,
      {
        append: function(e, t) {
          var i = ob(this);
          tb(arguments.length, 2),
            vb(i.entries, { key: XC(e), value: XC(t) }),
            kC || this.length++,
            i.updateURL();
        },
        delete: function(e) {
          for (
            var t = ob(this),
              i = tb(arguments.length, 1),
              s = t.entries,
              r = XC(e),
              n = i < 2 ? void 0 : arguments[1],
              a = void 0 === n ? n : XC(n),
              o = 0;
            o < s.length;

          ) {
            var c = s[o];
            if (c.key !== r || (void 0 !== a && c.value !== a)) o++;
            else if ((Ab(s, o, 1), void 0 !== a)) break;
          }
          kC || (this.size = s.length), t.updateURL();
        },
        get: function(e) {
          var t = ob(this).entries;
          tb(arguments.length, 1);
          for (var i = XC(e), s = 0; s < t.length; s++)
            if (t[s].key === i) return t[s].value;
          return null;
        },
        getAll: function(e) {
          var t = ob(this).entries;
          tb(arguments.length, 1);
          for (var i = XC(e), s = [], r = 0; r < t.length; r++)
            t[r].key === i && vb(s, t[r].value);
          return s;
        },
        has: function(e) {
          for (
            var t = ob(this).entries,
              i = tb(arguments.length, 1),
              s = XC(e),
              r = i < 2 ? void 0 : arguments[1],
              n = void 0 === r ? r : XC(r),
              a = 0;
            a < t.length;

          ) {
            var o = t[a++];
            if (o.key === s && (void 0 === n || o.value === n)) return !0;
          }
          return !1;
        },
        set: function(e, t) {
          var i = ob(this);
          tb(arguments.length, 1);
          for (
            var s, r = i.entries, n = !1, a = XC(e), o = XC(t), c = 0;
            c < r.length;
            c++
          )
            (s = r[c]).key === a &&
              (n ? Ab(r, c--, 1) : ((n = !0), (s.value = o)));
          n || vb(r, { key: a, value: o }),
            kC || (this.size = r.length),
            i.updateURL();
        },
        sort: function() {
          var e = ob(this);
          ib(e.entries, function(e, t) {
            return e.key > t.key ? 1 : -1;
          }),
            e.updateURL();
        },
        forEach: function(e) {
          for (
            var t,
              i = ob(this).entries,
              s = WC(e, arguments.length > 1 ? arguments[1] : void 0),
              r = 0;
            r < i.length;

          )
            s((t = i[r++]).value, t.key, this);
        },
        keys: function() {
          return new Fb(this, "keys");
        },
        values: function() {
          return new Fb(this, "values");
        },
        entries: function() {
          return new Fb(this, "entries");
        }
      },
      { enumerable: !0 }
    ),
    UC(Gb, sb, Gb.entries, { name: "entries" }),
    UC(
      Gb,
      "toString",
      function() {
        return ob(this).serialize();
      },
      { enumerable: !0 }
    ),
    kC &&
      xC(Gb, "size", {
        get: function() {
          return ob(this).entries.length;
        },
        configurable: !0,
        enumerable: !0
      }),
    BC(Vb, rb),
    OC({ global: !0, constructor: !0, forced: !MC }, { URLSearchParams: Vb }),
    !MC && HC(hb))
  ) {
    var jb = PC(pb.has),
      Hb = PC(pb.set),
      Kb = function(e) {
        if (qC(e)) {
          var t,
            i = e.body;
          if (YC(i) === rb)
            return (
              (t = e.headers ? new hb(e.headers) : new hb()),
              jb(t, "content-type") ||
                Hb(
                  t,
                  "content-type",
                  "application/x-www-form-urlencoded;charset=UTF-8"
                ),
              zC(e, { body: JC(0, XC(i)), headers: JC(0, t) })
            );
        }
        return e;
      };
    if (
      (HC(db) &&
        OC(
          { global: !0, enumerable: !0, dontCallGetSet: !0, forced: !0 },
          {
            fetch: function(e) {
              return db(e, arguments.length > 1 ? Kb(arguments[1]) : {});
            }
          }
        ),
      HC(lb))
    ) {
      var Wb = function(e) {
        return (
          jC(this, ub), new lb(e, arguments.length > 1 ? Kb(arguments[1]) : {})
        );
      };
      (ub.constructor = Wb),
        (Wb.prototype = ub),
        OC(
          { global: !0, constructor: !0, dontCallGetSet: !0, forced: !0 },
          { Request: Wb }
        );
    }
  }
  var Yb = { URLSearchParams: Vb, getState: ob },
    $b = s(ee.URLSearchParams),
    qb = {
      isBrowser: !0,
      classes: {
        URLSearchParams: void 0 !== $b ? $b : cC,
        FormData: "undefined" != typeof FormData ? FormData : null,
        Blob: "undefined" != typeof Blob ? Blob : null
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
  const Xb = "undefined" != typeof window && "undefined" != typeof document,
    zb = ("object" == typeof navigator && navigator) || void 0,
    Jb =
      Xb &&
      (!zb || ["ReactNative", "NativeScript", "NS"].indexOf(zb.product) < 0),
    Qb =
      "undefined" != typeof WorkerGlobalScope &&
      self instanceof WorkerGlobalScope &&
      "function" == typeof self.importScripts,
    Zb = (Xb && window.location.href) || "http://localhost";
  function eO(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function tO(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? eO(Object(i), !0).forEach(function(t) {
            gm(e, t, i[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
        : eO(Object(i)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
          });
    }
    return e;
  }
  var iO = tO(
    tO(
      {},
      Object.freeze({
        __proto__: null,
        hasBrowserEnv: Xb,
        hasStandardBrowserEnv: Jb,
        hasStandardBrowserWebWorkerEnv: Qb,
        navigator: zb,
        origin: Zb
      })
    ),
    qb
  );
  var sO = Z,
    rO = R,
    nO = ft("match"),
    aO = function(e) {
      var t;
      return sO(e) && (void 0 !== (t = e[nO]) ? !!t : "RegExp" === rO(e));
    },
    oO = ri,
    cO = N,
    dO = et,
    lO = h,
    hO = function() {
      var e = oO(this),
        t = "";
      return (
        e.hasIndices && (t += "d"),
        e.global && (t += "g"),
        e.ignoreCase && (t += "i"),
        e.multiline && (t += "m"),
        e.dotAll && (t += "s"),
        e.unicode && (t += "u"),
        e.unicodeSets && (t += "v"),
        e.sticky && (t += "y"),
        t
      );
    },
    uO = RegExp.prototype,
    pO = au.charAt,
    fO = N,
    EO = ri,
    mO = b,
    gO = R,
    _O = /./.exec,
    TO = TypeError,
    SO = wi,
    vO = N,
    RO = I,
    yO = co,
    AO = bo,
    IO = q,
    CO = Qs,
    bO = ji,
    OO = ri,
    DO = W,
    wO = R,
    LO = aO,
    NO = function(e) {
      var t = e.flags;
      return void 0 !== t || "flags" in uO || dO(e, "flags") || !lO(uO, e)
        ? t
        : cO(hO, e);
    },
    PO = ke,
    kO = r,
    MO = Ic,
    UO = function(e, t, i) {
      return t + (i ? pO(e, t).length : 1);
    },
    xO = function(e, t) {
      var i = e.exec;
      if (mO(i)) {
        var s = fO(i, e, t);
        return null !== s && EO(s), s;
      }
      if ("RegExp" === gO(e)) return fO(_O, e, t);
      throw new TO("RegExp#exec called on incompatible receiver");
    },
    FO = ka,
    BO = ft("matchAll"),
    VO = "RegExp String",
    GO = VO + " Iterator",
    jO = FO.set,
    HO = FO.getterFor(GO),
    KO = TypeError,
    WO = RO("".indexOf),
    YO = RO("".matchAll),
    $O =
      !!YO &&
      !kO(function() {
        YO("a", /./);
      }),
    qO = yO(
      function(e, t, i, s) {
        jO(this, {
          type: GO,
          regexp: e,
          string: t,
          global: i,
          unicode: s,
          done: !1
        });
      },
      VO,
      function() {
        var e = HO(this);
        if (e.done) return AO(void 0, !0);
        var t = e.regexp,
          i = e.string,
          s = xO(t, i);
        return null === s
          ? ((e.done = !0), AO(void 0, !0))
          : e.global
          ? ("" === bO(s[0]) &&
              (t.lastIndex = UO(i, CO(t.lastIndex), e.unicode)),
            AO(s, !1))
          : ((e.done = !0), AO(s, !1));
      }
    ),
    XO = function(e) {
      var t,
        i,
        s,
        r = OO(this),
        n = bO(e),
        a = MO(r, RegExp),
        o = bO(NO(r));
      return (
        (t = new a(a === RegExp ? r.source : r, o)),
        (i = !!~WO(o, "g")),
        (s = !!~WO(o, "u")),
        (t.lastIndex = CO(r.lastIndex)),
        new qO(t, n, i, s)
      );
    };
  SO(
    { target: "String", proto: !0, forced: $O },
    {
      matchAll: function(e) {
        var t,
          i,
          s,
          r,
          n = IO(this);
        if (DO(e)) {
          if ($O) return YO(n, e);
        } else {
          if (LO(e) && ((t = bO(IO(NO(e)))), !~WO(t, "g")))
            throw new KO("`.matchAll` does not allow non-global regexes");
          if ($O) return YO(n, e);
          if ((void 0 === (s = PO(e, BO)) && "RegExp" === wO(e) && (s = XO), s))
            return vO(s, e, n);
        }
        return (i = bO(n)), (r = new RegExp(e, "g")), vO(XO, r, i);
      }
    }
  );
  var zO = ls("String", "matchAll"),
    JO = h,
    QO = zO,
    ZO = String.prototype,
    eD = function(e) {
      var t = e.matchAll;
      return "string" == typeof e ||
        e === ZO ||
        (JO(ZO, e) && t === ZO.matchAll)
        ? QO
        : t;
    },
    tD = s(eD);
  function iD(e) {
    function t(e, i, s, r) {
      let n = e[r++];
      if ("__proto__" === n) return !0;
      const a = Number.isFinite(+n),
        o = r >= e.length;
      if (((n = !n && QI.isArray(s) ? s.length : n), o))
        return QI.hasOwnProp(s, n) ? (s[n] = [s[n], i]) : (s[n] = i), !a;
      (s[n] && QI.isObject(s[n])) || (s[n] = []);
      return (
        t(e, i, s[n], r) &&
          QI.isArray(s[n]) &&
          (s[n] = (function(e) {
            const t = {},
              i = Object.keys(e);
            let s;
            const r = i.length;
            let n;
            for (s = 0; s < r; s++) (n = i[s]), (t[n] = e[n]);
            return t;
          })(s[n])),
        !a
      );
    }
    if (QI.isFormData(e) && QI.isFunction(e.entries)) {
      const i = {};
      return (
        QI.forEachEntry(e, (e, s) => {
          t(
            (function(e) {
              return tD(QI)
                .call(QI, /\w+|\[(\w*)]/g, e)
                .map(e => ("[]" === e[0] ? "" : e[1] || e[0]));
            })(e),
            s,
            i,
            0
          );
        }),
        i
      );
    }
    return null;
  }
  const sD = {
    transitional: pC,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [
      function(e, t) {
        const i = t.getContentType() || "",
          s = i.indexOf("application/json") > -1,
          r = QI.isObject(e);
        r && QI.isHTMLForm(e) && (e = new FormData(e));
        if (QI.isFormData(e)) return s ? JSON.stringify(iD(e)) : e;
        if (
          QI.isArrayBuffer(e) ||
          QI.isBuffer(e) ||
          QI.isStream(e) ||
          QI.isFile(e) ||
          QI.isBlob(e) ||
          QI.isReadableStream(e)
        )
          return e;
        if (QI.isArrayBufferView(e)) return e.buffer;
        if (QI.isURLSearchParams(e))
          return (
            t.setContentType(
              "application/x-www-form-urlencoded;charset=utf-8",
              !1
            ),
            e.toString()
          );
        let n;
        if (r) {
          if (i.indexOf("application/x-www-form-urlencoded") > -1)
            return (function(e, t) {
              return aC(
                e,
                new iO.classes.URLSearchParams(),
                Object.assign(
                  {
                    visitor: function(e, t, i, s) {
                      return iO.isNode && QI.isBuffer(e)
                        ? (this.append(t, e.toString("base64")), !1)
                        : s.defaultVisitor.apply(this, arguments);
                    }
                  },
                  t
                )
              );
            })(e, this.formSerializer).toString();
          if ((n = QI.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
            const t = this.env && this.env.FormData;
            return aC(
              n ? { "files[]": e } : e,
              t && new t(),
              this.formSerializer
            );
          }
        }
        return r || s
          ? (t.setContentType("application/json", !1),
            (function(e, t, i) {
              if (QI.isString(e))
                try {
                  return (t || JSON.parse)(e), ms(QI).call(QI, e);
                } catch (e) {
                  if ("SyntaxError" !== e.name) throw e;
                }
              return (i || JSON.stringify)(e);
            })(e))
          : e;
      }
    ],
    transformResponse: [
      function(e) {
        const t = this.transitional || sD.transitional,
          i = t && t.forcedJSONParsing,
          s = "json" === this.responseType;
        if (QI.isResponse(e) || QI.isReadableStream(e)) return e;
        if (e && QI.isString(e) && ((i && !this.responseType) || s)) {
          const i = !(t && t.silentJSONParsing) && s;
          try {
            return JSON.parse(e);
          } catch (e) {
            if (i) {
              if ("SyntaxError" === e.name)
                throw ZI.from(
                  e,
                  ZI.ERR_BAD_RESPONSE,
                  this,
                  null,
                  this.response
                );
              throw e;
            }
          }
        }
        return e;
      }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: { FormData: iO.classes.FormData, Blob: iO.classes.Blob },
    validateStatus: function(e) {
      return e >= 200 && e < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  QI.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
    sD.headers[e] = {};
  });
  var rD = sD;
  const nD = QI.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const aD = Symbol("internals");
  function oD(e) {
    var t;
    return (
      e &&
      ms((t = String(e)))
        .call(t)
        .toLowerCase()
    );
  }
  function cD(e) {
    return !1 === e || null == e ? e : QI.isArray(e) ? e.map(cD) : String(e);
  }
  function dD(e, t, i, s, r) {
    return QI.isFunction(s)
      ? s.call(this, t, i)
      : (r && (t = i),
        QI.isString(t)
          ? QI.isString(s)
            ? -1 !== t.indexOf(s)
            : QI.isRegExp(s)
            ? s.test(t)
            : void 0
          : void 0);
  }
  class lD {
    constructor(e) {
      e && this.set(e);
    }
    set(e, t, i) {
      const s = this;
      function r(e, t, i) {
        const r = oD(t);
        if (!r) throw new Error("header name must be a non-empty string");
        const n = QI.findKey(s, r);
        (!n || void 0 === s[n] || !0 === i || (void 0 === i && !1 !== s[n])) &&
          (s[n || t] = cD(e));
      }
      const n = (e, t) => QI.forEach(e, (e, i) => r(e, i, t));
      if (QI.isPlainObject(e) || e instanceof this.constructor) n(e, t);
      else if (
        QI.isString(e) &&
        (e = ms(e).call(e)) &&
        !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(ms((a = e)).call(a))
      )
        n(
          (e => {
            const t = {};
            let i, s, r;
            return (
              e &&
                e.split("\n").forEach(function(e) {
                  var n, a;
                  (r = e.indexOf(":")),
                    (i = ms((n = e.substring(0, r)))
                      .call(n)
                      .toLowerCase()),
                    (s = ms((a = e.substring(r + 1))).call(a)),
                    !i ||
                      (t[i] && nD[i]) ||
                      ("set-cookie" === i
                        ? t[i]
                          ? t[i].push(s)
                          : (t[i] = [s])
                        : (t[i] = t[i] ? t[i] + ", " + s : s));
                }),
              t
            );
          })(e),
          t
        );
      else if (QI.isHeaders(e)) for (const [t, s] of e.entries()) r(s, t, i);
      else null != e && r(t, e, i);
      var a;
      return this;
    }
    get(e, t) {
      if ((e = oD(e))) {
        const i = QI.findKey(this, e);
        if (i) {
          const e = this[i];
          if (!t) return e;
          if (!0 === t)
            return (function(e) {
              const t = Object.create(null),
                i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
              let s;
              for (; (s = i.exec(e)); ) t[s[1]] = s[2];
              return t;
            })(e);
          if (QI.isFunction(t)) return t.call(this, e, i);
          if (QI.isRegExp(t)) return t.exec(e);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(e, t) {
      if ((e = oD(e))) {
        const i = QI.findKey(this, e);
        return !(!i || void 0 === this[i] || (t && !dD(0, this[i], i, t)));
      }
      return !1;
    }
    delete(e, t) {
      const i = this;
      let s = !1;
      function r(e) {
        if ((e = oD(e))) {
          const r = QI.findKey(i, e);
          !r || (t && !dD(0, i[r], r, t)) || (delete i[r], (s = !0));
        }
      }
      return QI.isArray(e) ? e.forEach(r) : r(e), s;
    }
    clear(e) {
      const t = Object.keys(this);
      let i = t.length,
        s = !1;
      for (; i--; ) {
        const r = t[i];
        (e && !dD(0, this[r], r, e, !0)) || (delete this[r], (s = !0));
      }
      return s;
    }
    normalize(e) {
      const t = this,
        i = {};
      return (
        QI.forEach(this, (s, r) => {
          var n;
          const a = QI.findKey(i, r);
          if (a) return (t[a] = cD(s)), void delete t[r];
          const o = e
            ? (function(e) {
                return ms(e)
                  .call(e)
                  .toLowerCase()
                  .replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
              })(r)
            : ms((n = String(r))).call(n);
          o !== r && delete t[r], (t[o] = cD(s)), (i[o] = !0);
        }),
        this
      );
    }
    concat() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      return this.constructor.concat(this, ...t);
    }
    toJSON(e) {
      const t = Object.create(null);
      return (
        QI.forEach(this, (i, s) => {
          null != i &&
            !1 !== i &&
            (t[s] = e && QI.isArray(i) ? i.join(", ") : i);
        }),
        t
      );
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON())
        .map(e => {
          let [t, i] = e;
          return t + ": " + i;
        })
        .join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(e) {
      return e instanceof this ? e : new this(e);
    }
    static concat(e) {
      const t = new this(e);
      for (
        var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), r = 1;
        r < i;
        r++
      )
        s[r - 1] = arguments[r];
      return s.forEach(e => t.set(e)), t;
    }
    static accessor(e) {
      const t = (this[aD] = this[aD] = { accessors: {} }).accessors,
        i = this.prototype;
      function s(e) {
        const s = oD(e);
        t[s] ||
          (!(function(e, t) {
            const i = QI.toCamelCase(" " + t);
            ["get", "set", "has"].forEach(s => {
              Object.defineProperty(e, s + i, {
                value: function(e, i, r) {
                  return this[s].call(this, t, e, i, r);
                },
                configurable: !0
              });
            });
          })(i, e),
          (t[s] = !0));
      }
      return QI.isArray(e) ? e.forEach(s) : s(e), this;
    }
  }
  lD.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
  ]),
    QI.reduceDescriptors(lD.prototype, (e, t) => {
      let { value: i } = e,
        s = t[0].toUpperCase() + t.slice(1);
      return {
        get: () => i,
        set(e) {
          this[s] = e;
        }
      };
    }),
    QI.freezeMethods(lD);
  var hD = lD;
  function uD(e, t) {
    const i = this || rD,
      s = t || i,
      r = hD.from(s.headers);
    let n = s.data;
    return (
      QI.forEach(e, function(e) {
        n = e.call(i, n, r.normalize(), t ? t.status : void 0);
      }),
      r.normalize(),
      n
    );
  }
  function pD(e) {
    return !(!e || !e.__CANCEL__);
  }
  function fD(e, t, i) {
    ZI.call(this, null == e ? "canceled" : e, ZI.ERR_CANCELED, t, i),
      (this.name = "CanceledError");
  }
  function ED(e, t, i) {
    const s = i.config.validateStatus;
    i.status && s && !s(i.status)
      ? t(
          new ZI(
            "Request failed with status code " + i.status,
            [ZI.ERR_BAD_REQUEST, ZI.ERR_BAD_RESPONSE][
              Math.floor(i.status / 100) - 4
            ],
            i.config,
            i.request,
            i
          )
        )
      : e(i);
  }
  QI.inherits(fD, ZI, { __CANCEL__: !0 });
  const mD = function(e, t) {
      let i =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3,
        s = 0;
      const r = (function(e, t) {
        e = e || 10;
        const i = new Array(e),
          s = new Array(e);
        let r,
          n = 0,
          a = 0;
        return (
          (t = void 0 !== t ? t : 1e3),
          function(o) {
            const c = Date.now(),
              d = s[a];
            r || (r = c), (i[n] = o), (s[n] = c);
            let l = a,
              h = 0;
            for (; l !== n; ) (h += i[l++]), (l %= e);
            if (((n = (n + 1) % e), n === a && (a = (a + 1) % e), c - r < t))
              return;
            const u = d && c - d;
            return u ? Math.round((1e3 * h) / u) : void 0;
          }
        );
      })(50, 250);
      return (function(e, t) {
        let i,
          s,
          r = 0,
          n = 1e3 / t;
        const a = function(t) {
          let n =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : Date.now();
          (r = n),
            (i = null),
            s && (clearTimeout(s), (s = null)),
            e.apply(null, t);
        };
        return [
          function() {
            const e = Date.now(),
              t = e - r;
            for (var o = arguments.length, c = new Array(o), d = 0; d < o; d++)
              c[d] = arguments[d];
            t >= n
              ? a(c, e)
              : ((i = c),
                s ||
                  (s = setTimeout(() => {
                    (s = null), a(i);
                  }, n - t)));
          },
          () => i && a(i)
        ];
      })(i => {
        const n = i.loaded,
          a = i.lengthComputable ? i.total : void 0,
          o = n - s,
          c = r(o);
        s = n;
        e({
          loaded: n,
          total: a,
          progress: a ? n / a : void 0,
          bytes: o,
          rate: c || void 0,
          estimated: c && a && n <= a ? (a - n) / c : void 0,
          event: i,
          lengthComputable: null != a,
          [t ? "download" : "upload"]: !0
        });
      }, i);
    },
    gD = (e, t) => {
      const i = null != e;
      return [s => t[0]({ lengthComputable: i, total: e, loaded: s }), t[1]];
    },
    _D = e =>
      function() {
        for (var t = arguments.length, i = new Array(t), s = 0; s < t; s++)
          i[s] = arguments[s];
        return QI.asap(() => e(...i));
      };
  var TD,
    SD = D,
    vD = l,
    RD = N,
    yD = r,
    AD = wr,
    ID = mr,
    CD = P,
    bD = Je,
    OD = K,
    DD = Object.assign,
    wD = Object.defineProperty,
    LD = vD([].concat),
    ND =
      !DD ||
      yD(function() {
        if (
          SD &&
          1 !==
            DD(
              { b: 1 },
              DD(
                wD({}, "a", {
                  enumerable: !0,
                  get: function() {
                    wD(this, "b", { value: 3, enumerable: !1 });
                  }
                }),
                { b: 2 }
              )
            ).b
        )
          return !0;
        var e = {},
          t = {},
          i = Symbol("assign detection"),
          s = "abcdefghijklmnopqrst";
        return (
          (e[i] = 7),
          s.split("").forEach(function(e) {
            t[e] = e;
          }),
          7 !== DD({}, e)[i] || AD(DD({}, t)).join("") !== s
        );
      })
        ? function(e, t) {
            for (
              var i = bD(e), s = arguments.length, r = 1, n = ID.f, a = CD.f;
              s > r;

            )
              for (
                var o,
                  c = OD(arguments[r++]),
                  d = n ? LD(AD(c), n(c)) : AD(c),
                  l = d.length,
                  h = 0;
                l > h;

              )
                (o = d[h++]), (SD && !RD(a, c, o)) || (i[o] = c[o]);
            return i;
          }
        : DD,
    PD = ri,
    kD = kn,
    MD = Qt,
    UD = N,
    xD = Je,
    FD = function(e, t, i, s) {
      try {
        return s ? t(PD(i)[0], i[1]) : t(i);
      } catch (t) {
        kD(e, "throw", t);
      }
    },
    BD = gn,
    VD = gc,
    GD = er,
    jD = Uu,
    HD = wn,
    KD = yn,
    WD = Array,
    YD = l,
    $D = 2147483647,
    qD = /[^\0-\u007E]/,
    XD = /[.\u3002\uFF0E\uFF61]/g,
    zD = "Overflow: input needs wider integers to process",
    JD = RangeError,
    QD = YD(XD.exec),
    ZD = Math.floor,
    ew = String.fromCharCode,
    tw = YD("".charCodeAt),
    iw = YD([].join),
    sw = YD([].push),
    rw = YD("".replace),
    nw = YD("".split),
    aw = YD("".toLowerCase),
    ow = function(e) {
      return e + 22 + 75 * (e < 26);
    },
    cw = function(e, t, i) {
      var s = 0;
      for (e = i ? ZD(e / 700) : e >> 1, e += ZD(e / t); e > 455; )
        (e = ZD(e / 35)), (s += 36);
      return ZD(s + (36 * e) / (e + 38));
    },
    dw = function(e) {
      var t = [];
      e = (function(e) {
        for (var t = [], i = 0, s = e.length; i < s; ) {
          var r = tw(e, i++);
          if (r >= 55296 && r <= 56319 && i < s) {
            var n = tw(e, i++);
            56320 == (64512 & n)
              ? sw(t, ((1023 & r) << 10) + (1023 & n) + 65536)
              : (sw(t, r), i--);
          } else sw(t, r);
        }
        return t;
      })(e);
      var i,
        s,
        r = e.length,
        n = 128,
        a = 0,
        o = 72;
      for (i = 0; i < e.length; i++) (s = e[i]) < 128 && sw(t, ew(s));
      var c = t.length,
        d = c;
      for (c && sw(t, "-"); d < r; ) {
        var l = $D;
        for (i = 0; i < e.length; i++) (s = e[i]) >= n && s < l && (l = s);
        var h = d + 1;
        if (l - n > ZD(($D - a) / h)) throw new JD(zD);
        for (a += (l - n) * h, n = l, i = 0; i < e.length; i++) {
          if ((s = e[i]) < n && ++a > $D) throw new JD(zD);
          if (s === n) {
            for (var u = a, p = 36; ; ) {
              var f = p <= o ? 1 : p >= o + 26 ? 26 : p - o;
              if (u < f) break;
              var E = u - f,
                m = 36 - f;
              sw(t, ew(ow(f + (E % m)))), (u = ZD(E / m)), (p += 36);
            }
            sw(t, ew(ow(u))), (o = cw(a, h, d === c)), (a = 0), d++;
          }
        }
        a++, n++;
      }
      return iw(t, "");
    },
    lw = wi,
    hw = D,
    uw = yC,
    pw = p,
    fw = Qt,
    Ew = l,
    mw = Ua,
    gw = Ho,
    _w = zo,
    Tw = et,
    Sw = ND,
    vw = function(e) {
      var t = xD(e),
        i = VD(this),
        s = arguments.length,
        r = s > 1 ? arguments[1] : void 0,
        n = void 0 !== r;
      n && (r = MD(r, s > 2 ? arguments[2] : void 0));
      var a,
        o,
        c,
        d,
        l,
        h,
        u = KD(t),
        p = 0;
      if (!u || (this === WD && BD(u)))
        for (a = GD(t), o = i ? new this(a) : WD(a); a > p; p++)
          (h = n ? r(t[p], p) : t[p]), jD(o, p, h);
      else
        for (
          o = i ? new this() : [], l = (d = HD(t, u)).next;
          !(c = UD(l, d)).done;
          p++
        )
          (h = n ? FD(d, r, [c.value, p], !0) : c.value), jD(o, p, h);
      return (o.length = p), o;
    },
    Rw = Cc,
    yw = au.codeAt,
    Aw = function(e) {
      var t,
        i,
        s = [],
        r = nw(rw(aw(e), XD, "."), ".");
      for (t = 0; t < r.length; t++)
        (i = r[t]), sw(s, QD(qD, i) ? "xn--" + dw(i) : i);
      return iw(s, ".");
    },
    Iw = ji,
    Cw = to,
    bw = Oc,
    Ow = Yb,
    Dw = ka,
    ww = Dw.set,
    Lw = Dw.getterFor("URL"),
    Nw = Ow.URLSearchParams,
    Pw = Ow.getState,
    kw = pw.URL,
    Mw = pw.TypeError,
    Uw = pw.parseInt,
    xw = Math.floor,
    Fw = Math.pow,
    Bw = Ew("".charAt),
    Vw = Ew(/./.exec),
    Gw = Ew([].join),
    jw = Ew((1).toString),
    Hw = Ew([].pop),
    Kw = Ew([].push),
    Ww = Ew("".replace),
    Yw = Ew([].shift),
    $w = Ew("".split),
    qw = Ew("".slice),
    Xw = Ew("".toLowerCase),
    zw = Ew([].unshift),
    Jw = "Invalid scheme",
    Qw = "Invalid host",
    Zw = "Invalid port",
    eL = /[a-z]/i,
    tL = /[\d+-.a-z]/i,
    iL = /\d/,
    sL = /^0x/i,
    rL = /^[0-7]+$/,
    nL = /^\d+$/,
    aL = /^[\da-f]+$/i,
    oL = /[\0\t\n\r #%/:<>?@[\\\]^|]/,
    cL = /[\0\t\n\r #/:<>?@[\\\]^|]/,
    dL = /^[\u0000-\u0020]+/,
    lL = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/,
    hL = /[\t\n\r]/g,
    uL = function(e) {
      var t, i, s, r;
      if ("number" == typeof e) {
        for (t = [], i = 0; i < 4; i++) zw(t, e % 256), (e = xw(e / 256));
        return Gw(t, ".");
      }
      if ("object" == typeof e) {
        for (
          t = "",
            s = (function(e) {
              for (var t = null, i = 1, s = null, r = 0, n = 0; n < 8; n++)
                0 !== e[n]
                  ? (r > i && ((t = s), (i = r)), (s = null), (r = 0))
                  : (null === s && (s = n), ++r);
              return r > i ? s : t;
            })(e),
            i = 0;
          i < 8;
          i++
        )
          (r && 0 === e[i]) ||
            (r && (r = !1),
            s === i
              ? ((t += i ? ":" : "::"), (r = !0))
              : ((t += jw(e[i], 16)), i < 7 && (t += ":")));
        return "[" + t + "]";
      }
      return e;
    },
    pL = {},
    fL = Sw({}, pL, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }),
    EL = Sw({}, fL, { "#": 1, "?": 1, "{": 1, "}": 1 }),
    mL = Sw({}, EL, {
      "/": 1,
      ":": 1,
      ";": 1,
      "=": 1,
      "@": 1,
      "[": 1,
      "\\": 1,
      "]": 1,
      "^": 1,
      "|": 1
    }),
    gL = function(e, t) {
      var i = yw(e, 0);
      return i > 32 && i < 127 && !Tw(t, e) ? e : encodeURIComponent(e);
    },
    _L = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 },
    TL = function(e, t) {
      var i;
      return (
        2 === e.length &&
        Vw(eL, Bw(e, 0)) &&
        (":" === (i = Bw(e, 1)) || (!t && "|" === i))
      );
    },
    SL = function(e) {
      var t;
      return (
        e.length > 1 &&
        TL(qw(e, 0, 2)) &&
        (2 === e.length ||
          "/" === (t = Bw(e, 2)) ||
          "\\" === t ||
          "?" === t ||
          "#" === t)
      );
    },
    vL = function(e) {
      return "." === e || "%2e" === Xw(e);
    },
    RL = {},
    yL = {},
    AL = {},
    IL = {},
    CL = {},
    bL = {},
    OL = {},
    DL = {},
    wL = {},
    LL = {},
    NL = {},
    PL = {},
    kL = {},
    ML = {},
    UL = {},
    xL = {},
    FL = {},
    BL = {},
    VL = {},
    GL = {},
    jL = {},
    HL = function(e, t, i) {
      var s,
        r,
        n,
        a = Iw(e);
      if (t) {
        if ((r = this.parse(a))) throw new Mw(r);
        this.searchParams = null;
      } else {
        if ((void 0 !== i && (s = new HL(i, !0)), (r = this.parse(a, null, s))))
          throw new Mw(r);
        (n = Pw(new Nw())).bindURL(this), (this.searchParams = n);
      }
    };
  HL.prototype = {
    type: "URL",
    parse: function(e, t, i) {
      var s,
        r,
        n,
        a,
        o,
        c = this,
        d = t || RL,
        l = 0,
        h = "",
        u = !1,
        p = !1,
        f = !1;
      for (
        e = Iw(e),
          t ||
            ((c.scheme = ""),
            (c.username = ""),
            (c.password = ""),
            (c.host = null),
            (c.port = null),
            (c.path = []),
            (c.query = null),
            (c.fragment = null),
            (c.cannotBeABaseURL = !1),
            (e = Ww(e, dL, "")),
            (e = Ww(e, lL, "$1"))),
          e = Ww(e, hL, ""),
          s = vw(e);
        l <= s.length;

      ) {
        switch (((r = s[l]), d)) {
          case RL:
            if (!r || !Vw(eL, r)) {
              if (t) return Jw;
              d = AL;
              continue;
            }
            (h += Xw(r)), (d = yL);
            break;
          case yL:
            if (r && (Vw(tL, r) || "+" === r || "-" === r || "." === r))
              h += Xw(r);
            else {
              if (":" !== r) {
                if (t) return Jw;
                (h = ""), (d = AL), (l = 0);
                continue;
              }
              if (
                t &&
                (c.isSpecial() !== Tw(_L, h) ||
                  ("file" === h &&
                    (c.includesCredentials() || null !== c.port)) ||
                  ("file" === c.scheme && !c.host))
              )
                return;
              if (((c.scheme = h), t))
                return void (
                  c.isSpecial() &&
                  _L[c.scheme] === c.port &&
                  (c.port = null)
                );
              (h = ""),
                "file" === c.scheme
                  ? (d = ML)
                  : c.isSpecial() && i && i.scheme === c.scheme
                  ? (d = IL)
                  : c.isSpecial()
                  ? (d = DL)
                  : "/" === s[l + 1]
                  ? ((d = CL), l++)
                  : ((c.cannotBeABaseURL = !0), Kw(c.path, ""), (d = VL));
            }
            break;
          case AL:
            if (!i || (i.cannotBeABaseURL && "#" !== r)) return Jw;
            if (i.cannotBeABaseURL && "#" === r) {
              (c.scheme = i.scheme),
                (c.path = Rw(i.path)),
                (c.query = i.query),
                (c.fragment = ""),
                (c.cannotBeABaseURL = !0),
                (d = jL);
              break;
            }
            d = "file" === i.scheme ? ML : bL;
            continue;
          case IL:
            if ("/" !== r || "/" !== s[l + 1]) {
              d = bL;
              continue;
            }
            (d = wL), l++;
            break;
          case CL:
            if ("/" === r) {
              d = LL;
              break;
            }
            d = BL;
            continue;
          case bL:
            if (((c.scheme = i.scheme), r === TD))
              (c.username = i.username),
                (c.password = i.password),
                (c.host = i.host),
                (c.port = i.port),
                (c.path = Rw(i.path)),
                (c.query = i.query);
            else if ("/" === r || ("\\" === r && c.isSpecial())) d = OL;
            else if ("?" === r)
              (c.username = i.username),
                (c.password = i.password),
                (c.host = i.host),
                (c.port = i.port),
                (c.path = Rw(i.path)),
                (c.query = ""),
                (d = GL);
            else {
              if ("#" !== r) {
                (c.username = i.username),
                  (c.password = i.password),
                  (c.host = i.host),
                  (c.port = i.port),
                  (c.path = Rw(i.path)),
                  c.path.length--,
                  (d = BL);
                continue;
              }
              (c.username = i.username),
                (c.password = i.password),
                (c.host = i.host),
                (c.port = i.port),
                (c.path = Rw(i.path)),
                (c.query = i.query),
                (c.fragment = ""),
                (d = jL);
            }
            break;
          case OL:
            if (!c.isSpecial() || ("/" !== r && "\\" !== r)) {
              if ("/" !== r) {
                (c.username = i.username),
                  (c.password = i.password),
                  (c.host = i.host),
                  (c.port = i.port),
                  (d = BL);
                continue;
              }
              d = LL;
            } else d = wL;
            break;
          case DL:
            if (((d = wL), "/" !== r || "/" !== Bw(h, l + 1))) continue;
            l++;
            break;
          case wL:
            if ("/" !== r && "\\" !== r) {
              d = LL;
              continue;
            }
            break;
          case LL:
            if ("@" === r) {
              u && (h = "%40" + h), (u = !0), (n = vw(h));
              for (var E = 0; E < n.length; E++) {
                var m = n[E];
                if (":" !== m || f) {
                  var g = gL(m, mL);
                  f ? (c.password += g) : (c.username += g);
                } else f = !0;
              }
              h = "";
            } else if (
              r === TD ||
              "/" === r ||
              "?" === r ||
              "#" === r ||
              ("\\" === r && c.isSpecial())
            ) {
              if (u && "" === h) return "Invalid authority";
              (l -= vw(h).length + 1), (h = ""), (d = NL);
            } else h += r;
            break;
          case NL:
          case PL:
            if (t && "file" === c.scheme) {
              d = xL;
              continue;
            }
            if (":" !== r || p) {
              if (
                r === TD ||
                "/" === r ||
                "?" === r ||
                "#" === r ||
                ("\\" === r && c.isSpecial())
              ) {
                if (c.isSpecial() && "" === h) return Qw;
                if (
                  t &&
                  "" === h &&
                  (c.includesCredentials() || null !== c.port)
                )
                  return;
                if ((a = c.parseHost(h))) return a;
                if (((h = ""), (d = FL), t)) return;
                continue;
              }
              "[" === r ? (p = !0) : "]" === r && (p = !1), (h += r);
            } else {
              if ("" === h) return Qw;
              if ((a = c.parseHost(h))) return a;
              if (((h = ""), (d = kL), t === PL)) return;
            }
            break;
          case kL:
            if (!Vw(iL, r)) {
              if (
                r === TD ||
                "/" === r ||
                "?" === r ||
                "#" === r ||
                ("\\" === r && c.isSpecial()) ||
                t
              ) {
                if ("" !== h) {
                  var _ = Uw(h, 10);
                  if (_ > 65535) return Zw;
                  (c.port = c.isSpecial() && _ === _L[c.scheme] ? null : _),
                    (h = "");
                }
                if (t) return;
                d = FL;
                continue;
              }
              return Zw;
            }
            h += r;
            break;
          case ML:
            if (((c.scheme = "file"), "/" === r || "\\" === r)) d = UL;
            else {
              if (!i || "file" !== i.scheme) {
                d = BL;
                continue;
              }
              switch (r) {
                case TD:
                  (c.host = i.host), (c.path = Rw(i.path)), (c.query = i.query);
                  break;
                case "?":
                  (c.host = i.host),
                    (c.path = Rw(i.path)),
                    (c.query = ""),
                    (d = GL);
                  break;
                case "#":
                  (c.host = i.host),
                    (c.path = Rw(i.path)),
                    (c.query = i.query),
                    (c.fragment = ""),
                    (d = jL);
                  break;
                default:
                  SL(Gw(Rw(s, l), "")) ||
                    ((c.host = i.host), (c.path = Rw(i.path)), c.shortenPath()),
                    (d = BL);
                  continue;
              }
            }
            break;
          case UL:
            if ("/" === r || "\\" === r) {
              d = xL;
              break;
            }
            i &&
              "file" === i.scheme &&
              !SL(Gw(Rw(s, l), "")) &&
              (TL(i.path[0], !0) ? Kw(c.path, i.path[0]) : (c.host = i.host)),
              (d = BL);
            continue;
          case xL:
            if (r === TD || "/" === r || "\\" === r || "?" === r || "#" === r) {
              if (!t && TL(h)) d = BL;
              else if ("" === h) {
                if (((c.host = ""), t)) return;
                d = FL;
              } else {
                if ((a = c.parseHost(h))) return a;
                if (("localhost" === c.host && (c.host = ""), t)) return;
                (h = ""), (d = FL);
              }
              continue;
            }
            h += r;
            break;
          case FL:
            if (c.isSpecial()) {
              if (((d = BL), "/" !== r && "\\" !== r)) continue;
            } else if (t || "?" !== r)
              if (t || "#" !== r) {
                if (r !== TD && ((d = BL), "/" !== r)) continue;
              } else (c.fragment = ""), (d = jL);
            else (c.query = ""), (d = GL);
            break;
          case BL:
            if (
              r === TD ||
              "/" === r ||
              ("\\" === r && c.isSpecial()) ||
              (!t && ("?" === r || "#" === r))
            ) {
              if (
                (".." === (o = Xw((o = h))) ||
                "%2e." === o ||
                ".%2e" === o ||
                "%2e%2e" === o
                  ? (c.shortenPath(),
                    "/" === r ||
                      ("\\" === r && c.isSpecial()) ||
                      Kw(c.path, ""))
                  : vL(h)
                  ? "/" === r || ("\\" === r && c.isSpecial()) || Kw(c.path, "")
                  : ("file" === c.scheme &&
                      !c.path.length &&
                      TL(h) &&
                      (c.host && (c.host = ""), (h = Bw(h, 0) + ":")),
                    Kw(c.path, h)),
                (h = ""),
                "file" === c.scheme && (r === TD || "?" === r || "#" === r))
              )
                for (; c.path.length > 1 && "" === c.path[0]; ) Yw(c.path);
              "?" === r
                ? ((c.query = ""), (d = GL))
                : "#" === r && ((c.fragment = ""), (d = jL));
            } else h += gL(r, EL);
            break;
          case VL:
            "?" === r
              ? ((c.query = ""), (d = GL))
              : "#" === r
              ? ((c.fragment = ""), (d = jL))
              : r !== TD && (c.path[0] += gL(r, pL));
            break;
          case GL:
            t || "#" !== r
              ? r !== TD &&
                ("'" === r && c.isSpecial()
                  ? (c.query += "%27")
                  : (c.query += "#" === r ? "%23" : gL(r, pL)))
              : ((c.fragment = ""), (d = jL));
            break;
          case jL:
            r !== TD && (c.fragment += gL(r, fL));
        }
        l++;
      }
    },
    parseHost: function(e) {
      var t, i, s;
      if ("[" === Bw(e, 0)) {
        if ("]" !== Bw(e, e.length - 1)) return Qw;
        if (
          ((t = (function(e) {
            var t,
              i,
              s,
              r,
              n,
              a,
              o,
              c = [0, 0, 0, 0, 0, 0, 0, 0],
              d = 0,
              l = null,
              h = 0,
              u = function() {
                return Bw(e, h);
              };
            if (":" === u()) {
              if (":" !== Bw(e, 1)) return;
              (h += 2), (l = ++d);
            }
            for (; u(); ) {
              if (8 === d) return;
              if (":" !== u()) {
                for (t = i = 0; i < 4 && Vw(aL, u()); )
                  (t = 16 * t + Uw(u(), 16)), h++, i++;
                if ("." === u()) {
                  if (0 === i) return;
                  if (((h -= i), d > 6)) return;
                  for (s = 0; u(); ) {
                    if (((r = null), s > 0)) {
                      if (!("." === u() && s < 4)) return;
                      h++;
                    }
                    if (!Vw(iL, u())) return;
                    for (; Vw(iL, u()); ) {
                      if (((n = Uw(u(), 10)), null === r)) r = n;
                      else {
                        if (0 === r) return;
                        r = 10 * r + n;
                      }
                      if (r > 255) return;
                      h++;
                    }
                    (c[d] = 256 * c[d] + r), (2 != ++s && 4 !== s) || d++;
                  }
                  if (4 !== s) return;
                  break;
                }
                if (":" === u()) {
                  if ((h++, !u())) return;
                } else if (u()) return;
                c[d++] = t;
              } else {
                if (null !== l) return;
                h++, (l = ++d);
              }
            }
            if (null !== l)
              for (a = d - l, d = 7; 0 !== d && a > 0; )
                (o = c[d]), (c[d--] = c[l + a - 1]), (c[l + --a] = o);
            else if (8 !== d) return;
            return c;
          })(qw(e, 1, -1))),
          !t)
        )
          return Qw;
        this.host = t;
      } else if (this.isSpecial()) {
        if (((e = Aw(e)), Vw(oL, e))) return Qw;
        if (
          ((t = (function(e) {
            var t,
              i,
              s,
              r,
              n,
              a,
              o,
              c = $w(e, ".");
            if (
              (c.length && "" === c[c.length - 1] && c.length--,
              (t = c.length) > 4)
            )
              return e;
            for (i = [], s = 0; s < t; s++) {
              if ("" === (r = c[s])) return e;
              if (
                ((n = 10),
                r.length > 1 &&
                  "0" === Bw(r, 0) &&
                  ((n = Vw(sL, r) ? 16 : 8), (r = qw(r, 8 === n ? 1 : 2))),
                "" === r)
              )
                a = 0;
              else {
                if (!Vw(10 === n ? nL : 8 === n ? rL : aL, r)) return e;
                a = Uw(r, n);
              }
              Kw(i, a);
            }
            for (s = 0; s < t; s++)
              if (((a = i[s]), s === t - 1)) {
                if (a >= Fw(256, 5 - t)) return null;
              } else if (a > 255) return null;
            for (o = Hw(i), s = 0; s < i.length; s++)
              o += i[s] * Fw(256, 3 - s);
            return o;
          })(e)),
          null === t)
        )
          return Qw;
        this.host = t;
      } else {
        if (Vw(cL, e)) return Qw;
        for (t = "", i = vw(e), s = 0; s < i.length; s++) t += gL(i[s], pL);
        this.host = t;
      }
    },
    cannotHaveUsernamePasswordPort: function() {
      return !this.host || this.cannotBeABaseURL || "file" === this.scheme;
    },
    includesCredentials: function() {
      return "" !== this.username || "" !== this.password;
    },
    isSpecial: function() {
      return Tw(_L, this.scheme);
    },
    shortenPath: function() {
      var e = this.path,
        t = e.length;
      !t || ("file" === this.scheme && 1 === t && TL(e[0], !0)) || e.length--;
    },
    serialize: function() {
      var e = this,
        t = e.scheme,
        i = e.username,
        s = e.password,
        r = e.host,
        n = e.port,
        a = e.path,
        o = e.query,
        c = e.fragment,
        d = t + ":";
      return (
        null !== r
          ? ((d += "//"),
            e.includesCredentials() && (d += i + (s ? ":" + s : "") + "@"),
            (d += uL(r)),
            null !== n && (d += ":" + n))
          : "file" === t && (d += "//"),
        (d += e.cannotBeABaseURL ? a[0] : a.length ? "/" + Gw(a, "/") : ""),
        null !== o && (d += "?" + o),
        null !== c && (d += "#" + c),
        d
      );
    },
    setHref: function(e) {
      var t = this.parse(e);
      if (t) throw new Mw(t);
      this.searchParams.update();
    },
    getOrigin: function() {
      var e = this.scheme,
        t = this.port;
      if ("blob" === e)
        try {
          return new KL(e.path[0]).origin;
        } catch (e) {
          return "null";
        }
      return "file" !== e && this.isSpecial()
        ? e + "://" + uL(this.host) + (null !== t ? ":" + t : "")
        : "null";
    },
    getProtocol: function() {
      return this.scheme + ":";
    },
    setProtocol: function(e) {
      this.parse(Iw(e) + ":", RL);
    },
    getUsername: function() {
      return this.username;
    },
    setUsername: function(e) {
      var t = vw(Iw(e));
      if (!this.cannotHaveUsernamePasswordPort()) {
        this.username = "";
        for (var i = 0; i < t.length; i++) this.username += gL(t[i], mL);
      }
    },
    getPassword: function() {
      return this.password;
    },
    setPassword: function(e) {
      var t = vw(Iw(e));
      if (!this.cannotHaveUsernamePasswordPort()) {
        this.password = "";
        for (var i = 0; i < t.length; i++) this.password += gL(t[i], mL);
      }
    },
    getHost: function() {
      var e = this.host,
        t = this.port;
      return null === e ? "" : null === t ? uL(e) : uL(e) + ":" + t;
    },
    setHost: function(e) {
      this.cannotBeABaseURL || this.parse(e, NL);
    },
    getHostname: function() {
      var e = this.host;
      return null === e ? "" : uL(e);
    },
    setHostname: function(e) {
      this.cannotBeABaseURL || this.parse(e, PL);
    },
    getPort: function() {
      var e = this.port;
      return null === e ? "" : Iw(e);
    },
    setPort: function(e) {
      this.cannotHaveUsernamePasswordPort() ||
        ("" === (e = Iw(e)) ? (this.port = null) : this.parse(e, kL));
    },
    getPathname: function() {
      var e = this.path;
      return this.cannotBeABaseURL ? e[0] : e.length ? "/" + Gw(e, "/") : "";
    },
    setPathname: function(e) {
      this.cannotBeABaseURL || ((this.path = []), this.parse(e, FL));
    },
    getSearch: function() {
      var e = this.query;
      return e ? "?" + e : "";
    },
    setSearch: function(e) {
      "" === (e = Iw(e))
        ? (this.query = null)
        : ("?" === Bw(e, 0) && (e = qw(e, 1)),
          (this.query = ""),
          this.parse(e, GL)),
        this.searchParams.update();
    },
    getSearchParams: function() {
      return this.searchParams.facade;
    },
    getHash: function() {
      var e = this.fragment;
      return e ? "#" + e : "";
    },
    setHash: function(e) {
      "" !== (e = Iw(e))
        ? ("#" === Bw(e, 0) && (e = qw(e, 1)),
          (this.fragment = ""),
          this.parse(e, jL))
        : (this.fragment = null);
    },
    update: function() {
      this.query = this.searchParams.serialize() || null;
    }
  };
  var KL = function(e) {
      var t = _w(this, WL),
        i = bw(arguments.length, 1) > 1 ? arguments[1] : void 0,
        s = ww(t, new HL(e, !1, i));
      hw ||
        ((t.href = s.serialize()),
        (t.origin = s.getOrigin()),
        (t.protocol = s.getProtocol()),
        (t.username = s.getUsername()),
        (t.password = s.getPassword()),
        (t.host = s.getHost()),
        (t.hostname = s.getHostname()),
        (t.port = s.getPort()),
        (t.pathname = s.getPathname()),
        (t.search = s.getSearch()),
        (t.searchParams = s.getSearchParams()),
        (t.hash = s.getHash()));
    },
    WL = KL.prototype,
    YL = function(e, t) {
      return {
        get: function() {
          return Lw(this)[e]();
        },
        set:
          t &&
          function(e) {
            return Lw(this)[t](e);
          },
        configurable: !0,
        enumerable: !0
      };
    };
  if (
    (hw &&
      (gw(WL, "href", YL("serialize", "setHref")),
      gw(WL, "origin", YL("getOrigin")),
      gw(WL, "protocol", YL("getProtocol", "setProtocol")),
      gw(WL, "username", YL("getUsername", "setUsername")),
      gw(WL, "password", YL("getPassword", "setPassword")),
      gw(WL, "host", YL("getHost", "setHost")),
      gw(WL, "hostname", YL("getHostname", "setHostname")),
      gw(WL, "port", YL("getPort", "setPort")),
      gw(WL, "pathname", YL("getPathname", "setPathname")),
      gw(WL, "search", YL("getSearch", "setSearch")),
      gw(WL, "searchParams", YL("getSearchParams")),
      gw(WL, "hash", YL("getHash", "setHash"))),
    mw(
      WL,
      "toJSON",
      function() {
        return Lw(this).serialize();
      },
      { enumerable: !0 }
    ),
    mw(
      WL,
      "toString",
      function() {
        return Lw(this).serialize();
      },
      { enumerable: !0 }
    ),
    kw)
  ) {
    var $L = kw.createObjectURL,
      qL = kw.revokeObjectURL;
    $L && mw(KL, "createObjectURL", fw($L, kw)),
      qL && mw(KL, "revokeObjectURL", fw(qL, kw));
  }
  Cw(KL, "URL"),
    lw({ global: !0, constructor: !0, forced: !uw, sham: !hw }, { URL: KL });
  var XL = wi,
    zL = r,
    JL = Oc,
    QL = ji,
    ZL = yC,
    eN = ne("URL"),
    tN =
      ZL &&
      zL(function() {
        eN.canParse();
      }),
    iN = zL(function() {
      return 1 !== eN.canParse.length;
    });
  XL(
    { target: "URL", stat: !0, forced: !tN || iN },
    {
      canParse: function(e) {
        var t = JL(arguments.length, 1),
          i = QL(e),
          s = t < 2 || void 0 === arguments[1] ? void 0 : QL(arguments[1]);
        try {
          return !!new eN(i, s);
        } catch (e) {
          return !1;
        }
      }
    }
  );
  var sN = wi,
    rN = Oc,
    nN = ji,
    aN = yC,
    oN = ne("URL");
  sN(
    { target: "URL", stat: !0, forced: !aN },
    {
      parse: function(e) {
        var t = rN(arguments.length, 1),
          i = nN(e),
          s = t < 2 || void 0 === arguments[1] ? void 0 : nN(arguments[1]);
        try {
          return new oN(i, s);
        } catch (e) {
          return null;
        }
      }
    }
  );
  var cN = s(ee.URL),
    dN = iO.hasStandardBrowserEnv
      ? ((e, t) => i => (
          (i = new cN(i, iO.origin)),
          e.protocol === i.protocol &&
            e.host === i.host &&
            (t || e.port === i.port)
        ))(
          new cN(iO.origin),
          iO.navigator && /(msie|trident)/i.test(iO.navigator.userAgent)
        )
      : () => !0,
    lN = iO.hasStandardBrowserEnv
      ? {
          write(e, t, i, s, r, n) {
            const a = [e + "=" + encodeURIComponent(t)];
            QI.isNumber(i) && a.push("expires=" + new Date(i).toGMTString()),
              QI.isString(s) && a.push("path=" + s),
              QI.isString(r) && a.push("domain=" + r),
              !0 === n && a.push("secure"),
              (document.cookie = a.join("; "));
          },
          read(e) {
            const t = document.cookie.match(
              new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")
            );
            return t ? decodeURIComponent(t[3]) : null;
          },
          remove(e) {
            this.write(e, "", Date.now() - 864e5);
          }
        }
      : { write() {}, read: () => null, remove() {} };
  function hN(e, t) {
    return e &&
      !(function(e) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
      })(t)
      ? (function(e, t) {
          return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
        })(e, t)
      : t;
  }
  function uN(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  const pN = e =>
    e instanceof hD
      ? (function(e) {
          for (var t = 1; t < arguments.length; t++) {
            var i = null != arguments[t] ? arguments[t] : {};
            t % 2
              ? uN(Object(i), !0).forEach(function(t) {
                  gm(e, t, i[t]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
              : uN(Object(i)).forEach(function(t) {
                  Object.defineProperty(
                    e,
                    t,
                    Object.getOwnPropertyDescriptor(i, t)
                  );
                });
          }
          return e;
        })({}, e)
      : e;
  function fN(e, t) {
    t = t || {};
    const i = {};
    function s(e, t, i, s) {
      return QI.isPlainObject(e) && QI.isPlainObject(t)
        ? QI.merge.call({ caseless: s }, e, t)
        : QI.isPlainObject(t)
        ? QI.merge({}, t)
        : QI.isArray(t)
        ? t.slice()
        : t;
    }
    function r(e, t, i, r) {
      return QI.isUndefined(t)
        ? QI.isUndefined(e)
          ? void 0
          : s(void 0, e, 0, r)
        : s(e, t, 0, r);
    }
    function n(e, t) {
      if (!QI.isUndefined(t)) return s(void 0, t);
    }
    function a(e, t) {
      return QI.isUndefined(t)
        ? QI.isUndefined(e)
          ? void 0
          : s(void 0, e)
        : s(void 0, t);
    }
    function o(i, r, n) {
      return n in t ? s(i, r) : n in e ? s(void 0, i) : void 0;
    }
    const c = {
      url: n,
      method: n,
      data: n,
      baseURL: a,
      transformRequest: a,
      transformResponse: a,
      paramsSerializer: a,
      timeout: a,
      timeoutMessage: a,
      withCredentials: a,
      withXSRFToken: a,
      adapter: a,
      responseType: a,
      xsrfCookieName: a,
      xsrfHeaderName: a,
      onUploadProgress: a,
      onDownloadProgress: a,
      decompress: a,
      maxContentLength: a,
      maxBodyLength: a,
      beforeRedirect: a,
      transport: a,
      httpAgent: a,
      httpsAgent: a,
      cancelToken: a,
      socketPath: a,
      responseEncoding: a,
      validateStatus: o,
      headers: (e, t, i) => r(pN(e), pN(t), 0, !0)
    };
    return (
      QI.forEach(Object.keys(Object.assign({}, e, t)), function(s) {
        const n = c[s] || r,
          a = n(e[s], t[s], s);
        (QI.isUndefined(a) && n !== o) || (i[s] = a);
      }),
      i
    );
  }
  var EN = e => {
    const t = fN({}, e);
    let i,
      {
        data: s,
        withXSRFToken: r,
        xsrfHeaderName: n,
        xsrfCookieName: a,
        headers: o,
        auth: c
      } = t;
    if (
      ((t.headers = o = hD.from(o)),
      (t.url = hC(hN(t.baseURL, t.url), e.params, e.paramsSerializer)),
      c &&
        o.set(
          "Authorization",
          "Basic " +
            btoa(
              (c.username || "") +
                ":" +
                (c.password ? unescape(encodeURIComponent(c.password)) : "")
            )
        ),
      QI.isFormData(s))
    )
      if (iO.hasStandardBrowserEnv || iO.hasStandardBrowserWebWorkerEnv)
        o.setContentType(void 0);
      else if (!1 !== (i = o.getContentType())) {
        const [e, ...t] = i
          ? i
              .split(";")
              .map(e => ms(e).call(e))
              .filter(Boolean)
          : [];
        o.setContentType([e || "multipart/form-data", ...t].join("; "));
      }
    if (
      iO.hasStandardBrowserEnv &&
      (r && QI.isFunction(r) && (r = r(t)), r || (!1 !== r && dN(t.url)))
    ) {
      const e = n && a && lN.read(a);
      e && o.set(n, e);
    }
    return t;
  };
  var mN =
    "undefined" != typeof XMLHttpRequest &&
    function(e) {
      return new Ru(function(t, i) {
        const s = EN(e);
        let r = s.data;
        const n = hD.from(s.headers).normalize();
        let a,
          o,
          c,
          d,
          l,
          { responseType: h, onUploadProgress: u, onDownloadProgress: p } = s;
        function f() {
          d && d(),
            l && l(),
            s.cancelToken && s.cancelToken.unsubscribe(a),
            s.signal && s.signal.removeEventListener("abort", a);
        }
        let E = new XMLHttpRequest();
        function m() {
          if (!E) return;
          const s = hD.from(
            "getAllResponseHeaders" in E && E.getAllResponseHeaders()
          );
          ED(
            function(e) {
              t(e), f();
            },
            function(e) {
              i(e), f();
            },
            {
              data:
                h && "text" !== h && "json" !== h ? E.response : E.responseText,
              status: E.status,
              statusText: E.statusText,
              headers: s,
              config: e,
              request: E
            }
          ),
            (E = null);
        }
        E.open(s.method.toUpperCase(), s.url, !0),
          (E.timeout = s.timeout),
          "onloadend" in E
            ? (E.onloadend = m)
            : (E.onreadystatechange = function() {
                E &&
                  4 === E.readyState &&
                  (0 !== E.status ||
                    (E.responseURL && 0 === E.responseURL.indexOf("file:"))) &&
                  setTimeout(m);
              }),
          (E.onabort = function() {
            E &&
              (i(new ZI("Request aborted", ZI.ECONNABORTED, e, E)), (E = null));
          }),
          (E.onerror = function() {
            i(new ZI("Network Error", ZI.ERR_NETWORK, e, E)), (E = null);
          }),
          (E.ontimeout = function() {
            let t = s.timeout
              ? "timeout of " + s.timeout + "ms exceeded"
              : "timeout exceeded";
            const r = s.transitional || pC;
            s.timeoutErrorMessage && (t = s.timeoutErrorMessage),
              i(
                new ZI(
                  t,
                  r.clarifyTimeoutError ? ZI.ETIMEDOUT : ZI.ECONNABORTED,
                  e,
                  E
                )
              ),
              (E = null);
          }),
          void 0 === r && n.setContentType(null),
          "setRequestHeader" in E &&
            QI.forEach(n.toJSON(), function(e, t) {
              E.setRequestHeader(t, e);
            }),
          QI.isUndefined(s.withCredentials) ||
            (E.withCredentials = !!s.withCredentials),
          h && "json" !== h && (E.responseType = s.responseType),
          p && (([c, l] = mD(p, !0)), E.addEventListener("progress", c)),
          u &&
            E.upload &&
            (([o, d] = mD(u)),
            E.upload.addEventListener("progress", o),
            E.upload.addEventListener("loadend", d)),
          (s.cancelToken || s.signal) &&
            ((a = t => {
              E &&
                (i(!t || t.type ? new fD(null, e, E) : t),
                E.abort(),
                (E = null));
            }),
            s.cancelToken && s.cancelToken.subscribe(a),
            s.signal &&
              (s.signal.aborted ? a() : s.signal.addEventListener("abort", a)));
        const g = (function(e) {
          const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
          return (t && t[1]) || "";
        })(s.url);
        g && -1 === iO.protocols.indexOf(g)
          ? i(new ZI("Unsupported protocol " + g + ":", ZI.ERR_BAD_REQUEST, e))
          : E.send(r || null);
      });
    };
  var gN = (e, t) => {
      const { length: i } = (e = e ? e.filter(Boolean) : []);
      if (t || i) {
        let i,
          s = new AbortController();
        const r = function(e) {
          if (!i) {
            (i = !0), a();
            const t = e instanceof Error ? e : this.reason;
            s.abort(
              t instanceof ZI ? t : new fD(t instanceof Error ? t.message : t)
            );
          }
        };
        let n =
          t &&
          setTimeout(() => {
            (n = null),
              r(new ZI("timeout ".concat(t, " of ms exceeded"), ZI.ETIMEDOUT));
          }, t);
        const a = () => {
          e &&
            (n && clearTimeout(n),
            (n = null),
            e.forEach(e => {
              e.unsubscribe
                ? e.unsubscribe(r)
                : e.removeEventListener("abort", r);
            }),
            (e = null));
        };
        e.forEach(e => e.addEventListener("abort", r));
        const { signal: o } = s;
        return (o.unsubscribe = () => QI.asap(a)), o;
      }
    },
    _N = s(vu),
    TN = pp.f("asyncIterator"),
    SN = s(TN);
  function vN(e, t) {
    (this.v = e), (this.k = t);
  }
  function RN(e) {
    var t, i;
    function s(t, i) {
      try {
        var n = e[t](i),
          a = n.value,
          o = a instanceof vN;
        _N.resolve(o ? a.v : a).then(
          function(i) {
            if (o) {
              var c = "return" === t ? "return" : "next";
              if (!a.k || i.done) return s(c, i);
              i = e[c](i).value;
            }
            r(n.done ? "return" : "normal", i);
          },
          function(e) {
            s("throw", e);
          }
        );
      } catch (e) {
        r("throw", e);
      }
    }
    function r(e, r) {
      switch (e) {
        case "return":
          t.resolve({ value: r, done: !0 });
          break;
        case "throw":
          t.reject(r);
          break;
        default:
          t.resolve({ value: r, done: !1 });
      }
      (t = t.next) ? s(t.key, t.arg) : (i = null);
    }
    (this._invoke = function(e, r) {
      return new _N(function(n, a) {
        var o = { key: e, arg: r, resolve: n, reject: a, next: null };
        i ? (i = i.next = o) : ((t = i = o), s(e, r));
      });
    }),
      "function" != typeof e.return && (this.return = void 0);
  }
  function yN(e) {
    return function() {
      return new RN(e.apply(this, arguments));
    };
  }
  function AN(e) {
    return new vN(e, 0);
  }
  function IN(e) {
    var t = {},
      i = !1;
    function s(t, s) {
      return (
        (i = !0),
        {
          done: !1,
          value: new vN(
            (s = new _N(function(i) {
              i(e[t](s));
            })),
            1
          )
        }
      );
    }
    return (
      (t[(void 0 !== um && pm) || "@@iterator"] = function() {
        return this;
      }),
      (t.next = function(e) {
        return i ? ((i = !1), e) : s("next", e);
      }),
      "function" == typeof e.throw &&
        (t.throw = function(e) {
          if (i) throw ((i = !1), e);
          return s("throw", e);
        }),
      "function" == typeof e.return &&
        (t.return = function(e) {
          return i ? ((i = !1), e) : s("return", e);
        }),
      t
    );
  }
  (RN.prototype[
    ("function" == typeof um && SN) || "@@asyncIterator"
  ] = function() {
    return this;
  }),
    (RN.prototype.next = function(e) {
      return this._invoke("next", e);
    }),
    (RN.prototype.throw = function(e) {
      return this._invoke("throw", e);
    }),
    (RN.prototype.return = function(e) {
      return this._invoke("return", e);
    });
  var CN = s(TN);
  function bN(e) {
    var t,
      i,
      s,
      r = 2;
    for (
      "undefined" != typeof Symbol && ((i = CN), (s = Symbol.iterator));
      r--;

    ) {
      if (i && null != (t = e[i])) return t.call(e);
      if (s && null != (t = e[s])) return new ON(t.call(e));
      (i = "@@asyncIterator"), (s = "@@iterator");
    }
    throw new TypeError("Object is not async iterable");
  }
  function ON(e) {
    function t(e) {
      if (Object(e) !== e)
        return Ru.reject(new TypeError(e + " is not an object."));
      var t = e.done;
      return Ru.resolve(e.value).then(function(e) {
        return { value: e, done: t };
      });
    }
    return (
      (ON = function(e) {
        (this.s = e), (this.n = e.next);
      }),
      (ON.prototype = {
        s: null,
        n: null,
        next: function() {
          return t(this.n.apply(this.s, arguments));
        },
        return: function(e) {
          var i = this.s.return;
          return void 0 === i
            ? Ru.resolve({ value: e, done: !0 })
            : t(i.apply(this.s, arguments));
        },
        throw: function(e) {
          var i = this.s.return;
          return void 0 === i ? Ru.reject(e) : t(i.apply(this.s, arguments));
        }
      }),
      new ON(e)
    );
  }
  const DN = function*(e, t) {
      let i = e.byteLength;
      if (!t || i < t) return void (yield e);
      let s,
        r = 0;
      for (; r < i; ) (s = r + t), yield e.slice(r, s), (r = s);
    },
    wN = (function() {
      var e = yN(function*(e, t) {
        var i,
          s = !1,
          r = !1;
        try {
          for (
            var n, a = bN(LN(e));
            (s = !(n = yield AN(a.next())).done);
            s = !1
          ) {
            const e = n.value;
            yield* IN(bN(DN(e, t)));
          }
        } catch (e) {
          (r = !0), (i = e);
        } finally {
          try {
            s && null != a.return && (yield AN(a.return()));
          } finally {
            if (r) throw i;
          }
        }
      });
      return function(t, i) {
        return e.apply(this, arguments);
      };
    })(),
    LN = (function() {
      var e = yN(function*(e) {
        if (e[CN]) return void (yield* IN(bN(e)));
        const t = e.getReader();
        try {
          for (;;) {
            const { done: e, value: i } = yield AN(t.read());
            if (e) break;
            yield i;
          }
        } finally {
          yield AN(t.cancel());
        }
      });
      return function(t) {
        return e.apply(this, arguments);
      };
    })(),
    NN = (e, t, i, s) => {
      const r = wN(e, t);
      let n,
        a = 0,
        o = e => {
          n || ((n = !0), s && s(e));
        };
      return new ReadableStream(
        {
          async pull(e) {
            try {
              const { done: t, value: s } = await r.next();
              if (t) return o(), void e.close();
              let n = s.byteLength;
              if (i) {
                let e = (a += n);
                i(e);
              }
              e.enqueue(new Uint8Array(s));
            } catch (e) {
              throw (o(e), e);
            }
          },
          cancel: e => (o(e), r.return())
        },
        { highWaterMark: 2 }
      );
    };
  function PN(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function kN(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? PN(Object(i), !0).forEach(function(t) {
            gm(e, t, i[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
        : PN(Object(i)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
          });
    }
    return e;
  }
  const MN =
      "function" == typeof fetch &&
      "function" == typeof Request &&
      "function" == typeof Response,
    UN = MN && "function" == typeof ReadableStream,
    xN =
      MN &&
      ("function" == typeof TextEncoder
        ? ((FN = new TextEncoder()), e => FN.encode(e))
        : async e => new Uint8Array(await new Response(e).arrayBuffer()));
  var FN;
  const BN = function(e) {
      try {
        for (
          var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1;
          s < t;
          s++
        )
          i[s - 1] = arguments[s];
        return !!e(...i);
      } catch (e) {
        return !1;
      }
    },
    VN =
      UN &&
      BN(() => {
        let e = !1;
        const t = new Request(iO.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            return (e = !0), "half";
          }
        }).headers.has("Content-Type");
        return e && !t;
      }),
    GN = UN && BN(() => QI.isReadableStream(new Response("").body)),
    jN = { stream: GN && (e => e.body) };
  var HN;
  MN &&
    ((HN = new Response()),
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
      !jN[e] &&
        (jN[e] = QI.isFunction(HN[e])
          ? t => t[e]()
          : (t, i) => {
              throw new ZI(
                "Response type '".concat(e, "' is not supported"),
                ZI.ERR_NOT_SUPPORT,
                i
              );
            });
    }));
  const KN = async (e, t) => {
    const i = QI.toFiniteNumber(e.getContentLength());
    return null == i
      ? (async e => {
          if (null == e) return 0;
          if (QI.isBlob(e)) return e.size;
          if (QI.isSpecCompliantForm(e)) {
            const t = new Request(iO.origin, { method: "POST", body: e });
            return (await t.arrayBuffer()).byteLength;
          }
          return QI.isArrayBufferView(e) || QI.isArrayBuffer(e)
            ? e.byteLength
            : (QI.isURLSearchParams(e) && (e += ""),
              QI.isString(e) ? (await xN(e)).byteLength : void 0);
        })(t)
      : i;
  };
  var WN =
    MN &&
    (async e => {
      let {
        url: t,
        method: i,
        data: s,
        signal: r,
        cancelToken: n,
        timeout: a,
        onDownloadProgress: o,
        onUploadProgress: c,
        responseType: d,
        headers: l,
        withCredentials: h = "same-origin",
        fetchOptions: u
      } = EN(e);
      d = d ? (d + "").toLowerCase() : "text";
      let p,
        f = gN([r, n && n.toAbortSignal()], a);
      const E =
        f &&
        f.unsubscribe &&
        (() => {
          f.unsubscribe();
        });
      let m;
      try {
        if (
          c &&
          VN &&
          "get" !== i &&
          "head" !== i &&
          0 !== (m = await KN(l, s))
        ) {
          let e,
            i = new Request(t, { method: "POST", body: s, duplex: "half" });
          if (
            (QI.isFormData(s) &&
              (e = i.headers.get("content-type")) &&
              l.setContentType(e),
            i.body)
          ) {
            const [e, t] = gD(m, mD(_D(c)));
            s = NN(i.body, 65536, e, t);
          }
        }
        QI.isString(h) || (h = h ? "include" : "omit");
        const r = "credentials" in Request.prototype;
        p = new Request(
          t,
          kN(
            kN({}, u),
            {},
            {
              signal: f,
              method: i.toUpperCase(),
              headers: l.normalize().toJSON(),
              body: s,
              duplex: "half",
              credentials: r ? h : void 0
            }
          )
        );
        let n = await fetch(p);
        const a = GN && ("stream" === d || "response" === d);
        if (GN && (o || (a && E))) {
          const e = {};
          ["status", "statusText", "headers"].forEach(t => {
            e[t] = n[t];
          });
          const t = QI.toFiniteNumber(n.headers.get("content-length")),
            [i, s] = (o && gD(t, mD(_D(o), !0))) || [];
          n = new Response(
            NN(n.body, 65536, i, () => {
              s && s(), E && E();
            }),
            e
          );
        }
        d = d || "text";
        let g = await jN[QI.findKey(jN, d) || "text"](n, e);
        return (
          !a && E && E(),
          await new Ru((t, i) => {
            ED(t, i, {
              data: g,
              headers: hD.from(n.headers),
              status: n.status,
              statusText: n.statusText,
              config: e,
              request: p
            });
          })
        );
      } catch (t) {
        if ((E && E(), t && "TypeError" === t.name && /fetch/i.test(t.message)))
          throw Object.assign(new ZI("Network Error", ZI.ERR_NETWORK, e, p), {
            cause: t.cause || t
          });
        throw ZI.from(t, t && t.code, e, p);
      }
    });
  const YN = { http: null, xhr: mN, fetch: WN };
  QI.forEach(YN, (e, t) => {
    if (e) {
      try {
        Object.defineProperty(e, "name", { value: t });
      } catch (e) {}
      Object.defineProperty(e, "adapterName", { value: t });
    }
  });
  const $N = e => "- ".concat(e),
    qN = e => QI.isFunction(e) || null === e || !1 === e;
  var XN = {
    getAdapter: e => {
      e = QI.isArray(e) ? e : [e];
      const { length: t } = e;
      let i, s;
      const r = {};
      for (let n = 0; n < t; n++) {
        let t;
        if (
          ((i = e[n]),
          (s = i),
          !qN(i) && ((s = YN[(t = String(i)).toLowerCase()]), void 0 === s))
        )
          throw new ZI("Unknown adapter '".concat(t, "'"));
        if (s) break;
        r[t || "#" + n] = s;
      }
      if (!s) {
        const e = Object.entries(r).map(e => {
          let [t, i] = e;
          return (
            "adapter ".concat(t, " ") +
            (!1 === i
              ? "is not supported by the environment"
              : "is not available in the build")
          );
        });
        throw new ZI(
          "There is no suitable adapter to dispatch the request " +
            (t
              ? e.length > 1
                ? "since :\n" + e.map($N).join("\n")
                : " " + $N(e[0])
              : "as no adapter specified"),
          "ERR_NOT_SUPPORT"
        );
      }
      return s;
    },
    adapters: YN
  };
  function zN(e) {
    if (
      (e.cancelToken && e.cancelToken.throwIfRequested(),
      e.signal && e.signal.aborted)
    )
      throw new fD(null, e);
  }
  function JN(e) {
    zN(e),
      (e.headers = hD.from(e.headers)),
      (e.data = uD.call(e, e.transformRequest)),
      -1 !== ["post", "put", "patch"].indexOf(e.method) &&
        e.headers.setContentType("application/x-www-form-urlencoded", !1);
    return XN.getAdapter(e.adapter || rD.adapter)(e).then(
      function(t) {
        return (
          zN(e),
          (t.data = uD.call(e, e.transformResponse, t)),
          (t.headers = hD.from(t.headers)),
          t
        );
      },
      function(t) {
        return (
          pD(t) ||
            (zN(e),
            t &&
              t.response &&
              ((t.response.data = uD.call(e, e.transformResponse, t.response)),
              (t.response.headers = hD.from(t.response.headers)))),
          Ru.reject(t)
        );
      }
    );
  }
  const QN = "1.7.9",
    ZN = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(
    (e, t) => {
      ZN[e] = function(i) {
        return typeof i === e || "a" + (t < 1 ? "n " : " ") + e;
      };
    }
  );
  const eP = {};
  (ZN.transitional = function(e, t, i) {
    function s(e, t) {
      return (
        "[Axios v" +
        QN +
        "] Transitional option '" +
        e +
        "'" +
        t +
        (i ? ". " + i : "")
      );
    }
    return (i, r, n) => {
      if (!1 === e)
        throw new ZI(
          s(r, " has been removed" + (t ? " in " + t : "")),
          ZI.ERR_DEPRECATED
        );
      return (
        t &&
          !eP[r] &&
          ((eP[r] = !0),
          console.warn(
            s(
              r,
              " has been deprecated since v" +
                t +
                " and will be removed in the near future"
            )
          )),
        !e || e(i, r, n)
      );
    };
  }),
    (ZN.spelling = function(e) {
      return (t, i) => (
        console.warn("".concat(i, " is likely a misspelling of ").concat(e)), !0
      );
    });
  var tP = {
    assertOptions: function(e, t, i) {
      if ("object" != typeof e)
        throw new ZI("options must be an object", ZI.ERR_BAD_OPTION_VALUE);
      const s = Object.keys(e);
      let r = s.length;
      for (; r-- > 0; ) {
        const n = s[r],
          a = t[n];
        if (a) {
          const t = e[n],
            i = void 0 === t || a(t, n, e);
          if (!0 !== i)
            throw new ZI(
              "option " + n + " must be " + i,
              ZI.ERR_BAD_OPTION_VALUE
            );
        } else if (!0 !== i)
          throw new ZI("Unknown option " + n, ZI.ERR_BAD_OPTION);
      }
    },
    validators: ZN
  };
  const iP = tP.validators;
  let sP = class {
    constructor(e) {
      (this.defaults = e),
        (this.interceptors = { request: new uC(), response: new uC() });
    }
    async request(e, t) {
      try {
        return await this._request(e, t);
      } catch (e) {
        if (e instanceof Error) {
          let t = {};
          Error.captureStackTrace
            ? Error.captureStackTrace(t)
            : (t = new Error());
          const i = t.stack ? t.stack.replace(/^.+\n/, "") : "";
          try {
            e.stack
              ? i &&
                !String(e.stack).endsWith(i.replace(/^.+\n.+\n/, "")) &&
                (e.stack += "\n" + i)
              : (e.stack = i);
          } catch (e) {}
        }
        throw e;
      }
    }
    _request(e, t) {
      "string" == typeof e ? ((t = t || {}).url = e) : (t = e || {}),
        (t = fN(this.defaults, t));
      const { transitional: i, paramsSerializer: s, headers: r } = t;
      void 0 !== i &&
        tP.assertOptions(
          i,
          {
            silentJSONParsing: iP.transitional(iP.boolean),
            forcedJSONParsing: iP.transitional(iP.boolean),
            clarifyTimeoutError: iP.transitional(iP.boolean)
          },
          !1
        ),
        null != s &&
          (QI.isFunction(s)
            ? (t.paramsSerializer = { serialize: s })
            : tP.assertOptions(
                s,
                { encode: iP.function, serialize: iP.function },
                !0
              )),
        tP.assertOptions(
          t,
          {
            baseUrl: iP.spelling("baseURL"),
            withXsrfToken: iP.spelling("withXSRFToken")
          },
          !0
        ),
        (t.method = (t.method || this.defaults.method || "get").toLowerCase());
      let n = r && QI.merge(r.common, r[t.method]);
      r &&
        QI.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          e => {
            delete r[e];
          }
        ),
        (t.headers = hD.concat(n, r));
      const a = [];
      let o = !0;
      this.interceptors.request.forEach(function(e) {
        ("function" == typeof e.runWhen && !1 === e.runWhen(t)) ||
          ((o = o && e.synchronous), a.unshift(e.fulfilled, e.rejected));
      });
      const c = [];
      let d;
      this.interceptors.response.forEach(function(e) {
        c.push(e.fulfilled, e.rejected);
      });
      let l,
        h = 0;
      if (!o) {
        const e = [JN.bind(this), void 0];
        for (
          e.unshift.apply(e, a),
            e.push.apply(e, c),
            l = e.length,
            d = Ru.resolve(t);
          h < l;

        )
          d = d.then(e[h++], e[h++]);
        return d;
      }
      l = a.length;
      let u = t;
      for (h = 0; h < l; ) {
        const e = a[h++],
          t = a[h++];
        try {
          u = e(u);
        } catch (e) {
          t.call(this, e);
          break;
        }
      }
      try {
        d = JN.call(this, u);
      } catch (e) {
        return Ru.reject(e);
      }
      for (h = 0, l = c.length; h < l; ) d = d.then(c[h++], c[h++]);
      return d;
    }
    getUri(e) {
      return hC(
        hN((e = fN(this.defaults, e)).baseURL, e.url),
        e.params,
        e.paramsSerializer
      );
    }
  };
  QI.forEach(["delete", "get", "head", "options"], function(e) {
    sP.prototype[e] = function(t, i) {
      return this.request(
        fN(i || {}, { method: e, url: t, data: (i || {}).data })
      );
    };
  }),
    QI.forEach(["post", "put", "patch"], function(e) {
      function t(t) {
        return function(i, s, r) {
          return this.request(
            fN(r || {}, {
              method: e,
              headers: t ? { "Content-Type": "multipart/form-data" } : {},
              url: i,
              data: s
            })
          );
        };
      }
      (sP.prototype[e] = t()), (sP.prototype[e + "Form"] = t(!0));
    });
  var rP = sP;
  class nP {
    constructor(e) {
      if ("function" != typeof e)
        throw new TypeError("executor must be a function.");
      let t;
      this.promise = new Ru(function(e) {
        t = e;
      });
      const i = this;
      this.promise.then(e => {
        if (!i._listeners) return;
        let t = i._listeners.length;
        for (; t-- > 0; ) i._listeners[t](e);
        i._listeners = null;
      }),
        (this.promise.then = e => {
          let t;
          const s = new Ru(e => {
            i.subscribe(e), (t = e);
          }).then(e);
          return (
            (s.cancel = function() {
              i.unsubscribe(t);
            }),
            s
          );
        }),
        e(function(e, s, r) {
          i.reason || ((i.reason = new fD(e, s, r)), t(i.reason));
        });
    }
    throwIfRequested() {
      if (this.reason) throw this.reason;
    }
    subscribe(e) {
      this.reason
        ? e(this.reason)
        : this._listeners
        ? this._listeners.push(e)
        : (this._listeners = [e]);
    }
    unsubscribe(e) {
      if (!this._listeners) return;
      const t = this._listeners.indexOf(e);
      -1 !== t && this._listeners.splice(t, 1);
    }
    toAbortSignal() {
      const e = new AbortController(),
        t = t => {
          e.abort(t);
        };
      return (
        this.subscribe(t),
        (e.signal.unsubscribe = () => this.unsubscribe(t)),
        e.signal
      );
    }
    static source() {
      let e;
      const t = new nP(function(t) {
        e = t;
      });
      return { token: t, cancel: e };
    }
  }
  var aP = nP;
  const oP = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(oP).forEach(e => {
    let [t, i] = e;
    oP[i] = t;
  });
  var cP = oP;
  const dP = (function e(t) {
    const i = new rP(t),
      s = cI(rP.prototype.request, i);
    return (
      QI.extend(s, rP.prototype, i, { allOwnKeys: !0 }),
      QI.extend(s, i, null, { allOwnKeys: !0 }),
      (s.create = function(i) {
        return e(fN(t, i));
      }),
      s
    );
  })(rD);
  (dP.Axios = rP),
    (dP.CanceledError = fD),
    (dP.CancelToken = aP),
    (dP.isCancel = pD),
    (dP.VERSION = QN),
    (dP.toFormData = aC),
    (dP.AxiosError = ZI),
    (dP.Cancel = dP.CanceledError),
    (dP.all = function(e) {
      return Ru.all(e);
    }),
    (dP.spread = function(e) {
      return function(t) {
        return e.apply(null, t);
      };
    }),
    (dP.isAxiosError = function(e) {
      return QI.isObject(e) && !0 === e.isAxiosError;
    }),
    (dP.mergeConfig = fN),
    (dP.AxiosHeaders = hD),
    (dP.formToJSON = e => iD(QI.isHTMLForm(e) ? new FormData(e) : e)),
    (dP.getAdapter = XN.getAdapter),
    (dP.HttpStatusCode = cP),
    (dP.default = dP);
  var lP = dP;
  const hP = () => {};
  function uP() {
    const e = {
      promise: void 0,
      isResolved: !1,
      isRejected: !1,
      isFinished: !1,
      resolve: void 0,
      reject: void 0,
      cancel: hP
    };
    return (
      (e.promise = new Promise((t, i) => {
        (e.resolve = i => {
          e.isFinished ||
            ((e.isResolved = !0), (e.isFinished = !0), t(i), (e.value = i));
        }),
          (e.reject = t => {
            e.isFinished || ((e.isRejected = !0), (e.isFinished = !0), i(t));
          });
      })),
      e
    );
  }
  const pP = new Map(),
    fP = new Map(),
    EP = new Map();
  let mP = (function(e) {
      return (
        (e.WIN_10 = "Windows 10"),
        (e.WIN_81 = "Windows 8.1"),
        (e.WIN_8 = "Windows 8"),
        (e.WIN_7 = "Windows 7"),
        (e.WIN_VISTA = "Windows Vista"),
        (e.WIN_SERVER_2003 = "Windows Server 2003"),
        (e.WIN_XP = "Windows XP"),
        (e.WIN_2000 = "Windows 2000"),
        (e.ANDROID = "Android"),
        (e.HARMONY_OS = "HarmonyOS"),
        (e.OPEN_BSD = "Open BSD"),
        (e.SUN_OS = "Sun OS"),
        (e.LINUX = "Linux"),
        (e.IOS = "iOS"),
        (e.MAC_OS = "Mac OS"),
        (e.CHROMIUM_OS = "Chromium OS"),
        (e.QNX = "QNX"),
        (e.UNIX = "UNIX"),
        (e.BEOS = "BeOS"),
        (e.OS_2 = "OS/2"),
        (e.SEARCH_BOT = "Search Bot"),
        e
      );
    })({}),
    gP = (function(e) {
      return (
        (e.CHROME = "Chrome"),
        (e.SAFARI = "Safari"),
        (e.EDGE = "Edge"),
        (e.FIREFOX = "Firefox"),
        (e.OPERA = "OPR"),
        (e.QQ = "QQBrowser"),
        (e.WECHAT = "MicroMessenger"),
        e
      );
    })({});
  const _P = new DA();
  let TP = _P.getResult(),
    SP = null;
  function vP(e) {
    if (!SP) {
      e && _P.setUA(e), (TP = _P.getResult());
      const t = (function(e) {
          if ("Blink" === e.engine.name && "WeChat" !== e.browser.name)
            return gP.CHROME;
          switch (e.browser.name) {
            case "Chrome Headless":
            case "Chrome":
            case "Chromium":
              return gP.CHROME;
            case "Safari":
            case "Mobile Safari":
              return gP.SAFARI;
            case "Edge":
              return gP.EDGE;
            case "Firefox":
              return gP.FIREFOX;
            case "QQ":
            case "QQBrowser":
              return gP.QQ;
            case "Opera":
              return gP.OPERA;
            case "WeChat":
              return gP.WECHAT;
            default:
              return e.browser.name || "";
          }
        })(TP),
        i = RP(TP),
        s = (function(e) {
          return "Windows" === e.os.name
            ? e.os.version
              ? e.os.name + " " + e.os.version
              : e.os.name
            : e.os.name || "";
        })(TP),
        r = TP.os.version,
        n = RP(TP, !1),
        a = TP.device.type;
      if (!(t && i && s && r))
        return {
          name: t,
          version: i,
          os: s,
          osVersion: r,
          browserVersion: n,
          deviceType: a
        };
      SP = {
        name: t,
        version: i,
        os: s,
        osVersion: r,
        browserVersion: n,
        deviceType: a
      };
    }
    return SP;
  }
  function RP(e) {
    let t,
      i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    return (
      (t =
        "Blink" === e.engine.name
          ? e.engine.version || ""
          : e.browser.version || ""),
      i ? t.split(".")[0] : t
    );
  }
  function yP() {
    return vP().os;
  }
  function AP() {
    const e = vP();
    return "".concat(e.os, " ").concat(e.osVersion);
  }
  function IP() {
    const e = vP();
    return !!(
      ("WebKit" === TP.engine.name &&
        e.os === mP.MAC_OS &&
        navigator.maxTouchPoints &&
        navigator.maxTouchPoints > 0 &&
        e.name !== gP.SAFARI) ||
      (wP() && e.name !== gP.SAFARI)
    );
  }
  function CP() {
    return vP().name === gP.CHROME;
  }
  function bP() {
    return vP().name === gP.SAFARI;
  }
  function OP() {
    return vP().name === gP.EDGE;
  }
  function DP() {
    return vP().name === gP.FIREFOX;
  }
  function wP() {
    return vP().os === mP.IOS;
  }
  function LP(e) {
    const t = vP();
    return !(t.name !== gP.CHROME || !t.osVersion) && Number(t.version) >= e;
  }
  function NP(e) {
    const t = vP();
    return !(t.name !== gP.CHROME || !t.osVersion) && Number(t.version) < e;
  }
  function PP(e, t, i) {
    const s = vP();
    return (
      !(s.name !== e || !s.osVersion) &&
      (i
        ? Number(s.version) >= t && Number(s.version) <= i
        : Number(s.version) === t)
    );
  }
  function kP(e) {
    const t = vP();
    return !(t.name !== gP.SAFARI || !t.osVersion) && Number(t.version) >= e;
  }
  function MP(e, t, i) {
    const s = vP();
    if (s.os !== mP.IOS || !s.osVersion) return !1;
    const r = s.osVersion.split(".");
    return i
      ? (t && Number(r[0]) === e && Number(r[1]) < t) || Number(r[0]) < e
      : t
      ? (Number(r[0]) === e && Number(r[1]) <= t) || Number(r[0]) < e
      : Number(r[0]) <= e;
  }
  function UP(e, t, i) {
    const s = vP();
    if (s.name !== gP.SAFARI || !s.osVersion || !s.browserVersion) return !1;
    const r = s.browserVersion.split(".");
    return i
      ? (t && Number(r[0]) === e && Number(r[1]) < t) || Number(r[0]) < e
      : t
      ? (Number(r[0]) === e && Number(r[1]) <= t) || Number(r[0]) < e
      : Number(r[0]) <= e;
  }
  function xP() {
    const e = vP();
    if (e.os !== mP.IOS || !e.osVersion) return !1;
    const t = e.osVersion.split(".");
    return Number(t[0]) < 14 || (14 === Number(t[0]) && Number(t[1]) <= 6);
  }
  function FP() {
    const e = vP();
    if (e.os !== mP.IOS || !e.osVersion) return !1;
    const t = e.osVersion.split(".");
    return 15 === Number(t[0]);
  }
  function BP() {
    const e = vP();
    if (e.os !== mP.IOS || !e.osVersion) return !1;
    const t = e.osVersion.split(".");
    return 16 === Number(t[0]);
  }
  function VP() {
    const e = vP();
    if (e.os !== mP.IOS || !e.osVersion) return !1;
    const t = e.osVersion.split(".");
    return 15 === Number(t[0]) && Number(t[1]) >= 1;
  }
  function GP() {
    return bP() && navigator.maxTouchPoints > 0;
  }
  function jP() {
    return vP().name === gP.WECHAT;
  }
  function HP() {
    const e = yP();
    return (
      (function() {
        const { deviceType: e } = vP();
        return "mobile" === e || "tablet" === e;
      })() ||
      e === mP.ANDROID ||
      e === mP.IOS ||
      e === mP.HARMONY_OS
    );
  }
  function KP() {
    const e = vP();
    return (
      e.name !== gP.EDGE &&
      e.name !== gP.SAFARI &&
      !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i)
    );
  }
  function WP() {
    return yP() === mP.ANDROID;
  }
  function YP() {
    const e = vP();
    return (
      WP() &&
      (e.name === gP.CHROME ||
        e.name === gP.WECHAT ||
        /chrome|chromium/i.test(navigator.userAgent))
    );
  }
  function $P(e, t, i) {
    return (
      (t = (function(e) {
        var t = (function(e, t) {
          if ("object" != typeof e || !e) return e;
          var i = e[Symbol.toPrimitive];
          if (void 0 !== i) {
            var s = i.call(e, "string");
            if ("object" != typeof s) return s;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(e);
        })(e);
        return "symbol" == typeof t ? t : t + "";
      })(t)) in e
        ? Object.defineProperty(e, t, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
          })
        : (e[t] = i),
      e
    );
  }
  function qP(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function XP(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? qP(Object(i), !0).forEach(function(t) {
            $P(e, t, i[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
        : qP(Object(i)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
          });
    }
    return e;
  }
  let zP = (function(e) {
      return (
        (e.UNEXPECTED_ERROR = "UNEXPECTED_ERROR"),
        (e.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE"),
        (e.TIMEOUT = "TIMEOUT"),
        (e.INVALID_PARAMS = "INVALID_PARAMS"),
        (e.NOT_READABLE = "NOT_READABLE"),
        (e.NOT_SUPPORTED = "NOT_SUPPORTED"),
        (e.INVALID_OPERATION = "INVALID_OPERATION"),
        (e.OPERATION_ABORTED = "OPERATION_ABORTED"),
        (e.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT"),
        (e.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED"),
        (e.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED"),
        (e.DATACHANNEL_FAILED = "DATACHANNEL_FAILED"),
        (e.NETWORK_ERROR = "NETWORK_ERROR"),
        (e.NETWORK_TIMEOUT = "NETWORK_TIMEOUT"),
        (e.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR"),
        (e.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT"),
        (e.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED"),
        (e.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND"),
        (e.ELECTRON_IS_NULL = "ELECTRON_IS_NULL"),
        (e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR =
          "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR"),
        (e.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE"),
        (e.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL"),
        (e.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID"),
        (e.PERMISSION_DENIED = "PERMISSION_DENIED"),
        (e.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED"),
        (e.TRACK_IS_DISABLED = "TRACK_IS_DISABLED"),
        (e.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR"),
        (e.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED"),
        (e.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR"),
        (e.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR"),
        (e.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE"),
        (e.INVALID_UINT_UID_FROM_STRING_UID =
          "INVALID_UINT_UID_FROM_STRING_UID"),
        (e.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER"),
        (e.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER"),
        (e.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS"),
        (e.UID_CONFLICT = "UID_CONFLICT"),
        (e.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR"),
        (e.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED"),
        (e.TOKEN_EXPIRE = "TOKEN_EXPIRE"),
        (e.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK"),
        (e.INVALID_TRACK = "INVALID_TRACK"),
        (e.SENDER_NOT_FOUND = "SENDER_NOT_FOUND"),
        (e.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED"),
        (e.SET_ANSWER_FAILED = "SET_ANSWER_FAILED"),
        (e.ICE_FAILED = "ICE_FAILED"),
        (e.PC_CLOSED = "PC_CLOSED"),
        (e.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED"),
        (e.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED"),
        (e.GET_LOCAL_CONNECTION_PARAMS_FAILED =
          "GET_LOCAL_CONNECTION_PARAMS_FAILED"),
        (e.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED"),
        (e.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED"),
        (e.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST"),
        (e.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE"),
        (e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS =
          "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS"),
        (e.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK"),
        (e.INVALID_REMOTE_USER = "INVALID_REMOTE_USER"),
        (e.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED"),
        (e.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED"),
        (e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH =
          "CUSTOM_REPORT_FREQUENCY_TOO_HIGH"),
        (e.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED"),
        (e.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR"),
        (e.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED"),
        (e.WS_ABORT = "WS_ABORT"),
        (e.WS_DISCONNECT = "WS_DISCONNECT"),
        (e.WS_ERR = "WS_ERR"),
        (e.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT"),
        (e.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT"),
        (e.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT"),
        (e.LIVE_STREAMING_INTERNAL_SERVER_ERROR =
          "LIVE_STREAMING_INTERNAL_SERVER_ERROR"),
        (e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED =
          "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED"),
        (e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED =
          "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED"),
        (e.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR"),
        (e.LIVE_STREAMING_INVALID_RAW_STREAM =
          "LIVE_STREAMING_INVALID_RAW_STREAM"),
        (e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT =
          "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT"),
        (e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE =
          "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE"),
        (e.LIVE_STREAMING_WARN_FREQUENT_REQUEST =
          "LIVE_STREAMING_WARN_FREQUENT_REQUEST"),
        (e.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR"),
        (e.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR"),
        (e.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR"),
        (e.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC"),
        (e.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST"),
        (e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST =
          "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST"),
        (e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE =
          "CROSS_CHANNEL_SERVER_ERROR_RESPONSE"),
        (e.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE"),
        (e.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR"),
        (e.INVALID_PLUGIN = "INVALID_PLUGIN"),
        (e.DISCONNECT_P2P = "DISCONNECT_P2P"),
        (e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED =
          "CONVERTING_IMAGEDATA_TO_BLOB_FAILED"),
        (e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED =
          "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED"),
        (e.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT"),
        (e.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR"),
        (e.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT"),
        (e.PROHIBITED_OPERATION = "PROHIBITED_OPERATION"),
        (e.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED"),
        (e.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED"),
        e
      );
    })({}),
    JP = class extends Error {
      constructor(e) {
        let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
          i = arguments.length > 2 ? arguments[2] : void 0;
        super(t),
          $P(this, "code", void 0),
          $P(this, "message", void 0),
          $P(this, "data", void 0),
          $P(this, "name", "AgoraRTCException"),
          (this.code = e),
          (this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t)),
          (this.data = i);
      }
      toString() {
        return this.data
          ? ""
              .concat(this.message, "\ndata: ")
              .concat(JSON.stringify(this.data))
          : this.message;
      }
      print() {
        let e =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : "error",
          t = arguments.length > 1 ? arguments[1] : void 0;
        return (
          "error" === e && (t || console).error(this.toString()),
          "warning" === e && (t || console).warn(this.toString()),
          this
        );
      }
      throw(e) {
        throw (this.print("error", e), this);
      }
    };
  function QP(e, t) {
    if ("boolean" != typeof e)
      throw new JP(
        zP.INVALID_PARAMS,
        "Invalid ".concat(t, ": The value is of the boolean type.")
      );
  }
  function ZP(e, t, i) {
    if (!i.includes(e))
      throw new JP(
        zP.INVALID_PARAMS,
        "".concat(t, " can only be set as ").concat(JSON.stringify(i))
      );
  }
  function ek(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
      s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;
    if (
      e < i ||
      e > s ||
      ((!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) &&
        !(function(e) {
          return "number" == typeof e && e % 1 == 0;
        })(e))
    )
      throw new JP(
        zP.INVALID_PARAMS,
        "invalid "
          .concat(t, ": the value range is [")
          .concat(i, ", ")
          .concat(s, "]. integer only")
      );
  }
  function tk(e, t) {
    if ("number" != typeof e) {
      if (!(e.min || e.max || e.ideal || e.exact))
        throw new JP(
          zP.INVALID_PARAMS,
          "".concat(t, " is not a valid ConstrainLong")
        );
      void 0 !== e.min && ek(e.min, "".concat(t, ".min"), 0, 1 / 0),
        void 0 !== e.max && ek(e.max, "".concat(t, ".max"), 1, 1 / 0),
        void 0 !== e.exact && ek(e.exact, "".concat(t, ".exact"), 1, 1 / 0),
        void 0 !== e.ideal && ek(e.ideal, "".concat(t, ".ideal"), 1, 1 / 0);
    } else ek(e, t, 1, 1 / 0);
  }
  function ik(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
      s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255,
      r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
    if (null == e)
      throw new JP(
        zP.INVALID_PARAMS,
        "".concat(t || "param", " cannot be empty")
      );
    if (!nk(e, i, s, r))
      throw new JP(
        zP.INVALID_PARAMS,
        "Invalid "
          .concat(t || "string param", ": Length of the string: [")
          .concat(i, ",")
          .concat(s, "].")
          .concat(r ? " ASCII characters only." : "")
      );
  }
  function sk(e, t) {
    if (!Array.isArray(e))
      throw new JP(zP.INVALID_PARAMS, "".concat(t, " should be an array"));
  }
  function rk(e) {
    return null == e;
  }
  function nk(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255,
      s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    return (
      "string" == typeof e &&
      e.length <= i &&
      e.length >= t &&
      (!s ||
        (function(e) {
          if ("string" != typeof e) return !1;
          for (let t = 0; t < e.length; t += 1) {
            const i = e.charCodeAt(t);
            if (i < 0 || i > 255) return !1;
          }
          return !0;
        })(e))
    );
  }
  var ak = (function(e) {
      return (
        (e.COVERED = "COVERED"),
        (e.POSITION = "POSITION"),
        (e.SIZE = "SIZE"),
        (e.STYLE = "STYLE"),
        e
      );
    })(ak || {}),
    ok = (function(e) {
      return (
        (e.UNMOUNTED = "UNMOUNTED"),
        (e.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT"),
        e
      );
    })(ok || {});
  const ck = new (class {
    constructor() {
      $P(this, "_clientSize", null),
        $P(this, "getClientWidth", () =>
          document.documentElement
            ? document.documentElement.clientWidth
            : document.body.clientWidth
        ),
        $P(this, "getClientHeight", () =>
          document.documentElement
            ? document.documentElement.clientHeight
            : document.body.clientHeight
        ),
        $P(this, "getStyle", e => window.getComputedStyle(e, null)),
        $P(this, "checkCssVisibleProperty", e => {
          let t = !0;
          const i = this.getStyle(e),
            { display: s, visibility: r, opacity: n, filter: a } = i;
          return (
            ("none" === s ||
              ["hidden", "collapse"].includes(r) ||
              Number(n) < 0.1) &&
              (t = !1),
            !!t &&
              (a &&
                a
                  .split(" ")
                  .filter(e => {
                    const t = e.split("(")[0];
                    return ["brightness", "blur", "opacity"].includes(t);
                  })
                  .map(e => {
                    const [t, i] = e.split(/\(|\)/);
                    return [t, Number(i.match(/^[0-9\.]+/))];
                  })
                  .forEach(e => {
                    const [i, s] = e;
                    switch (i) {
                      case "brightness":
                        (s < 0.1 || s > 3) && (t = !1);
                        break;
                      case "blur":
                        s > 3 && (t = !1);
                        break;
                      case "opacity":
                        s < 0.1 && (t = !1);
                    }
                  }),
              t)
          );
        }),
        $P(this, "checkPropertyUpToAllParentNodes", (e, t) => {
          let i = !0,
            s = !0;
          const r = e => t(e);
          let n = e;
          for (; n && s; )
            r(n) || ((i = !1), (s = !1)), (n = n.parentElement), n || (s = !1);
          return i;
        }),
        $P(this, "checkActualCssVisibleIncludeInherit", e =>
          this.checkPropertyUpToAllParentNodes(e, this.checkCssVisibleProperty)
        ),
        $P(this, "getSizeAboutClient", e => {
          const {
              width: t,
              height: i,
              left: s,
              right: r,
              top: n,
              bottom: a
            } = e.getBoundingClientRect(),
            o = this.getClientWidth(),
            c = this.getClientHeight();
          return {
            width: t,
            height: i,
            left: s,
            right: r,
            top: n,
            bottom: a,
            clientWidth: o,
            clientHeight: c,
            clientMin: Math.min(o, c)
          };
        }),
        $P(this, "checkActualSize", () => {
          const { width: e, height: t, clientMin: i } = this._clientSize;
          return this.checkSizeIsVisible(e, t, i);
        }),
        $P(this, "elementFromPoint", (e, t) =>
          document.elementFromPoint ? document.elementFromPoint(e, t) : null
        ),
        $P(this, "checkCoverForAPoint", (e, t, i) => {
          const s = this.elementFromPoint(e, t);
          return null !== s && s !== i;
        }),
        $P(this, "getPointPositionList", () => {
          const { width: e, height: t, left: i, top: s } = this._clientSize,
            r = e / 6,
            n = t / 6,
            a = [],
            o = 10 ** 6;
          for (let e = 0; e < 5; e++)
            for (let t = 0; t < 5; t++) {
              const c =
                  (i * o +
                    (0 === e ? 0.1 : 4 === e ? (r * e * o - 1e5) / o : r * e) *
                      o) /
                  o,
                d =
                  (s * o +
                    (0 === t ? 0.1 : 4 === t ? (n * t * o - 1e5) / o : n * t) *
                      o) /
                  o;
              a.push({ x: c, y: d });
            }
          return [...a];
        }),
        $P(
          this,
          "checkElementCover",
          e =>
            this.getPointPositionList()
              .map(t => this.checkCoverForAPoint(t.x, t.y, e))
              .filter(e => !!e).length > 6
        ),
        $P(
          this,
          "checkSizeIsVisible",
          (e, t, i) => (e > 50 || i / e <= 10) && (t > 50 || i / t <= 10)
        ),
        $P(this, "checkSizeOfPartInClient", () => {
          const {
            left: e,
            right: t,
            top: i,
            bottom: s,
            clientHeight: r,
            clientWidth: n,
            clientMin: a
          } = this._clientSize;
          let o, c, d, l;
          if (e < 0) o = 0;
          else {
            if (!(e < n)) return !1;
            o = e;
          }
          if (t < 0) return !1;
          if (((c = t < n ? t : n), i < 0)) d = 0;
          else {
            if (!(i < r)) return !1;
            d = i;
          }
          if (s < 0) return !1;
          l = s < r ? s : r;
          const h = c - o,
            u = l - d;
          return this.checkSizeIsVisible(h, u, a);
        }),
        $P(
          this,
          "returnHiddenResult",
          e => ((this._clientSize = null), { visible: !1, reason: e })
        ),
        $P(this, "checkOneElementVisible", e => {
          if (e instanceof HTMLElement) {
            if (this.checkElementIsMountedOnDom(e)) {
              if (this.checkActualCssVisibleIncludeInherit(e)) {
                if (
                  ((this._clientSize = this.getSizeAboutClient(e)),
                  this.checkElementCover(e))
                )
                  return this.returnHiddenResult(ak.COVERED);
                {
                  const e = this.checkActualSize(),
                    t = this.checkSizeOfPartInClient();
                  return e && !t
                    ? this.returnHiddenResult(ak.POSITION)
                    : e
                    ? ((this._clientSize = null), { visible: !0 })
                    : this.returnHiddenResult(ak.SIZE);
                }
              }
              return this.returnHiddenResult(ak.STYLE);
            }
            return this.returnHiddenResult(ok.UNMOUNTED);
          }
          return this.returnHiddenResult(ok.INVALID_HTML_ELEMENT);
        }),
        $P(this, "checkElementIsMountedOnDom", e =>
          this.checkPropertyUpToAllParentNodes(e, e =>
            "HTML" !== e.nodeName.toUpperCase()
              ? null !== e.parentElement
              : !!document.documentElement
          )
        );
    }
  })();
  function dk(e) {
    return new TextEncoder().encode(e);
  }
  const lk = function(e, t) {
    const i = new Uint8Array(e.byteLength + t.byteLength);
    return (
      i.set(new Uint8Array(e), 0), i.set(new Uint8Array(t), e.byteLength), i
    );
  };
  const hk = async e =>
    (function(e, t) {
      let i = "";
      return (
        new Uint8Array(e).forEach(e => {
          i += e.toString(t).padStart(2, "0");
        }),
        i
      );
    })(await crypto.subtle.digest("SHA-256", dk(e)), 16);
  let uk = class {
    constructor() {
      $P(this, "_events", {}), $P(this, "addListener", this.on);
    }
    getListeners(e) {
      return this._events[e] ? this._events[e].map(e => e.listener) : [];
    }
    on(e, t) {
      this._events[e] || (this._events[e] = []);
      const i = this._events[e];
      -1 === this._indexOfListener(i, t) && i.push({ listener: t, once: !1 });
    }
    once(e, t) {
      this._events[e] || (this._events[e] = []);
      const i = this._events[e];
      -1 === this._indexOfListener(i, t) && i.push({ listener: t, once: !0 });
    }
    off(e, t) {
      if (!this._events[e]) return;
      const i = this._events[e],
        s = this._indexOfListener(i, t);
      -1 !== s && i.splice(s, 1),
        0 === this._events[e].length && delete this._events[e];
    }
    removeAllListeners(e) {
      e ? delete this._events[e] : (this._events = {});
    }
    emit(e) {
      this._events[e] || (this._events[e] = []);
      const t = this._events[e].map(e => e);
      for (
        var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), r = 1;
        r < i;
        r++
      )
        s[r - 1] = arguments[r];
      for (let i = 0; i < t.length; i += 1) {
        const r = t[i];
        r.once && this.off(e, r.listener), r.listener.apply(this, s || []);
      }
    }
    safeEmit(e) {
      for (
        var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1;
        s < t;
        s++
      )
        i[s - 1] = arguments[s];
      [...(this._events[e] || [])].forEach(t => {
        t.once && this.off(e, t.listener);
        try {
          t.listener.apply(this, i);
        } catch (t) {
          console.error(
            "safeEmit event:"
              .concat(e, " error ")
              .concat(null == t ? void 0 : t.toString())
          );
        }
      });
    }
    _indexOfListener(e, t) {
      let i = e.length;
      for (; i--; ) if (e[i].listener === t) return i;
      return -1;
    }
  };
  let pk = null;
  function fk() {
    if (pk) return pk;
    if (window.electron) return (pk = window.electron);
    if (!window.require) return null;
    try {
      return (pk = window.require("electron")), pk;
    } catch (e) {
      return null;
    }
  }
  let Ek = (function(e) {
      return (
        (e.CREATE_CLIENT = "createClient"),
        (e.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements"),
        (e.SET_AREA = "setArea"),
        (e.PRELOAD = "PRELOAD"),
        (e.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive"),
        (e.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive"),
        (e.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack"),
        (e.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack"),
        (e.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack"),
        (e.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack"),
        (e.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack"),
        (e.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks"),
        (e.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack"),
        (e.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig"),
        (e.START_PROXY_SERVER = "Client.startProxyServer"),
        (e.STOP_PROXY_SERVER = "Client.stopProxyServer"),
        (e.SET_PROXY_SERVER = "Client.setProxyServer"),
        (e.SET_TURN_SERVER = "Client.setTurnServer"),
        (e.SET_CLIENT_ROLE = "Client.setClientRole"),
        (e.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter"),
        (e.ENABLE_DUAL_STREAM = "Client.enableDualStream"),
        (e.DISABLE_DUAL_STREAM = "Client.disableDualStream"),
        (e.JOIN = "Client.join"),
        (e.LEAVE = "Client.leave"),
        (e.PUBLISH = "Client.publish"),
        (e.UNPUBLISH = "Client.unpublish"),
        (e.SUBSCRIBE = "Client.subscribe"),
        (e.MASS_SUBSCRIBE = "Client.massSubscribe"),
        (e.MASS_UNSUBSCRIBE = "Client.massUnsubscribe"),
        (e.UNSUBSCRIBE = "Client.unsubscribe"),
        (e.RENEW_TOKEN = "Client.renewToken"),
        (e.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType"),
        (e.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption"),
        (e.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator"),
        (e.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage"),
        (e.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent"),
        (e.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent"),
        (e.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy"),
        (e.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning"),
        (e.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError"),
        (e.START_LIVE_STREAMING = "Client.startLiveStreaming"),
        (e.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding"),
        (e.STOP_LIVE_STREAMING = "Client.stopLiveStreaming"),
        (e.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay"),
        (e.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay"),
        (e.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay"),
        (e.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request"),
        (e.SET_CONFIG_DISTRIBUTE = "_configDistribute"),
        (e.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute"),
        (e.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play"),
        (e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement"),
        (e.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop"),
        (e.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume"),
        (e.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice"),
        (e.BUFFER_AUDIO_TRACK_START =
          "BufferSourceAudioTrack.startProcessAudioBuffer"),
        (e.BUFFER_AUDIO_TRACK_STOP =
          "BufferSourceAudioTrack.stopProcessAudioBuffer"),
        (e.BUFFER_AUDIO_TRACK_PAUSE =
          "BufferSourceAudioTrack.pauseProcessAudioBuffer"),
        (e.BUFFER_AUDIO_TRACK_RESUME =
          "BufferSourceAudioTrack.resumeProcessAudioBuffer"),
        (e.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer"),
        (e.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play"),
        (e.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop"),
        (e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE =
          "LocalVideoTrack.getVideoElementVisibleStatus"),
        (e.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect"),
        (e.LOCAL_VIDEO_SEND_SEI_DATA = "LocalVideoTrack.sendSeiData"),
        (e.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice"),
        (e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG =
          "CameraVideoTrack.setEncoderConfiguration"),
        (e.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play"),
        (e.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop"),
        (e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE =
          "RemoteVideoTrack.getVideoElementVisibleStatus"),
        (e.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play"),
        (e.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop"),
        (e.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume"),
        (e.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice"),
        (e.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack"),
        (e.STREAM_TYPE_CHANGE = "streamTypeChange"),
        (e.CONNECTION_STATE_CHANGE = "connectionStateChange"),
        (e.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage"),
        (e.IMAGE_MODERATION_UPLOAD = "imageModerationUpload"),
        (e.REPUB_AFTER_PC_CONNECTED = "repubAfterPCConnected"),
        e
      );
    })({}),
    mk = (function(e) {
      return (e.TRACER = "tracer"), e;
    })({});
  function gk(e) {
    return (
      ek(e.timeout, "config.timeout", 0, 1e5),
      ek(e.timeoutFactor, "config.timeoutFactor", 0, 100, !1),
      ek(e.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0),
      ek(e.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0),
      !0
    );
  }
  !(function(e) {
    (e[(e.AUDIENCE_LEVEL_LOW_LATENCY = 1)] = "AUDIENCE_LEVEL_LOW_LATENCY"),
      (e[(e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2)] =
        "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY"),
      (e[(e.AUDIENCE_LEVEL_SYNC_LATENCY = 3)] = "AUDIENCE_LEVEL_SYNC_LATENCY");
  })({});
  let _k = (function(e) {
    return (
      (e.LEAVE = "LEAVE"),
      (e.NETWORK_ERROR = "NETWORK_ERROR"),
      (e.SERVER_ERROR = "SERVER_ERROR"),
      (e.UID_BANNED = "UID_BANNED"),
      (e.FALLBACK = "FALLBACK"),
      (e.IP_BANNED = "IP_BANNED"),
      (e.CHANNEL_BANNED = "CHANNEL_BANNED"),
      (e.LICENSE_MISSING = "LICENSE_MISSING"),
      (e.LICENSE_EXPIRED = "LICENSE_EXPIRED"),
      (e.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED"),
      (e.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID"),
      (e.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE"),
      (e.LICENSE_ILLEGAL = "LICENSE_ILLEGAL"),
      (e.TOKEN_EXPIRE = "TOKEN_EXPIRE"),
      e
    );
  })({});
  function Tk(e) {
    if (!Array.isArray(e) || e.length < 1) return !1;
    try {
      e.forEach(e => {
        if (!e.urls) throw Error();
      });
    } catch (e) {
      return !1;
    }
    return !0;
  }
  function Sk(e) {
    return (
      ik(e.turnServerURL, "turnServerURL"),
      ik(e.username, "username"),
      ik(e.password, "password"),
      e.udpport && ek(e.udpport, "udpport", 1, 99999, !0),
      e.forceturn && QP(e.forceturn, "forceturn"),
      e.security && QP(e.security, "security"),
      e.tcpport && ek(e.tcpport, "tcpport", 1, 99999, !0),
      !0
    );
  }
  function vk(e) {
    return (
      void 0 !== e.level && ZP(e.level, "level", [1, 2, 3]),
      void 0 !== e.delay && ek(e.delay, "delay", 0, 3e3, !0),
      !0
    );
  }
  let Rk = (function(e) {
      return (
        (e.PEERCONNECTION_STATE_CHANGE = "peerconnection-state-change"),
        (e.AUDIO_METADATA = "audio-metadata"),
        (e.CONNECTION_STATE_CHANGE = "connection-state-change"),
        (e.MEDIA_RECONNECT_START = "media-reconnect-start"),
        (e.MEDIA_RECONNECT_END = "media-reconnect-end"),
        (e.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy"),
        (e.USER_JOINED = "user-joined"),
        (e.USER_LEAVED = "user-left"),
        (e.USER_PUBLISHED = "user-published"),
        (e.USER_UNPUBLISHED = "user-unpublished"),
        (e.USER_INFO_UPDATED = "user-info-updated"),
        (e.CLIENT_BANNED = "client-banned"),
        (e.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state"),
        (e.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event"),
        (e.VOLUME_INDICATOR = "volume-indicator"),
        (e.CRYPT_ERROR = "crypt-error"),
        (e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire"),
        (e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire"),
        (e.NETWORK_QUALITY = "network-quality"),
        (e.STREAM_TYPE_CHANGED = "stream-type-changed"),
        (e.STREAM_FALLBACK = "stream-fallback"),
        (e.RECEIVE_METADATA = "receive-metadata"),
        (e.STREAM_MESSAGE = "stream-message"),
        (e.LIVE_STREAMING_ERROR = "live-streaming-error"),
        (e.LIVE_STREAMING_WARNING = "live-streaming-warning"),
        (e.EXCEPTION = "exception"),
        (e.ERROR = "error"),
        (e.P2P_LOST = "p2p_lost"),
        (e.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy"),
        (e.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket"),
        (e.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change"),
        (e.PUBLISHED_USER_LIST = "published-user-list"),
        (e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE =
          "content-inspect-connection-state-change"),
        (e.CONTENT_INSPECT_ERROR = "content-inspect-error"),
        (e.CONTENT_INSPECT_RESULT = "content-inspect-result"),
        (e.IMAGE_MODERATION_CONNECTION_STATE_CHANGE =
          "image-moderation-connection-state-change"),
        e
      );
    })({}),
    yk = (function(e) {
      return (
        (e.NETWORK_ERROR = "NETWORK_ERROR"),
        (e.SERVER_ERROR = "SERVER_ERROR"),
        (e.MULTI_IP = "MULTI_IP"),
        (e.TIMEOUT = "TIMEOUT"),
        (e.OFFLINE = "OFFLINE"),
        (e.LEAVE = "LEAVE"),
        (e.P2P_FAILED = "P2P_FAILED"),
        (e.FALLBACK = "FALLBACK"),
        (e.REGIONAL_DISTRIBUTION = "REGIONAL_DISTRIBUTION"),
        e
      );
    })({}),
    Ak = (function(e) {
      return (e.ONLINE = "ONLINE"), (e.OFFLINE = "OFFLINE"), e;
    })({}),
    Ik = (function(e) {
      return (
        (e.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE"),
        (e.ONLINE = "ONLINE"),
        (e.OFFLINE = "OFFLINE"),
        e
      );
    })({});
  function Ck(e, t) {
    for (
      var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), r = 2;
      r < i;
      r++
    )
      s[r - 2] = arguments[r];
    return 0 === e.getListeners(t).length
      ? Promise.reject(new JP(zP.UNEXPECTED_ERROR, "can not emit promise"))
      : new Promise((i, r) => {
          e.emit(t, ...s, i, r);
        });
  }
  function bk(e, t) {
    if (0 === e.getListeners(t).length) return Promise.resolve();
    for (
      var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), r = 2;
      r < i;
      r++
    )
      s[r - 2] = arguments[r];
    return Ck(e, t, ...s);
  }
  function Ok(e, t) {
    if (0 === e.getListeners(t).length) return null;
    for (
      var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), r = 2;
      r < i;
      r++
    )
      s[r - 2] = arguments[r];
    return Dk(e, t, ...s);
  }
  function Dk(e, t) {
    let i = null,
      s = null;
    for (
      var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), a = 2;
      a < r;
      a++
    )
      n[a - 2] = arguments[a];
    if (
      (e.emit(
        t,
        ...n,
        e => {
          i = e;
        },
        e => {
          s = e;
        }
      ),
      null !== s)
    )
      throw s;
    if (null === i) throw new JP(zP.UNEXPECTED_ERROR, "handler is not sync");
    return i;
  }
  const wk = new (class extends uk {
    set networkState(e) {
      this.emit(Ik.NETWORK_STATE_CHANGE, e, this._networkState),
        e === Ak.ONLINE
          ? this.emit(Ik.ONLINE)
          : e === Ak.OFFLINE &&
            ((this.onlineWaiter = new Promise(e => {
              this.once(Ik.ONLINE, () => {
                (this.onlineWaiter = void 0), e(Ak.ONLINE);
              });
            })),
            this.emit(Ik.OFFLINE)),
        (this._networkState = e);
    }
    get networkState() {
      return this._networkState;
    }
    get isOnline() {
      return this._networkState === Ak.ONLINE;
    }
    constructor() {
      super(),
        $P(this, "_moduleName", "network-indicator"),
        $P(this, "_networkState", Ak.ONLINE),
        $P(this, "onlineWaiter", void 0),
        window.addEventListener("online", () => {
          this.networkState = Ak.ONLINE;
        }),
        window.addEventListener("offline", () => {
          this.networkState = Ak.OFFLINE;
        });
    }
  })();
  function Lk(e, t) {
    const i = e.indexOf(t);
    -1 !== i && e.splice(i, 1);
  }
  function Nk(e) {
    const t = [];
    return (
      e.forEach(e => {
        -1 === t.indexOf(e) && t.push(e);
      }),
      t
    );
  }
  function Pk(e) {
    "undefined" != typeof Promise
      ? Promise.resolve().then(e)
      : setTimeout(e, 0);
  }
  function kk(e) {
    return JSON.parse(JSON.stringify(e));
  }
  function Mk(e) {
    try {
      return kk(e);
    } catch (t) {
      return e;
    }
  }
  const Uk = {};
  function xk(e, t) {
    Uk[t] || ((Uk[t] = !0), e());
  }
  function Fk(e) {
    const t = window.atob(e),
      i = new Uint8Array(new ArrayBuffer(t.length));
    for (let e = 0; e < t.length; e += 1) i[e] = t.charCodeAt(e);
    return i;
  }
  function Bk(e) {
    let t = "";
    for (let i = 0; i < e.length; i += 1) t += String.fromCharCode(e[i]);
    return window.btoa(t);
  }
  function Vk(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16,
      i = new TextEncoder().encode(e);
    if (i.length > t) i = i.slice(0, t);
    else if (i.length < t) {
      const e = new Uint8Array(t);
      e.set(i), (i = e);
    }
    return i;
  }
  function Gk() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    const s = t.reduce((e, t) => e + t.length, 0),
      r = new Uint8Array(new ArrayBuffer(s));
    let n = 0;
    return (
      t.forEach(e => {
        r.set(e, n), (n += e.length);
      }),
      r
    );
  }
  function jk(e) {
    return window.TextEncoder ? new TextEncoder().encode(e).length : e.length;
  }
  function Hk(e) {
    let t = 0;
    return (
      (/DingTalk/i.test(navigator.userAgent) ||
        /AliApp/i.test(navigator.userAgent)) &&
        e.realFormData &&
        (e = e.realFormData),
      e.forEach(e => {
        t += "string" == typeof e ? jk(e) : e.size;
      }),
      t + 138
    );
  }
  function Kk(e) {
    const t = new JP(zP.TIMEOUT, "timeout");
    return new Promise((i, s) => {
      window.setTimeout(() => s(t), e);
    });
  }
  function Wk(e) {
    return new Promise(t => {
      window.setTimeout(t, e);
    });
  }
  function Yk() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7,
      t = arguments.length > 1 ? arguments[1] : void 0;
    const i = Math.random()
      .toString(16)
      .substr(2, e)
      .toLowerCase();
    return i.length === e
      ? "".concat(t).concat(i)
      : "".concat(t).concat(i) + Yk(e - i.length, "");
  }
  function $k() {
    return Yk(32, "").toUpperCase();
  }
  const qk = () => {},
    Xk = new (class {
      constructor() {
        $P(this, "fnMap", new Map());
      }
      throttleByKey(e, t, i, s) {
        for (
          var r = arguments.length, n = new Array(r > 4 ? r - 4 : 0), a = 4;
          a < r;
          a++
        )
          n[a - 4] = arguments[a];
        if (this.fnMap.has(t)) {
          const r = this.fnMap.get(t);
          if (r.threshold !== i) {
            r.fn(...r.args), clearTimeout(r.timer);
            const a = window.setTimeout(() => {
              const e = this.fnMap.get(t);
              e && e.fn(...e.args), this.fnMap.delete(t);
            }, i);
            this.fnMap.set(t, {
              fn: e,
              threshold: i,
              timer: a,
              args: n,
              skipFn: s
            });
          } else
            r.skipFn && r.skipFn(...r.args),
              this.fnMap.set(
                t,
                XP(XP({}, r), {}, { fn: e, args: n, skipFn: s })
              );
        } else {
          const r = window.setTimeout(() => {
            const e = this.fnMap.get(t);
            e && e.fn(...e.args), this.fnMap.delete(t);
          }, i);
          this.fnMap.set(t, {
            fn: e,
            threshold: i,
            timer: r,
            args: n,
            skipFn: s
          });
        }
      }
    })(),
    zk = Xk.throttleByKey.bind(Xk);
  function Jk(e) {
    return "object" == typeof e && null !== e && !(e instanceof RegExp);
  }
  function Qk(e, t) {
    if (!Jk(e) || !Jk(t)) return t;
    if (
      (Array.isArray(e) && !Array.isArray(t)) ||
      (!Array.isArray(e) && Array.isArray(t))
    )
      return t;
    if (Array.isArray(t) && Array.isArray(e)) {
      const i = [...e];
      for (let s = 0; s < t.length; s++) i[s] = Qk(e[s], t[s]);
      return i;
    }
    {
      const i = XP({}, e);
      for (const s in t)
        Object.prototype.hasOwnProperty.call(t, s) &&
          (Object.prototype.hasOwnProperty.call(e, s)
            ? (i[s] = Qk(e[s], t[s]))
            : (i[s] = t[s]));
      return i;
    }
  }
  function Zk(e, t) {
    let i = [0];
    if ((t && (i = new Array(t).fill(0)), 0 === e)) return i;
    let s = 0;
    for (; e > 0 && ((i[s] = 255 & e), (e >>= 8), s++, !t || s !== t); );
    return i;
  }
  function eM(e) {
    return "number" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0;
  }
  let tM = 1,
    iM = console,
    sM = class {
      static setLogger(e) {
        iM = e;
      }
      constructor(e, t) {
        $P(this, "id", void 0),
          $P(this, "lockingPromise", Promise.resolve()),
          $P(this, "locks", 0),
          $P(this, "name", ""),
          $P(this, "lockId", void 0),
          (this.lockId = tM++),
          e && (this.name = e),
          t && (this.id = t),
          this.logger("created");
      }
      logger(e, t) {
        const i =
            (this.id ? "[".concat(this.id, "]") : "") +
            "[lock-".concat(this.name, "-").concat(this.lockId, "]"),
          s =
            "created" === e
              ? "is ".concat(e, ".")
              : "is "
                  .concat(e, ", current queue ")
                  .concat(this.locks, ". ")
                  .concat(null != t ? t : "");
        iM.debug("".concat(i, " ").concat(s));
      }
      setId(e) {
        this.id = e;
      }
      get isLocked() {
        return this.locks > 0;
      }
      lock(e) {
        let t;
        (this.locks += 1), this.logger("locked", e);
        const i = new Promise(i => {
            t = () => {
              (this.locks -= 1), this.logger("unlocked", e), i();
            };
          }),
          s = this.lockingPromise.then(() => t);
        return (this.lockingPromise = this.lockingPromise.then(() => i)), s;
      }
    };
  function rM(e, t) {
    return function(i, s, r) {
      const n = r.value;
      if ("function" != typeof n)
        throw new Error("Cannot use mutex on object property.");
      return (
        (r.value = async function() {
          const i = this[t];
          if (!i)
            throw new Error(
              "mutex property key ".concat(t, " doesn't exist on ").concat(e)
            );
          const r = await i.lock("From ".concat(e, ".").concat(s));
          try {
            for (var a = arguments.length, o = new Array(a), c = 0; c < a; c++)
              o[c] = arguments[c];
            return await n.apply(this, o);
          } finally {
            r();
          }
        }),
        r
      );
    };
  }
  const nM = {
    timeout: 500,
    timeoutFactor: 1.5,
    maxRetryCount: 1 / 0,
    maxRetryTimeout: 1e4
  };
  function aM(e, t) {
    const i = Math.floor(t.timeout * Math.pow(t.timeoutFactor, e));
    return Math.min(t.maxRetryTimeout, i);
  }
  function oM(e, t, i, s) {
    const r = Object.assign({}, nM, s);
    let n = r.timeout;
    const a = async () => {
      await (function(e) {
        return new Promise(t => {
          window.setTimeout(t, e);
        });
      })(n),
        (n *= r.timeoutFactor),
        (n = Math.min(r.maxRetryTimeout, n));
    };
    let o = !1;
    const c = new Promise(async (s, n) => {
      (t = t || (() => !1)), (i = i || (() => !0));
      for (let c = 0; c < r.maxRetryCount; c += 1) {
        if (o) return n(new JP(zP.OPERATION_ABORTED));
        try {
          const i = await e();
          if (!t(i, c)) return s(i);
          if (c + 1 === r.maxRetryCount) return s(i);
          await a();
        } catch (e) {
          if (!i(e, c)) return n(e);
          if (c + 1 === r.maxRetryCount) return n(e);
          await a();
        }
      }
    });
    return (c.cancel = () => (o = !0)), c;
  }
  let cM,
    dM = 0,
    lM = 0;
  function hM(e, t, i, s) {
    return new Promise((r, n) => {
      (t.responseType = t.responseType || "json"),
        t.data && !i
          ? ((t.data = JSON.stringify(t.data)), (dM += jk(t.data)))
          : i &&
            (t.data.size
              ? (dM += t.data.size)
              : t.data instanceof FormData
              ? (dM += Hk(t.data))
              : (dM += jk(JSON.stringify(t.data)))),
        (t.headers = t.headers || {}),
        (t.headers["Content-Type"] =
          t.headers["Content-Type"] || "application/json"),
        (t.method = "POST"),
        (t.url = e),
        lP
          .request(t)
          .then(e => {
            "string" == typeof e.data
              ? (lM += jk(e.data))
              : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array
              ? (lM += e.data.byteLength)
              : (lM += jk(JSON.stringify(e.data))),
              s && r({ data: e.data, headers: e.headers }),
              r(e.data);
          })
          .catch(e => {
            lP.isCancel(e)
              ? n(new JP(zP.OPERATION_ABORTED, "cancel token canceled"))
              : "ECONNABORTED" === e.code
              ? n(new JP(zP.NETWORK_TIMEOUT, e.message))
              : e.response
              ? n(new JP(zP.NETWORK_RESPONSE_ERROR, e.response.status))
              : n(new JP(zP.NETWORK_ERROR, e.message));
          });
    });
  }
  async function uM(e, t) {
    const i = new Blob([t.data], { type: "buffer" });
    return await hM(
      e,
      XP(
        XP({}, t),
        {},
        { data: i, headers: { "Content-Type": "application/octet-stream" } }
      ),
      !0
    );
  }
  const pM = () => void 0 !== window.isSecureContext;
  function fM(e) {
    if (Array.isArray(e)) return e.map(e => e);
    if (!EM(e)) return e;
    const t = {};
    for (const i in e) {
      const s = e[i];
      EM(s) || Array.isArray(s) ? (t[i] = fM(s)) : (t[i] = s);
    }
    return t;
  }
  function EM(e) {
    return !("object" != typeof e || Array.isArray(e) || !e);
  }
  let mM = class {
    constructor(e) {
      $P(this, "input", []), $P(this, "size", void 0), (this.size = e);
    }
    add(e) {
      this.input.push(e),
        this.input.length > this.size && this.input.splice(0, 1);
    }
    diffMean() {
      return 0 === this.input.length
        ? 0
        : (this.input[this.input.length - 1] - this.input[0]) /
            this.input.length;
    }
  };
  const gM = {
      address: "unknown",
      candidateType: "unknown",
      id: "unknown",
      port: 0,
      priority: 0,
      protocol: "unknown",
      type: "unknown"
    },
    _M = {
      timestamp: 0,
      bitrate: { actualEncoded: 0, transmit: 0 },
      sendPacketLossRate: 0,
      recvPacketLossRate: 0,
      videoRecv: [],
      videoSend: [],
      audioRecv: [],
      audioSend: [],
      selectedCandidatePair: {
        id: "unknown",
        localCandidate: gM,
        remoteCandidate: gM
      },
      updateInterval: 0
    },
    TM = {
      firsCount: 0,
      nacksCount: 0,
      plisCount: 0,
      framesDecodeCount: 0,
      framesDecodeInterval: 0,
      framesDecodeFreezeTime: 0,
      decodeFrameRate: 0,
      bytes: 0,
      packetsLost: 0,
      packetLostRate: 0,
      packets: 0,
      ssrc: 0,
      qpSumPerFrame: 0,
      framesDroppedCount: 0,
      outputFrameRate: 0,
      packetsDiscarded: 0,
      framesAssembledFromMultiplePackets: 0,
      totalProcessingDelay: 0,
      avgDecodeMs: 0,
      avgFramesAssembledFromMultiplePacketsMs: 0,
      avgProcessingDelayMs: 0,
      avgInterFrameDelayMs: 0,
      totalAssemblyTime: 0
    },
    SM = {
      firsCount: 0,
      nacksCount: 0,
      plisCount: 0,
      frameCount: 0,
      bytes: 0,
      packets: 0,
      packetsLost: 0,
      packetLostRate: 0,
      ssrc: 0,
      rttMs: 0,
      jitterMs: 0,
      qpSumPerFrame: 0
    },
    vM = {
      bytes: 0,
      packets: 0,
      packetsLost: 0,
      packetLostRate: 0,
      ssrc: 0,
      rttMs: 0,
      jitterMs: 0
    },
    RM = {
      jitterBufferMs: 0,
      jitterMs: 0,
      bytes: 0,
      packetsLost: 0,
      packetLostRate: 0,
      packetsDiscarded: 0,
      packets: 0,
      ssrc: 0,
      receivedFrames: 0,
      droppedFrames: 0,
      concealedSamples: 0,
      totalSamplesReceived: 0
    };
  let yM = class {
      constructor(e, t) {
        $P(this, "onFirstVideoReceived", void 0),
          $P(this, "onFirstVideoDecoded", void 0),
          $P(this, "onFirstAudioReceived", void 0),
          $P(this, "onFirstVideoDecodedTimeout", void 0),
          $P(this, "onFirstAudioDecoded", void 0),
          $P(this, "onSelectedLocalCandidateChanged", void 0),
          $P(this, "onSelectedRemoteCandidateChanged", void 0),
          $P(this, "videoIsReady", !1),
          $P(this, "videoIsReady2", {}),
          $P(this, "pc", void 0),
          $P(this, "options", void 0),
          $P(this, "intervalTimer", void 0),
          $P(this, "stats", fM(_M)),
          $P(this, "isFirstVideoReceived", {}),
          $P(this, "isFirstVideoDecoded", {}),
          $P(this, "isFirstAudioReceived", {}),
          $P(this, "isFirstAudioDecoded", {}),
          $P(this, "isFirstVideoDecodedTimeout", {}),
          $P(this, "lossRateWindowStats", []),
          (this.pc = e),
          (this.options = t),
          (this.intervalTimer = window.setInterval(async () => {
            this.updateStats();
          }, this.options.updateInterval));
      }
      getStats() {
        return this.stats;
      }
      getSelectedCandidatePair() {
        return new Promise(e => {
          e({ local: XP({}, gM), remote: XP({}, gM) });
        });
      }
      setVideoIsReady(e) {
        this.videoIsReady = e;
      }
      setVideoIsReady2(e, t) {
        this.videoIsReady2[e] = t;
      }
      getVideoIsReady(e) {
        return this.videoIsReady2[e] || !1;
      }
      setIsFirstAudioDecoded(e) {}
      destroy() {
        window.clearInterval(this.intervalTimer), (this.pc = void 0);
      }
      calcLossRate(e) {
        this.lossRateWindowStats.push(e),
          this.lossRateWindowStats.length > this.options.lossRateInterval &&
            this.lossRateWindowStats.splice(0, 1);
        const t = this.lossRateWindowStats.length,
          i = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
        let s = 0,
          r = 0,
          n = 0,
          a = 0;
        for (const o of i)
          e[o].forEach((e, i) => {
            if (
              !this.lossRateWindowStats[t - 1][o][i] ||
              !this.lossRateWindowStats[0][o][i]
            )
              return;
            const c =
                this.lossRateWindowStats[t - 1][o][i].packets -
                this.lossRateWindowStats[0][o][i].packets,
              d =
                this.lossRateWindowStats[t - 1][o][i].packetsLost -
                this.lossRateWindowStats[0][o][i].packetsLost;
            "videoSend" === o || "audioSend" === o
              ? ((s += c), (n += d))
              : ((r += c), (a += d)),
              Number.isNaN(c) || Number.isNaN(c)
                ? (e.packetLostRate = 0)
                : (e.packetLostRate = c <= 0 || d <= 0 ? 0 : d / (c + d));
          });
        (e.sendPacketLossRate = s <= 0 || n <= 0 ? 0 : n / (s + n)),
          (e.recvPacketLossRate = r <= 0 || a <= 0 ? 0 : a / (r + a));
      }
    },
    AM = class extends yM {
      constructor() {
        super(...arguments),
          $P(this, "_stats", _M),
          $P(this, "lastDecodeVideoReceiverStats", new Map());
      }
      async updateStats() {
        const e = await this._getStats(),
          t = this.statsResponsesToObjects(e);
        this._stats = fM(_M);
        const i = t.filter(e => "ssrc" === e.type);
        this.processSSRCStats(i);
        const s = t.find(e => "VideoBwe" === e.type);
        s && this.processBandwidthStats(s),
          (this._stats.timestamp = Date.now()),
          this.calcLossRate(this._stats),
          (this.stats = this._stats);
      }
      processBandwidthStats(e) {
        (this._stats.bitrate = {
          actualEncoded: Number(e.googActualEncBitrate),
          targetEncoded: Number(e.googTargetEncBitrate),
          retransmit: Number(e.googRetransmitBitrate),
          transmit: Number(e.googTransmitBitrate)
        }),
          (this._stats.sendBandwidth = Number(e.googAvailableSendBandwidth));
      }
      processSSRCStats(e) {
        e.forEach(e => {
          const t = e.id.includes("send");
          switch ("".concat(e.mediaType, "_").concat(t ? "send" : "recv")) {
            case "video_send": {
              const t = fM(SM);
              (t.codec = e.googCodecName),
                (t.adaptionChangeReason = "none"),
                e.googCpuLimitedResolution && (t.adaptionChangeReason = "cpu"),
                e.googBandwidthLimitedResolution &&
                  (t.adaptionChangeReason = "bandwidth"),
                (t.avgEncodeMs = Number(e.googAvgEncodeMs)),
                (t.inputFrame = {
                  width:
                    Number(e.googFrameWidthInput) ||
                    Number(e.googFrameWidthSent),
                  height:
                    Number(e.googFrameHeightInput) ||
                    Number(e.googFrameHeightSent),
                  frameRate: Number(e.googFrameRateInput)
                }),
                (t.sentFrame = {
                  width: Number(e.googFrameWidthSent),
                  height: Number(e.googFrameHeightSent),
                  frameRate: Number(e.googFrameRateInput)
                }),
                (t.firsCount = Number(e.googFirReceived)),
                (t.nacksCount = Number(e.googNacksReceived)),
                (t.plisCount = Number(e.googPlisReceived)),
                (t.frameCount = Number(e.framesEncoded)),
                (t.bytes = Number(e.bytesSent)),
                (t.packets = Number(e.packetsSent)),
                (t.packetsLost = Number(e.packetsLost)),
                (t.ssrc = Number(e.ssrc)),
                (t.rttMs = Number(e.googRtt || 0)),
                this._stats.videoSend.push(t),
                (this._stats.rtt = t.rttMs);
              break;
            }
            case "video_recv": {
              const t = fM(TM),
                i = this.lastDecodeVideoReceiverStats.get(Number(e.ssrc));
              if (
                ((t.codec = e.googCodecName),
                (t.targetDelayMs = Number(e.googTargetDelayMs)),
                (t.renderDelayMs = Number(e.googRenderDelayMs)),
                (t.currentDelayMs = Number(e.googCurrentDelayMs)),
                (t.minPlayoutDelayMs = Number(e.googMinPlayoutDelayMs)),
                (t.decodeMs = Number(e.googDecodeMs)),
                (t.maxDecodeMs = Number(e.googMaxDecodeMs)),
                (t.receivedFrame = {
                  width: Number(e.googFrameWidthReceived),
                  height: Number(e.googFrameHeightReceived),
                  frameRate: Number(e.googFrameRateReceived)
                }),
                (t.decodedFrame = {
                  width: Number(e.googFrameWidthReceived),
                  height: Number(e.googFrameHeightReceived),
                  frameRate: Number(e.googFrameRateDecoded)
                }),
                (t.decodeFrameRate = Number(e.googFrameRateDecoded)),
                (t.outputFrame = {
                  width: Number(e.googFrameWidthReceived),
                  height: Number(e.googFrameHeightReceived),
                  frameRate: Number(e.googFrameRateOutput)
                }),
                (t.jitterBufferMs = Number(e.googJitterBufferMs)),
                (t.firsCount = Number(e.googFirsSent)),
                (t.nacksCount = Number(e.googNacksSent)),
                (t.plisCount = Number(e.googPlisSent)),
                (t.framesDecodeCount = Number(e.framesDecoded)),
                (t.bytes = Number(e.bytesReceived)),
                (t.packets = Number(e.packetsReceived)),
                (t.packetsLost = Number(e.packetsLost)),
                (t.ssrc = Number(e.ssrc)),
                t.packets > 0 &&
                  !this.isFirstVideoReceived[t.ssrc] &&
                  (this.onFirstVideoReceived &&
                    this.onFirstVideoReceived(t.ssrc),
                  (this.isFirstVideoReceived[t.ssrc] = !0)),
                t.framesDecodeCount > 0 &&
                  !this.isFirstVideoDecoded[t.ssrc] &&
                  (this.onFirstVideoDecoded &&
                    this.onFirstVideoDecoded(
                      t.ssrc,
                      t.decodedFrame.width,
                      t.decodedFrame.height
                    ),
                  (this.isFirstVideoDecoded[t.ssrc] = !0)),
                i)
              ) {
                const s = i.stats,
                  r = Date.now() - i.lts;
                (t.framesDecodeFreezeTime = s.framesDecodeFreezeTime),
                  (t.framesDecodeInterval = s.framesDecodeInterval),
                  t.framesDecodeCount > s.framesDecodeCount &&
                  this.isFirstVideoDecoded[t.ssrc]
                    ? ((i.lts = Date.now()),
                      (t.framesDecodeInterval = r),
                      t.framesDecodeInterval >= this.options.freezeRateLimit &&
                        (this.getVideoIsReady(parseInt(e.ssrc, 10))
                          ? (t.framesDecodeFreezeTime += t.framesDecodeInterval)
                          : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0)))
                    : t.framesDecodeCount < i.stats.framesDecodeCount &&
                      (t.framesDecodeInterval = 0);
              }
              this.lastDecodeVideoReceiverStats.set(t.ssrc, {
                stats: XP({}, t),
                lts: Date.now()
              }),
                this._stats.videoRecv.push(t);
              break;
            }
            case "audio_recv": {
              const t = fM(RM);
              (t.codec = e.googCodecName),
                (t.outputLevel = Math.abs(Number(e.audioOutputLevel)) / 32767),
                (t.decodingCNG = Number(e.googDecodingCNG)),
                (t.decodingCTN = Number(e.googDecodingCTN)),
                (t.decodingCTSG = Number(e.googDecodingCTSG)),
                (t.decodingNormal = Number(e.googDecodingNormal)),
                (t.decodingPLC = Number(e.googDecodingPLC)),
                (t.decodingPLCCNG = Number(e.googDecodingPLCCNG)),
                (t.expandRate = Number(e.googExpandRate)),
                (t.accelerateRate = Number(e.googAccelerateRate)),
                (t.preemptiveExpandRate = Number(e.googPreemptiveExpandRate)),
                (t.secondaryDecodedRate = Number(e.googSecondaryDecodedRate)),
                (t.speechExpandRate = Number(e.googSpeechExpandRate)),
                (t.preferredJitterBufferMs = Number(
                  e.googPreferredJitterBufferMs
                )),
                (t.jitterBufferMs = Number(e.googJitterBufferMs)),
                (t.jitterMs = Number(e.googJitterReceived)),
                (t.bytes = Number(e.bytesReceived)),
                (t.packets = Number(e.packetsReceived)),
                (t.packetsLost = Number(e.packetsLost)),
                (t.ssrc = Number(e.ssrc)),
                (t.receivedFrames =
                  Number(e.googDecodingCTN) || Number(e.packetsReceived)),
                (t.droppedFrames =
                  Number(e.googDecodingPLC) + Number(e.googDecodingPLCCNG) ||
                  Number(e.packetsLost)),
                t.receivedFrames > 0 &&
                  !this.isFirstAudioReceived[t.ssrc] &&
                  (this.onFirstAudioReceived &&
                    this.onFirstAudioReceived(t.ssrc),
                  (this.isFirstAudioReceived[t.ssrc] = !0)),
                t.decodingNormal > 0 &&
                  !this.isFirstAudioDecoded[t.ssrc] &&
                  (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc),
                  (this.isFirstAudioDecoded[t.ssrc] = !0)),
                this._stats.audioRecv.push(t);
              break;
            }
            case "audio_send": {
              const t = fM(vM);
              (t.codec = e.googCodecName),
                (t.inputLevel = Math.abs(Number(e.audioInputLevel)) / 32767),
                (t.aecReturnLoss = Number(
                  e.googEchoCancellationReturnLoss || 0
                )),
                (t.aecReturnLossEnhancement = Number(
                  e.googEchoCancellationReturnLossEnhancement || 0
                )),
                (t.residualEchoLikelihood = Number(
                  e.googResidualEchoLikelihood || 0
                )),
                (t.residualEchoLikelihoodRecentMax = Number(
                  e.googResidualEchoLikelihoodRecentMax || 0
                )),
                (t.bytes = Number(e.bytesSent)),
                (t.packets = Number(e.packetsSent)),
                (t.packetsLost = Number(e.packetsLost)),
                (t.ssrc = Number(e.ssrc)),
                (t.rttMs = Number(e.googRtt || 0)),
                (this._stats.rtt = t.rttMs),
                this._stats.audioSend.push(t);
              break;
            }
          }
        });
      }
      _getStats() {
        return new Promise((e, t) => {
          this.pc.getStats(e, t);
        });
      }
      statsResponsesToObjects(e) {
        const t = [];
        return (
          e.result().forEach(e => {
            const i = {
              id: e.id,
              timestamp: e.timestamp.valueOf().toString(),
              type: e.type
            };
            e.names().forEach(t => {
              i[t] = e.stat(t);
            }),
              t.push(i);
          }),
          t
        );
      }
    },
    IM = (function(e) {
      return (
        (e.BANDWIDTH = "bandwidth"),
        (e.CPU = "cpu"),
        (e.NONE = "none"),
        (e.OTHER = "other"),
        e
      );
    })({}),
    CM = (function(e) {
      return (
        (e.L1T1 = "L1T1"),
        (e.L1T2 = "L1T2"),
        (e.L1T3 = "L1T3"),
        (e.L1T3_KEY = "L1T3_KEY"),
        (e.L2T1_KEY = "L2T1_KEY"),
        (e.L2T2_KEY = "L2T2_KEY"),
        (e.L2T3_KEY = "L2T3_KEY"),
        (e.L3T1_KEY = "L3T1_KEY"),
        (e.L3T2_KEY = "L3T2_KEY"),
        (e.L3T3_KEY = "L3T3_KEY"),
        e
      );
    })({}),
    bM = (function(e) {
      return (
        (e[(e.new = 0)] = "new"),
        (e[(e.connecting = 1)] = "connecting"),
        (e[(e.connected = 2)] = "connected"),
        (e[(e.disconnected = 3)] = "disconnected"),
        (e[(e.failed = 4)] = "failed"),
        (e[(e.closed = 5)] = "closed"),
        e
      );
    })({}),
    OM = (function(e) {
      return (
        (e.CERTIFICATE = "certificate"),
        (e.CODEC = "codec"),
        (e.CANDIDATE_PAIR = "candidate-pair"),
        (e.LOCAL_CANDIDATE = "local-candidate"),
        (e.REMOTE_CANDIDATE = "remote-candidate"),
        (e.INBOUND = "inbound-rtp"),
        (e.TRACK = "track"),
        (e.OUTBOUND = "outbound-rtp"),
        (e.PC = "peer-connection"),
        (e.REMOTE_INBOUND = "remote-inbound-rtp"),
        (e.REMOTE_OUTBOUND = "remote-outbound-rtp"),
        (e.TRANSPORT = "transport"),
        (e.CSRC = "csrc"),
        (e.DATA_CHANNEL = "data-channel"),
        (e.STREAM = "stream"),
        (e.SENDER = "sender"),
        (e.RECEIVER = "receiver"),
        e
      );
    })({});
  var DM = (function(e) {
    return (
      (e[(e.kNone = 1)] = "kNone"),
      (e[(e.kMillisecondsFromSeconds = 1e3)] = "kMillisecondsFromSeconds"),
      (e[(e.kBytesToBits = 8)] = "kBytesToBits"),
      e
    );
  })(DM || {});
  function wM(e, t, i, s) {
    let r =
      arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : DM.kNone;
    if (!t) return;
    const n = Number(t[i]);
    if ("number" != typeof n) return;
    const a = Number(t[s]);
    if ("number" != typeof a) return;
    if (!e) return a ? (n / a) * r : void 0;
    const o = Number(e[i]);
    if ("number" != typeof o) return;
    const c = Number(e[s]);
    if ("number" != typeof c) return;
    const d = a - c;
    return d ? ((n - o) / d) * r : void 0;
  }
  let LM = class extends yM {
      constructor() {
        super(...arguments),
          $P(this, "_stats", _M),
          $P(this, "report", void 0),
          $P(this, "lastDecodeVideoReceiverStats", new Map()),
          $P(this, "lastVideoFramesRecv", new Map()),
          $P(this, "lastVideoFramesSent", new Map()),
          $P(this, "lastVideoFramesDecode", new Map()),
          $P(this, "lastVideoFramesOutput", new Map()),
          $P(this, "lastVideoJBDelay", new Map()),
          $P(this, "lastAudioJBDelay", new Map()),
          $P(this, "mediaBytesSent", new Map()),
          $P(this, "mediaBytesRetransmit", new Map()),
          $P(this, "mediaBytesTargetEncode", new Map()),
          $P(this, "lastDecodeAudioReceiverStats", new Map()),
          $P(this, "lastEncoderMs", new Map());
      }
      async updateStats() {
        (this.report = await this.pc.getStats()),
          (this._stats = fM(_M)),
          this.report.forEach(e => {
            switch (e.type) {
              case OM.OUTBOUND:
              case OM.INBOUND: {
                const t = e.mediaType || e.kind,
                  i = !t && "frameWidth" in e,
                  s = !t && !("frameWidth" in e);
                e.type === OM.OUTBOUND
                  ? "audio" === t || s
                    ? this.processAudioOutboundStats(e)
                    : ("video" === t || i) && this.processVideoOutboundStats(e)
                  : e.type === OM.INBOUND &&
                    ("audio" === t || s
                      ? this.processAudioInboundStats(e)
                      : ("video" === t || i) &&
                        this.processVideoInboundStats(e));
                break;
              }
              case OM.TRANSPORT: {
                const t = this.report.get(e.selectedCandidatePairId);
                t && this.processCandidatePairStats(t);
                break;
              }
              case OM.CANDIDATE_PAIR:
                e.selected && this.processCandidatePairStats(e);
            }
          }),
          this.updateSendBitrate(),
          (this._stats.updateInterval = Date.now() - this.stats.timestamp),
          (this._stats.timestamp = Date.now()),
          this.calcLossRate(this._stats),
          (this.stats = this._stats);
      }
      async getSelectedCandidatePair() {
        const e = await this.pc.getStats(),
          t = { local: XP({}, gM), remote: XP({}, gM) };
        return (
          e.forEach(i => {
            let s;
            if (
              (i.type === OM.TRANSPORT &&
                (s = e.get(i.selectedCandidatePairId)),
              i.type === OM.CANDIDATE_PAIR && i.selected && (s = i),
              s)
            ) {
              const i = (e, t) => {
                (e.type = t.type),
                  (e.id = t.id),
                  t.address && (e.address = t.address),
                  t.candidateType && (e.candidateType = t.candidateType),
                  t.port && (e.port = t.port),
                  t.priority && (e.priority = t.priority),
                  t.protocol && (e.protocol = t.protocol),
                  t.relayProtocol && (e.relayProtocol = t.relayProtocol);
              };
              if (s.localCandidateId) {
                const r = e.get(s.localCandidateId);
                r && i(t.local, r);
              }
              if (s.remoteCandidateId) {
                const r = e.get(s.remoteCandidateId);
                r && i(t.remote, r);
              }
            }
          }),
          t
        );
      }
      processCandidatePairStats(e) {
        if (
          ((this._stats.sendBandwidth = e.availableOutgoingBitrate || 0),
          e.currentRoundTripTime &&
            (this._stats.rtt = 1e3 * e.currentRoundTripTime),
          this._stats.videoSend.forEach(t => {
            e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);
          }),
          this._stats.audioSend.forEach(t => {
            e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);
          }),
          (this._stats.selectedCandidatePair.id = e.id),
          e.localCandidateId)
        ) {
          const t = this.report.get(e.localCandidateId);
          t && this.processCandidateStats(t);
        }
        if (e.remoteCandidateId) {
          const t = this.report.get(e.remoteCandidateId);
          t && this.processCandidateStats(t);
        }
      }
      processCandidateStats(e) {
        let t;
        e.type === OM.LOCAL_CANDIDATE &&
          (t = this._stats.selectedCandidatePair.localCandidate),
          e.type === OM.REMOTE_CANDIDATE &&
            (t = this._stats.selectedCandidatePair.remoteCandidate),
          t &&
            ((t.type = e.type),
            (t.id = e.id),
            e.address && (t.address = e.address),
            e.candidateType && (t.candidateType = e.candidateType),
            e.port && (t.port = e.port),
            e.priority && (t.priority = e.priority),
            e.protocol && (t.protocol = e.protocol),
            e.relayProtocol && (t.relayProtocol = e.relayProtocol),
            e.type === OM.LOCAL_CANDIDATE &&
              this.stats.selectedCandidatePair.localCandidate.id !== t.id &&
              this.onSelectedLocalCandidateChanged &&
              this.onSelectedLocalCandidateChanged(
                XP({}, t),
                XP({}, this.stats.selectedCandidatePair.localCandidate)
              ),
            e.type === OM.REMOTE_CANDIDATE &&
              this.stats.selectedCandidatePair.remoteCandidate.id !== t.id &&
              this.onSelectedRemoteCandidateChanged &&
              this.onSelectedRemoteCandidateChanged(
                XP({}, t),
                XP({}, this.stats.selectedCandidatePair.remoteCandidate)
              ));
      }
      processAudioInboundStats(e) {
        let t = this._stats.audioRecv.find(t => t.ssrc === e.ssrc);
        t || ((t = fM(RM)), this._stats.audioRecv.push(t)),
          (t.ssrc = e.ssrc),
          (t.packets = e.packetsReceived),
          (t.packetsLost = e.packetsLost),
          (t.packetsDiscarded = e.packetsDiscarded),
          (t.bytes = e.bytesReceived),
          (t.jitterMs = 1e3 * e.jitter),
          (t.retransmittedBytesReceived = e.retransmittedBytesReceived),
          (t.retransmittedPacketsReceived = e.retransmittedPacketsReceived),
          (t.totalProcessingDelay = e.totalProcessingDelay),
          (t.jitterBufferEmittedCount = e.jitterBufferEmittedCount);
        const i = this.lastDecodeAudioReceiverStats.get(t.ssrc);
        (t.avgProcessingDelayMs = wM(
          i,
          t,
          "totalProcessingDelay",
          "jitterBufferEmittedCount",
          DM.kMillisecondsFromSeconds
        )),
          this.processAudioTrackReceiverStats(e, e.trackId, t),
          e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)),
          t.receivedFrames || (t.receivedFrames = e.packetsReceived),
          t.droppedFrames || (t.droppedFrames = e.packetsLost),
          t.receivedFrames > 0 &&
            !this.isFirstAudioReceived[t.ssrc] &&
            (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc),
            (this.isFirstAudioReceived[t.ssrc] = !0)),
          t.outputLevel &&
            t.outputLevel > 0 &&
            !this.isFirstAudioDecoded[t.ssrc] &&
            (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc),
            (this.isFirstAudioDecoded[t.ssrc] = !0)),
          "number" == typeof e.concealedSamples &&
            (t.concealedSamples = e.concealedSamples),
          this.lastDecodeAudioReceiverStats.set(t.ssrc, XP({}, t));
      }
      processVideoInboundStats(e) {
        let t = this._stats.videoRecv.find(t => t.ssrc === e.ssrc);
        t || ((t = fM(TM)), this._stats.videoRecv.push(t)),
          (t.ssrc = e.ssrc),
          (t.packets = e.packetsReceived),
          (t.packetsLost = e.packetsLost),
          (t.bytes = e.bytesReceived),
          (t.firsCount = e.firCount),
          (t.nacksCount = e.nackCount),
          (t.plisCount = e.pliCount),
          (t.framesDecodeCount = e.framesDecoded),
          (t.framesDroppedCount = e.framesDropped),
          (t.totalInterFrameDelay = e.totalInterFrameDelay),
          (t.totalSquaredInterFrameDelay = e.totalSquaredInterFrameDelay),
          (t.totalFreezesDuration = e.totalFreezesDuration),
          (t.totalProcessingDelay = e.totalProcessingDelay),
          (t.packetsDiscarded = e.packetsDiscarded),
          (t.framesAssembledFromMultiplePackets =
            e.framesAssembledFromMultiplePackets),
          (t.totalAssemblyTime = e.totalAssemblyTime),
          (t.keyFramesDecoded = e.keyFramesDecoded),
          (t.retransmittedBytesReceived = e.retransmittedBytesReceived),
          (t.retransmittedPacketsReceived = e.retransmittedPacketsReceived);
        const i = this.lastDecodeVideoReceiverStats.get(t.ssrc),
          s = this.lastVideoFramesDecode.get(t.ssrc),
          r = this.lastVideoFramesOutput.get(t.ssrc),
          n = Date.now();
        if (t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc]) {
          const e = t.decodedFrame ? t.decodedFrame.width : 0,
            i = t.decodedFrame ? t.decodedFrame.height : 0;
          this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, e, i),
            (this.isFirstVideoDecoded[t.ssrc] = !0);
        }
        if (i) {
          const s = i.stats,
            r = n - i.lts;
          (t.framesDecodeFreezeTime = s.framesDecodeFreezeTime),
            (t.framesDecodeInterval = s.framesDecodeInterval),
            !this.isFirstVideoDecoded[t.ssrc] &&
              r > this.options.firstVideoDecodedTimeout &&
              !this.isFirstVideoDecodedTimeout[t.ssrc] &&
              (this.onFirstVideoDecodedTimeout &&
                this.onFirstVideoDecodedTimeout(t.ssrc),
              (this.isFirstVideoDecodedTimeout[t.ssrc] = !0)),
            t.framesDecodeCount > s.framesDecodeCount &&
            this.isFirstVideoDecoded[t.ssrc]
              ? ((i.lts = Date.now()),
                (t.framesDecodeInterval = r),
                t.framesDecodeInterval >= this.options.freezeRateLimit &&
                  (this.getVideoIsReady(parseInt(e.ssrc))
                    ? (t.framesDecodeFreezeTime += t.framesDecodeInterval)
                    : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0)))
              : t.framesDecodeCount < s.framesDecodeCount &&
                (t.framesDecodeInterval = 0),
            e.framesDecoded &&
              e.qpSum &&
              (i.stats.framesDecodeCount > e.framesDecoded
                ? (t.qpSumPerFrame = e.qpSum / e.framesDecoded)
                : (t.qpSumPerFrame =
                    (e.qpSum - i.qpSum) /
                    (e.framesDecoded - i.stats.framesDecodeCount)));
        }
        e.totalDecodeTime &&
          ((t.decodeMs = 1e3 * e.totalDecodeTime),
          (t.avgDecodeMs = wM(
            null == i ? void 0 : i.stats,
            t,
            "decodeMs",
            "framesDecodeCount"
          ))),
          (t.avgProcessingDelayMs = wM(
            null == i ? void 0 : i.stats,
            t,
            "totalProcessingDelay",
            "framesDecodeCount",
            DM.kMillisecondsFromSeconds
          )),
          (t.avgFramesAssembledFromMultiplePacketsMs = wM(
            null == i ? void 0 : i.stats,
            t,
            "totalAssemblyTime",
            "framesAssembledFromMultiplePackets",
            DM.kMillisecondsFromSeconds
          )),
          (t.avgInterFrameDelayMs = wM(
            null == i ? void 0 : i.stats,
            t,
            "totalInterFrameDelay",
            "framesDecodeCount",
            DM.kMillisecondsFromSeconds
          )),
          s && n - s.lts >= 800
            ? ((t.decodeFrameRate = Math.round(
                (t.framesDecodeCount - s.count) / ((n - s.lts) / 1e3)
              )),
              this.lastVideoFramesDecode.set(t.ssrc, {
                count: t.framesDecodeCount,
                lts: n,
                rate: t.decodeFrameRate
              }))
            : s
            ? (t.decodeFrameRate = s.rate)
            : this.lastVideoFramesDecode.set(t.ssrc, {
                count: t.framesDecodeCount,
                lts: n,
                rate: 0
              }),
          t.framesDroppedCount &&
            e.framesReceived &&
            (r && n - r.lts >= 800
              ? ((t.outputFrameRate = Math.round(
                  (e.framesReceived - t.framesDroppedCount - r.count) /
                    ((n - r.lts) / 1e3)
                )),
                this.lastVideoFramesOutput.set(t.ssrc, {
                  count: e.framesReceived - t.framesDroppedCount,
                  lts: n,
                  rate: Math.max(t.outputFrameRate, 0)
                }))
              : r
              ? (t.outputFrameRate = r.rate)
              : this.lastVideoFramesOutput.set(t.ssrc, {
                  count: e.framesReceived - t.framesDroppedCount,
                  lts: n,
                  rate: 0
                })),
          this.processVideoTrackReceiverStats(e, e.trackId, t),
          e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)),
          e.framerateMean && (t.framesRateFirefox = e.framerateMean),
          t.packets > 0 &&
            !this.isFirstVideoReceived[t.ssrc] &&
            (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc),
            (this.isFirstVideoReceived[t.ssrc] = !0)),
          this.lastDecodeVideoReceiverStats.set(t.ssrc, {
            stats: XP({}, t),
            lts: i ? i.lts : Date.now(),
            qpSum: e.qpSum
          });
      }
      processVideoOutboundStats(e) {
        let t = this._stats.videoSend.find(t => t.ssrc === e.ssrc);
        t || ((t = fM(SM)), this._stats.videoSend.push(t));
        const i = this.mediaBytesSent.get(e.ssrc);
        if (i) i.add(e.bytesSent);
        else {
          const t = new mM(10);
          t.add(e.bytesSent), this.mediaBytesSent.set(e.ssrc, t);
        }
        if (void 0 !== e.retransmittedBytesSent) {
          const t = this.mediaBytesRetransmit.get(e.ssrc);
          if (t) t.add(e.retransmittedBytesSent);
          else {
            const t = new mM(10);
            t.add(e.retransmittedBytesSent),
              this.mediaBytesRetransmit.set(e.ssrc, t);
          }
        }
        if (e.totalEncodedBytesTarget) {
          const t = this.mediaBytesTargetEncode.get(e.ssrc);
          if (t) t.add(e.totalEncodedBytesTarget);
          else {
            const t = new mM(10);
            t.add(e.totalEncodedBytesTarget),
              this.mediaBytesTargetEncode.set(e.ssrc, t);
          }
        }
        if (
          ((t.ssrc = e.ssrc),
          (t.bytes = e.bytesSent),
          (t.packets = e.packetsSent),
          (t.firsCount = e.firCount),
          (t.nacksCount = e.nackCount),
          (t.plisCount = e.pliCount),
          (t.frameCount = e.framesEncoded),
          (t.adaptionChangeReason = e.qualityLimitationReason),
          (t.scalabilityMode = e.scalabilityMode),
          (t.retransmittedBytesSent = e.retransmittedBytesSent),
          (t.retransmittedPacketsSent = e.retransmittedPacketsSent),
          (t.hugeFramesSent = e.hugeFramesSent),
          (t.keyFramesEncoded = e.keyFramesEncoded),
          e.totalEncodeTime && e.framesEncoded)
        ) {
          const i = this.lastEncoderMs.get(e.ssrc);
          if (!i || i.lastFrameCount > e.framesEncoded)
            t.avgEncodeMs = (1e3 * e.totalEncodeTime) / e.framesEncoded;
          else {
            const s = e.framesEncoded - i.lastFrameCount,
              r = e.totalEncodeTime - i.lastEncoderTime;
            t.avgEncodeMs = (1e3 * r) / s;
          }
        }
        if (e.framesEncoded && e.qpSum) {
          const i = this.lastEncoderMs.get(e.ssrc);
          !i || i.lastFrameCount > e.framesEncoded
            ? (t.qpSumPerFrame = e.qpSum / e.framesEncoded)
            : (t.qpSumPerFrame =
                (e.qpSum - i.lastQpSum) / (e.framesEncoded - i.lastFrameCount));
        }
        if (
          (this.lastEncoderMs.set(e.ssrc, {
            lastFrameCount: e.framesEncoded,
            lastEncoderTime: e.totalEncodeTime,
            lastQpSum: e.qpSum,
            lts: Date.now()
          }),
          e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)),
          e.mediaSourceId && this.processVideoMediaSource(e.mediaSourceId, t),
          this.processVideoTrackSenderStats(e, e.trackId, t),
          e.remoteId)
        )
          this.processRemoteInboundStats(e.remoteId, t);
        else {
          const i = this.findRemoteStatsId(e.ssrc, OM.REMOTE_INBOUND);
          i && this.processRemoteInboundStats(i, t);
        }
      }
      processAudioOutboundStats(e) {
        let t = this._stats.audioSend.find(t => t.ssrc === e.ssrc);
        if (
          (t || ((t = fM(vM)), this._stats.audioSend.push(t)),
          (t.ssrc = e.ssrc),
          (t.packets = e.packetsSent),
          (t.bytes = e.bytesSent),
          (t.retransmittedBytesSent = e.retransmittedBytesSent),
          (t.retransmittedPacketsSent = e.retransmittedPacketsSent),
          e.mediaSourceId && this.processAudioMediaSource(e.mediaSourceId, t),
          e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)),
          this.processAudioTrackSenderStats(e, e.trackId, t),
          e.remoteId)
        )
          this.processRemoteInboundStats(e.remoteId, t);
        else {
          const i = this.findRemoteStatsId(e.ssrc, OM.REMOTE_INBOUND);
          i && this.processRemoteInboundStats(i, t);
        }
      }
      findRemoteStatsId(e, t) {
        const i = Array.from(this.report.values()).find(
          i => i.type === t && i.ssrc === e
        );
        return i ? i.id : null;
      }
      processVideoMediaSource(e, t) {
        const i = this.report.get(e);
        i &&
          i.width &&
          i.height &&
          i.framesPerSecond &&
          (t.inputFrame = {
            width: i.width,
            height: i.height,
            frameRate: i.framesPerSecond
          });
      }
      processAudioMediaSource(e, t) {
        const i = this.report.get(e);
        i && (t.inputLevel = i.audioLevel);
      }
      processVideoTrackSenderStats(e, t, i) {
        var s, r, n, a;
        const o = t ? this.report.get(t) : void 0,
          c =
            null !== (s = null == o ? void 0 : o.framesSent) && void 0 !== s
              ? s
              : e.framesSent;
        if ("number" != typeof c) return;
        let d =
            null !== (r = null == o ? void 0 : o.frameWidth) && void 0 !== r
              ? r
              : e.frameWidth,
          l =
            null !== (n = null == o ? void 0 : o.frameHeight) && void 0 !== n
              ? n
              : e.frameHeight,
          h =
            null !== (a = null == o ? void 0 : o.framesPerSecond) &&
            void 0 !== a
              ? a
              : e.framesPerSecond;
        if (
          (("number" == typeof d && "number" == typeof l) || ((d = 0), (l = 0)),
          null == h)
        ) {
          const e = Date.now(),
            t = this.lastVideoFramesSent.get(i.ssrc);
          t && e - t.lts >= 800
            ? ((h = Math.round((c - t.count) / ((e - t.lts) / 1e3))),
              this.lastVideoFramesSent.set(i.ssrc, {
                count: c,
                lts: e,
                rate: h
              }))
            : t
            ? (h = t.rate)
            : this.lastVideoFramesSent.set(i.ssrc, {
                count: c,
                lts: e,
                rate: 0
              });
        }
        i.sentFrame = { width: d, height: l, frameRate: Math.max(0, h) };
      }
      processVideoTrackReceiverStats(e, t, i) {
        var s, r, n, a, o;
        const c = t ? this.report.get(t) : void 0,
          d =
            null !== (s = null == c ? void 0 : c.framesReceived) && void 0 !== s
              ? s
              : e.framesReceived,
          l =
            null !== (r = null == c ? void 0 : c.frameWidth) && void 0 !== r
              ? r
              : e.frameWidth,
          h =
            null !== (n = null == c ? void 0 : c.frameHeight) && void 0 !== n
              ? n
              : e.frameHeight,
          u =
            null !== (a = null == c ? void 0 : c.jitterBufferDelay) &&
            void 0 !== a
              ? a
              : e.jitterBufferDelay,
          p =
            null !== (o = null == c ? void 0 : c.jitterBufferEmittedCount) &&
            void 0 !== o
              ? o
              : e.jitterBufferEmittedCount;
        if ("number" == typeof d) {
          const e = this.lastVideoFramesRecv.get(i.ssrc),
            t = Date.now();
          i.framesReceivedCount = d;
          let s = 0;
          e && t - e.lts >= 800
            ? ((s = Math.round((d - e.count) / ((t - e.lts) / 1e3))),
              this.lastVideoFramesRecv.set(i.ssrc, {
                count: d,
                lts: t,
                rate: s
              }))
            : e
            ? (s = e.rate)
            : this.lastVideoFramesRecv.set(i.ssrc, {
                count: d,
                lts: t,
                rate: 0
              }),
            (i.receivedFrame = {
              width: l || 0,
              height: h || 0,
              frameRate: s || 0
            }),
            (i.decodedFrame = {
              width: l || 0,
              height: h || 0,
              frameRate: i.decodeFrameRate || 0
            }),
            (i.outputFrame = {
              width: l || 0,
              height: h || 0,
              frameRate: i.outputFrameRate || i.decodeFrameRate || 0
            });
        }
        if (u && p) {
          const e = this.lastVideoJBDelay.get(i.ssrc) || {
            jitterBufferDelay: 0,
            jitterBufferEmittedCount: 0,
            jitterBufferMs: 0
          };
          let t = e.jitterBufferMs;
          const s = p - e.jitterBufferEmittedCount;
          s > 0 && (t = (1e3 * (u - e.jitterBufferDelay)) / s),
            (i.jitterBufferMs = t),
            (i.currentDelayMs = Math.round(t)),
            this.lastVideoJBDelay.set(i.ssrc, {
              jitterBufferDelay: u,
              jitterBufferEmittedCount: p,
              jitterBufferMs: i.currentDelayMs
            });
        }
      }
      processAudioTrackSenderStats(e, t, i) {
        var s, r, n, a;
        const o = t ? this.report.get(t) : void 0,
          c =
            null !==
              (s =
                null !== (r = null == o ? void 0 : o.echoReturnLoss) &&
                void 0 !== r
                  ? r
                  : e.echoReturnLoss) && void 0 !== s
              ? s
              : 0,
          d =
            null !==
              (n =
                null !==
                  (a = null == o ? void 0 : o.echoReturnLossEnhancement) &&
                void 0 !== a
                  ? a
                  : e.echoReturnLossEnhancement) && void 0 !== n
              ? n
              : 0;
        (i.aecReturnLoss = c), (i.aecReturnLossEnhancement = d);
      }
      processAudioTrackReceiverStats(e, t, i) {
        var s, r, n, a, o, c, d;
        const l = t ? this.report.get(t) : void 0,
          h =
            null !==
              (s = null == l ? void 0 : l.removedSamplesForAcceleration) &&
            void 0 !== s
              ? s
              : e.removedSamplesForAcceleration,
          u =
            null !== (r = null == l ? void 0 : l.totalSamplesReceived) &&
            void 0 !== r
              ? r
              : e.totalSamplesReceived,
          p =
            null !== (n = null == l ? void 0 : l.jitterBufferDelay) &&
            void 0 !== n
              ? n
              : e.jitterBufferDelay,
          f =
            null !== (a = null == l ? void 0 : l.jitterBufferEmittedCount) &&
            void 0 !== a
              ? a
              : e.jitterBufferEmittedCount,
          E =
            null !== (o = null == l ? void 0 : l.audioLevel) && void 0 !== o
              ? o
              : null == e
              ? void 0
              : e.audioLevel,
          m =
            null !== (c = null == l ? void 0 : l.totalSamplesDuration) &&
            void 0 !== c
              ? c
              : null == e
              ? void 0
              : e.totalSamplesDuration,
          g =
            null !== (d = null == l ? void 0 : l.concealedSamples) &&
            void 0 !== d
              ? d
              : e.concealedSamples;
        if (
          ("number" == typeof u && (i.totalSamplesReceived = u),
          h && u && (i.accelerateRate = h / u),
          p && f)
        ) {
          const e = this.lastAudioJBDelay.get(i.ssrc) || {
            jitterBufferDelay: 0,
            jitterBufferEmittedCount: 0,
            jitterBufferMs: 0
          };
          let t = e.jitterBufferMs;
          const s = f - e.jitterBufferEmittedCount;
          s > 0 && (t = (1e3 * (p - e.jitterBufferDelay)) / s),
            (i.jitterBufferMs = Math.round(t)),
            this.lastAudioJBDelay.set(i.ssrc, {
              jitterBufferDelay: p,
              jitterBufferEmittedCount: f,
              jitterBufferMs: i.jitterBufferMs
            });
        }
        i.outputLevel = E;
        let _ = 1920;
        m && u && ((_ = u / m / 50), (i.receivedFrames = Math.round(u / _))),
          g && (i.droppedFrames = Math.round(g / _));
      }
      processRemoteInboundStats(e, t) {
        const i = this.report.get(e);
        i &&
          ((t.packetsLost = i.packetsLost),
          i.roundTripTime && (t.rttMs = 1e3 * i.roundTripTime),
          i.jitter && (t.jitterMs = 1e3 * i.jitter),
          i.timestamp && (t.timestamp = i.timestamp));
      }
      getCodecFromCodecStats(e) {
        const t = this.report.get(e);
        if (!t) return "";
        const i = t.mimeType.match(/\/(.*)$/);
        return i && i[1] ? i[1] : "";
      }
      updateSendBitrate() {
        let e = 0,
          t = null,
          i = null;
        this.mediaBytesSent.forEach(t => {
          e += t.diffMean();
        }),
          this.mediaBytesRetransmit.forEach(e => {
            t = null === t ? e.diffMean() : t + e.diffMean();
          }),
          this.mediaBytesTargetEncode.forEach(e => {
            i = null === i ? e.diffMean() : i + e.diffMean();
          });
        const s = null !== t ? e - t : e;
        (this._stats.bitrate = {
          actualEncoded: (8 * s) / (this.options.updateInterval / 1e3),
          transmit: (8 * e) / (this.options.updateInterval / 1e3)
        }),
          null !== t &&
            (this._stats.bitrate.retransmit =
              (8 * t) / (this.options.updateInterval / 1e3)),
          null !== i &&
            (this._stats.bitrate.targetEncoded =
              (8 * i) / (this.options.updateInterval / 1e3));
      }
    },
    NM = class extends yM {
      updateStats() {
        return Promise.resolve();
      }
    };
  const PM = "websdk_ng_install_id";
  function kM() {
    try {
      if (WM("INSTALL_ID")) return WM("INSTALL_ID");
      let e = window.localStorage.getItem(PM);
      return (
        e || ((e = $k()), window.localStorage.setItem(PM, e)),
        KM("INSTALL_ID", e),
        e
      );
    } catch (e) {
      return;
    }
  }
  const MM = (function(e) {
      if (e.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return e;
      const t = e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-([0-9]+)/);
      if (t && t[1] && t[2]) {
        const e = t[1],
          i = t[2];
        return "".concat(e, ".").concat(i);
      }
      return "4.0.0.999";
    })("4.23.2"),
    UM = (function() {
      try {
        return !0 === JSON.parse("true");
      } catch (e) {
        return !0;
      }
    })();
  let xM = (function(e) {
    return (
      (e.Default = "default"),
      (e.Auto = "auto"),
      (e.Relay = "relay"),
      (e.SdRtn = "sd-rtn"),
      e
    );
  })({});
  const FM = (function() {
    const e = "us".concat("erna", "me"),
      t = "pa".concat("sswo", "rd"),
      i = ["t", "s", "t"];
    i.splice(1, 0, "e");
    const s = i.join(""),
      r = [];
    for (let e = 0; e < 6; e++) r.push("1");
    const n = r.join(""),
      a = {};
    return (
      (a[e] = s),
      (a[t] = n),
      Object.assign(a, {
        turnServerURL: "",
        tcpport: 3433,
        udpport: 3478,
        forceturn: !1
      })
    );
  })();
  window.DEFAULT_TURN_CONFIG = FM;
  const BM = {
      ENABLE_PUBLISHED_USER_LIST: !0,
      MAX_SUBSCRIPTION: 50,
      SUBSCRIBE_AUDIO_FILTER_TOPN: void 0,
      ENABLE_PUBLISH_AUDIO_FILTER: void 0,
      ENABLE_USER_LICENSE_CHECK: !0,
      DISABLE_FEC: void 0,
      ENABLE_NTP_REPORT: !1,
      ENABLE_INSTANT_VIDEO: !1,
      ENABLE_USER_AUTO_REBALANCE_CHECK: !0,
      ENABLE_LOSSBASED_BWE: !0,
      ENABLE_AUT_CC: !1,
      ENABLE_CC_FALLBACK: void 0,
      SUBSCRIBE_TWCC: !0,
      PUBLISH_TWCC: !1,
      ENABLE_SVC_DEFAULT_CODECS: ["H264", "VP8", "VP9", "AV1"],
      SVC: [],
      ENABLE_FULL_LINK_AV_SYNC: !1,
      SVC_MODE: null,
      PRE_SUB_NUM: 2,
      ENABLE_AUT_FEEDBACK: !1,
      SVC_EXTENDED: ["VP9"]
    },
    VM = {
      MIN_FRAME_RATE: 1,
      MAX_FRAME_RATE: 30,
      MAX_THRESHOLD_FRAMERATE: 30,
      BITRATE_MIN_THRESHOLD: 100,
      BITRATE_MAX_THRESHOLD: 100,
      MAX_SCALE: 5,
      BWE_SCALE_UP_THRESHOLD: 0.6,
      BWE_SCALE_DOWN_THRESHOLD: 0.6,
      PERF_SCALE_UP_THRESHOLD: 0.7,
      PERF_SCALE_DOWN_THRESHOLD: 0.6,
      MOTION_RESOLUTION_FACTOR: 0.8,
      MOTION_BITRATE_FACTOR: 0.6,
      DETAIL_FRAMERATE_FACTOR: 0.8,
      DETAIL_BITRATE_FACTOR: 0.6,
      BALANCE_RESOLUTION_FACTOR: 0.9,
      BALANCE_FRAMERATE_FACTOR: 0.9,
      BALANCE_BITRATE_FACTOR: 0.6,
      OVERUSE_TIMES_THRESHOLD: 10,
      UNDERUSE_TIMES_THRESHOLD: 40
    },
    GM = "v4.23.2-17-gaee6b520-dirty(2025/4/2 17:12:39)",
    jM = {
      ENABLE_EVENT_REPORT: !0,
      UPLOAD_LOG: !1,
      ENABLE_AG_ADAPTATION: !0,
      FORCE_AG_HIGH_FRAMERATE: !1,
      FORCE_SUPPORT_AG_ADAPTATION: !1,
      ENCODER_CONFIG_LIMIT: {},
      CAMERA_CAPTURE_CONFIG: void 0,
      ENABLE_PRELOAD: !0,
      NEW_ICE_RESTART: !1,
      ICE_RESTART_INTERVAL: 1e4,
      RESTART_SEQUENCE: ["udp_tcp_relay", "relay"],
      FIRST_TCP_CANDIDATE: !1,
      FIRST_TCP_CANDIDATE_INTERVAL: 1e3,
      TURN_DOMAIN: "edge.agora.io",
      USE_TURN_IP: !1,
      NEW_TURN_MODE: void 0,
      NEW_FORCE_TURN: !1
    },
    HM = XP(
      XP(
        XP({}, jM),
        {},
        {
          PROCESS_ID: "",
          ENCRYPT_AES: !0,
          AREAS: ["CHINA", "GLOBAL"],
          WEBCS_DOMAIN: [
            "webrtc2-ap-web-1.agora.io",
            "webrtc2-2.ap.sd-rtn.com"
          ],
          WEBCS_DOMAIN_BACKUP_LIST: [
            "webrtc2-ap-web-3.agora.io",
            "webrtc2-4.ap.sd-rtn.com"
          ],
          PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
          CDS_AP: [
            "cds-ap-web-1.agora.io",
            "cds-web-2.ap.sd-rtn.com",
            "cds-ap-web-3.agora.io",
            "cds-web-4.ap.sd-rtn.com"
          ],
          ACCOUNT_REGISTER: [
            "sua-ap-web-1.agora.io",
            "sua-web-2.ap.sd-rtn.com",
            "sua-ap-web-3.agora.io",
            "sua-web-4.ap.sd-rtn.com"
          ],
          UAP_AP: [
            "uap-ap-web-1.agora.io",
            "uap-web-2.ap.sd-rtn.com",
            "uap-ap-web-3.agora.io",
            "uap-web-4.ap.sd-rtn.com"
          ],
          LOG_UPLOAD_SERVER: "logservice.agora.io",
          EVENT_REPORT_DOMAIN: "statscollector-1.agora.io",
          EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com",
          GATEWAY_ADDRESS: [],
          GATEWAY_WSS_ADDRESS: "",
          LIVE_STREAMING_ADDRESS: "",
          HTTP_CONNECT_TIMEOUT: 5e3,
          SIGNAL_REQUEST_TIMEOUT: 1e4,
          REPORT_STATS: !0,
          NOT_REPORT_EVENT: [],
          PING_PONG_TIME_OUT: 10,
          WEBSOCKET_TIMEOUT_MIN: 1e4,
          EVENT_REPORT_SEND_INTERVAL: 3e3,
          CONFIG_DISTRIBUTE_INTERVAL: 3e5,
          ENABLE_CONFIG_DISTRIBUTE: !0,
          CANDIDATE_TIMEOUT: 5e3,
          SHOW_REPORT_INVOKER_LOG: !1,
          SHOW_REPORT_USER_INVOKER_LOG: !0,
          JOIN_EXTEND: "",
          PUB_EXTEND: "",
          SUB_EXTEND: "",
          FORCE_TURN: !1,
          TURN_ENABLE_TCP: !0,
          TURN_ENABLE_UDP: !0,
          MAX_UPLOAD_CACHE: 50,
          UPLOAD_CACHE_INTERVAL: 2e3,
          AJAX_REQUEST_CONCURRENT: 3,
          REPORT_APP_SCENARIO: void 0,
          GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"],
          CONNECT_GATEWAY_WITHOUT_DOMAIN: !1,
          WORKER_DOMAIN: "edge.agora.io",
          EVENT_REPORT_RETRY: !0,
          CHROME_FORCE_PLAN_B: !1,
          AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400,
          AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3,
          AUDIO_VOLUME_INDICATION_INTERVAL: 2e3,
          VOLUME_VOICE_WEIGHT: 10,
          GET_VOLUME_OF_MUTED_AUDIO_TRACK: !1,
          STATS_UPDATE_INTERVAL: 250,
          NORMAL_EVENT_QUEUE_CAPACITY: 100,
          CUSTOM_REPORT: !0,
          CUSTOM_REPORT_LIMIT: 20,
          PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io",
          PROXY_SERVER_TYPE3: [
            "webrtc-cloud-proxy.sd-rtn.com",
            "webrtc-cloud-proxy.agora.io"
          ],
          CUSTOM_PUB_ANSWER_MODIFIER: null,
          CUSTOM_SUB_ANSWER_MODIFIER: null,
          CUSTOM_PUB_OFFER_MODIFIER: null,
          CUSTOM_SUB_OFFER_MODIFIER: null,
          DSCP_TYPE: "high",
          REMOVE_NEW_CODECS: !0,
          FRAGEMENT_LENGTH: 3,
          WEBSOCKET_COMPRESS: !1,
          SIMULCAST: !1,
          PRELOAD_MEDIA_COUNT: 0,
          CHECK_VIDEO_VISIBLE_INTERVAL: 3e4,
          CHECK_LOCAL_STATS_INTERVAL: 250,
          PROFILE_SWITCH_INTERVAL: 2e3,
          UNSUPPORTED_VIDEO_CODEC: [],
          ENUMERATE_DEVICES_INTERVAL: !1,
          ENUMERATE_DEVICES_INTERVAL_TIME: 1e4,
          USE_NEW_TOKEN: !1,
          CLOSE_AFB_FOR_LOCAL_AP: !0,
          JOIN_MAX_CONCURRENCY: 6,
          JOIN_WITH_FALLBACK_SIGNAL_PROXY: !0,
          JOIN_WITH_FALLBACK_MEDIA_PROXY: !0,
          JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: !1,
          JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3,
          JOIN_GATEWAY_USE_443PORT_ONLY: !1,
          JOIN_GATEWAY_USE_DUAL_DOMAIN: !0,
          JOIN_GATEWAY_FALLBACK_PORT: 443,
          USE_TURN_SERVER_OF_GATEWAY: !1,
          H264_PROFILE_LEVEL_ID: "",
          USE_NEW_LOG: !1,
          LOG_VERSION: 3,
          MEDIA_DEVICE_CONSTRAINTS: null,
          ENCRYPT_PROXY_USERNAME_AND_PSW: !0,
          SDP_LOGGING: !1,
          CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"],
          REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: !1,
          LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: !1,
          BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE",
          AI_DENOISER_PARAMETERS: { excludedLinks: [] },
          ADJUST_3A_FROM_PLUGINS: !0,
          RAISE_H264_BASELINE_PRIORITY: !0,
          FILTER_SEND_H264_BASELINE: !1,
          FIRST_H264_PROFILE_LEVEL_ID: "42001f",
          FIRST_PACKETIZATION_MODE: "",
          X_GOOGLE_START_BITRATE: void 0,
          NEW_REPORT_SERVER: !1,
          NEW_REPORT_SERVER_DOMAINS: [
            "data-reporting.agora.io",
            "data-reporting.agora.io"
          ],
          VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,
          VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3,
          VIDEO_INSPECT_QUALITY_RATIO: 0.9,
          VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io",
          VIDEO_INSPECT_WORKER_MANAGER_PORT: "",
          VIDEO_INSPECT_WORKER_PORT: "",
          SHOW_VIDEO_INSPECT_WORKER_MESSAGE: !1,
          STATS_COLLECTOR_PORT: 443,
          FORCE_TURN_TCP: !1,
          WEBAUDIO_INIT_OPTIONS: void 0,
          FILTER_VIDEO_FEC: !0,
          FILTER_AUDIO_FEC: !1,
          CHROME_DUAL_STREAM_USE_ENCODING: !0,
          DISABLE_DUAL_STREAM_USE_ENCODING: !1,
          EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4,
          ICE_RESTART: !0,
          FINGERPRINT: null,
          ENABLE_VIDEO_FRAME_CALLBACK: !0,
          VIDEO_FREEZE_DURATION: 500,
          SPATIALIZER_PARAMETERS: {},
          UPLOAD_LOG_INTERVAL: 3e3,
          UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3,
          UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4,
          UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3,
          UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4,
          UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200,
          UPLOAD_LOG_LENGTH_EACH_TIME: 10,
          APP_TYPE: 0,
          DISABLE_WEBAUDIO: !1,
          CHANNEL_MEDIA_RELAY_SERVERS: void 0,
          KEEP_LAST_FRAME: !0,
          FORWARD_P2P_CREATION: !0,
          SYNC_GROUP: !0,
          BLOCK_LOCAL_CLIENT: !1,
          ENABLE_AUDIO_TOPN: !1,
          ENABLE_AUDIO_METADATA: !1,
          ENABLE_AUDIO_PTS_METADATA: !1,
          TOPN_SMOOTH_LEVEL: void 0,
          TOPN_NEW_SPEAKER_DELAY: void 0,
          TOPN_SWITCH_HOLD_MS: void 0,
          TOPN_AUDIO_GAIN: void 0,
          TOPN_SILENCE_THRESHOLD: 250,
          AP_AREA: !0,
          ENABLE_ENCODED_TRANSFORM: !1,
          ENABLE_VIDEO_SEI: !1,
          IMAGE_MODERATION_WORKER_HOST: "edge.agora.io",
          IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,
          IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3,
          SHOW_IMAGE_MODERATION_WORKER_MESSAGE: !1,
          IMAGE_MODERATION_QUALITY_RATIO: 0.9,
          IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3,
          SHOW_GLOBAL_CLIENT_LIST: !1,
          DATASTREAM_MAX_RETRANSMITS: 10,
          TCP_CANDIDATE_ONLY: !1,
          EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3,
          SHOW_P2P_LOG: !1,
          MAX_P2P_TIMEOUT: 3e4,
          P2P_TOKEN_INTERVAL: 1e3,
          SHOW_DATASTREAM2_LOG: !1,
          RESTRICTION_SET_PLAYBACK_DEVICE: !0,
          USE_PURE_ENCRYPTION_MASTER_KEY: !1,
          ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,
          ACCOUNT_REGISTER_RETRY_RATIO: 2,
          ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4,
          ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5,
          AUDIO_CONTEXT: null,
          WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3,
          PLAYER_STATE_DEFER: 2e3,
          SIGNAL_REQUEST_WATCH_INTERVAL: 1e3,
          FILEPATH_LENMAX: 255,
          DUALSTREAM_OPERATION_CHECK: !0,
          MEDIA_ELEMENT_EXISTS_DEPTH: 3,
          SHIM_CANDIDATE: !1,
          LEAVE_MSG_TIMEOUT: 2e3,
          STATS_FILTER: { transportId: !0, googTrackId: !0 },
          FILTER_VIDEO_CODEC: [],
          USE_NEW_NETWORK_CONFIG: !1,
          AUTO_RESET_AUDIO_ROUTE: !1,
          PLUGIN_INFO: [],
          OVERUSE_DETECTOR_PARAMS: VM,
          CUSTOM_ADAPTATION_DEFAULT_MODE: "",
          HIDE_NO_POSTER: !1,
          AP_CACHE_NUM: 10,
          AP_UPDATE_INTERVAL: 12e4,
          AP_CACHE_LIFETIME: 12e4,
          MAX_PRELOAD_ASYNC_LENGTH: 3,
          DISABLE_SCREEN_SHARE_REMB: !1
        },
        BM
      ),
      {},
      {
        USE_CANDIDATE_FROM_AP_DETAIL: !1,
        AP_REQUEST_DETAIL: void 0,
        ENABLE_ROLE_SELECT_EDGE: !1,
        CLIENT_ROLE_OPTIONS: void 0,
        COMPATIBLE_SDP_EXTENSION: ["gdpr_forbidden"],
        LIMIT_BITRATE: void 0,
        EXPERIMENTS: {},
        USE_PUB_RTX: !0,
        USE_SUB_RTX: !0,
        ENABLE_DATASTREAM_2: !1,
        USE_XR: !0,
        ENABLE_PREALLOC_PC: !1,
        ENABLE_PRE_SUB: !1,
        ENABLE_SVC: !1
      },
      { INSTALL_ID: "" }
    );
  function KM(e, t, i) {
    var s;
    Object.keys(HM).includes(e) &&
      ((!i && Object.keys($M).includes(e)) ||
        ((HM[e] = t),
        ("ENABLE_VIDEO_SEI" !== e &&
          "ENABLE_AUDIO_TOPN" !== e &&
          "ENABLE_AUDIO_METADATA" !== e &&
          "ENABLE_AUDIO_PTS_METADATA" !== e) ||
          !0 !== t ||
          ((HM.ENABLE_ENCODED_TRANSFORM = !0),
          "ENABLE_AUDIO_PTS_METADATA" === e && (HM.ENABLE_AUDIO_METADATA = !0)),
        "USE_NEW_NETWORK_CONFIG" === e &&
          t &&
          ((s = !!t),
          (HM.USE_NEW_NETWORK_CONFIG = s),
          s &&
            ((HM.WEBCS_DOMAIN = ["webrtc2-2.ap.sd-rtn.com"]),
            (HM.WEBCS_DOMAIN_BACKUP_LIST = ["webrtc2-4.ap.sd-rtn.com"]),
            (HM.CDS_AP = [
              "cds-web-2.ap.sd-rtn.com",
              "cds-web-4.ap.sd-rtn.com"
            ]),
            (HM.ACCOUNT_REGISTER = [
              "sua-web-2.ap.sd-rtn.com",
              "sua-web-4.ap.sd-rtn.com"
            ]),
            (HM.EVENT_REPORT_DOMAIN = "web-2.statscollector.sd-rtn.com"),
            (HM.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-1.agora.io"),
            (HM.GATEWAY_DOMAINS = ["edge.sd-rtn.com"]))),
        "ENABLE_PRE_SUB" === e &&
          t &&
          ((HM.ENABLE_INSTANT_VIDEO = !0), (HM.ENABLE_PREALLOC_PC = !0)),
        "ENABLE_SVC" === e && t && (HM.ENABLE_AUT_CC = !0),
        "NEW_FORCE_TURN" === e &&
          t &&
          (HM.NEW_TURN_MODE || (HM.NEW_TURN_MODE = 4))));
  }
  function WM(e) {
    return HM[e];
  }
  UM ||
    ((HM.WEBCS_DOMAIN = [
      "ap-web-1-oversea.agora.io",
      "ap-web-1-north-america.agora.io"
    ]),
    (HM.WEBCS_DOMAIN_BACKUP_LIST = [
      "ap-web-2-oversea.agora.io",
      "ap-web-2-north-america.agora.io"
    ]),
    (HM.PROXY_CS = [
      "proxy-ap-web-oversea.agora.io",
      "proxy-ap-web-america.agora.io"
    ]),
    (HM.CDS_AP = [
      "cds-ap-web-oversea.agora.io",
      "cds-ap-web-america.agora.io",
      "cds-ap-web-america2.agora.io"
    ]),
    (HM.ACCOUNT_REGISTER = [
      "sua-ap-web-oversea.agora.io",
      "sua-ap-web-america.agora.io",
      "sua-ap-web-america2.agora.io"
    ]),
    (HM.UAP_AP = [
      "uap-ap-web-oversea.agora.io",
      "uap-ap-web-america.agora.io",
      "uap-ap-web-america2.agora.io"
    ]),
    (HM.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io"),
    (HM.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io"),
    (HM.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io"),
    (HM.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io"),
    (HM.AREAS = ["NORTH_AMERICA", "OVERSEA"]));
  let YM = (function(e) {
    return (e[(e.REALTIME = 1)] = "REALTIME"), e;
  })({});
  const $M = {};
  var qM = (function(e) {
    return (
      (e.SET_SESSION_ID = "SET_SESSION_ID"),
      (e.SET_P2P_ID = "SET_P2P_id"),
      (e.SET_DC_ID = "SET_DC_id"),
      (e.SET_UID = "SET_UID"),
      (e.SET_INT_UID = "SET_INT_UID"),
      (e.SET_PUB_ID = "SET_PUB_ID"),
      (e.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE"),
      (e.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED"),
      (e.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START"),
      (e.AVOID_JOIN_START = "AVOID_JOIN_START"),
      (e.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END"),
      (e.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START"),
      (e.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END"),
      (e.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START"),
      (e.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END"),
      (e.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START"),
      (e.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END"),
      (e.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START"),
      (e.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END"),
      (e.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN"),
      (e.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH"),
      (e.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE"),
      (e.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE"),
      (e.RESET_JOIN_CHANNEL_SERVICE_RECORDS =
        "RESET_JOIN_CHANNEL_SERVICE_RECORDS"),
      (e.RESET_KEY_METRICS = "RESET_KEY_METRICS"),
      (e.SET_USE_P2P = "SET_USE_P2P"),
      (e.SET_TRANSPORT_TYPE = "SET_TRANSPORT_TYPE"),
      e
    );
  })(qM || {});
  class XM {
    constructor(e, t, i, s) {
      $P(this, "state", void 0),
        (this.state = {
          codec: e,
          audioCodec: t,
          mode: i,
          clientId: s,
          sessionId: null,
          p2pId: 0,
          dcId: 0,
          pubId: 0,
          subId: 0,
          avoidJoinStart: 0,
          keyMetrics: { publish: [], subscribe: [] },
          joinChannelServiceRecords: [],
          cloudProxyServerMode: "disabled",
          useP2P: !1,
          p2pTransport: xM.Default,
          hasStartJoinChannel: !1,
          isABTestSuccess: !1
        });
    }
    dispatch(e) {
      this.state = (function(e, t) {
        switch (t.type) {
          case qM.SET_SESSION_ID:
            return XP(XP({}, e), {}, { sessionId: t.sessionId });
          case qM.SET_P2P_ID:
            return XP(XP({}, e), {}, { p2pId: t.p2pId });
          case qM.SET_UID:
            return XP(XP({}, e), {}, { uid: t.uid });
          case qM.SET_INT_UID:
            return XP(XP({}, e), {}, { intUid: t.intUid });
          case qM.SET_PUB_ID:
            return XP(XP({}, e), {}, { pubId: t.pubId });
          case qM.KEY_METRIC_CLIENT_CREATED:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { clientCreated: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_JOIN_START:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { joinStart: t.metric }
                )
              }
            );
          case qM.AVOID_JOIN_START:
            return XP(XP({}, e), {}, { avoidJoinStart: t.avoidJoinStart });
          case qM.KEY_METRIC_JOIN_END:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(XP({}, e.keyMetrics), {}, { joinEnd: t.metric })
              }
            );
          case qM.KEY_METRIC_REQUEST_AP_START:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { requestAPStart: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_REQUEST_AP_END:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { requestAPEnd: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_JOIN_GATEWAY_START:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { joinGatewayStart: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_JOIN_GATEWAY_END:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { joinGatewayEnd: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_PEER_CONNECTION_START:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { peerConnectionStart: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_PEER_CONNECTION_END:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { peerConnectionEnd: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_DESCRIPTION_START:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { descriptionStart: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { signalChannelOpen: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_ICE_CONNECTION_END:
            return XP(
              XP({}, e),
              {},
              {
                keyMetrics: XP(
                  XP({}, e.keyMetrics),
                  {},
                  { iceConnectionEnd: t.metric }
                )
              }
            );
          case qM.KEY_METRIC_PUBLISH: {
            const i = e.keyMetrics.publish,
              s = i.findIndex(e => e.trackId === t.metric.trackId);
            return -1 !== s
              ? ((i[s] = XP(XP({}, i[s]), t.metric)),
                XP(
                  XP({}, e),
                  {},
                  {
                    keyMetrics: XP(
                      XP({}, e.keyMetrics),
                      {},
                      { publish: [...i] }
                    )
                  }
                ))
              : XP(
                  XP({}, e),
                  {},
                  {
                    keyMetrics: XP(
                      XP({}, e.keyMetrics),
                      {},
                      { publish: [...e.keyMetrics.publish, t.metric] }
                    )
                  }
                );
          }
          case qM.KEY_METRIC_SUBSCRIBE: {
            const i = e.keyMetrics.subscribe,
              s = i.findIndex(
                e => e.userId === t.metric.userId && e.type === t.metric.type
              );
            return -1 !== s
              ? ((i[s] = XP(XP({}, i[s]), t.metric)),
                XP(
                  XP({}, e),
                  {},
                  {
                    keyMetrics: XP(
                      XP({}, e.keyMetrics),
                      {},
                      { subscribe: [...i] }
                    )
                  }
                ))
              : XP(
                  XP({}, e),
                  {},
                  {
                    keyMetrics: XP(
                      XP({}, e.keyMetrics),
                      {},
                      { subscribe: [...e.keyMetrics.subscribe, t.metric] }
                    )
                  }
                );
          }
          case qM.SET_CLOUD_PROXY_SERVER_MODE:
            return (e.cloudProxyServerMode = t.mode), e;
          case qM.RECORD_JOIN_CHANNEL_SERVICE:
            return (
              "number" != typeof t.index
                ? (e.joinChannelServiceRecords = [
                    ...e.joinChannelServiceRecords,
                    t.record
                  ])
                : ((e.joinChannelServiceRecords[t.index] = XP(
                    XP({}, e.joinChannelServiceRecords[t.index]),
                    t.record
                  )),
                  (e.joinChannelServiceRecords = [
                    ...e.joinChannelServiceRecords
                  ])),
              e
            );
          case qM.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
            return (e.joinChannelServiceRecords = []), e;
          case qM.RESET_KEY_METRICS:
            return (e.keyMetrics = { publish: [], subscribe: [] }), e;
          case qM.SET_USE_P2P:
            return XP(XP({}, e), {}, { useP2P: t.val });
          case qM.SET_TRANSPORT_TYPE:
            return XP(XP({}, e), {}, { p2pTransport: t.val });
          default:
            return e;
        }
      })(this.state, e);
    }
    set sessionId(e) {
      this.dispatch({ type: qM.SET_SESSION_ID, sessionId: e });
    }
    get sessionId() {
      return this.state.sessionId;
    }
    set cid(e) {
      this.state.cid = e;
    }
    get cid() {
      return this.state.cid;
    }
    set codec(e) {
      this.state.codec = e;
    }
    get codec() {
      return this.state.codec;
    }
    get mode() {
      return this.state.mode;
    }
    get audioCodec() {
      return this.state.audioCodec;
    }
    get clientId() {
      return this.state.clientId;
    }
    set p2pId(e) {
      this.dispatch({ type: qM.SET_P2P_ID, p2pId: e });
    }
    get p2pId() {
      return this.state.p2pId;
    }
    set dcId(e) {
      this.dispatch({ type: qM.SET_DC_ID, dcId: e });
    }
    get dcId() {
      return this.state.dcId;
    }
    set uid(e) {
      this.dispatch({ type: qM.SET_UID, uid: e });
    }
    get uid() {
      return this.state.uid;
    }
    set intUid(e) {
      this.dispatch({ type: qM.SET_INT_UID, intUid: e });
    }
    get intUid() {
      return this.state.intUid;
    }
    set pubId(e) {
      this.dispatch({ type: qM.SET_PUB_ID, pubId: e });
    }
    get pubId() {
      return this.state.pubId;
    }
    set cloudProxyServerMode(e) {
      this.dispatch({ type: qM.SET_CLOUD_PROXY_SERVER_MODE, mode: e });
    }
    get cloudProxyServerMode() {
      return this.state.cloudProxyServerMode;
    }
    set useP2P(e) {
      this.dispatch({ type: qM.SET_USE_P2P, val: e });
    }
    get useP2P() {
      return this.state.useP2P;
    }
    set p2pTransport(e) {
      this.dispatch({ type: qM.SET_TRANSPORT_TYPE, val: e });
    }
    get p2pTransport() {
      return this.state.p2pTransport;
    }
    set hasStartJoinChannel(e) {
      this.state.hasStartJoinChannel = e;
    }
    get hasStartJoinChannel() {
      return this.state.hasStartJoinChannel;
    }
    set isABTestSuccess(e) {
      this.state.isABTestSuccess = e;
    }
    get isABTestSuccess() {
      return this.state.isABTestSuccess;
    }
    clientCreated() {
      this.dispatch({ type: qM.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
    }
    joinStart() {
      this.dispatch({ type: qM.KEY_METRIC_JOIN_START, metric: Date.now() });
    }
    joinEnd() {
      this.dispatch({ type: qM.KEY_METRIC_JOIN_END, metric: Date.now() });
    }
    requestAPStart() {
      this.dispatch({
        type: qM.KEY_METRIC_REQUEST_AP_START,
        metric: Date.now()
      });
    }
    requestAPEnd() {
      this.dispatch({ type: qM.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
    }
    joinGatewayStart() {
      this.dispatch({
        type: qM.KEY_METRIC_JOIN_GATEWAY_START,
        metric: Date.now()
      });
    }
    joinGatewayEnd() {
      this.dispatch({
        type: qM.KEY_METRIC_JOIN_GATEWAY_END,
        metric: Date.now()
      });
    }
    peerConnectionStart() {
      this.dispatch({
        type: qM.KEY_METRIC_PEER_CONNECTION_START,
        metric: Date.now()
      });
    }
    peerConnectionEnd() {
      this.dispatch({
        type: qM.KEY_METRIC_PEER_CONNECTION_END,
        metric: Date.now()
      });
    }
    descriptionStart() {
      this.dispatch({
        type: qM.KEY_METRIC_DESCRIPTION_START,
        metric: Date.now()
      });
    }
    signalChannelOpen() {
      this.dispatch({
        type: qM.KEY_METRIC_SIGNAL_CHANNEL_OPEN,
        metric: Date.now()
      });
    }
    iceConnectionEnd() {
      this.dispatch({
        type: qM.KEY_METRIC_ICE_CONNECTION_END,
        metric: Date.now()
      });
    }
    publish(e, t, i, s) {
      this.dispatch({
        type: qM.KEY_METRIC_PUBLISH,
        metric: XP(
          XP({ trackId: e, type: t }, i && { publishStart: i }),
          s && { publishEnd: s }
        )
      });
    }
    subscribe(e, t, i, s, r, n, a) {
      this.dispatch({
        type: qM.KEY_METRIC_SUBSCRIBE,
        metric: XP(
          XP(
            XP(
              XP(
                XP({ userId: e, type: t }, i && { subscribeStart: i }),
                s && { subscribeEnd: s }
              ),
              r && { firstFrame: r }
            ),
            n && { streamAdded: n }
          ),
          a && { firstDecoded: a }
        )
      });
    }
    massSubscribe(e, t, i, s) {
      e.forEach(e => {
        this.dispatch({
          type: qM.KEY_METRIC_SUBSCRIBE,
          metric: XP(
            XP(
              XP(
                { userId: e.userId, type: e.type },
                t && { subscribeStart: t }
              ),
              i && { subscribeEnd: i }
            ),
            s && { firstFrame: s }
          )
        });
      });
    }
    get keyMetrics() {
      return this.state.keyMetrics;
    }
    recordJoinChannelService(e, t) {
      "gateway" === e.service &&
        Array.isArray(e.urls) &&
        (e.urls = e.urls.map(e =>
          e.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")
        ));
      try {
        return "number" != typeof t
          ? (this.dispatch({
              type: qM.RECORD_JOIN_CHANNEL_SERVICE,
              record: XP(
                XP({}, e),
                {},
                {
                  sessionId: this.sessionId,
                  cloudProxyMode: this.cloudProxyServerMode,
                  uid: this.uid
                }
              )
            }),
            this.state.joinChannelServiceRecords.length - 1)
          : (t < 0 ||
              t >= this.state.joinChannelServiceRecords.length ||
              this.dispatch({
                type: qM.RECORD_JOIN_CHANNEL_SERVICE,
                record: e,
                index: t
              }),
            t);
      } catch (e) {
        return 0;
      }
    }
    resetJoinChannelServiceRecords() {
      this.dispatch({ type: qM.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
    }
    resetKeyMetrics() {
      this.dispatch({ type: qM.RESET_KEY_METRICS });
    }
    get joinChannelServiceRecords() {
      try {
        return this.state.joinChannelServiceRecords;
      } catch (e) {
        return [];
      }
    }
    get avoidJoinStart() {
      return this.state.avoidJoinStart;
    }
    set avoidJoinStart(e) {
      this.dispatch({ type: qM.AVOID_JOIN_START, avoidJoinStart: e });
    }
  }
  let zM = (function(e) {
    return (
      (e.h264 = "h264"),
      (e.h265 = "h265"),
      (e.vp8 = "vp8"),
      (e.vp9 = "vp9"),
      (e.av1 = "av1"),
      e
    );
  })({});
  !(function(e) {
    (e.opus = "opus"), (e.pcma = "pcma"), (e.pcmu = "pcmu"), (e.g722 = "g722");
  })({});
  const JM = 128,
    QM = 96,
    ZM = 1e3,
    eU = 10;
  let tU = 0;
  var iU = (() => {
    var e = {
        8: (e, t, i) => {
          i.r(t),
            i.d(t, {
              Parser: () => R,
              Printer: () => b,
              parse: () => L,
              print: () => N
            });
          const s = "\n",
            r = "".concat("\r").concat(s),
            n = " ";
          let a;
          function o(e) {
            return e >= "0" && e <= "9";
          }
          function c(e) {
            return e >= "!" && e <= "~";
          }
          function d(e) {
            return c(e) || (e >= "Â" && e <= "Ã¿");
          }
          function l(e) {
            return (
              "!" === e ||
              (e >= "#" && e <= "'") ||
              (e >= "*" && e <= "+") ||
              (e >= "-" && e <= ".") ||
              (e >= "0" && e <= "9") ||
              (e >= "A" && e <= "Z") ||
              (e >= "^" && e <= "~")
            );
          }
          function h(e) {
            return e >= "1" && e <= "9";
          }
          function u(e) {
            return (e >= "A" && e <= "Z") || (e >= "a" && e <= "z");
          }
          function p(e) {
            return "d" === e || "h" === e || "m" === e || "s" === e;
          }
          function f(e) {
            return (
              (e > "" && e < "\t") ||
              (e > "\v" && e < "\f") ||
              (e > "" && e < "Ã¿")
            );
          }
          function E(e) {
            return u(e) || o(e) || "+" === e || "/" === e;
          }
          function m(e) {
            return (
              o(e) || u(e) || "+" === e || "/" === e || "-" === e || "_" === e
            );
          }
          function g(e) {
            return u(e) || o(e) || "+" === e || "/" === e;
          }
          function _(e, t) {
            var i = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var s = Object.getOwnPropertySymbols(e);
              t &&
                (s = s.filter(function(t) {
                  return Object.getOwnPropertyDescriptor(e, t).enumerable;
                })),
                i.push.apply(i, s);
            }
            return i;
          }
          function T(e) {
            for (var t = 1; t < arguments.length; t++) {
              var i = null != arguments[t] ? arguments[t] : {};
              t % 2
                ? _(Object(i), !0).forEach(function(t) {
                    S(e, t, i[t]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(i)
                  )
                : _(Object(i)).forEach(function(t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(i, t)
                    );
                  });
            }
            return e;
          }
          function S(e, t, i) {
            return (
              t in e
                ? Object.defineProperty(e, t, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                  })
                : (e[t] = i),
              e
            );
          }
          !(function(e) {
            (e.VERSION = "v"),
              (e.ORIGIN = "o"),
              (e.SESSION_NAME = "s"),
              (e.INFORMATION = "i"),
              (e.URI = "u"),
              (e.EMAIL = "e"),
              (e.PHONE = "p"),
              (e.CONNECTION = "c"),
              (e.BANDWIDTH = "b"),
              (e.TIME = "t"),
              (e.REPEAT = "r"),
              (e.ZONE_ADJUSTMENTS = "z"),
              (e.KEY = "k"),
              (e.ATTRIBUTE = "a"),
              (e.MEDIA = "m");
          })(a || (a = {}));
          class v {
            consumeText(e, t) {
              let i = t;
              for (; i < e.length; ) {
                const t = e[i];
                if ("\0" === t || "\r" === t || t === s) break;
                i += 1;
              }
              if (i - t == 0) throw new Error("Invalid text, at ".concat(e));
              return i;
            }
            consumeUnicastAddress(e, t, i) {
              return this.consumeTill(e, t, n);
            }
            consumeOneOrMore(e, t, i) {
              let s = t;
              for (; i(e[s]); ) s++;
              if (s - t == 0)
                throw new Error("Invalid rule at ".concat(t, "."));
              return s;
            }
            consumeSpace(e, t) {
              if (e[t] === n) return t + 1;
              throw new Error("Invalid space at ".concat(t, "."));
            }
            consumeIP4Address(e, t) {
              let i = t;
              for (let t = 0; t < 4; t++)
                if (((i = this.consumeDecimalUChar(e, i)), 3 !== t)) {
                  if ("." !== e[i]) throw new Error("Invalid IP4 address.");
                  i++;
                }
              return i;
            }
            consumeDecimalUChar(e, t) {
              let i = t;
              for (let t = 0; t < 3 && o(e[i]); t++, i++);
              if (i - t == 0) throw new Error("Invalid decimal uchar.");
              const s = parseInt(e.slice(t, i));
              if (s >= 0 && s <= 255) return i;
              throw new Error("Invalid decimal uchar");
            }
            consumeIP6Address(e, t) {
              let i = this.consumeHexpart(e, t);
              return ":" === e[i]
                ? ((i += 1), (i = this.consumeIP4Address(e, i)), i)
                : i;
            }
            consumeHexpart(e, t) {
              let i = t;
              if (":" === e[i] && ":" === e[i + 1]) {
                i += 2;
                try {
                  i = this.consumeHexseq(e, i);
                } catch (e) {}
                return i;
              }
              if (
                ((i = this.consumeHexseq(e, i)),
                ":" === e[i] && ":" === e[i + 1])
              ) {
                i += 2;
                try {
                  i = this.consumeHexseq(e, i);
                } catch (e) {}
                return i;
              }
              return i;
            }
            consumeHexseq(e, t) {
              let i = t;
              for (
                ;
                (i = this.consumeHex4(e, i)), ":" === e[i] && ":" !== e[i + 1];

              )
                i += 1;
              return i;
            }
            consumeHex4(e, t) {
              let i = 0;
              for (; i < 4; i++)
                if (
                  !(
                    ((s = e[t + i]) >= "0" && s <= "9") ||
                    (s >= "a" && s <= "f") ||
                    (s >= "A" && s <= "F")
                  )
                ) {
                  if (0 === i) throw new Error("Invalid hex 4");
                  break;
                }
              var s;
              return t + i;
            }
            consumeFQDN(e, t) {
              let i = t;
              for (; o(e[i]) || u(e[i]) || "-" === e[i] || "." === e[i]; )
                i += 1;
              if (i - t < 4) throw new Error("Invalid FQDN");
              return i;
            }
            consumeExtnAddr(e, t) {
              return this.consumeOneOrMore(e, t, d);
            }
            consumeMulticastAddress(e, t, i) {
              switch (i) {
                case "IP4":
                case "ip4":
                  return this.consumeIP4MulticastAddress(e, t);
                case "IP6":
                case "ip6":
                  return this.consumeIP6MulticastAddress(e, t);
                default:
                  try {
                    return this.consumeFQDN(e, t);
                  } catch (i) {
                    return this.consumeExtnAddr(e, t);
                  }
              }
            }
            consumeIP6MulticastAddress(e, t) {
              const i = this.consumeHexpart(e, t);
              return "/" === e[i] ? this.consumeInteger(e, i + 1) : i;
            }
            consumeIP4MulticastAddress(e, t) {
              let i = t + 3;
              const s = e.slice(t, i),
                r = parseInt(s);
              if (r < 224 || r > 239)
                throw new Error(
                  "Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255."
                );
              for (let t = 0; t < 3; t++) {
                if ("." !== e[i])
                  throw new Error("Invalid IP4 multicast address.");
                (i += 1), (i = this.consumeDecimalUChar(e, i));
              }
              return (
                "/" === e[i] && (i += 1),
                (i = this.consumeTTL(e, i)),
                "/" === e[i] && (i = this.consumeInteger(e, i)),
                i
              );
            }
            consumeInteger(e, t) {
              if (!h(e[t])) throw new Error("Invalid integer.");
              for (t += 1; o(e[t]); ) t += 1;
              return t;
            }
            consumeTTL(e, t) {
              if ("0" === e[t]) return t + 1;
              if (!h(e[t])) throw new Error("Invalid TTL.");
              t += 1;
              for (let i = 0; i < 2 && o(e[t]); i++) t += 1;
              return t;
            }
            consumeToken(e, t) {
              return this.consumeOneOrMore(e, t, l);
            }
            consumeTime(e, t) {
              let i = t;
              if ("0" === e[i]) return i + 1;
              for (h(e[i]) && (i += 1); o(e[i]); ) i++;
              if (i - t < 10) throw new Error("Invalid time");
              return i;
            }
            consumeAddress(e, t) {
              return this.consumeTill(e, t, n);
            }
            consumeTypedTime(e, t) {
              let i = t;
              return (i = this.consumeOneOrMore(e, i, o)), p(e[i]) ? i + 1 : i;
            }
            consumeRepeatInterval(e, t) {
              if (!h(e[t])) throw new Error("Invalid repeat interval");
              for (t += 1; o(e[t]); ) t += 1;
              return p(e[t]) && (t += 1), t;
            }
            consumePort(e, t) {
              return this.consumeOneOrMore(e, t, o);
            }
            consume(e, t, i) {
              for (let s = 0; s < i.length; s++) {
                if (t + s >= e.length)
                  throw new Error("consume exceeding value length");
                if (e[t + s] !== i[s])
                  throw new Error(
                    "consume ".concat(i, " failed at ").concat(s)
                  );
              }
              return t + i.length;
            }
            consumeTill(e, t, i) {
              let s = t;
              for (
                ;
                s < e.length &&
                ("string" != typeof i || e[s] !== i) &&
                ("function" != typeof i || !i(e[s]));

              )
                s++;
              return s;
            }
          }
          class R extends v {
            constructor() {
              super(), S(this, "records", []), S(this, "currentLine", 0);
            }
            parse(e) {
              const t = this.probeEOL(e);
              (this.records = e
                .split(t)
                .filter(e => !!e.trim())
                .map(this.parseLine)),
                (this.currentLine = 0);
              const i = this.parseVersion(),
                s = this.parseOrigin(),
                r = this.parseSessionName(),
                n = this.parseInformation(),
                a = this.parseUri(),
                o = this.parseEmail(),
                c = this.parsePhone(),
                d = this.parseConnection(),
                l = this.parseBandWidth(),
                h = this.parseTimeFields(),
                u = this.parseKey(),
                p = this.parseSessionAttribute(),
                f = this.parseMediaDescription();
              if (this.currentLine !== this.records.length)
                throw new Error("parsing failed, non exhaustive sdp lines.");
              return {
                version: i,
                origin: s,
                sessionName: r,
                information: n,
                uri: a,
                emails: o,
                phones: c,
                connection: d,
                bandwidths: l,
                timeFields: h,
                key: u,
                attributes: p,
                mediaDescriptions: f
              };
            }
            getCurrentRecord() {
              const e = this.records[this.currentLine];
              if (!e) throw new Error("Record doesn't exit.");
              return e;
            }
            probeEOL(e) {
              for (let t = 0; t < e.length; t++)
                if (e[t] === s) return "\r" === e[t - 1] ? r : s;
              throw new Error("Invalid newline character.");
            }
            parseLine(e, t) {
              if (e.length < 2)
                throw new Error(
                  "Invalid sdp line, sdp line should be of form <type>=<value>."
                );
              const i = e[0];
              if ("=" !== e[1])
                throw new Error(
                  'Invalid sdp line, <type> should be a single character followed by an "=" sign.'
                );
              return { type: i, value: e.slice(2), line: t, cur: 0 };
            }
            parseSessionAttribute() {
              const e = new A();
              for (; this.currentLine < this.records.length; ) {
                const t = this.getCurrentRecord();
                if (t.type !== a.ATTRIBUTE) break;
                const i = {
                  attField: this.extractOneOrMore(t, e => l(e) && ":" !== e),
                  _cur: 0
                };
                ":" === t.value[t.cur] &&
                  ((t.cur += 1), (i.attValue = this.extractOneOrMore(t, f))),
                  e.parse(i),
                  this.currentLine++;
              }
              return e.digest();
            }
            parseMediaAttributes(e) {
              const t = new I(e);
              for (; this.currentLine < this.records.length; ) {
                const e = this.getCurrentRecord();
                if (e.type !== a.ATTRIBUTE) break;
                const i = {
                  attField: this.extractOneOrMore(e, e => l(e) && ":" !== e),
                  _cur: 0
                };
                ":" === e.value[e.cur] &&
                  ((e.cur += 1), (i.attValue = this.extractOneOrMore(e, f))),
                  t.parse(i),
                  this.currentLine++;
              }
              return t.digest();
            }
            parseKey() {
              const e = this.getCurrentRecord();
              if (e.type === a.KEY) {
                if (
                  "prompt" === e.value ||
                  "clear:" === e.value ||
                  "base64:" === e.value ||
                  "uri:" === e.value
                )
                  return e.value;
                throw (this.currentLine++, new Error("Invalid key."));
              }
            }
            parseZone() {
              const e = this.getCurrentRecord();
              if (e.type === a.ZONE_ADJUSTMENTS) {
                const t = [];
                for (;;)
                  try {
                    const i = this.extract(e, this.consumeTime);
                    this.consumeSpaceForRecord(e);
                    let s = !1;
                    "-" === e.value[e.cur] && ((s = !0), (e.cur += 1));
                    const r = this.extract(e, this.consumeTypedTime);
                    t.push({ time: i, typedTime: r, back: s });
                  } catch (e) {
                    break;
                  }
                if (0 === t.length) throw new Error("Invalid zone adjustments");
                return this.currentLine++, t;
              }
              return [];
            }
            parseRepeat() {
              const e = [];
              for (;;) {
                const t = this.getCurrentRecord();
                if (t.type !== a.REPEAT) break;
                {
                  const i = this.extract(t, this.consumeRepeatInterval),
                    s = this.parseTypedTime(t);
                  e.push({ repeatInterval: i, typedTimes: s }),
                    this.currentLine++;
                }
              }
              return e;
            }
            parseTypedTime(e) {
              const t = [];
              for (;;)
                try {
                  this.consumeSpaceForRecord(e),
                    t.push(this.extract(e, this.consumeTypedTime));
                } catch (e) {
                  break;
                }
              if (0 === t.length) throw new Error("Invalid typed time.");
              return t;
            }
            parseTime() {
              const e = this.getCurrentRecord(),
                t = this.extract(e, this.consumeTime);
              this.consumeSpaceForRecord(e);
              const i = this.extract(e, this.consumeTime);
              return this.currentLine++, { startTime: t, stopTime: i };
            }
            parseBandWidth() {
              const e = [];
              for (; this.currentLine < this.records.length; ) {
                const t = this.getCurrentRecord();
                if (t.type !== a.BANDWIDTH) break;
                {
                  const i = this.extractOneOrMore(t, l);
                  if (":" !== t.value[t.cur])
                    throw new Error("Invalid bandwidth field.");
                  t.cur++;
                  const s = this.extractOneOrMore(t, o);
                  e.push({ bwtype: i, bandwidth: s }), this.currentLine++;
                }
              }
              return e;
            }
            parseVersion() {
              const e = this.getCurrentRecord();
              if (e.type !== a.VERSION)
                throw new Error("first sdp record must be version");
              const t = e.value.slice(0, this.consumeOneOrMore(e.value, 0, o));
              if (t.length !== e.value.length)
                throw new Error(
                  'invalid proto version, "v='.concat(e.value, '"')
                );
              return this.currentLine++, t;
            }
            parseOrigin() {
              const e = this.getCurrentRecord();
              if (e.type !== a.ORIGIN)
                throw new Error("second line of sdp must be origin");
              const t = this.extractOneOrMore(e, d);
              this.consumeSpaceForRecord(e);
              const i = this.extractOneOrMore(e, o);
              this.consumeSpaceForRecord(e);
              const s = this.extractOneOrMore(e, o);
              this.consumeSpaceForRecord(e);
              const r = this.extractOneOrMore(e, l);
              this.consumeSpaceForRecord(e);
              const n = this.extractOneOrMore(e, l);
              this.consumeSpaceForRecord(e);
              const c = this.extract(e, this.consumeUnicastAddress);
              return (
                this.currentLine++,
                {
                  username: t,
                  sessId: i,
                  sessVersion: s,
                  nettype: r,
                  addrtype: n,
                  unicastAddress: c
                }
              );
            }
            parseSessionName() {
              const e = this.getCurrentRecord();
              if (e.type === a.SESSION_NAME) {
                const t = this.extract(e, this.consumeText);
                return this.currentLine++, t;
              }
            }
            parseInformation() {
              const e = this.getCurrentRecord();
              if (e.type !== a.INFORMATION) return;
              const t = this.extract(e, this.consumeText);
              return this.currentLine++, t;
            }
            parseUri() {
              const e = this.getCurrentRecord();
              if (e.type === a.URI) return this.currentLine++, e.value;
            }
            parseEmail() {
              const e = [];
              for (;;) {
                const t = this.getCurrentRecord();
                if (t.type !== a.EMAIL) break;
                e.push(t.value), this.currentLine++;
              }
              return e;
            }
            parsePhone() {
              const e = [];
              for (;;) {
                const t = this.getCurrentRecord();
                if (t.type !== a.PHONE) break;
                e.push(t.value), this.currentLine++;
              }
              return e;
            }
            parseConnection() {
              const e = this.getCurrentRecord();
              if (e.type === a.CONNECTION) {
                const t = this.extractOneOrMore(e, l);
                this.consumeSpaceForRecord(e);
                const i = this.extractOneOrMore(e, l);
                this.consumeSpaceForRecord(e);
                const s = this.extract(e, this.consumeAddress);
                return (
                  this.currentLine++, { nettype: t, addrtype: i, address: s }
                );
              }
            }
            parseMedia() {
              const e = this.getCurrentRecord(),
                t = this.extract(e, this.consumeToken);
              this.consumeSpaceForRecord(e);
              let i = this.extract(e, this.consumePort);
              "/" === e.value[e.cur] &&
                ((e.cur += 1), (i += this.extract(e, this.consumeInteger))),
                this.consumeSpaceForRecord(e);
              const s = [];
              for (
                s.push(this.extract(e, this.consumeToken));
                "/" === e.value[e.cur];

              )
                (e.cur += 1), s.push(this.extract(e, this.consumeToken));
              if (0 === s.length) throw new Error("Invalid proto");
              const r = this.parseFmt(e);
              return (
                this.currentLine++,
                { mediaType: t, port: i, protos: s, fmts: r }
              );
            }
            parseTimeFields() {
              const e = [];
              for (; this.getCurrentRecord().type === a.TIME; ) {
                const t = this.parseTime(),
                  i = this.parseRepeat(),
                  s = this.parseZone();
                e.push({ time: t, repeats: i, zones: s });
              }
              return e;
            }
            parseMediaDescription() {
              const e = [];
              for (
                ;
                this.currentLine < this.records.length &&
                this.getCurrentRecord().type === a.MEDIA;

              ) {
                const t = this.parseMedia(),
                  i = this.parseInformation(),
                  s = this.parseConnections(),
                  r = this.parseBandWidth(),
                  n = this.parseKey(),
                  a = this.parseMediaAttributes(t);
                e.push({
                  media: t,
                  information: i,
                  connections: s,
                  bandwidths: r,
                  key: n,
                  attributes: a
                });
              }
              return e;
            }
            parseConnections() {
              const e = [];
              for (
                ;
                this.currentLine < this.records.length &&
                this.getCurrentRecord().type === a.CONNECTION;

              )
                e.push(this.parseConnection());
              return e;
            }
            parseFmt(e) {
              const t = [];
              for (;;)
                try {
                  this.consumeSpaceForRecord(e),
                    t.push(this.extract(e, this.consumeToken));
                } catch (e) {
                  break;
                }
              if (0 === t.length) throw new Error("Invalid fmts");
              return t;
            }
            extract(e, t, ...i) {
              const s = t.call(this, e.value, e.cur, ...i),
                r = e.value.slice(e.cur, s);
              return (e.cur = s), r;
            }
            extractOneOrMore(e, t) {
              const i = this.consumeOneOrMore(e.value, e.cur, t),
                s = e.value.slice(e.cur, i);
              return (e.cur = i), s;
            }
            consumeSpaceForRecord(e) {
              if (e.value[e.cur] !== n)
                throw new Error("Invalid space at ".concat(e.cur, "."));
              e.cur += 1;
            }
          }
          class y extends v {
            constructor(...e) {
              super(...e),
                S(this, "attributes", void 0),
                S(this, "digested", !1);
            }
            extractOneOrMore(e, t, i) {
              const s = this.consumeOneOrMore(e.attValue, e._cur, t),
                r = e.attValue.slice(e._cur, s),
                [n, a] = i || [];
              if ("number" == typeof n && r.length < n)
                throw new Error(
                  "error in length, should be more or equal than ".concat(
                    n,
                    " characters."
                  )
                );
              if ("number" == typeof a && r.length > a)
                throw new Error(
                  "error in length, should be less or equal than ".concat(
                    a,
                    " characters."
                  )
                );
              return (e._cur = s), r;
            }
            consumeAttributeSpace(e) {
              if (e.attValue[e._cur] !== n)
                throw new Error("Invalid space at ".concat(e._cur, "."));
              e._cur += 1;
            }
            extract(e, t, ...i) {
              if (!e.attValue)
                throw new Error("Nothing to extract from attValue.");
              const s = t.call(this, e.attValue, e._cur, ...i),
                r = e.attValue.slice(e._cur, s);
              return (e._cur = s), r;
            }
            atEnd(e) {
              if (!e.attValue) throw new Error();
              return e._cur >= e.attValue.length;
            }
            peekChar(e) {
              if (!e.attValue) throw new Error();
              return e.attValue[e._cur];
            }
            peek(e, t) {
              if (!e.attValue) throw new Error();
              for (let i = 0; i < t.length; i++)
                if (t[i] !== e.attValue[e._cur + i]) return !1;
              return !0;
            }
            parseIceUfrag(e) {
              if (this.attributes.iceUfrag)
                throw new Error(
                  "Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'"
                );
              this.attributes.iceUfrag = this.extractOneOrMore(e, E, [4, 256]);
            }
            parseIcePwd(e) {
              if (this.attributes.icePwd)
                throw new Error(
                  "Invalid ice-pwd, should be only a single line if 'a=ice-pwd'"
                );
              this.attributes.icePwd = this.extractOneOrMore(e, E, [22, 256]);
            }
            parseIceOptions(e) {
              if (this.attributes.iceOptions)
                throw new Error(
                  "Invalid ice-options, should be only one 'ice-options' line"
                );
              const t = [];
              for (; !this.atEnd(e); ) {
                t.push(this.extractOneOrMore(e, E));
                try {
                  this.consumeAttributeSpace(e);
                } catch (t) {
                  if (this.atEnd(e)) break;
                  throw t;
                }
              }
              this.attributes.iceOptions = t;
            }
            parseFingerprint(e) {
              const t = this.extract(e, this.consumeToken);
              this.consumeAttributeSpace(e);
              const i = this.extract(e, this.consumeTill);
              this.attributes.fingerprints.push({
                hashFunction: t,
                fingerprint: i
              });
            }
            parseExtmap(e) {
              const t = this.extractOneOrMore(e, o);
              let i;
              "/" === this.peekChar(e) &&
                (this.extract(e, this.consume, "/"),
                (i = this.extract(e, this.consumeToken))),
                this.consumeAttributeSpace(e);
              const s = this.extract(e, this.consumeTill, n),
                r = T(
                  T({ entry: parseInt(t, 10) }, i && { direction: i }),
                  {},
                  { extensionName: s }
                );
              this.peekChar(e) === n &&
                (this.consumeAttributeSpace(e),
                (r.extensionAttributes = this.extract(e, this.consumeTill))),
                this.attributes.extmaps.push(r);
            }
            parseSetup(e) {
              if (this.attributes.setup)
                throw new Error("must only be one single 'a=setup' line.");
              const t = this.extract(e, this.consumeTill);
              if (
                "active" !== t &&
                "passive" !== t &&
                "actpass" !== t &&
                "holdconn" !== t
              )
                throw new Error(
                  "role must be one of 'active', 'passive', 'actpass', 'holdconn'."
                );
              this.attributes.setup = t;
            }
          }
          class A extends y {
            constructor(...e) {
              super(...e),
                S(this, "attributes", {
                  unrecognized: [],
                  groups: [],
                  extmaps: [],
                  fingerprints: [],
                  identities: []
                });
            }
            parse(e) {
              if (this.digested) throw new Error("already digested");
              try {
                switch (e.attField) {
                  case "group":
                    this.parseGroup(e);
                    break;
                  case "ice-lite":
                    this.parseIceLite();
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e);
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e);
                    break;
                  case "setup":
                    this.parseSetup(e);
                    break;
                  case "tls-id":
                    this.parseTlsId(e);
                    break;
                  case "identity":
                    this.parseIdentity(e);
                    break;
                  case "extmap":
                    this.parseExtmap(e);
                    break;
                  case "msid-semantic":
                    this.parseMsidSemantic(e);
                    break;
                  default:
                    (e.ignored = !0), this.attributes.unrecognized.push(e);
                }
              } catch (t) {
                throw (console.error(
                  "parsing session attribute "
                    .concat(e.attField, ' error, "a=')
                    .concat(e.attField, ":")
                    .concat(e.attValue, '"')
                ),
                t);
              }
              if (!e.ignored && e.attValue && !this.atEnd(e))
                throw new Error("attribute parsing error");
            }
            digest() {
              return (this.digested = !0), this.attributes;
            }
            parseGroup(e) {
              const t = this.extract(e, this.consumeToken),
                i = [];
              for (; !this.atEnd(e) && this.peekChar(e) === n; )
                this.consumeAttributeSpace(e),
                  i.push(this.extract(e, this.consumeToken));
              this.attributes.groups.push({
                semantic: t,
                identificationTag: i
              });
            }
            parseIceLite() {
              if (this.attributes.iceLite)
                throw new Error(
                  "Invalid ice-lite, should be only a single line of 'a=ice-lite'"
                );
              this.attributes.iceLite = !0;
            }
            parseTlsId(e) {
              if (this.attributes.tlsId)
                throw new Error("must be only one tld-id line");
              this.attributes.tlsId = this.extractOneOrMore(e, m);
            }
            parseIdentity(e) {
              const t = this.extractOneOrMore(e, g),
                i = [];
              for (; !this.atEnd(e) && this.peekChar(e) === n; ) {
                this.consumeAttributeSpace(e);
                const t = this.extract(e, this.consumeToken);
                this.extract(e, this.consume, "=");
                const s = this.extractOneOrMore(e, e => e !== n && f(e));
                i.push({ name: t, value: s });
              }
              this.attributes.identities.push({
                assertionValue: t,
                extensions: i
              });
            }
            parseMsidSemantic(e) {
              this.peekChar(e) === n && this.consumeAttributeSpace(e);
              const t = {
                semantic: this.extract(e, this.consumeToken),
                identifierList: []
              };
              for (;;) {
                try {
                  this.consumeAttributeSpace(e);
                } catch (e) {
                  break;
                }
                if ("*" === this.peekChar(e)) {
                  this.extract(e, this.consume, "*"), (t.applyForAll = !0);
                  break;
                }
                {
                  const i = this.extract(e, this.consumeTill, n);
                  t.identifierList.push(i);
                }
              }
              this.attributes.msidSemantic = t;
            }
          }
          class I extends y {
            constructor(e) {
              super(),
                S(this, "attributes", void 0),
                -1 !== e.protos.indexOf("RTP") || e.protos.indexOf("rtp"),
                (this.attributes = {
                  unrecognized: [],
                  candidates: [],
                  extmaps: [],
                  fingerprints: [],
                  imageattr: [],
                  msids: [],
                  remoteCandidatesList: [],
                  rids: [],
                  ssrcs: [],
                  ssrcGroups: [],
                  rtcpFeedbackWildcards: [],
                  payloads: []
                });
            }
            parse(e) {
              if (this.digested) throw new Error("already digested");
              try {
                switch (e.attField) {
                  case "extmap":
                    this.parseExtmap(e);
                    break;
                  case "setup":
                    this.parseSetup(e);
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e);
                    break;
                  case "candidate":
                    this.parseCandidate(e);
                    break;
                  case "remote-candidate":
                    this.parseRemoteCandidate(e);
                    break;
                  case "end-of-candidates":
                    this.parseEndOfCandidates();
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e);
                    break;
                  case "rtpmap":
                    this.parseRtpmap(e);
                    break;
                  case "ptime":
                    this.parsePtime(e);
                    break;
                  case "maxptime":
                    this.parseMaxPtime(e);
                    break;
                  case "sendrecv":
                  case "recvonly":
                  case "sendonly":
                  case "inactive":
                    this.parseDirection(e);
                    break;
                  case "ssrc":
                    this.parseSSRC(e);
                    break;
                  case "fmtp":
                    this.parseFmtp(e);
                    break;
                  case "rtcp-fb":
                    this.parseRtcpFb(e);
                    break;
                  case "rtcp-mux":
                    this.parseRTCPMux();
                    break;
                  case "rtcp-mux-only":
                    this.parseRTCPMuxOnly();
                    break;
                  case "rtcp-rsize":
                    this.parseRTCPRsize();
                    break;
                  case "rtcp":
                    this.parseRTCP(e);
                    break;
                  case "mid":
                    this.parseMid(e);
                    break;
                  case "msid":
                    this.parseMsid(e);
                    break;
                  case "imageattr":
                    this.parseImageAttr(e);
                    break;
                  case "rid":
                    this.parseRid(e);
                    break;
                  case "simulcast":
                    this.parseSimulcast(e);
                    break;
                  case "sctp-port":
                    this.parseSctpPort(e);
                    break;
                  case "max-message-size":
                    this.parseMaxMessageSize(e);
                    break;
                  case "ssrc-group":
                    this.parseSSRCGroup(e);
                    break;
                  default:
                    (e.ignored = !0), this.attributes.unrecognized.push(e);
                }
              } catch (t) {
                throw (console.error(
                  "parsing media attribute "
                    .concat(e.attField, ' error, "a=')
                    .concat(e.attField, ":")
                    .concat(e.attValue, '"')
                ),
                t);
              }
              if (!e.ignored && e.attValue && !this.atEnd(e))
                throw new Error("attribute parsing error");
            }
            parseCandidate(e) {
              const t = this.extractOneOrMore(e, E, [1, 32]);
              this.consumeAttributeSpace(e);
              const i = this.extractOneOrMore(e, o, [1, 5]);
              this.consumeAttributeSpace(e);
              const s = this.extract(e, this.consumeToken);
              this.consumeAttributeSpace(e);
              const r = this.extractOneOrMore(e, o, [1, 10]);
              this.consumeAttributeSpace(e);
              const a = this.extract(e, this.consumeAddress);
              this.consumeAttributeSpace(e);
              const d = this.extract(e, this.consumePort);
              this.consumeAttributeSpace(e),
                this.extract(e, this.consume, "typ"),
                this.consumeAttributeSpace(e);
              const l = {
                foundation: t,
                componentId: i,
                transport: s,
                priority: r,
                connectionAddress: a,
                port: d,
                type: this.extract(e, this.consumeToken),
                extension: {}
              };
              for (
                this.peek(e, " raddr") &&
                  (this.extract(e, this.consume, " raddr"),
                  this.consumeAttributeSpace(e),
                  (l.relAddr = this.extract(e, this.consumeAddress))),
                  this.peek(e, " rport") &&
                    (this.extract(e, this.consume, " rport"),
                    this.consumeAttributeSpace(e),
                    (l.relPort = this.extract(e, this.consumePort)));
                this.peekChar(e) === n;

              ) {
                this.consumeAttributeSpace(e);
                const t = this.extract(e, this.consumeToken);
                this.consumeAttributeSpace(e),
                  (l.extension[t] = this.extractOneOrMore(e, c));
              }
              this.attributes.candidates.push(l);
            }
            parseRemoteCandidate(e) {
              const t = [];
              for (;;) {
                const i = this.extractOneOrMore(e, o, [1, 5]);
                this.consumeAttributeSpace(e);
                const s = this.extract(e, this.consumeAddress);
                this.consumeAttributeSpace(e);
                const r = this.extract(e, this.consumePort);
                t.push({ componentId: i, connectionAddress: s, port: r });
                try {
                  this.consumeAttributeSpace(e);
                } catch (e) {
                  break;
                }
              }
              this.attributes.remoteCandidatesList.push(t);
            }
            parseEndOfCandidates() {
              if (this.attributes.endOfCandidates)
                throw new Error("must be only one line of end-of-candidates");
              this.attributes.endOfCandidates = !0;
            }
            parseRtpmap(e) {
              const t = this.extract(e, this.consumeToken);
              this.consumeAttributeSpace(e);
              const i = this.extract(e, this.consumeTill, "/");
              this.extract(e, this.consume, "/");
              const s = {
                encodingName: i,
                clockRate: this.extractOneOrMore(e, o)
              };
              this.atEnd(e) ||
                "/" !== this.peekChar(e) ||
                (this.extract(e, this.consume, "/"),
                (s.encodingParameters = parseInt(
                  this.extract(e, this.consumeTill),
                  10
                )));
              const r = this.attributes.payloads.find(
                e => e.payloadType === parseInt(t, 10)
              );
              r
                ? (r.rtpMap = s)
                : this.attributes.payloads.push({
                    payloadType: parseInt(t, 10),
                    rtpMap: s,
                    rtcpFeedbacks: []
                  });
            }
            parsePtime(e) {
              if (this.attributes.ptime)
                throw new Error("must be only one line of ptime");
              this.attributes.ptime = this.extract(e, this.consumeTill);
            }
            parseMaxPtime(e) {
              if (this.attributes.maxPtime)
                throw new Error("must be only one line of ptime");
              this.attributes.maxPtime = this.extract(e, this.consumeTill);
            }
            parseDirection(e) {
              if (this.attributes.direction)
                throw new Error("must be only one line of direction info");
              this.attributes.direction = e.attField;
            }
            parseSSRC(e) {
              const t = this.extractOneOrMore(e, o);
              this.consumeAttributeSpace(e);
              const i = this.extract(e, this.consumeTill, ":");
              let s;
              ":" === this.peekChar(e) &&
                (this.extract(e, this.consume, ":"),
                (s = this.extract(e, this.consumeTill)));
              const r = this.attributes.ssrcs.find(
                e => e.ssrcId === parseInt(t, 10)
              );
              r
                ? (r.attributes[i] = s)
                : this.attributes.ssrcs.push({
                    ssrcId: parseInt(t, 10),
                    attributes: { [i]: s }
                  });
            }
            parseFmtp(e) {
              const t = this.extract(e, this.consumeTill, n);
              this.consumeAttributeSpace(e);
              const i = this.extract(e, this.consumeTill),
                s = {};
              i.split(";").forEach(e => {
                let [t, i] = e.split("=");
                t = t.trim();
                const r = "string" == typeof i ? i.trim() : null;
                "string" == typeof t && t.length > 0 && (s[t] = r);
              });
              const r = this.attributes.payloads.find(
                e => e.payloadType === parseInt(t, 10)
              );
              r
                ? (r.fmtp = { parameters: s })
                : this.attributes.payloads.push({
                    payloadType: parseInt(t, 10),
                    rtcpFeedbacks: [],
                    fmtp: { parameters: s }
                  });
            }
            parseFmtParameters(e) {
              const t = {},
                i = this.extract(e, this.consumeTill, "=");
              e._cur++;
              const s = this.extract(e, this.consumeTill, ";");
              for (t[i] = s; ";" === e.attValue[e._cur]; ) {
                const i = this.extract(e, this.consumeTill, "=");
                e._cur++;
                const s = this.extract(e, this.consumeTill, ";");
                t[i] = s;
              }
              return t;
            }
            parseRtcpFb(e) {
              let t = "";
              (t =
                "*" === this.peekChar(e)
                  ? this.extract(e, this.consume, "*")
                  : this.extract(e, this.consumeTill, n)),
                this.consumeAttributeSpace(e);
              const i = this.extract(e, this.consumeTill, n);
              let s;
              if ("trr-int" === i)
                s = { type: i, interval: this.extract(e, this.consumeTill) };
              else {
                const t = { type: i };
                this.peekChar(e) === n &&
                  (this.consumeAttributeSpace(e),
                  (t.parameter = this.extract(e, this.consumeToken)),
                  this.peekChar(e) === n &&
                    (t.additional = this.extract(e, this.consumeTill))),
                  (s = t);
              }
              if ("*" === t) this.attributes.rtcpFeedbackWildcards.push(s);
              else {
                const e = this.attributes.payloads.find(
                  e => e.payloadType === parseInt(t, 10)
                );
                e
                  ? e.rtcpFeedbacks.push(s)
                  : this.attributes.payloads.push({
                      payloadType: parseInt(t, 10),
                      rtcpFeedbacks: [s]
                    });
              }
            }
            parseRTCPMux() {
              if (this.attributes.rtcpMux)
                throw new Error("must be single line of rtcp-mux");
              this.attributes.rtcpMux = !0;
            }
            parseRTCPMuxOnly() {
              if (this.attributes.rtcpMuxOnly)
                throw new Error("must be single line of rtcp-only");
              this.attributes.rtcpMuxOnly = !0;
            }
            parseRTCPRsize() {
              if (this.attributes.rtcpRsize)
                throw new Error("must be single line of rtcp-rsize");
              this.attributes.rtcpRsize = !0;
            }
            parseRTCP(e) {
              if (this.attributes.rtcp)
                throw new Error("must be single line of rtcp");
              const t = { port: this.extract(e, this.consumePort) };
              this.peekChar(e) === n &&
                (this.consumeAttributeSpace(e),
                (t.netType = this.extractOneOrMore(e, l)),
                this.consumeAttributeSpace(e),
                (t.addressType = this.extractOneOrMore(e, l)),
                this.consumeAttributeSpace(e),
                (t.address = this.extract(e, this.consumeAddress))),
                (this.attributes.rtcp = t);
            }
            parseMsid(e) {
              const t = { id: this.extractOneOrMore(e, l, [1, 64]) };
              this.peekChar(e) === n &&
                (this.consumeAttributeSpace(e),
                (t.appdata = this.extractOneOrMore(e, l, [1, 64]))),
                this.attributes.msids.push(t);
            }
            parseImageAttr(e) {
              this.attributes.imageattr.push(e.attValue);
            }
            parseRid(e) {
              const t = this.extractOneOrMore(
                e,
                e => u(e) || o(e) || "_" === e || "-" === e
              );
              this.consumeAttributeSpace(e);
              const i = {
                id: t,
                direction: this.extract(e, this.consumeToken),
                params: []
              };
              if (this.peekChar(e) === n) {
                if ((this.consumeAttributeSpace(e), this.peek(e, "pt="))) {
                  this.extract(e, this.consume, "pt=");
                  const t = [];
                  for (;;) {
                    const i = this.extract(e, this.consumeToken);
                    t.push(i);
                    try {
                      this.extract(e, this.consume, ",");
                    } catch (e) {
                      break;
                    }
                  }
                  (i.payloads = t),
                    this.peekChar(e) === n && this.extract(e, this.consume, n);
                }
                for (;;) {
                  const t = this.extract(e, this.consumeToken);
                  switch (t) {
                    case "depend": {
                      const s = {
                        type: t,
                        rids: this.extract(e, this.consume, "=").split(",")
                      };
                      i.params.push(s);
                      break;
                    }
                    default: {
                      const s = { type: t };
                      "=" === this.peekChar(e) &&
                        (this.extract(e, this.consume, "="),
                        (s.val = this.extract(e, this.consumeTill, ";"))),
                        i.params.push(s);
                    }
                  }
                  try {
                    this.extract(e, this.consume, ";");
                  } catch (e) {
                    break;
                  }
                }
              }
              this.attributes.rids.push(i);
            }
            parseSimulcast(e) {
              if (this.attributes.simulcast)
                throw new Error("must be single line of simulcast");
              (this.attributes.simulcast = e.attValue),
                this.extract(e, this.consumeTill);
            }
            parseSctpPort(e) {
              this.attributes.sctpPort = this.extractOneOrMore(e, o, [1, 5]);
            }
            parseMaxMessageSize(e) {
              this.attributes.maxMessageSize = this.extractOneOrMore(e, o, [
                1,
                void 0
              ]);
            }
            digest() {
              return (this.digested = !0), this.attributes;
            }
            parseMid(e) {
              this.attributes.mid = this.extract(e, this.consumeToken);
            }
            parseSSRCGroup(e) {
              const t = this.extract(e, this.consumeToken),
                i = [];
              for (;;)
                try {
                  this.consumeAttributeSpace(e);
                  const t = this.extract(e, this.consumeInteger);
                  i.push(parseInt(t, 10));
                } catch (e) {
                  break;
                }
              this.attributes.ssrcGroups.push({ semantic: t, ssrcIds: i });
            }
          }
          function C(e, t, i) {
            return (
              t in e
                ? Object.defineProperty(e, t, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                  })
                : (e[t] = i),
              e
            );
          }
          class b {
            constructor() {
              C(this, "eol", r);
            }
            print(e, t) {
              let i = "";
              return (
                t && (this.eol = t),
                (i += this.printVersion(e.version)),
                (i += this.printOrigin(e.origin)),
                (i += this.printSessionName(e.sessionName)),
                (i += this.printInformation(e.information)),
                (i += this.printUri(e.uri)),
                (i += this.printEmail(e.emails)),
                (i += this.printPhone(e.phones)),
                (i += this.printConnection(e.connection)),
                (i += this.printBandwidth(e.bandwidths)),
                (i += this.printTimeFields(e.timeFields)),
                (i += this.printKey(e.key)),
                (i += this.printSessionAttributes(e.attributes)),
                (i += this.printMediaDescription(e.mediaDescriptions)),
                i
              );
            }
            printVersion(e) {
              return "v=".concat(e).concat(this.eol);
            }
            printOrigin(e) {
              return "o="
                .concat(e.username, " ")
                .concat(e.sessId, " ")
                .concat(e.sessVersion, " ")
                .concat(e.nettype, " ")
                .concat(e.addrtype, " ")
                .concat(e.unicastAddress)
                .concat(this.eol);
            }
            printSessionName(e) {
              return e ? "s=".concat(e).concat(this.eol) : "";
            }
            printInformation(e) {
              return e ? "i=".concat(e).concat(this.eol) : "";
            }
            printUri(e) {
              return e ? "u=".concat(e).concat(this.eol) : "";
            }
            printEmail(e) {
              let t = "";
              for (const i of e) t += "e=".concat(i).concat(this.eol);
              return t;
            }
            printPhone(e) {
              let t = "";
              for (const i of e) t += "e=".concat(i).concat(this.eol);
              return t;
            }
            printConnection(e) {
              return e
                ? "c="
                    .concat(e.nettype, " ")
                    .concat(e.addrtype, " ")
                    .concat(e.address)
                    .concat(this.eol)
                : "";
            }
            printBandwidth(e) {
              let t = "";
              for (const i of e)
                t += "b="
                  .concat(i.bwtype, ":")
                  .concat(i.bandwidth)
                  .concat(this.eol);
              return t;
            }
            printTimeFields(e) {
              let t = "";
              for (const i of e) {
                t += "t="
                  .concat(i.time.startTime, " ")
                  .concat(i.time.startTime)
                  .concat(this.eol);
                for (const e of i.repeats)
                  t += "r="
                    .concat(e.repeatInterval, " ")
                    .concat(e.typedTimes.join(" "))
                    .concat(this.eol);
                i.zoneAdjustments &&
                  ((t += "z="),
                  (t += "z="
                    .concat(
                      i.zoneAdjustments
                        .map(e =>
                          ""
                            .concat(e.time, " ")
                            .concat(e.back ? "-" : "", " ")
                            .concat(e.typedTime)
                        )
                        .join(" ")
                    )
                    .concat(this.eol)),
                  (t += this.eol));
              }
              return t;
            }
            printKey(e) {
              return e ? "k=".concat(e).concat(this.eol) : "";
            }
            printAttributes(e) {
              let t = "";
              for (const i of e)
                t += "a="
                  .concat(i.attField)
                  .concat(i.attValue ? ":".concat(i.attValue) : "")
                  .concat(this.eol);
              return t;
            }
            printMediaDescription(e) {
              let t = "";
              for (const i of e)
                (t += this.printMedia(i.media)),
                  (t += this.printInformation(i.information)),
                  (t += this.printConnections(i.connections)),
                  (t += this.printBandwidth(i.bandwidths)),
                  (t += this.printKey(i.key)),
                  (t += this.printMediaAttributes(i));
              return t;
            }
            printConnections(e) {
              let t = "";
              for (const i of e) t += this.printConnection(i);
              return t;
            }
            printMedia(e) {
              return "m="
                .concat(e.mediaType, " ")
                .concat(e.port, " ")
                .concat(e.protos.join("/"), " ")
                .concat(e.fmts.join(" "))
                .concat(this.eol);
            }
            printSessionAttributes(e) {
              return new D(this.eol).print(e);
            }
            printMediaAttributes(e) {
              return new w(this.eol).print(e);
            }
          }
          class O {
            constructor(e) {
              C(this, "eol", void 0), (this.eol = e);
            }
            printIceUfrag(e) {
              return void 0 === e
                ? ""
                : "a=ice-ufrag:".concat(e).concat(this.eol);
            }
            printIcePwd(e) {
              return void 0 === e
                ? ""
                : "a=ice-pwd:".concat(e).concat(this.eol);
            }
            printIceOptions(e) {
              return void 0 === e
                ? ""
                : "a=ice-options:".concat(e.join(n)).concat(this.eol);
            }
            printFingerprints(e) {
              return e.length > 0
                ? e
                    .map(e =>
                      "a=fingerprint:"
                        .concat(e.hashFunction)
                        .concat(n)
                        .concat(e.fingerprint)
                    )
                    .join(this.eol) + this.eol
                : "";
            }
            printExtmap(e) {
              return e
                .map(e =>
                  "a=extmap:"
                    .concat(e.entry)
                    .concat(e.direction ? "/".concat(e.direction) : "")
                    .concat(n)
                    .concat(e.extensionName)
                    .concat(
                      e.extensionAttributes
                        ? "".concat(n).concat(e.extensionAttributes)
                        : ""
                    )
                    .concat(this.eol)
                )
                .join("");
            }
            printSetup(e) {
              return void 0 === e ? "" : "a=setup:".concat(e).concat(this.eol);
            }
            printUnrecognized(e) {
              return e
                .map(e =>
                  "a="
                    .concat(e.attField)
                    .concat(e.attValue ? ":".concat(e.attValue) : "")
                    .concat(this.eol)
                )
                .join("");
            }
          }
          class D extends O {
            print(e) {
              let t = "";
              return (
                (t += this.printGroups(e.groups)),
                (t += this.printMsidSemantic(e.msidSemantic)),
                (t += this.printIceLite(e.iceLite)),
                (t += this.printIceUfrag(e.iceUfrag)),
                (t += this.printIcePwd(e.icePwd)),
                (t += this.printIceOptions(e.iceOptions)),
                (t += this.printFingerprints(e.fingerprints)),
                (t += this.printSetup(e.setup)),
                (t += this.printTlsId(e.tlsId)),
                (t += this.printIdentity(e.identities)),
                (t += this.printExtmap(e.extmaps)),
                (t += this.printUnrecognized(e.unrecognized)),
                t
              );
            }
            printGroups(e) {
              let t = "";
              return (
                e.length > 0 &&
                  (t += e
                    .map(e =>
                      "a=group:"
                        .concat(e.semantic)
                        .concat(
                          e.identificationTag
                            .map(e => "".concat(n).concat(e))
                            .join("")
                        )
                        .concat(this.eol)
                    )
                    .join("")),
                t
              );
            }
            printIceLite(e) {
              return void 0 === e ? "" : "a=ice-lite" + this.eol;
            }
            printTlsId(e) {
              return e ? "a=tls-id:".concat(e).concat(this.eol) : "";
            }
            printIdentity(e) {
              return 0 === e.length
                ? ""
                : e
                    .map(e =>
                      "a=identity:".concat(e.assertionValue).concat(
                        e.extensions.map(e =>
                          ""
                            .concat(n)
                            .concat(e.name)
                            .concat(e.value ? "=".concat(e.value) : "")
                        )
                      )
                    )
                    .join(this.eol) + this.eol;
            }
            printMsidSemantic(e) {
              if (!e) return "";
              let t = "a=msid-semantic:".concat(e.semantic);
              return (
                e.applyForAll
                  ? (t += "".concat(n, "*"))
                  : e.identifierList.length > 0 &&
                    (t += e.identifierList.map(e => "".concat(n).concat(e))),
                t + this.eol
              );
            }
          }
          class w extends O {
            print(e) {
              const t = e.attributes;
              let i = "";
              return (
                (i += this.printRTCP(t.rtcp)),
                (i += this.printIceUfrag(t.iceUfrag)),
                (i += this.printIcePwd(t.icePwd)),
                (i += this.printIceOptions(t.iceOptions)),
                (i += this.printCandidates(t.candidates)),
                (i += this.printRemoteCandidatesList(t.remoteCandidatesList)),
                (i += this.printEndOfCandidates(t.endOfCandidates)),
                (i += this.printFingerprints(t.fingerprints)),
                (i += this.printSetup(t.setup)),
                (i += this.printMid(t.mid)),
                (i += this.printExtmap(t.extmaps)),
                (i += this.printRTPRelated(t)),
                (i += this.printPtime(t.ptime)),
                (i += this.printMaxPtime(t.maxPtime)),
                (i += this.printDirection(t.direction)),
                (i += this.printSSRCGroups(t.ssrcGroups)),
                (i += this.printSSRC(t.ssrcs)),
                (i += this.printRTCPMux(t.rtcpMux)),
                (i += this.printRTCPMuxOnly(t.rtcpMuxOnly)),
                (i += this.printRTCPRsize(t.rtcpRsize)),
                (i += this.printMSId(t.msids)),
                (i += this.printImageattr(t.imageattr)),
                (i += this.printRid(t.rids)),
                (i += this.printSimulcast(t.simulcast)),
                (i += this.printSCTPPort(t.sctpPort)),
                (i += this.printMaxMessageSize(t.maxMessageSize)),
                (i += this.printUnrecognized(t.unrecognized)),
                i
              );
            }
            printCandidates(e) {
              return e
                .map(e =>
                  "a=candidate:"
                    .concat(e.foundation)
                    .concat(n)
                    .concat(e.componentId)
                    .concat(n)
                    .concat(e.transport)
                    .concat(n)
                    .concat(e.priority)
                    .concat(n)
                    .concat(e.connectionAddress)
                    .concat(n)
                    .concat(e.port)
                    .concat(n, "typ")
                    .concat(n)
                    .concat(e.type)
                    .concat(
                      e.relAddr
                        ? ""
                            .concat(n, "raddr")
                            .concat(n)
                            .concat(e.relAddr)
                        : ""
                    )
                    .concat(
                      e.relPort
                        ? ""
                            .concat(n, "rport")
                            .concat(n)
                            .concat(e.relPort)
                        : ""
                    )
                    .concat(
                      Object.keys(e.extension)
                        .map(t =>
                          ""
                            .concat(n)
                            .concat(t)
                            .concat(n)
                            .concat(e.extension[t])
                        )
                        .join("")
                    )
                    .concat(this.eol)
                )
                .join("");
            }
            printRemoteCandidatesList(e) {
              return e
                .map(e =>
                  "a=remote-candidates:".concat(e.join(n)).concat(this.eol)
                )
                .join("");
            }
            printEndOfCandidates(e) {
              return void 0 === e ? "" : "a=end-of-candidates" + this.eol;
            }
            printRTPRelated(e) {
              if (!e.payloads) return "";
              const t = e.payloads;
              let i = "";
              i += e.rtcpFeedbackWildcards
                .map(e => this.printRTCPFeedback("*", e))
                .join("");
              for (const e of t)
                (i += this.printRtpMap(e.payloadType, e.rtpMap)),
                  (i += this.printFmtp(e.payloadType, e.fmtp)),
                  (i += e.rtcpFeedbacks
                    .map(t => this.printRTCPFeedback(e.payloadType, t))
                    .join(""));
              return i;
            }
            printFmtp(e, t) {
              if (!t) return "";
              const i = Object.keys(t.parameters);
              return 1 === i.length && null === t.parameters[i[0]]
                ? "a=fmtp:"
                    .concat(e)
                    .concat(n)
                    .concat(i[0])
                    .concat(this.eol)
                : "a=fmtp:"
                    .concat(e)
                    .concat(n)
                    .concat(
                      Object.keys(t.parameters)
                        .map(e => "".concat(e, "=").concat(t.parameters[e]))
                        .join(";")
                    )
                    .concat(this.eol);
            }
            printRtpMap(e, t) {
              return t
                ? "a=rtpmap:"
                    .concat(e)
                    .concat(n)
                    .concat(t.encodingName, "/")
                    .concat(t.clockRate)
                    .concat(
                      t.encodingParameters
                        ? "/".concat(t.encodingParameters)
                        : ""
                    )
                    .concat(this.eol)
                : "";
            }
            printRTCPFeedback(e, t) {
              let i = "a=rtcp-fb:".concat(e).concat(n),
                s = t;
              return (
                "trr-int" === s.type
                  ? (i += "ttr-int".concat(n).concat(s.interval))
                  : ((i += "".concat(s.type)),
                    s.parameter &&
                      ((i += "".concat(n).concat(s.parameter)),
                      s.additional &&
                        (i += "".concat(n).concat(s.additional)))),
                i + this.eol
              );
            }
            printPtime(e) {
              return void 0 === e ? "" : "a=ptime:".concat(e).concat(this.eol);
            }
            printMaxPtime(e) {
              return void 0 === e
                ? ""
                : "a=maxptime:".concat(e).concat(this.eol);
            }
            printDirection(e) {
              return void 0 === e ? "" : "a=".concat(e).concat(this.eol);
            }
            printSSRC(e) {
              return e
                .map(e =>
                  Object.keys(e.attributes)
                    .map(t =>
                      "a=ssrc:"
                        .concat(e.ssrcId.toString(10))
                        .concat(n)
                        .concat(t)
                        .concat(
                          e.attributes[t] ? ":".concat(e.attributes[t]) : ""
                        )
                        .concat(this.eol)
                    )
                    .join("")
                )
                .join("");
            }
            printRTCPMux(e) {
              return void 0 === e ? "" : "a=rtcp-mux".concat(this.eol);
            }
            printRTCPMuxOnly(e) {
              return void 0 === e ? "" : "a=rtcp-mux-only".concat(this.eol);
            }
            printRTCPRsize(e) {
              return void 0 === e ? "" : "a=rtcp-rsize".concat(this.eol);
            }
            printRTCP(e) {
              if (void 0 === e) return "";
              let t = "a=rtcp:".concat(e.port);
              return (
                e.netType && (t += "".concat(n).concat(e.netType)),
                e.addressType && (t += "".concat(n).concat(e.addressType)),
                e.address && (t += "".concat(n).concat(e.address)),
                t + this.eol
              );
            }
            printMSId(e) {
              return e
                .map(e =>
                  "a=msid:"
                    .concat(e.id)
                    .concat(e.appdata ? "".concat(n).concat(e.appdata) : "")
                    .concat(this.eol)
                )
                .join("");
            }
            printImageattr(e) {
              return e
                .map(e => "a=imageattr:".concat(e).concat(this.eol))
                .join("");
            }
            printRid(e) {
              return e
                .map(e => {
                  let t = "a=rid:"
                    .concat(e.id)
                    .concat(n)
                    .concat(e.direction);
                  return (
                    e.payloads &&
                      (t += "".concat(n, "pt=").concat(e.payloads.join(","))),
                    e.params.length > 0 &&
                      (t += ""
                        .concat(n)
                        .concat(
                          e.params
                            .map(e =>
                              "depend" === e.type
                                ? "depend=".concat(e.rids.join(","))
                                : "".concat(e.type, "=").concat(e.val)
                            )
                            .join(";")
                        )),
                    t + this.eol
                  );
                })
                .join("");
            }
            printSimulcast(e) {
              return void 0 === e
                ? ""
                : "a=simulcast:".concat(e).concat(this.eol);
            }
            printSCTPPort(e) {
              return void 0 === e
                ? ""
                : "a=sctp-port:".concat(e).concat(this.eol);
            }
            printMaxMessageSize(e) {
              return void 0 === e
                ? ""
                : "a=max-message-size:".concat(e).concat(this.eol);
            }
            printMid(e) {
              return void 0 === e ? "" : "a=mid:".concat(e).concat(this.eol);
            }
            printSSRCGroups(e) {
              return e
                .map(e =>
                  "a=ssrc-group:"
                    .concat(e.semantic)
                    .concat(
                      e.ssrcIds
                        .map(e => "".concat(n).concat(e.toString(10)))
                        .join("")
                    )
                    .concat(this.eol)
                )
                .join("");
            }
          }
          function L(e) {
            return new R().parse(e);
          }
          function N(e, t) {
            return new b().print(e, t);
          }
        }
      },
      t = {};
    function i(s) {
      if (t[s]) return t[s].exports;
      var r = (t[s] = { exports: {} });
      return e[s](r, r.exports, i), r.exports;
    }
    return (
      (i.d = (e, t) => {
        for (var s in t)
          i.o(t, s) &&
            !i.o(e, s) &&
            Object.defineProperty(e, s, { enumerable: !0, get: t[s] });
      }),
      (i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
      (i.r = e => {
        "undefined" != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(e, "__esModule", { value: !0 });
      }),
      i(8)
    );
  })();
  function sU(e) {
    return iU.parse(e);
  }
  function rU(e, t) {
    return iU.print(e, t);
  }
  function nU(e, t, i) {
    return (
      (t = (function(e) {
        var t = (function(e, t) {
          if ("object" != typeof e || !e) return e;
          var i = e[Symbol.toPrimitive];
          if (void 0 !== i) {
            var s = i.call(e, "string");
            if ("object" != typeof s) return s;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(e);
        })(e);
        return "symbol" == typeof t ? t : t + "";
      })(t)) in e
        ? Object.defineProperty(e, t, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
          })
        : (e[t] = i),
      e
    );
  }
  function aU(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function oU(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? aU(Object(i), !0).forEach(function(t) {
            nU(e, t, i[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
        : aU(Object(i)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
          });
    }
    return e;
  }
  const cU = new (class extends uk {
    constructor() {
      super(...arguments), nU(this, "currentUploadLogID", 0);
    }
    reportLogUploadError(e) {
      const { errorRange: t } = e;
      t[t.length - 1] &&
        t[t.length - 1] > this.currentUploadLogID &&
        ((this.currentUploadLogID = t[t.length - 1]),
        this.emit("REPORT_LOG_UPLOAD", e));
    }
  })();
  class dU {
    constructor(e) {
      nU(this, "logger", void 0),
        nU(this, "prefixLists", []),
        (this.logger = e);
    }
    debug() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      this.logger.debug(...this.prefixLists, ...t);
    }
    info() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      this.logger.info(...this.prefixLists, ...t);
    }
    warning() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      this.logger.warning(...this.prefixLists, ...t);
    }
    error() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      this.logger.error(...this.prefixLists, ...t);
    }
    prefix(e) {
      return this.prefixLists.push(e), this;
    }
    popPrefix() {
      return this.prefixLists.pop(), this;
    }
  }
  function lU() {
    const e = new Date();
    return e.toTimeString().split(" ")[0] + ":" + e.getMilliseconds();
  }
  function hU() {
    const e = new Date(),
      t = /((\d+:){2}\d+)/.exec(new Date().toUTCString());
    return t
      ? (null == t ? void 0 : t[0]) + ":" + e.getUTCMilliseconds()
      : e.toTimeString().split(" ")[0] + ":" + e.getMilliseconds();
  }
  const uU = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 },
    pU = Date.now(),
    fU = e => {
      for (const t in uU)
        if (Object.prototype.hasOwnProperty.call(uU, t) && uU[t] === e)
          return t;
      return "DEFAULT";
    };
  const EU = new (class {
    constructor() {
      nU(this, "proxyServerURL", void 0),
        nU(this, "logLevel", uU.DEBUG),
        nU(this, "uploadState", "collecting"),
        nU(this, "uploadLogWaitingList", []),
        nU(this, "uploadLogUploadingList", []),
        nU(this, "uploadErrorCount", 0),
        nU(this, "currentLogID", 0),
        nU(this, "url", void 0),
        nU(this, "extLog", (e, t) => {
          this.appendLogToWaitingList(e, ...t);
        });
    }
    debug() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      const s = [uU.DEBUG].concat(t);
      this.log.apply(this, s);
    }
    info() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      const s = [uU.INFO].concat(t);
      this.log.apply(this, s);
    }
    warning() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      const s = [uU.WARNING].concat(t);
      this.log.apply(this, s);
    }
    warn() {
      this.warning(...arguments);
    }
    error() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      const s = [uU.ERROR].concat(t);
      this.log.apply(this, s);
    }
    upload() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      const s = [uU.DEBUG].concat(t);
      this.uploadLog.apply(this, s);
    }
    setLogLevel(e) {
      (e = Math.min(Math.max(0, e), 4)), (this.logLevel = e);
    }
    enableLogUpload() {
      KM("UPLOAD_LOG", !0);
    }
    disableLogUpload() {
      KM("UPLOAD_LOG", !1),
        (this.uploadLogUploadingList = []),
        (this.uploadLogWaitingList = []);
    }
    setProxyServer(e) {
      this.proxyServerURL = e;
    }
    prefix(e) {
      return new dU(this).prefix(e);
    }
    log() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      if (Date.now() - pU < 100)
        return void setTimeout(() => {
          this.log(...t);
        }, Date.now() - pU);
      const s = Math.max(0, Math.min(4, t[0]));
      if (
        ((t[0] = lU() + " Agora-SDK [".concat(fU(s), "]:")),
        this.appendLogToWaitingList(s, ...t),
        s < this.logLevel)
      )
        return;
      const r = lU() + " %cAgora-SDK [".concat(fU(s), "]:");
      let n = [];
      if (!WM("USE_NEW_LOG"))
        switch (s) {
          case uU.DEBUG:
            (n = [r, "color: #64B5F6;"].concat(t.slice(1))),
              console.log.apply(console, n);
            break;
          case uU.INFO:
            (n = [r, "color: #1E88E5; font-weight: bold;"].concat(t.slice(1))),
              console.log.apply(console, n);
            break;
          case uU.WARNING:
            (n = [r, "color: #FB8C00; font-weight: bold;"].concat(t.slice(1))),
              console.warn.apply(console, n);
            break;
          case uU.ERROR:
            (n = [r, "color: #B00020; font-weight: bold;"].concat(t.slice(1))),
              console.error.apply(console, n);
        }
    }
    uploadLog() {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      if (Date.now() - pU < 100)
        return void setTimeout(() => {
          this.uploadLog(...t);
        }, Date.now() - pU);
      const s = Math.max(0, Math.min(4, t[0]));
      (t[0] = lU() + " Agora-SDK [".concat(fU(s), "]:")),
        this.appendLogToWaitingList(s, ...t);
    }
    appendLogToWaitingList(e) {
      if (!WM("UPLOAD_LOG")) return;
      for (
        var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1;
        s < t;
        s++
      )
        i[s - 1] = arguments[s];
      Array.isArray(i[0])
        ? (i[0][0] = hU() + " Agora-SDK [".concat(fU(e), "]:"))
        : (i[0] = hU() + " Agora-SDK [".concat(fU(e), "]:"));
      let r = "";
      i.forEach(e => {
        "object" == typeof e && (e = JSON.stringify(e)),
          (r += "".concat(e, " "));
      }),
        this.uploadLogWaitingList.push({
          payload_str: r,
          log_level: e,
          log_item_id: this.currentLogID++
        }),
        "uploading" === this.uploadState &&
          0 === this.uploadLogUploadingList.length &&
          this.uploadLogInterval();
    }
    startUpload() {
      (this.uploadState = "uploading"),
        0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
    }
    async uploadLogs() {
      const e = this.uploadLogUploadingList,
        t = {
          sdk_version: MM,
          process_id: WM("PROCESS_ID"),
          payload: JSON.stringify(e)
        };
      return oM(
        async () => {
          const e = await lP.post(
            this.url ||
              (this.proxyServerURL
                ? "https://"
                    .concat(this.proxyServerURL, "/ls/?h=")
                    .concat(WM("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1")
                : "https://".concat(WM("LOG_UPLOAD_SERVER"), "/upload/v1")),
            t,
            { responseType: "text" }
          );
          if ("OK" !== e.data) {
            const t = new Error("unexpected upload log response");
            throw ((t.response = e), t);
          }
        },
        () => ((this.uploadLogUploadingList = []), !1),
        t => {
          const i = {
            status: -1,
            message: t.message,
            errorRange: e.map(e => e.log_item_id)
          };
          return (
            t.response
              ? ((i.status = t.response.status),
                (i.data = t.response.data),
                (i.headers = t.response.headers))
              : t.request && (i.status = t.request.status),
            cU.reportLogUploadError(i),
            !0
          );
        },
        {
          timeout: WM("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"),
          maxRetryTimeout: WM("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL")
        }
      );
    }
    uploadLogInterval() {
      (0 === this.uploadLogUploadingList.length &&
        0 === this.uploadLogWaitingList.length) ||
        (0 === this.uploadLogUploadingList.length &&
          (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(
            0,
            WM("UPLOAD_LOG_LENGTH_EACH_TIME")
          )),
        this.uploadLogs()
          .then(() => {
            (this.uploadErrorCount = 0),
              this.uploadLogWaitingList.length > 0 &&
                window.setTimeout(
                  () => this.uploadLogInterval(),
                  WM("UPLOAD_LOG_INTERVAL")
                );
          })
          .catch(e => {
            (this.uploadErrorCount += 1),
              this.uploadErrorCount < 2
                ? window.setTimeout(
                    () => this.uploadLogInterval(),
                    WM("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")
                  )
                : window.setTimeout(
                    () => this.uploadLogInterval(),
                    WM("UPLOAD_LOG_RETRY_INTERVAL_V1")
                  );
          }));
    }
  })();
  var mU;
  function gU(e) {
    return (
      ik(e.reportId, "params.reportId", 0, 100, !1),
      ik(e.category, "params.category", 0, 100, !1),
      ik(e.event, "params.event", 0, 100, !1),
      ik(e.label, "params.label", 0, 100, !1),
      ek(
        e.value,
        "params.value",
        Number.MIN_SAFE_INTEGER,
        Number.MAX_SAFE_INTEGER,
        !1
      ),
      !0
    );
  }
  ((mU = {}).FREE = "free"),
    (mU.UPLOADING = "uploading"),
    (function(e) {
      (e[(e.MISC = 0)] = "MISC"),
        (e[(e.INTERNAL_EVENT = 1)] = "INTERNAL_EVENT"),
        (e[(e.PUBLIC_EVENT = 2)] = "PUBLIC_EVENT"),
        (e[(e.WEB_EVENT = 3)] = "WEB_EVENT"),
        (e[(e.INTERNAL_API = 4)] = "INTERNAL_API"),
        (e[(e.WEB_API = 5)] = "WEB_API"),
        (e[(e.PUBLIC_API = 6)] = "PUBLIC_API");
    })({});
  const _U = {
    sid: "",
    lts: 0,
    success: null,
    cname: null,
    uid: null,
    peer: null,
    cid: null,
    elapse: null,
    extend: null,
    vid: 0
  };
  let TU = (function(e) {
      return (
        (e.PUBLISH = "publish"),
        (e.SUBSCRIBE = "subscribe"),
        (e.WS_COMPRESSOR_INIT = "ws_compressor_init"),
        (e.SESSION_INIT = "session_init"),
        (e.JOIN_CHOOSE_SERVER = "join_choose_server"),
        (e.REQ_USER_ACCOUNT = "req_user_account"),
        (e.JOIN_GATEWAY = "join_gateway"),
        (e.REJOIN_GATEWAY = "rejoin_gateway"),
        (e.STREAM_SWITCH = "stream_switch"),
        (e.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager"),
        (e.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter"),
        (e.FIRST_VIDEO_RECEIVED = "first_video_received"),
        (e.FIRST_AUDIO_RECEIVED = "first_audio_received"),
        (e.FIRST_VIDEO_DECODE = "first_video_decode"),
        (e.FIRST_AUDIO_DECODE = "first_audio_decode"),
        (e.ON_ADD_AUDIO_STREAM = "on_add_audio_stream"),
        (e.ON_ADD_VIDEO_STREAM = "on_add_video_stream"),
        (e.ON_UPDATE_STREAM = "on_update_stream"),
        (e.ON_REMOVE_STREAM = "on_remove_stream"),
        (e.USER_ANALYTICS = "req_user_analytics"),
        (e.PC_STATS = "pc_stats"),
        (e.UPDATE_REMOTE_RTPCAPABILITIES = "update_remote_rtpCapabilities"),
        (e.AB_TEST = "ab_test"),
        e
      );
    })({}),
    SU = (function(e) {
      return (
        (e.SESSION = "io.agora.pb.Wrtc.Session"),
        (e.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer"),
        (e.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount"),
        (e.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway"),
        (e.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway"),
        (e.PUBLISH = "io.agora.pb.Wrtc.Publish"),
        (e.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe"),
        (e.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit"),
        (e.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch"),
        (e.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped"),
        (e.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped"),
        (e.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter"),
        (e.REQUEST_PROXY_WORKER_MANAGER =
          "io.agora.pb.Wrtc.RequestProxyWorkerManager"),
        (e.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke"),
        (e.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived"),
        (e.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived"),
        (e.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode"),
        (e.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode"),
        (e.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream"),
        (e.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream"),
        (e.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream"),
        (e.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream"),
        (e.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout"),
        (e.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus"),
        (e.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent"),
        (e.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent"),
        (e.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP"),
        (e.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit"),
        (e.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics"),
        (e.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed"),
        (e.PC_STATS = "io.agora.pb.Wrtc.PCStats"),
        (e.UPDATE_REMOTE_RTPCAPABILITIES =
          "io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities"),
        (e.AB_TEST = "io.agora.pb.Wrtc.ABTest"),
        e
      );
    })({});
  !(function(e) {
    (e[(e.WORKER_EVENT = 156)] = "WORKER_EVENT"),
      (e[(e.AP_WORKER_EVENT = 160)] = "AP_WORKER_EVENT");
  })({});
  let vU = (function(e) {
    return (
      (e[(e.SESSION = 26)] = "SESSION"),
      (e[(e.JOIN_CHOOSE_SERVER = 27)] = "JOIN_CHOOSE_SERVER"),
      (e[(e.REQ_USER_ACCOUNT = 196)] = "REQ_USER_ACCOUNT"),
      (e[(e.JOIN_GATEWAY = 28)] = "JOIN_GATEWAY"),
      (e[(e.PUBLISH = 30)] = "PUBLISH"),
      (e[(e.SUBSCRIBE = 29)] = "SUBSCRIBE"),
      (e[(e.WS_COMPRESSOR_INIT = 9430)] = "WS_COMPRESSOR_INIT"),
      (e[(e.STREAM_SWITCH = 32)] = "STREAM_SWITCH"),
      (e[(e.AUDIO_SENDING_STOPPED = 33)] = "AUDIO_SENDING_STOPPED"),
      (e[(e.VIDEO_SENDING_STOPPED = 34)] = "VIDEO_SENDING_STOPPED"),
      (e[(e.REQUEST_PROXY_APPCENTER = 35)] = "REQUEST_PROXY_APPCENTER"),
      (e[(e.REQUEST_PROXY_WORKER_MANAGER = 36)] =
        "REQUEST_PROXY_WORKER_MANAGER"),
      (e[(e.API_INVOKE = 41)] = "API_INVOKE"),
      (e[(e.FIRST_VIDEO_RECEIVED = 348)] = "FIRST_VIDEO_RECEIVED"),
      (e[(e.FIRST_AUDIO_RECEIVED = 349)] = "FIRST_AUDIO_RECEIVED"),
      (e[(e.FIRST_VIDEO_DECODE = 350)] = "FIRST_VIDEO_DECODE"),
      (e[(e.FIRST_AUDIO_DECODE = 351)] = "FIRST_AUDIO_DECODE"),
      (e[(e.ON_ADD_AUDIO_STREAM = 352)] = "ON_ADD_AUDIO_STREAM"),
      (e[(e.ON_ADD_VIDEO_STREAM = 353)] = "ON_ADD_VIDEO_STREAM"),
      (e[(e.ON_UPDATE_STREAM = 356)] = "ON_UPDATE_STREAM"),
      (e[(e.ON_REMOVE_STREAM = 355)] = "ON_REMOVE_STREAM"),
      (e[(e.JOIN_CHANNEL_TIMEOUT = 407)] = "JOIN_CHANNEL_TIMEOUT"),
      (e[(e.PEER_PUBLISH_STATUS = 408)] = "PEER_PUBLISH_STATUS"),
      (e[(e.WORKER_EVENT = 156)] = "WORKER_EVENT"),
      (e[(e.AP_WORKER_EVENT = 160)] = "AP_WORKER_EVENT"),
      (e[(e.JOIN_WEB_PROXY_AP = 700)] = "JOIN_WEB_PROXY_AP"),
      (e[(e.WEBSOCKET_QUIT = 671)] = "WEBSOCKET_QUIT"),
      (e[(e.USER_ANALYTICS = 1e4)] = "USER_ANALYTICS"),
      (e[(e.AUTOPLAY_FAILED = 9178)] = "AUTOPLAY_FAILED"),
      e
    );
  })({});
  function RU() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return function(t, i, s) {
      const r = s.value;
      if ("function" == typeof r) {
        const n =
          e.className ||
          t.__className__ ||
          ("AgoraRTCClient" === t.constructor.name
            ? "Client"
            : t.constructor.name);
        s.value = function() {
          for (var t, s = arguments.length, a = new Array(s), o = 0; o < s; o++)
            a[o] = arguments[o];
          let c = a;
          if (e.argsMap)
            try {
              c = e.argsMap(this, ...a);
            } catch (e) {
              EU.warning(e), (c = []);
            }
          try {
            JSON.stringify(c);
          } catch (e) {
            EU.warning(
              "arguments for method "
                .concat(n, ".")
                .concat(String(i), " not serializable for apiInvoke.")
            ),
              (c = []);
          }
          const d = (e.report || yU).reportApiInvoke(
            this._sessionId || null,
            {
              id:
                this._clientId ||
                (null === (t = this.store) || void 0 === t
                  ? void 0
                  : t.clientId) ||
                this._ID,
              name: "".concat(n, ".").concat(String(i)),
              options: c,
              tag: mk.TRACER,
              reportResult: e.reportResult
            },
            e.throttleTime
          );
          try {
            const t = r.apply(this, a);
            return t instanceof Promise
              ? t
                  .then(t => (d.onSuccess(e.reportResult && t), t))
                  .catch(e => {
                    throw (d.onError(e), e);
                  })
              : (d.onSuccess(e.reportResult && t), t);
          } catch (e) {
            throw (d.onError(e), e);
          }
        };
      }
      return s;
    };
  }
  const yU = new (class {
    constructor() {
      nU(this, "baseInfoMap", new Map()),
        nU(this, "proxyServer", void 0),
        nU(this, "eventUploadTimer", void 0),
        nU(this, "setSessionIdTimer", void 0),
        nU(this, "url", void 0),
        nU(this, "sids", new Set()),
        nU(this, "backupUrl", void 0),
        nU(this, "_appId", void 0),
        nU(this, "_aid", 0),
        nU(this, "keyEventUploadPendingItems", []),
        nU(this, "normalEventUploadPendingItems", []),
        nU(this, "apiInvokeUploadPendingItems", []),
        nU(this, "apiInvokeCount", 0),
        nU(this, "apiInvokeLoggedCount", 0),
        nU(this, "ltsList", []),
        nU(this, "lastSendNormalEventTime", Date.now()),
        nU(this, "customReportCounterTimer", void 0),
        nU(this, "customReportCount", 0),
        nU(this, "extApiInvoke", async e => {
          for (const t of e) {
            const e = oU(
              oU({}, t),
              {},
              { sid: null, invokeId: ++this.apiInvokeCount, tag: mk.TRACER }
            );
            this.sendApiInvoke(e);
          }
        }),
        (this.eventUploadTimer = window.setInterval(
          this.doSend.bind(this),
          WM("EVENT_REPORT_SEND_INTERVAL")
        )),
        (this.setSessionIdTimer = window.setInterval(
          this.appendSessionId.bind(this),
          WM("EVENT_REPORT_SEND_INTERVAL")
        ));
    }
    getBaseInfoBySessionId(e) {
      return this.baseInfoMap.get(e);
    }
    setAppId(e) {
      (this._appId = e),
        (this._aid =
          parseInt(
            e.replace(/[a-fA-F0-9]{8}/g, e => {
              let [t, i] = e;
              return t + i;
            }),
            16
          ) || 0);
    }
    reportApiInvoke(e, t, i) {
      (t.timeout = t.timeout || 6e4),
        (t.reportResult = void 0 === t.reportResult || t.reportResult);
      const s = Date.now();
      this.apiInvokeCount += 1;
      const r = this.apiInvokeCount,
        n = !!WM("SHOW_REPORT_INVOKER_LOG"),
        a = !!WM("SHOW_REPORT_USER_INVOKER_LOG"),
        o = n || (a && t.id);
      o && (this.apiInvokeLoggedCount += 1);
      const c = this.apiInvokeLoggedCount;
      function d(e, i) {
        if (o) {
          let s = "[apiInvoke-".concat(c, "]");
          t.id && (s += "[".concat(t.id, "]")),
            t.name && (s += "[".concat(t.name, "]")),
            EU.info(
              "".concat(s, " ").concat(e),
              "start" === e ? t.options : i || ""
            );
        }
      }
      const l = () => ({
        tag: t.tag,
        invokeId: r,
        sid: e,
        name: t.name,
        apiInvokeTime: s,
        options: t.options,
        states: t.states || null
      });
      d("start");
      let h = !1;
      Wk(t.timeout).then(() => {
        h ||
          (this.sendApiInvoke(
            oU(oU({}, l()), {}, { error: zP.API_INVOKE_TIMEOUT, success: !1 })
          ),
          d("timeout"));
      });
      const u = new JP(
        zP.UNEXPECTED_ERROR,
        "".concat(t.name, ": this api invoke is end")
      );
      return {
        onSuccess: e => {
          const s = () => {
            if (h) throw u;
            return (
              (h = !0),
              this.sendApiInvoke(
                oU(
                  oU({}, l()),
                  {},
                  { success: !0 },
                  t.reportResult && { result: e }
                )
              ),
              d("onSuccess"),
              e
            );
          };
          return i ? zk(s, t.name + "Success", i, () => (h = !0)) : s();
        },
        onError: e => {
          const s = () => {
            if (h) throw e;
            (h = !0),
              this.sendApiInvoke(
                oU(oU({}, l()), {}, { success: !1, error: e })
              ),
              d("onFailure", e.toString());
          };
          return i ? zk(s, t.name + "Error", i, () => (h = !0)) : s();
        }
      };
    }
    sessionInit(e, t) {
      if (this.baseInfoMap.has(e)) return;
      const i = Date.now(),
        s = this.createBaseInfo(e, i);
      s.cname = t.cname;
      const r = Object.assign(
          {},
          {
            willUploadConsoleLog: WM("UPLOAD_LOG"),
            maxTouchPoints: navigator.maxTouchPoints,
            areaVersion: UM ? "global" : "oversea",
            areas: WM("AREAS") && WM("AREAS").join(",")
          },
          t.extend
        ),
        {
          stringUid: n,
          channelProfile: a,
          channelMode: o,
          isABTestSuccess: c,
          lsid: d,
          clientRole: l
        } = t,
        h = Date.now(),
        u = oU(
          oU({}, s),
          {},
          {
            eventType: TU.SESSION_INIT,
            appid: t.appid,
            browser: navigator.userAgent,
            buildFormat: t.buildFormat,
            build: GM,
            lts: h,
            elapse: h - i,
            extend: JSON.stringify(r),
            mode: t.mode,
            process: WM("PROCESS_ID"),
            appType: WM("APP_TYPE"),
            success: !0,
            version: MM,
            stringUid: n,
            channelProfile: a,
            channelMode: o,
            isABTestSuccess: c,
            lsid: d,
            clientType: window.navigator.userAgent.includes("AgoraWebView")
              ? 42
              : 20,
            clientRole: l,
            serviceId: WM("PROCESS_ID"),
            extensionID: WM("PLUGIN_INFO").join(",") || ""
          }
        );
      this.send({ type: SU.SESSION, data: u }, !0);
    }
    joinChooseServer(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU({}, s),
          {},
          {
            role: t.role,
            eventType: TU.JOIN_CHOOSE_SERVER,
            lts: r,
            eventElapse: t.elapse || r - t.lts,
            chooseServerAddr: t.csAddr,
            errorCode: t.ec,
            elapse: r - i.startTime,
            success: t.succ,
            chooseServerAddrList: JSON.stringify(t.serverList),
            uid: t.uid ? parseInt(t.uid) : null,
            cid: t.cid ? parseInt(t.cid) : null,
            chooseServerIp: t.csIp || "",
            opid: t.opid,
            unilbsServerIds: t.unilbsServerIds,
            extend: t.extend || void 0,
            isHttp3: t.isHttp3,
            corssRegionTagReq: t.corssRegionTagReq || void 0,
            corssRegionTagRes: t.corssRegionTagRes || void 0
          }
        );
      this.send({ type: SU.JOIN_CHOOSE_SERVER, data: n }, !0);
    }
    reqUserAccount(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU({}, s),
          {},
          {
            eventType: TU.REQ_USER_ACCOUNT,
            lts: r,
            success: t.success,
            serverAddress: t.serverAddr,
            stringUid: t.stringUid,
            uid: t.uid,
            errorCode: t.errorCode,
            elapse: t.elapse || r - i.startTime,
            eventElapse: r - t.lts,
            extend: JSON.stringify(t.extend)
          }
        );
      this.send({ type: SU.REQ_USER_ACCOUNT, data: n }, !0);
    }
    joinGateway(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info;
      t.vid && (s.vid = t.vid), (s.uid = t.uid), (s.cid = t.cid);
      const r = Date.now(),
        { firstSuccess: n, avoidJoinStartTime: a, addr: o, isProxy: c } = t,
        d = r - (n && a ? a : i.startTime),
        l = oU(
          oU({}, s),
          {},
          {
            eventType: TU.JOIN_GATEWAY,
            lts: r,
            gatewayAddr: t.addr,
            success: t.succ,
            errorCode: t.ec,
            errorMsg: t.errorMsg || "",
            elapse: d,
            eventElapse: r - t.lts,
            firstSuccess: n,
            signalChannel: t.signalChannel,
            preload: t.preload ? 1 : 0,
            installId: kM(),
            isABTestSuccess: t.isABTestSuccess ? 1 : 0
          }
        ),
        h = l.success ? 1 : 0;
      if ((t.succ && (i.lastJoinSuccessTime = r), n))
        this.send({ type: SU.JOIN_GATEWAY, data: l }, !0);
      else {
        let e;
        if (o)
          if (c) {
            const t = o.match(/h=(\d{1,3}-){3}\d{1,3}/g),
              i = o.match(/p=[0-9]{1,6}/g);
            e = {
              isSuccess: h,
              gatewayIp:
                t && t.length ? t[0].split("=")[1].replace(/-/g, ".") : "",
              port: i && i.length ? i[0].split("=")[1] : "",
              isProxy: c ? 1 : 0
            };
          } else {
            const t = o.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g),
              i = o.match(/(:|p=)[0-9]{1,6}/g);
            e = {
              isSuccess: h,
              gatewayIp:
                t && t.length ? t[0].split("//")[1].replace(/-/g, ".") : "",
              port: i && i.length ? i[0].split(/:|p=/g)[1] : "",
              isProxy: c ? 1 : 0
            };
          }
        else e = { isSuccess: h, gatewayIp: "", port: "", isProxy: c ? 1 : 0 };
        delete l.success,
          delete l.eventType,
          delete l.firstSuccess,
          (l.vid = Number(l.vid));
        const t = Object.assign({}, l, e, { eventType: TU.REJOIN_GATEWAY });
        this.send({ type: SU.RE_JOIN_GATEWAY, data: t }, !0);
      }
    }
    joinChannelTimeout(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = Date.now(),
        r = oU(
          oU({}, i.info),
          {},
          { lts: s, timeout: t, elapse: s - i.startTime }
        );
      this.send({ type: SU.JOIN_CHANNEL_TIMEOUT, data: r }, !0);
    }
    publish(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU({}, s),
          {},
          {
            eventType: TU.PUBLISH,
            lts: r,
            eventElapse: t.eventElapse,
            elapse: r - i.startTime,
            success: t.succ,
            errorCode: t.ec,
            videoName: t.videoName,
            audioName: t.audioName,
            screenName: t.screenName,
            screenshare: t.screenshare,
            audio: t.audio,
            video: t.video,
            p2pid: t.p2pid,
            publishRequestid: t.publishRequestid
          }
        );
      this.send({ type: SU.PUBLISH, data: n }, !0);
    }
    subscribe(e, t, i) {
      const s = this.baseInfoMap.get(e);
      if (!s) return;
      const r = s.info,
        n = Date.now(),
        a = oU(
          oU({}, r),
          {},
          {
            eventType: TU.SUBSCRIBE,
            lts: n,
            eventElapse: t.eventElapse,
            elapse: n - s.startTime,
            success: t.succ,
            errorCode: t.ec,
            video: t.video,
            audio: t.audio,
            subscribeRequestid: t.subscribeRequestid,
            p2pid: t.p2pid,
            preSsrc: t.preSsrc ? 1 : 0
          },
          i && { extend: JSON.stringify({ isMassSubscribe: !0 }) }
        );
      "string" == typeof t.peerid
        ? (a.peerSuid = t.peerid)
        : (a.peer = t.peerid),
        this.send({ type: SU.SUBSCRIBE, data: a }, !0);
    }
    wsCompressorInit(e) {
      const t = [...this.baseInfoMap.keys()],
        i = t.length ? t[0] : "UnableToGetSid",
        s = this.baseInfoMap.get(i);
      if (!s) return;
      const r = s.info,
        n = Date.now(),
        a = oU(
          oU({}, r),
          {},
          {
            eventType: TU.WS_COMPRESSOR_INIT,
            lts: n,
            eventElapse: e.eventElapse,
            elapse: n - s.startTime,
            status: e.status ? 1 : 2
          }
        );
      this.send({ type: SU.WS_COMPRESSOR_INIT, data: a }, !0);
    }
    firstRemoteVideoDecode(e, t, i, s) {
      const r = this.baseInfoMap.get(e);
      if (!r) return;
      const n = r.info,
        a = Date.now(),
        o = oU(
          oU(oU({}, n), s),
          {},
          {
            elapse: a - r.startTime,
            eventType: t,
            lts: a,
            firstDecodeFrame: Math.max((s.firstFrame || a) - r.startTime, 0),
            apEnd: Math.max(s.apEnd - r.startTime, 0),
            apStart: Math.max(s.apStart - r.startTime, 0),
            joinGwEnd: Math.max(s.joinGwEnd - r.startTime, 0),
            joinGwStart: Math.max(s.joinGwStart - r.startTime, 0),
            pcEnd: Math.max(s.pcEnd - r.startTime, 0),
            pcStart: Math.max(s.pcStart - r.startTime, 0),
            subscriberEnd: Math.max(s.subscriberEnd - r.startTime, 0),
            subscriberStart: Math.max(s.subscriberStart - r.startTime, 0),
            videoAddNotify: Math.max(s.videoAddNotify - r.startTime, 0)
          }
        );
      this.send({ type: i, data: o }, !0);
    }
    firstRemoteFrame(e, t, i, s) {
      const r = this.baseInfoMap.get(e);
      if (!r) return;
      const n = r.info,
        a = Date.now(),
        o = oU(
          oU(oU({}, n), s),
          {},
          { elapse: a - r.startTime, eventType: t, lts: a }
        );
      this.send({ type: i, data: o }, !0);
    }
    abTest(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU(oU({}, s), t),
          {},
          {
            vid: void 0 === s.vid ? 0 : Number(s.vid),
            elapse: r - i.startTime,
            eventType: TU.AB_TEST,
            lts: r
          }
        );
      this.send({ type: SU.AB_TEST, data: n }, !0);
    }
    pcStats(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU(oU({}, s), t),
          {},
          {
            vid: void 0 === s.vid ? 0 : Number(s.vid),
            elapse: r - i.startTime,
            eventType: TU.PC_STATS,
            lts: r,
            preallocation: t.preallocation ? 1 : 0
          }
        );
      this.send({ type: SU.PC_STATS, data: n }, !0);
    }
    updateRemoteRTPCapabilities(e, t) {
      if (e) {
        const i = this.baseInfoMap.get(e);
        if (!i) return;
        const s = i.info,
          r = Date.now(),
          n = oU(
            oU(oU({}, s), t),
            {},
            {
              vid: void 0 === s.vid ? 0 : Number(s.vid),
              eventType: TU.UPDATE_REMOTE_RTPCAPABILITIES,
              lts: r
            }
          );
        this.send({ type: SU.UPDATE_REMOTE_RTPCAPABILITIES, data: n }, !0);
      }
    }
    onGatewayStream(e, t, i, s) {
      const r = this.baseInfoMap.get(e);
      if (!r) return;
      const n = r.info,
        a = Date.now(),
        o = oU(oU(oU({}, n), s), {}, { eventType: t, lts: a });
      this.send({ type: i, data: o }, !0);
    }
    streamSwitch(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU({}, s),
          {},
          {
            eventType: TU.STREAM_SWITCH,
            lts: r,
            isDual: t.isdual,
            elapse: r - i.startTime,
            success: t.succ
          }
        );
      this.send({ type: SU.STREAM_SWITCH, data: n }, !0);
    }
    requestProxyAppCenter(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU({}, s),
          {},
          {
            eventType: TU.REQUEST_PROXY_APPCENTER,
            lts: r,
            eventElapse: r - t.lts,
            elapse: r - i.startTime,
            APAddr: t.APAddr,
            workerManagerList: t.workerManagerList,
            response: t.response,
            errorCode: t.ec,
            success: t.succ
          }
        );
      this.send({ type: SU.REQUEST_PROXY_APPCENTER, data: n }, !0);
    }
    requestProxyWorkerManager(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU({}, s),
          {},
          {
            eventType: TU.REQUEST_PROXY_WORKER_MANAGER,
            lts: r,
            eventElapse: r - t.lts,
            elapse: r - i.startTime,
            workerManagerAddr: t.workerManagerAddr,
            response: t.response,
            errorCode: t.ec,
            success: t.succ
          }
        );
      this.send({ type: SU.REQUEST_PROXY_WORKER_MANAGER, data: n }, !0);
    }
    setProxyServer(e) {
      (this.proxyServer = e),
        e
          ? EU.debug("reportProxyServerurl: ".concat(e))
          : EU.debug("disable reportProxyServerurl: ".concat(e));
    }
    peerPublishStatus(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU({}, s),
          {},
          {
            subscribeElapse: t.subscribeElapse,
            peer: t.peer,
            peerPublishDuration: Math.max(
              t.audioPublishDuration,
              t.videoPublishDuration
            ),
            audiotag: t.audioPublishDuration > 0 ? 1 : -1,
            videotag: t.videoPublishDuration > 0 ? 1 : -1,
            lts: r,
            elapse: r - i.startTime,
            joinChannelSuccessElapse: r - (i.lastJoinSuccessTime || r),
            peerPublishDurationVideo: t.videoPublishDuration,
            peerPublishDurationAudio: t.audioPublishDuration
          }
        );
      this.send({ type: SU.PEER_PUBLISH_STATUS, data: n }, !0);
    }
    workerEvent(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now();
      (function(e, t, i) {
        const s = e[t];
        if (!s || "string" != typeof s) return [e];
        e[t] = "";
        const r = jk(JSON.stringify(e));
        let n = 0;
        const a = [];
        let o = 0;
        for (let c = 0; c < s.length; c++)
          (o += s.charCodeAt(c) <= 127 ? 1 : 3),
            o <= i - r ||
              ((a[a.length] = XP(XP({}, e), {}, { [t]: s.substring(n, c) })),
              (n = c),
              (o = s.charCodeAt(c) <= 127 ? 1 : 3));
        return (
          n !== s.length - 1 &&
            (a[a.length] = XP(XP({}, e), {}, { [t]: s.substring(n) })),
          a
        );
      })(
        oU(
          oU(oU({}, s), t),
          {},
          { elapse: r - i.startTime, lts: r, productType: "WebRTC" }
        ),
        "payload",
        1300
      ).forEach(e => this.send({ type: SU.WORKER_EVENT, data: e }, !0));
    }
    apworkerEvent(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(oU(oU({}, s), t), {}, { elapse: r - i.startTime, lts: r });
      this.send({ type: SU.AP_WORKER_EVENT, data: n }, !0);
    }
    joinWebProxyAP(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(
          oU(oU({}, s), t),
          {},
          { elapse: r - i.startTime, lts: r, extend: t.extend || void 0 }
        );
      this.send({ type: SU.JOIN_WEB_PROXY_AP, data: n }, !0);
    }
    WebSocketQuit(e, t) {
      const i = this.baseInfoMap.get(e);
      if (!i) return;
      const s = i.info,
        r = Date.now(),
        n = oU(oU(oU({}, s), t), {}, { elapse: r - i.startTime, lts: r });
      this.send({ type: SU.WEBSOCKET_QUIT, data: n }, !0);
    }
    async sendCustomReportMessage(e, t) {
      if (
        ((this.customReportCount += t.length),
        this.customReportCount > WM("CUSTOM_REPORT_LIMIT"))
      )
        throw new JP(zP.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
      this.customReportCounterTimer ||
        (this.customReportCounterTimer = window.setInterval(() => {
          this.customReportCount = 0;
        }, 5e3));
      const i = Date.now(),
        s = t.map(t => ({
          type: SU.USER_ANALYTICS,
          data: oU(oU({ sid: e }, t), {}, { lts: i })
        }));
      try {
        WM("NEW_REPORT_SERVER")
          ? await this.postDataToStatsCollector2(s)
          : await this.postDataToStatsCollector(s);
      } catch (e) {
        throw (EU.error("send custom report message failed", e.toString()),
        new JP(zP.CUSTOM_REPORT_SEND_FAILED, e.message));
      }
    }
    sendApiInvoke(e) {
      const t = WM("NOT_REPORT_EVENT");
      if (e.tag && t.includes && t.includes(e.tag)) return !1;
      if (null === e.sid) return this.apiInvokeUploadPendingItems.push(e), !1;
      const i = this.baseInfoMap.get(e.sid);
      if (!i) return this.apiInvokeUploadPendingItems.push(e), !1;
      const { cname: s, uid: r, cid: n } = i.info;
      let a;
      if (((e.lts = e.lts || Date.now()), e.error))
        if (e.error instanceof JP) {
          const { code: t, message: i } = e.error;
          a = t || i || e.error.toString();
        } else a = e.error.toString();
      const o = {
        invokeId: e.invokeId,
        sid: e.sid,
        cname: s,
        cid: n,
        uid: r,
        lts: e.lts,
        success: e.success,
        elapse: e.lts - i.startTime,
        execElapse: e.lts - e.apiInvokeTime,
        apiName: e.name,
        options: e.options ? JSON.stringify(e.options) : void 0,
        execStates: e.states ? JSON.stringify(e.states) : void 0,
        execResult: e.result ? JSON.stringify(e.result) : void 0,
        errorCode: e.error ? a : void 0,
        errorMsg: e.error ? JSON.stringify(e.error) : void 0
      };
      return this.send({ type: SU.API_INVOKE, data: o }, !1), !0;
    }
    addSid(e) {
      this.sids.add(e);
    }
    removeSid(e) {
      this.sids.delete(e);
    }
    appendSessionId() {
      const e = this.apiInvokeUploadPendingItems;
      if (0 === e.length) return;
      const t = Array.from(this.sids).find(e => null !== e);
      t &&
        e.forEach(e => {
          e && ((e.sid = t), this.sendApiInvoke(Object.assign({}, e)));
        }),
        (e.length = 0);
    }
    send(e, t) {
      if (t)
        return (
          this.keyEventUploadPendingItems.push(e),
          void this.sendItems(this.keyEventUploadPendingItems, !0)
        );
      this.normalEventUploadPendingItems.push(e),
        this.normalEventUploadPendingItems.length >
          WM("NORMAL_EVENT_QUEUE_CAPACITY") &&
          this.normalEventUploadPendingItems.splice(0, 1),
        this.normalEventUploadPendingItems.length >= 10 &&
          this.sendItems(this.normalEventUploadPendingItems, !1);
    }
    doSend() {
      this.keyEventUploadPendingItems.length > 0 &&
        this.sendItems(this.keyEventUploadPendingItems, !0),
        this.normalEventUploadPendingItems.length > 0 &&
          Date.now() - this.lastSendNormalEventTime >= 5e3 &&
          this.sendItems(this.normalEventUploadPendingItems, !1);
    }
    sendItems(e, t) {
      const i = [],
        s = [];
      for (; e.length; ) {
        const t = e.shift();
        i.length < 20 ? i.push(t) : s.push(t);
      }
      e.push(...s);
      for (const e of [...i])
        -1 !== this.ltsList.indexOf(e.data.lts)
          ? ((e.data.lts = this.ltsList[this.ltsList.length - 1] + 1),
            this.ltsList.push(e.data.lts))
          : (this.ltsList.push(e.data.lts), this.ltsList.sort((e, t) => e - t));
      return (
        t || (this.lastSendNormalEventTime = Date.now()),
        WM("ENABLE_EVENT_REPORT")
          ? (i.length &&
              (WM("NEW_REPORT_SERVER")
                ? this.postDataToStatsCollector2(i)
                : this.postDataToStatsCollector(i)
              ).catch(
                (e => i => {
                  WM("EVENT_REPORT_RETRY") &&
                    (t
                      ? (this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(
                          e
                        ))
                      : ((this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(
                          e
                        )),
                        this.normalEventUploadPendingItems.length >
                          WM("NORMAL_EVENT_QUEUE_CAPACITY") &&
                          (this.normalEventUploadPendingItems.splice(
                            0,
                            this.normalEventUploadPendingItems.length -
                              WM("NORMAL_EVENT_QUEUE_CAPACITY")
                          ),
                          EU.warning("report: drop normal events"))));
                })(i)
              ),
            e)
          : e
      );
    }
    async postDataToStatsCollector2(e) {
      wk.networkState === Ak.OFFLINE &&
        (await Promise.race([wk.onlineWaiter, Wk(2 * nM.maxRetryTimeout)]));
      const t = e => {
          let t = new Uint8Array();
          return (
            e.forEach(e => {
              const i = dk(JSON.stringify(e.data)),
                s = new ArrayBuffer(5),
                r = (e => {
                  let t = 0;
                  return (
                    Object.entries(SU).forEach(i => {
                      let [s, r] = i;
                      r === e.type && (t = vU[s]);
                    }),
                    t
                  );
                })(e),
                n = new DataView(s);
              n.setUint16(0, i.byteLength, !0),
                n.setUint8(2, 255 & r),
                n.setUint8(3, (r >>> 8) & 255),
                n.setUint8(4, (r >>> 16) & 255),
                (t = lk(t, new Uint8Array(s))),
                (t = lk(t, i));
            }),
            t
          );
        },
        i = "event";
      let s = this.proxyServer
        ? "https://"
            .concat(this.proxyServer, "/rs/?h=")
            .concat(WM("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=")
            .concat(i)
        : "https://".concat(WM("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i);
      for (let r = 0; r < 2; r += 1) {
        1 === r &&
          (s = this.proxyServer
            ? "https://"
                .concat(this.proxyServer, "/rs/?h=")
                .concat(WM("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=")
                .concat(i)
            : "https://"
                .concat(WM("NEW_REPORT_SERVER_DOMAINS")[1], "/")
                .concat(i));
        try {
          await hM(
            s,
            {
              timeout: 1e4,
              data: t(e),
              headers: oU(
                oU(
                  {
                    biz: "webrtc",
                    sendts: Math.round(Date.now() / 1e3),
                    debug: "false"
                  },
                  this._appId && { appid: this._appId }
                ),
                {},
                { "Content-Type": "application/octet-stream" }
              )
            },
            !0
          );
        } catch (e) {
          if (1 === r) throw e;
          continue;
        }
        return;
      }
    }
    async postDataToStatsCollector(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const i = (e => {
          const t = e && e.data.sid && this.baseInfoMap.get(e.data.sid);
          return (t && t.info.vid && +t.info.vid) || 0;
        })(e[0]),
        s = i ? void 0 : this._aid,
        r = {
          msgType: "EventMessages",
          sentTs: Math.round(Date.now() / 1e3),
          payloads: e.map(e => JSON.stringify(e)),
          vid: i,
          aid: s
        };
      wk.networkState === Ak.OFFLINE &&
        (await Promise.race([wk.onlineWaiter, Wk(2 * nM.maxRetryTimeout)]));
      const n = t ? "/events/proto-raws" : "/events/messages";
      let a =
        this.url ||
        (this.proxyServer
          ? "https://"
              .concat(this.proxyServer, "/rs/?h=")
              .concat(WM("EVENT_REPORT_DOMAIN"), "&p=")
              .concat(WM("STATS_COLLECTOR_PORT"), "&d=")
              .concat(n)
          : "https://"
              .concat(WM("EVENT_REPORT_DOMAIN"), ":")
              .concat(WM("STATS_COLLECTOR_PORT"))
              .concat(n));
      for (let e = 0; e < 2; e += 1) {
        1 === e &&
          (a =
            this.backupUrl ||
            (this.proxyServer
              ? "https://"
                  .concat(this.proxyServer, "/rs/?h=")
                  .concat(WM("EVENT_REPORT_BACKUP_DOMAIN"), "&p=")
                  .concat(WM("STATS_COLLECTOR_PORT"), "&d=")
                  .concat(n)
              : "https://"
                  .concat(WM("EVENT_REPORT_BACKUP_DOMAIN"), ":")
                  .concat(WM("STATS_COLLECTOR_PORT"))
                  .concat(n)));
        try {
          t
            ? await uM(a, { timeout: 1e4, data: r })
            : await hM(a, { timeout: 1e4, data: r });
        } catch (t) {
          if (1 === e) throw t;
          continue;
        }
        return;
      }
    }
    createBaseInfo(e, t) {
      const i = Object.assign({}, _U);
      return (i.sid = e), this.baseInfoMap.set(e, { info: i, startTime: t }), i;
    }
    reportResourceTiming(e, t) {
      const i = performance.getEntriesByName(e),
        s = i[i.length - 1];
      s &&
        this.reportApiInvoke(t, {
          name: "Client.resourceTiming",
          options: s,
          tag: mk.TRACER
        }).onSuccess();
    }
  })();
  cU.on("REPORT_LOG_UPLOAD", e => {
    (e.networkState = wk.networkState),
      yU
        .reportApiInvoke(null, {
          name: "logUploadError",
          options: e,
          tag: mk.TRACER
        })
        .onSuccess("logUploadError");
  });
  class AU extends JP {
    constructor(e) {
      super(
        e,
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
        arguments.length > 2 ? arguments[2] : void 0
      ),
        nU(this, "name", "AgoraRTCException");
    }
    print() {
      let e =
        arguments.length > 0 && void 0 !== arguments[0]
          ? arguments[0]
          : "error";
      return super.print(e, EU);
    }
    throw() {
      super.throw(EU);
    }
  }
  let IU = !0,
    CU = !0;
  function bU(e, t, i) {
    const s = e.match(t);
    return s && s.length >= i && parseInt(s[i], 10);
  }
  function OU(e, t, i) {
    if (!e.RTCPeerConnection) return;
    const s = e.RTCPeerConnection.prototype,
      r = s.addEventListener;
    s.addEventListener = function(e, s) {
      if (e !== t) return r.apply(this, arguments);
      const n = e => {
        const t = i(e);
        t && (s.handleEvent ? s.handleEvent(t) : s(t));
      };
      return (
        (this._eventMap = this._eventMap || {}),
        this._eventMap[t] || (this._eventMap[t] = new Map()),
        this._eventMap[t].set(s, n),
        r.apply(this, [e, n])
      );
    };
    const n = s.removeEventListener;
    (s.removeEventListener = function(e, i) {
      if (e !== t || !this._eventMap || !this._eventMap[t])
        return n.apply(this, arguments);
      if (!this._eventMap[t].has(i)) return n.apply(this, arguments);
      const s = this._eventMap[t].get(i);
      return (
        this._eventMap[t].delete(i),
        0 === this._eventMap[t].size && delete this._eventMap[t],
        0 === Object.keys(this._eventMap).length && delete this._eventMap,
        n.apply(this, [e, s])
      );
    }),
      Object.defineProperty(s, "on" + t, {
        get() {
          return this["_on" + t];
        },
        set(e) {
          this["_on" + t] &&
            (this.removeEventListener(t, this["_on" + t]),
            delete this["_on" + t]),
            e && this.addEventListener(t, (this["_on" + t] = e));
        },
        enumerable: !0,
        configurable: !0
      });
  }
  function DU(e) {
    return "boolean" != typeof e
      ? new Error("Argument type: " + typeof e + ". Please use a boolean.")
      : ((IU = e),
        e ? "adapter.js logging disabled" : "adapter.js logging enabled");
  }
  function wU(e) {
    return "boolean" != typeof e
      ? new Error("Argument type: " + typeof e + ". Please use a boolean.")
      : ((CU = !e),
        "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"));
  }
  function LU() {
    if ("object" == typeof window) {
      if (IU) return;
      "undefined" != typeof console &&
        "function" == typeof console.log &&
        console.log.apply(console, arguments);
    }
  }
  function NU(e, t) {
    CU && console.warn(e + " is deprecated, please use " + t + " instead.");
  }
  function PU(e) {
    return "[object Object]" === Object.prototype.toString.call(e);
  }
  function kU(e) {
    return PU(e)
      ? Object.keys(e).reduce(function(t, i) {
          const s = PU(e[i]),
            r = s ? kU(e[i]) : e[i],
            n = s && !Object.keys(r).length;
          return void 0 === r || n ? t : Object.assign(t, { [i]: r });
        }, {})
      : e;
  }
  function MU(e, t, i) {
    t &&
      !i.has(t.id) &&
      (i.set(t.id, t),
      Object.keys(t).forEach(s => {
        s.endsWith("Id")
          ? MU(e, e.get(t[s]), i)
          : s.endsWith("Ids") &&
            t[s].forEach(t => {
              MU(e, e.get(t), i);
            });
      }));
  }
  function UU(e, t, i) {
    const s = i ? "outbound-rtp" : "inbound-rtp",
      r = new Map();
    if (null === t) return r;
    const n = [];
    return (
      e.forEach(e => {
        "track" === e.type && e.trackIdentifier === t.id && n.push(e);
      }),
      n.forEach(t => {
        e.forEach(i => {
          i.type === s && i.trackId === t.id && MU(e, i, r);
        });
      }),
      r
    );
  }
  const xU = LU;
  function FU(e, t) {
    const i = e && e.navigator;
    if (!i.mediaDevices) return;
    const s = function(e) {
        if ("object" != typeof e || e.mandatory || e.optional) return e;
        const t = {};
        return (
          Object.keys(e).forEach(i => {
            if ("require" === i || "advanced" === i || "mediaSource" === i)
              return;
            const s = "object" == typeof e[i] ? e[i] : { ideal: e[i] };
            void 0 !== s.exact &&
              "number" == typeof s.exact &&
              (s.min = s.max = s.exact);
            const r = function(e, t) {
              return e
                ? e + t.charAt(0).toUpperCase() + t.slice(1)
                : "deviceId" === t
                ? "sourceId"
                : t;
            };
            if (void 0 !== s.ideal) {
              t.optional = t.optional || [];
              let e = {};
              "number" == typeof s.ideal
                ? ((e[r("min", i)] = s.ideal),
                  t.optional.push(e),
                  (e = {}),
                  (e[r("max", i)] = s.ideal),
                  t.optional.push(e))
                : ((e[r("", i)] = s.ideal), t.optional.push(e));
            }
            void 0 !== s.exact && "number" != typeof s.exact
              ? ((t.mandatory = t.mandatory || {}),
                (t.mandatory[r("", i)] = s.exact))
              : ["min", "max"].forEach(e => {
                  void 0 !== s[e] &&
                    ((t.mandatory = t.mandatory || {}),
                    (t.mandatory[r(e, i)] = s[e]));
                });
          }),
          e.advanced && (t.optional = (t.optional || []).concat(e.advanced)),
          t
        );
      },
      r = function(e, r) {
        if (t.version >= 61) return r(e);
        if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
          const t = function(e, t, i) {
            t in e && !(i in e) && ((e[i] = e[t]), delete e[t]);
          };
          t(
            (e = JSON.parse(JSON.stringify(e))).audio,
            "autoGainControl",
            "googAutoGainControl"
          ),
            t(e.audio, "noiseSuppression", "googNoiseSuppression"),
            (e.audio = s(e.audio));
        }
        if (e && "object" == typeof e.video) {
          let n = e.video.facingMode;
          n = n && ("object" == typeof n ? n : { ideal: n });
          const a = t.version < 66;
          if (
            n &&
            ("user" === n.exact ||
              "environment" === n.exact ||
              "user" === n.ideal ||
              "environment" === n.ideal) &&
            (!i.mediaDevices.getSupportedConstraints ||
              !i.mediaDevices.getSupportedConstraints().facingMode ||
              a)
          ) {
            let t;
            if (
              (delete e.video.facingMode,
              "environment" === n.exact || "environment" === n.ideal
                ? (t = ["back", "rear"])
                : ("user" !== n.exact && "user" !== n.ideal) || (t = ["front"]),
              t)
            )
              return i.mediaDevices.enumerateDevices().then(i => {
                let a = (i = i.filter(e => "videoinput" === e.kind)).find(e =>
                  t.some(t => e.label.toLowerCase().includes(t))
                );
                return (
                  !a && i.length && t.includes("back") && (a = i[i.length - 1]),
                  a &&
                    (e.video.deviceId = n.exact
                      ? { exact: a.deviceId }
                      : { ideal: a.deviceId }),
                  (e.video = s(e.video)),
                  xU("chrome: " + JSON.stringify(e)),
                  r(e)
                );
              });
          }
          e.video = s(e.video);
        }
        return xU("chrome: " + JSON.stringify(e)), r(e);
      },
      n = function(e) {
        return t.version >= 64
          ? e
          : {
              name:
                {
                  PermissionDeniedError: "NotAllowedError",
                  PermissionDismissedError: "NotAllowedError",
                  InvalidStateError: "NotAllowedError",
                  DevicesNotFoundError: "NotFoundError",
                  ConstraintNotSatisfiedError: "OverconstrainedError",
                  TrackStartError: "NotReadableError",
                  MediaDeviceFailedDueToShutdown: "NotAllowedError",
                  MediaDeviceKillSwitchOn: "NotAllowedError",
                  TabCaptureError: "AbortError",
                  ScreenCaptureError: "AbortError",
                  DeviceCaptureError: "AbortError"
                }[e.name] || e.name,
              message: e.message,
              constraint: e.constraint || e.constraintName,
              toString() {
                return this.name + (this.message && ": ") + this.message;
              }
            };
      };
    if (
      ((i.getUserMedia = function(e, t, s) {
        r(e, e => {
          i.webkitGetUserMedia(e, t, e => {
            s && s(n(e));
          });
        });
      }.bind(i)),
      i.mediaDevices.getUserMedia)
    ) {
      const e = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
      i.mediaDevices.getUserMedia = function(t) {
        return r(t, t =>
          e(t).then(
            e => {
              if (
                (t.audio && !e.getAudioTracks().length) ||
                (t.video && !e.getVideoTracks().length)
              )
                throw (e.getTracks().forEach(e => {
                  e.stop();
                }),
                new DOMException("", "NotFoundError"));
              return e;
            },
            e => Promise.reject(n(e))
          )
        );
      };
    }
  }
  function BU(e) {
    e.MediaStream = e.MediaStream || e.webkitMediaStream;
  }
  function VU(e) {
    if (
      "object" == typeof e &&
      e.RTCPeerConnection &&
      !("ontrack" in e.RTCPeerConnection.prototype)
    ) {
      Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
        get() {
          return this._ontrack;
        },
        set(e) {
          this._ontrack && this.removeEventListener("track", this._ontrack),
            this.addEventListener("track", (this._ontrack = e));
        },
        enumerable: !0,
        configurable: !0
      });
      const t = e.RTCPeerConnection.prototype.setRemoteDescription;
      e.RTCPeerConnection.prototype.setRemoteDescription = function() {
        return (
          this._ontrackpoly ||
            ((this._ontrackpoly = t => {
              t.stream.addEventListener("addtrack", i => {
                let s;
                s = e.RTCPeerConnection.prototype.getReceivers
                  ? this.getReceivers().find(
                      e => e.track && e.track.id === i.track.id
                    )
                  : { track: i.track };
                const r = new Event("track");
                (r.track = i.track),
                  (r.receiver = s),
                  (r.transceiver = { receiver: s }),
                  (r.streams = [t.stream]),
                  this.dispatchEvent(r);
              }),
                t.stream.getTracks().forEach(i => {
                  let s;
                  s = e.RTCPeerConnection.prototype.getReceivers
                    ? this.getReceivers().find(
                        e => e.track && e.track.id === i.id
                      )
                    : { track: i };
                  const r = new Event("track");
                  (r.track = i),
                    (r.receiver = s),
                    (r.transceiver = { receiver: s }),
                    (r.streams = [t.stream]),
                    this.dispatchEvent(r);
                });
            }),
            this.addEventListener("addstream", this._ontrackpoly)),
          t.apply(this, arguments)
        );
      };
    } else OU(e, "track", e => (e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e));
  }
  function GU(e) {
    if (
      "object" == typeof e &&
      e.RTCPeerConnection &&
      !("getSenders" in e.RTCPeerConnection.prototype) &&
      "createDTMFSender" in e.RTCPeerConnection.prototype
    ) {
      const t = function(e, t) {
        return {
          track: t,
          get dtmf() {
            return (
              void 0 === this._dtmf &&
                ("audio" === t.kind
                  ? (this._dtmf = e.createDTMFSender(t))
                  : (this._dtmf = null)),
              this._dtmf
            );
          },
          _pc: e
        };
      };
      if (!e.RTCPeerConnection.prototype.getSenders) {
        e.RTCPeerConnection.prototype.getSenders = function() {
          return (this._senders = this._senders || []), this._senders.slice();
        };
        const i = e.RTCPeerConnection.prototype.addTrack;
        e.RTCPeerConnection.prototype.addTrack = function(e, s) {
          let r = i.apply(this, arguments);
          return r || ((r = t(this, e)), this._senders.push(r)), r;
        };
        const s = e.RTCPeerConnection.prototype.removeTrack;
        e.RTCPeerConnection.prototype.removeTrack = function(e) {
          s.apply(this, arguments);
          const t = this._senders.indexOf(e);
          -1 !== t && this._senders.splice(t, 1);
        };
      }
      const i = e.RTCPeerConnection.prototype.addStream;
      e.RTCPeerConnection.prototype.addStream = function(e) {
        (this._senders = this._senders || []),
          i.apply(this, [e]),
          e.getTracks().forEach(e => {
            this._senders.push(t(this, e));
          });
      };
      const s = e.RTCPeerConnection.prototype.removeStream;
      e.RTCPeerConnection.prototype.removeStream = function(e) {
        (this._senders = this._senders || []),
          s.apply(this, [e]),
          e.getTracks().forEach(e => {
            const t = this._senders.find(t => t.track === e);
            t && this._senders.splice(this._senders.indexOf(t), 1);
          });
      };
    } else if (
      "object" == typeof e &&
      e.RTCPeerConnection &&
      "getSenders" in e.RTCPeerConnection.prototype &&
      "createDTMFSender" in e.RTCPeerConnection.prototype &&
      e.RTCRtpSender &&
      !("dtmf" in e.RTCRtpSender.prototype)
    ) {
      const t = e.RTCPeerConnection.prototype.getSenders;
      (e.RTCPeerConnection.prototype.getSenders = function() {
        const e = t.apply(this, []);
        return e.forEach(e => (e._pc = this)), e;
      }),
        Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
          get() {
            return (
              void 0 === this._dtmf &&
                ("audio" === this.track.kind
                  ? (this._dtmf = this._pc.createDTMFSender(this.track))
                  : (this._dtmf = null)),
              this._dtmf
            );
          }
        });
    }
  }
  function jU(e) {
    if (!e.RTCPeerConnection) return;
    const t = e.RTCPeerConnection.prototype.getStats;
    e.RTCPeerConnection.prototype.getStats = function() {
      const [e, i, s] = arguments;
      if (arguments.length > 0 && "function" == typeof e)
        return t.apply(this, arguments);
      if (0 === t.length && (0 === arguments.length || "function" != typeof e))
        return t.apply(this, []);
      const r = function(e) {
          const t = {};
          return (
            e.result().forEach(e => {
              const i = {
                id: e.id,
                timestamp: e.timestamp,
                type:
                  {
                    localcandidate: "local-candidate",
                    remotecandidate: "remote-candidate"
                  }[e.type] || e.type
              };
              e.names().forEach(t => {
                i[t] = e.stat(t);
              }),
                (t[i.id] = i);
            }),
            t
          );
        },
        n = function(e) {
          return new Map(Object.keys(e).map(t => [t, e[t]]));
        };
      if (arguments.length >= 2) {
        const s = function(e) {
          i(n(r(e)));
        };
        return t.apply(this, [s, e]);
      }
      return new Promise((e, i) => {
        t.apply(this, [
          function(t) {
            e(n(r(t)));
          },
          i
        ]);
      }).then(i, s);
    };
  }
  function HU(e) {
    if (
      !(
        "object" == typeof e &&
        e.RTCPeerConnection &&
        e.RTCRtpSender &&
        e.RTCRtpReceiver
      )
    )
      return;
    if (!("getStats" in e.RTCRtpSender.prototype)) {
      const t = e.RTCPeerConnection.prototype.getSenders;
      t &&
        (e.RTCPeerConnection.prototype.getSenders = function() {
          const e = t.apply(this, []);
          return e.forEach(e => (e._pc = this)), e;
        });
      const i = e.RTCPeerConnection.prototype.addTrack;
      i &&
        (e.RTCPeerConnection.prototype.addTrack = function() {
          const e = i.apply(this, arguments);
          return (e._pc = this), e;
        }),
        (e.RTCRtpSender.prototype.getStats = function() {
          const e = this;
          return this._pc.getStats().then(t => UU(t, e.track, !0));
        });
    }
    if (!("getStats" in e.RTCRtpReceiver.prototype)) {
      const t = e.RTCPeerConnection.prototype.getReceivers;
      t &&
        (e.RTCPeerConnection.prototype.getReceivers = function() {
          const e = t.apply(this, []);
          return e.forEach(e => (e._pc = this)), e;
        }),
        OU(e, "track", e => ((e.receiver._pc = e.srcElement), e)),
        (e.RTCRtpReceiver.prototype.getStats = function() {
          const e = this;
          return this._pc.getStats().then(t => UU(t, e.track, !1));
        });
    }
    if (
      !("getStats" in e.RTCRtpSender.prototype) ||
      !("getStats" in e.RTCRtpReceiver.prototype)
    )
      return;
    const t = e.RTCPeerConnection.prototype.getStats;
    e.RTCPeerConnection.prototype.getStats = function() {
      if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
        const e = arguments[0];
        let t, i, s;
        return (
          this.getSenders().forEach(i => {
            i.track === e && (t ? (s = !0) : (t = i));
          }),
          this.getReceivers().forEach(
            t => (t.track === e && (i ? (s = !0) : (i = t)), t.track === e)
          ),
          s || (t && i)
            ? Promise.reject(
                new DOMException(
                  "There are more than one sender or receiver for the track.",
                  "InvalidAccessError"
                )
              )
            : t
            ? t.getStats()
            : i
            ? i.getStats()
            : Promise.reject(
                new DOMException(
                  "There is no sender or receiver for the track.",
                  "InvalidAccessError"
                )
              )
        );
      }
      return t.apply(this, arguments);
    };
  }
  function KU(e) {
    e.RTCPeerConnection.prototype.getLocalStreams = function() {
      return (
        (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        Object.keys(this._shimmedLocalStreams).map(
          e => this._shimmedLocalStreams[e][0]
        )
      );
    };
    const t = e.RTCPeerConnection.prototype.addTrack;
    e.RTCPeerConnection.prototype.addTrack = function(e, i) {
      if (!i) return t.apply(this, arguments);
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      const s = t.apply(this, arguments);
      return (
        this._shimmedLocalStreams[i.id]
          ? -1 === this._shimmedLocalStreams[i.id].indexOf(s) &&
            this._shimmedLocalStreams[i.id].push(s)
          : (this._shimmedLocalStreams[i.id] = [i, s]),
        s
      );
    };
    const i = e.RTCPeerConnection.prototype.addStream;
    e.RTCPeerConnection.prototype.addStream = function(e) {
      (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        e.getTracks().forEach(e => {
          const t = this.getSenders().find(t => t.track === e);
          if (t)
            throw new DOMException(
              "Track already exists.",
              "InvalidAccessError"
            );
        });
      const t = this.getSenders();
      i.apply(this, arguments);
      const s = this.getSenders().filter(e => -1 === t.indexOf(e));
      this._shimmedLocalStreams[e.id] = [e].concat(s);
    };
    const s = e.RTCPeerConnection.prototype.removeStream;
    e.RTCPeerConnection.prototype.removeStream = function(e) {
      return (
        (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        delete this._shimmedLocalStreams[e.id],
        s.apply(this, arguments)
      );
    };
    const r = e.RTCPeerConnection.prototype.removeTrack;
    e.RTCPeerConnection.prototype.removeTrack = function(e) {
      return (
        (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        e &&
          Object.keys(this._shimmedLocalStreams).forEach(t => {
            const i = this._shimmedLocalStreams[t].indexOf(e);
            -1 !== i && this._shimmedLocalStreams[t].splice(i, 1),
              1 === this._shimmedLocalStreams[t].length &&
                delete this._shimmedLocalStreams[t];
          }),
        r.apply(this, arguments)
      );
    };
  }
  function WU(e, t) {
    if (!e.RTCPeerConnection) return;
    if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return KU(e);
    const i = e.RTCPeerConnection.prototype.getLocalStreams;
    e.RTCPeerConnection.prototype.getLocalStreams = function() {
      const e = i.apply(this);
      return (
        (this._reverseStreams = this._reverseStreams || {}),
        e.map(e => this._reverseStreams[e.id])
      );
    };
    const s = e.RTCPeerConnection.prototype.addStream;
    e.RTCPeerConnection.prototype.addStream = function(t) {
      if (
        ((this._streams = this._streams || {}),
        (this._reverseStreams = this._reverseStreams || {}),
        t.getTracks().forEach(e => {
          const t = this.getSenders().find(t => t.track === e);
          if (t)
            throw new DOMException(
              "Track already exists.",
              "InvalidAccessError"
            );
        }),
        !this._reverseStreams[t.id])
      ) {
        const i = new e.MediaStream(t.getTracks());
        (this._streams[t.id] = i), (this._reverseStreams[i.id] = t), (t = i);
      }
      s.apply(this, [t]);
    };
    const r = e.RTCPeerConnection.prototype.removeStream;
    function n(e, t) {
      let i = t.sdp;
      return (
        Object.keys(e._reverseStreams || []).forEach(t => {
          const s = e._reverseStreams[t],
            r = e._streams[s.id];
          i = i.replace(new RegExp(r.id, "g"), s.id);
        }),
        new RTCSessionDescription({ type: t.type, sdp: i })
      );
    }
    (e.RTCPeerConnection.prototype.removeStream = function(e) {
      (this._streams = this._streams || {}),
        (this._reverseStreams = this._reverseStreams || {}),
        r.apply(this, [this._streams[e.id] || e]),
        delete this._reverseStreams[
          this._streams[e.id] ? this._streams[e.id].id : e.id
        ],
        delete this._streams[e.id];
    }),
      (e.RTCPeerConnection.prototype.addTrack = function(t, i) {
        if ("closed" === this.signalingState)
          throw new DOMException(
            "The RTCPeerConnection's signalingState is 'closed'.",
            "InvalidStateError"
          );
        const s = [].slice.call(arguments, 1);
        if (1 !== s.length || !s[0].getTracks().find(e => e === t))
          throw new DOMException(
            "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
            "NotSupportedError"
          );
        const r = this.getSenders().find(e => e.track === t);
        if (r)
          throw new DOMException("Track already exists.", "InvalidAccessError");
        (this._streams = this._streams || {}),
          (this._reverseStreams = this._reverseStreams || {});
        const n = this._streams[i.id];
        if (n)
          n.addTrack(t),
            Promise.resolve().then(() => {
              this.dispatchEvent(new Event("negotiationneeded"));
            });
        else {
          const s = new e.MediaStream([t]);
          (this._streams[i.id] = s),
            (this._reverseStreams[s.id] = i),
            this.addStream(s);
        }
        return this.getSenders().find(e => e.track === t);
      }),
      ["createOffer", "createAnswer"].forEach(function(t) {
        const i = e.RTCPeerConnection.prototype[t],
          s = {
            [t]() {
              const e = arguments;
              return arguments.length && "function" == typeof arguments[0]
                ? i.apply(this, [
                    t => {
                      const i = n(this, t);
                      e[0].apply(null, [i]);
                    },
                    t => {
                      e[1] && e[1].apply(null, t);
                    },
                    arguments[2]
                  ])
                : i.apply(this, arguments).then(e => n(this, e));
            }
          };
        e.RTCPeerConnection.prototype[t] = s[t];
      });
    const a = e.RTCPeerConnection.prototype.setLocalDescription;
    e.RTCPeerConnection.prototype.setLocalDescription = function() {
      return arguments.length && arguments[0].type
        ? ((arguments[0] = (function(e, t) {
            let i = t.sdp;
            return (
              Object.keys(e._reverseStreams || []).forEach(t => {
                const s = e._reverseStreams[t],
                  r = e._streams[s.id];
                i = i.replace(new RegExp(s.id, "g"), r.id);
              }),
              new RTCSessionDescription({ type: t.type, sdp: i })
            );
          })(this, arguments[0])),
          a.apply(this, arguments))
        : a.apply(this, arguments);
    };
    const o = Object.getOwnPropertyDescriptor(
      e.RTCPeerConnection.prototype,
      "localDescription"
    );
    Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
      get() {
        const e = o.get.apply(this);
        return "" === e.type ? e : n(this, e);
      }
    }),
      (e.RTCPeerConnection.prototype.removeTrack = function(e) {
        if ("closed" === this.signalingState)
          throw new DOMException(
            "The RTCPeerConnection's signalingState is 'closed'.",
            "InvalidStateError"
          );
        if (!e._pc)
          throw new DOMException(
            "Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.",
            "TypeError"
          );
        if (!(e._pc === this))
          throw new DOMException(
            "Sender was not created by this connection.",
            "InvalidAccessError"
          );
        let t;
        (this._streams = this._streams || {}),
          Object.keys(this._streams).forEach(i => {
            this._streams[i].getTracks().find(t => e.track === t) &&
              (t = this._streams[i]);
          }),
          t &&
            (1 === t.getTracks().length
              ? this.removeStream(this._reverseStreams[t.id])
              : t.removeTrack(e.track),
            this.dispatchEvent(new Event("negotiationneeded")));
      });
  }
  function YU(e, t) {
    !e.RTCPeerConnection &&
      e.webkitRTCPeerConnection &&
      (e.RTCPeerConnection = e.webkitRTCPeerConnection),
      e.RTCPeerConnection &&
        t.version < 53 &&
        [
          "setLocalDescription",
          "setRemoteDescription",
          "addIceCandidate"
        ].forEach(function(t) {
          const i = e.RTCPeerConnection.prototype[t],
            s = {
              [t]() {
                return (
                  (arguments[0] = new ("addIceCandidate" === t
                    ? e.RTCIceCandidate
                    : e.RTCSessionDescription)(arguments[0])),
                  i.apply(this, arguments)
                );
              }
            };
          e.RTCPeerConnection.prototype[t] = s[t];
        });
  }
  function $U(e, t) {
    OU(e, "negotiationneeded", e => {
      const i = e.target;
      if (
        !(
          t.version < 72 ||
          (i.getConfiguration && "plan-b" === i.getConfiguration().sdpSemantics)
        ) ||
        "stable" === i.signalingState
      )
        return e;
    });
  }
  var qU = Object.freeze({
    __proto__: null,
    fixNegotiationNeeded: $U,
    shimAddTrackRemoveTrack: WU,
    shimAddTrackRemoveTrackWithNative: KU,
    shimGetDisplayMedia: function(e, t) {
      (e.navigator.mediaDevices &&
        "getDisplayMedia" in e.navigator.mediaDevices) ||
        (e.navigator.mediaDevices &&
          ("function" == typeof t
            ? (e.navigator.mediaDevices.getDisplayMedia = function(i) {
                return t(i).then(t => {
                  const s = i.video && i.video.width,
                    r = i.video && i.video.height,
                    n = i.video && i.video.frameRate;
                  return (
                    (i.video = {
                      mandatory: {
                        chromeMediaSource: "desktop",
                        chromeMediaSourceId: t,
                        maxFrameRate: n || 3
                      }
                    }),
                    s && (i.video.mandatory.maxWidth = s),
                    r && (i.video.mandatory.maxHeight = r),
                    e.navigator.mediaDevices.getUserMedia(i)
                  );
                });
              })
            : console.error(
                "shimGetDisplayMedia: getSourceId argument is not a function"
              )));
    },
    shimGetSendersWithDtmf: GU,
    shimGetStats: jU,
    shimGetUserMedia: FU,
    shimMediaStream: BU,
    shimOnTrack: VU,
    shimPeerConnection: YU,
    shimSenderReceiverGetStats: HU
  });
  function XU(e, t) {
    const i = e && e.navigator,
      s = e && e.MediaStreamTrack;
    if (
      ((i.getUserMedia = function(e, t, s) {
        NU("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"),
          i.mediaDevices.getUserMedia(e).then(t, s);
      }),
      !(
        t.version > 55 &&
        "autoGainControl" in i.mediaDevices.getSupportedConstraints()
      ))
    ) {
      const e = function(e, t, i) {
          t in e && !(i in e) && ((e[i] = e[t]), delete e[t]);
        },
        t = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
      if (
        ((i.mediaDevices.getUserMedia = function(i) {
          return (
            "object" == typeof i &&
              "object" == typeof i.audio &&
              ((i = JSON.parse(JSON.stringify(i))),
              e(i.audio, "autoGainControl", "mozAutoGainControl"),
              e(i.audio, "noiseSuppression", "mozNoiseSuppression")),
            t(i)
          );
        }),
        s && s.prototype.getSettings)
      ) {
        const t = s.prototype.getSettings;
        s.prototype.getSettings = function() {
          const i = t.apply(this, arguments);
          return (
            e(i, "mozAutoGainControl", "autoGainControl"),
            e(i, "mozNoiseSuppression", "noiseSuppression"),
            i
          );
        };
      }
      if (s && s.prototype.applyConstraints) {
        const t = s.prototype.applyConstraints;
        s.prototype.applyConstraints = function(i) {
          return (
            "audio" === this.kind &&
              "object" == typeof i &&
              ((i = JSON.parse(JSON.stringify(i))),
              e(i, "autoGainControl", "mozAutoGainControl"),
              e(i, "noiseSuppression", "mozNoiseSuppression")),
            t.apply(this, [i])
          );
        };
      }
    }
  }
  function zU(e) {
    "object" == typeof e &&
      e.RTCTrackEvent &&
      "receiver" in e.RTCTrackEvent.prototype &&
      !("transceiver" in e.RTCTrackEvent.prototype) &&
      Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return { receiver: this.receiver };
        }
      });
  }
  function JU(e, t) {
    if (
      "object" != typeof e ||
      (!e.RTCPeerConnection && !e.mozRTCPeerConnection)
    )
      return;
    !e.RTCPeerConnection &&
      e.mozRTCPeerConnection &&
      (e.RTCPeerConnection = e.mozRTCPeerConnection),
      t.version < 53 &&
        [
          "setLocalDescription",
          "setRemoteDescription",
          "addIceCandidate"
        ].forEach(function(t) {
          const i = e.RTCPeerConnection.prototype[t],
            s = {
              [t]() {
                return (
                  (arguments[0] = new ("addIceCandidate" === t
                    ? e.RTCIceCandidate
                    : e.RTCSessionDescription)(arguments[0])),
                  i.apply(this, arguments)
                );
              }
            };
          e.RTCPeerConnection.prototype[t] = s[t];
        });
    const i = {
        inboundrtp: "inbound-rtp",
        outboundrtp: "outbound-rtp",
        candidatepair: "candidate-pair",
        localcandidate: "local-candidate",
        remotecandidate: "remote-candidate"
      },
      s = e.RTCPeerConnection.prototype.getStats;
    e.RTCPeerConnection.prototype.getStats = function() {
      const [e, r, n] = arguments;
      return s
        .apply(this, [e || null])
        .then(e => {
          if (t.version < 53 && !r)
            try {
              e.forEach(e => {
                e.type = i[e.type] || e.type;
              });
            } catch (t) {
              if ("TypeError" !== t.name) throw t;
              e.forEach((t, s) => {
                e.set(s, Object.assign({}, t, { type: i[t.type] || t.type }));
              });
            }
          return e;
        })
        .then(r, n);
    };
  }
  function QU(e) {
    if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
    if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
    const t = e.RTCPeerConnection.prototype.getSenders;
    t &&
      (e.RTCPeerConnection.prototype.getSenders = function() {
        const e = t.apply(this, []);
        return e.forEach(e => (e._pc = this)), e;
      });
    const i = e.RTCPeerConnection.prototype.addTrack;
    i &&
      (e.RTCPeerConnection.prototype.addTrack = function() {
        const e = i.apply(this, arguments);
        return (e._pc = this), e;
      }),
      (e.RTCRtpSender.prototype.getStats = function() {
        return this.track
          ? this._pc.getStats(this.track)
          : Promise.resolve(new Map());
      });
  }
  function ZU(e) {
    if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
    if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
    const t = e.RTCPeerConnection.prototype.getReceivers;
    t &&
      (e.RTCPeerConnection.prototype.getReceivers = function() {
        const e = t.apply(this, []);
        return e.forEach(e => (e._pc = this)), e;
      }),
      OU(e, "track", e => ((e.receiver._pc = e.srcElement), e)),
      (e.RTCRtpReceiver.prototype.getStats = function() {
        return this._pc.getStats(this.track);
      });
  }
  function ex(e) {
    e.RTCPeerConnection &&
      !("removeStream" in e.RTCPeerConnection.prototype) &&
      (e.RTCPeerConnection.prototype.removeStream = function(e) {
        NU("removeStream", "removeTrack"),
          this.getSenders().forEach(t => {
            t.track && e.getTracks().includes(t.track) && this.removeTrack(t);
          });
      });
  }
  function tx(e) {
    e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel);
  }
  function ix(e) {
    if ("object" != typeof e || !e.RTCPeerConnection) return;
    const t = e.RTCPeerConnection.prototype.addTransceiver;
    t &&
      (e.RTCPeerConnection.prototype.addTransceiver = function() {
        this.setParametersPromises = [];
        let e = arguments[1] && arguments[1].sendEncodings;
        void 0 === e && (e = []), (e = [...e]);
        const i = e.length > 0;
        i &&
          e.forEach(e => {
            if ("rid" in e) {
              if (!/^[a-z0-9]{0,16}$/i.test(e.rid))
                throw new TypeError("Invalid RID value provided.");
            }
            if (
              "scaleResolutionDownBy" in e &&
              !(parseFloat(e.scaleResolutionDownBy) >= 1)
            )
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0))
              throw new RangeError("max_framerate must be >= 0.0");
          });
        const s = t.apply(this, arguments);
        if (i) {
          const { sender: t } = s,
            i = t.getParameters();
          (!("encodings" in i) ||
            (1 === i.encodings.length &&
              0 === Object.keys(i.encodings[0]).length)) &&
            ((i.encodings = e),
            (t.sendEncodings = e),
            this.setParametersPromises.push(
              t
                .setParameters(i)
                .then(() => {
                  delete t.sendEncodings;
                })
                .catch(() => {
                  delete t.sendEncodings;
                })
            ));
        }
        return s;
      });
  }
  function sx(e) {
    if ("object" != typeof e || !e.RTCRtpSender) return;
    const t = e.RTCRtpSender.prototype.getParameters;
    t &&
      (e.RTCRtpSender.prototype.getParameters = function() {
        const e = t.apply(this, arguments);
        return (
          "encodings" in e ||
            (e.encodings = [].concat(this.sendEncodings || [{}])),
          e
        );
      });
  }
  function rx(e) {
    if ("object" != typeof e || !e.RTCPeerConnection) return;
    const t = e.RTCPeerConnection.prototype.createOffer;
    e.RTCPeerConnection.prototype.createOffer = function() {
      return this.setParametersPromises && this.setParametersPromises.length
        ? Promise.all(this.setParametersPromises)
            .then(() => t.apply(this, arguments))
            .finally(() => {
              this.setParametersPromises = [];
            })
        : t.apply(this, arguments);
    };
  }
  function nx(e) {
    if ("object" != typeof e || !e.RTCPeerConnection) return;
    const t = e.RTCPeerConnection.prototype.createAnswer;
    e.RTCPeerConnection.prototype.createAnswer = function() {
      return this.setParametersPromises && this.setParametersPromises.length
        ? Promise.all(this.setParametersPromises)
            .then(() => t.apply(this, arguments))
            .finally(() => {
              this.setParametersPromises = [];
            })
        : t.apply(this, arguments);
    };
  }
  var ax = Object.freeze({
    __proto__: null,
    shimAddTransceiver: ix,
    shimCreateAnswer: nx,
    shimCreateOffer: rx,
    shimGetDisplayMedia: function(e, t) {
      (e.navigator.mediaDevices &&
        "getDisplayMedia" in e.navigator.mediaDevices) ||
        (e.navigator.mediaDevices &&
          (e.navigator.mediaDevices.getDisplayMedia = function(i) {
            if (!i || !i.video) {
              const e = new DOMException(
                "getDisplayMedia without video constraints is undefined"
              );
              return (
                (e.name = "NotFoundError"), (e.code = 8), Promise.reject(e)
              );
            }
            return (
              !0 === i.video
                ? (i.video = { mediaSource: t })
                : (i.video.mediaSource = t),
              e.navigator.mediaDevices.getUserMedia(i)
            );
          }));
    },
    shimGetParameters: sx,
    shimGetUserMedia: XU,
    shimOnTrack: zU,
    shimPeerConnection: JU,
    shimRTCDataChannel: tx,
    shimReceiverGetStats: ZU,
    shimRemoveStream: ex,
    shimSenderGetStats: QU
  });
  function ox(e) {
    if ("object" == typeof e && e.RTCPeerConnection) {
      if (
        ("getLocalStreams" in e.RTCPeerConnection.prototype ||
          (e.RTCPeerConnection.prototype.getLocalStreams = function() {
            return (
              this._localStreams || (this._localStreams = []),
              this._localStreams
            );
          }),
        !("addStream" in e.RTCPeerConnection.prototype))
      ) {
        const t = e.RTCPeerConnection.prototype.addTrack;
        (e.RTCPeerConnection.prototype.addStream = function(e) {
          this._localStreams || (this._localStreams = []),
            this._localStreams.includes(e) || this._localStreams.push(e),
            e.getAudioTracks().forEach(i => t.call(this, i, e)),
            e.getVideoTracks().forEach(i => t.call(this, i, e));
        }),
          (e.RTCPeerConnection.prototype.addTrack = function(e, ...i) {
            return (
              i &&
                i.forEach(e => {
                  this._localStreams
                    ? this._localStreams.includes(e) ||
                      this._localStreams.push(e)
                    : (this._localStreams = [e]);
                }),
              t.apply(this, arguments)
            );
          });
      }
      "removeStream" in e.RTCPeerConnection.prototype ||
        (e.RTCPeerConnection.prototype.removeStream = function(e) {
          this._localStreams || (this._localStreams = []);
          const t = this._localStreams.indexOf(e);
          if (-1 === t) return;
          this._localStreams.splice(t, 1);
          const i = e.getTracks();
          this.getSenders().forEach(e => {
            i.includes(e.track) && this.removeTrack(e);
          });
        });
    }
  }
  function cx(e) {
    if (
      "object" == typeof e &&
      e.RTCPeerConnection &&
      ("getRemoteStreams" in e.RTCPeerConnection.prototype ||
        (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }),
      !("onaddstream" in e.RTCPeerConnection.prototype))
    ) {
      Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
        get() {
          return this._onaddstream;
        },
        set(e) {
          this._onaddstream &&
            (this.removeEventListener("addstream", this._onaddstream),
            this.removeEventListener("track", this._onaddstreampoly)),
            this.addEventListener("addstream", (this._onaddstream = e)),
            this.addEventListener(
              "track",
              (this._onaddstreampoly = e => {
                e.streams.forEach(e => {
                  if (
                    (this._remoteStreams || (this._remoteStreams = []),
                    this._remoteStreams.includes(e))
                  )
                    return;
                  this._remoteStreams.push(e);
                  const t = new Event("addstream");
                  (t.stream = e), this.dispatchEvent(t);
                });
              })
            );
        }
      });
      const t = e.RTCPeerConnection.prototype.setRemoteDescription;
      e.RTCPeerConnection.prototype.setRemoteDescription = function() {
        const e = this;
        return (
          this._onaddstreampoly ||
            this.addEventListener(
              "track",
              (this._onaddstreampoly = function(t) {
                t.streams.forEach(t => {
                  if (
                    (e._remoteStreams || (e._remoteStreams = []),
                    e._remoteStreams.indexOf(t) >= 0)
                  )
                    return;
                  e._remoteStreams.push(t);
                  const i = new Event("addstream");
                  (i.stream = t), e.dispatchEvent(i);
                });
              })
            ),
          t.apply(e, arguments)
        );
      };
    }
  }
  function dx(e) {
    if ("object" != typeof e || !e.RTCPeerConnection) return;
    const t = e.RTCPeerConnection.prototype,
      i = t.createOffer,
      s = t.createAnswer,
      r = t.setLocalDescription,
      n = t.setRemoteDescription,
      a = t.addIceCandidate;
    (t.createOffer = function(e, t) {
      const s = arguments.length >= 2 ? arguments[2] : arguments[0],
        r = i.apply(this, [s]);
      return t ? (r.then(e, t), Promise.resolve()) : r;
    }),
      (t.createAnswer = function(e, t) {
        const i = arguments.length >= 2 ? arguments[2] : arguments[0],
          r = s.apply(this, [i]);
        return t ? (r.then(e, t), Promise.resolve()) : r;
      });
    let o = function(e, t, i) {
      const s = r.apply(this, [e]);
      return i ? (s.then(t, i), Promise.resolve()) : s;
    };
    (t.setLocalDescription = o),
      (o = function(e, t, i) {
        const s = n.apply(this, [e]);
        return i ? (s.then(t, i), Promise.resolve()) : s;
      }),
      (t.setRemoteDescription = o),
      (o = function(e, t, i) {
        const s = a.apply(this, [e]);
        return i ? (s.then(t, i), Promise.resolve()) : s;
      }),
      (t.addIceCandidate = o);
  }
  function lx(e) {
    const t = e && e.navigator;
    if (t.mediaDevices && t.mediaDevices.getUserMedia) {
      const e = t.mediaDevices,
        i = e.getUserMedia.bind(e);
      t.mediaDevices.getUserMedia = e => i(hx(e));
    }
    !t.getUserMedia &&
      t.mediaDevices &&
      t.mediaDevices.getUserMedia &&
      (t.getUserMedia = function(e, i, s) {
        t.mediaDevices.getUserMedia(e).then(i, s);
      }.bind(t));
  }
  function hx(e) {
    return e && void 0 !== e.video
      ? Object.assign({}, e, { video: kU(e.video) })
      : e;
  }
  function ux(e) {
    if (!e.RTCPeerConnection) return;
    const t = e.RTCPeerConnection;
    (e.RTCPeerConnection = function(e, i) {
      if (e && e.iceServers) {
        const t = [];
        for (let i = 0; i < e.iceServers.length; i++) {
          let s = e.iceServers[i];
          !s.hasOwnProperty("urls") && s.hasOwnProperty("url")
            ? (NU("RTCIceServer.url", "RTCIceServer.urls"),
              (s = JSON.parse(JSON.stringify(s))),
              (s.urls = s.url),
              delete s.url,
              t.push(s))
            : t.push(e.iceServers[i]);
        }
        e.iceServers = t;
      }
      return new t(e, i);
    }),
      (e.RTCPeerConnection.prototype = t.prototype),
      "generateCertificate" in t &&
        Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
          get: () => t.generateCertificate
        });
  }
  function px(e) {
    "object" == typeof e &&
      e.RTCTrackEvent &&
      "receiver" in e.RTCTrackEvent.prototype &&
      !("transceiver" in e.RTCTrackEvent.prototype) &&
      Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return { receiver: this.receiver };
        }
      });
  }
  function fx(e) {
    const t = e.RTCPeerConnection.prototype.createOffer;
    e.RTCPeerConnection.prototype.createOffer = function(e) {
      if (e) {
        void 0 !== e.offerToReceiveAudio &&
          (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
        const t = this.getTransceivers().find(
          e => "audio" === e.receiver.track.kind
        );
        !1 === e.offerToReceiveAudio && t
          ? "sendrecv" === t.direction
            ? t.setDirection
              ? t.setDirection("sendonly")
              : (t.direction = "sendonly")
            : "recvonly" === t.direction &&
              (t.setDirection
                ? t.setDirection("inactive")
                : (t.direction = "inactive"))
          : !0 !== e.offerToReceiveAudio ||
            t ||
            this.addTransceiver("audio", { direction: "recvonly" }),
          void 0 !== e.offerToReceiveVideo &&
            (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
        const i = this.getTransceivers().find(
          e => "video" === e.receiver.track.kind
        );
        !1 === e.offerToReceiveVideo && i
          ? "sendrecv" === i.direction
            ? i.setDirection
              ? i.setDirection("sendonly")
              : (i.direction = "sendonly")
            : "recvonly" === i.direction &&
              (i.setDirection
                ? i.setDirection("inactive")
                : (i.direction = "inactive"))
          : !0 !== e.offerToReceiveVideo ||
            i ||
            this.addTransceiver("video", { direction: "recvonly" });
      }
      return t.apply(this, arguments);
    };
  }
  function Ex(e) {
    "object" != typeof e ||
      e.AudioContext ||
      (e.AudioContext = e.webkitAudioContext);
  }
  var mx = Object.freeze({
      __proto__: null,
      shimAudioContext: Ex,
      shimCallbacksAPI: dx,
      shimConstraints: hx,
      shimCreateOfferLegacy: fx,
      shimGetUserMedia: lx,
      shimLocalStreamsAPI: ox,
      shimRTCIceServerUrls: ux,
      shimRemoteStreamsAPI: cx,
      shimTrackEventTransceiver: px
    }),
    gx = { exports: {} };
  !(function(e) {
    const t = {
      generateIdentifier: function() {
        return Math.random()
          .toString(36)
          .substring(2, 12);
      }
    };
    (t.localCName = t.generateIdentifier()),
      (t.splitLines = function(e) {
        return e
          .trim()
          .split("\n")
          .map(e => e.trim());
      }),
      (t.splitSections = function(e) {
        return e
          .split("\nm=")
          .map((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n");
      }),
      (t.getDescription = function(e) {
        const i = t.splitSections(e);
        return i && i[0];
      }),
      (t.getMediaSections = function(e) {
        const i = t.splitSections(e);
        return i.shift(), i;
      }),
      (t.matchPrefix = function(e, i) {
        return t.splitLines(e).filter(e => 0 === e.indexOf(i));
      }),
      (t.parseCandidate = function(e) {
        let t;
        t =
          0 === e.indexOf("a=candidate:")
            ? e.substring(12).split(" ")
            : e.substring(10).split(" ");
        const i = {
          foundation: t[0],
          component: { 1: "rtp", 2: "rtcp" }[t[1]] || t[1],
          protocol: t[2].toLowerCase(),
          priority: parseInt(t[3], 10),
          ip: t[4],
          address: t[4],
          port: parseInt(t[5], 10),
          type: t[7]
        };
        for (let e = 8; e < t.length; e += 2)
          switch (t[e]) {
            case "raddr":
              i.relatedAddress = t[e + 1];
              break;
            case "rport":
              i.relatedPort = parseInt(t[e + 1], 10);
              break;
            case "tcptype":
              i.tcpType = t[e + 1];
              break;
            case "ufrag":
              (i.ufrag = t[e + 1]), (i.usernameFragment = t[e + 1]);
              break;
            default:
              void 0 === i[t[e]] && (i[t[e]] = t[e + 1]);
          }
        return i;
      }),
      (t.writeCandidate = function(e) {
        const t = [];
        t.push(e.foundation);
        const i = e.component;
        "rtp" === i ? t.push(1) : "rtcp" === i ? t.push(2) : t.push(i),
          t.push(e.protocol.toUpperCase()),
          t.push(e.priority),
          t.push(e.address || e.ip),
          t.push(e.port);
        const s = e.type;
        return (
          t.push("typ"),
          t.push(s),
          "host" !== s &&
            e.relatedAddress &&
            e.relatedPort &&
            (t.push("raddr"),
            t.push(e.relatedAddress),
            t.push("rport"),
            t.push(e.relatedPort)),
          e.tcpType &&
            "tcp" === e.protocol.toLowerCase() &&
            (t.push("tcptype"), t.push(e.tcpType)),
          (e.usernameFragment || e.ufrag) &&
            (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)),
          "candidate:" + t.join(" ")
        );
      }),
      (t.parseIceOptions = function(e) {
        return e.substring(14).split(" ");
      }),
      (t.parseRtpMap = function(e) {
        let t = e.substring(9).split(" ");
        const i = { payloadType: parseInt(t.shift(), 10) };
        return (
          (t = t[0].split("/")),
          (i.name = t[0]),
          (i.clockRate = parseInt(t[1], 10)),
          (i.channels = 3 === t.length ? parseInt(t[2], 10) : 1),
          (i.numChannels = i.channels),
          i
        );
      }),
      (t.writeRtpMap = function(e) {
        let t = e.payloadType;
        void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
        const i = e.channels || e.numChannels || 1;
        return (
          "a=rtpmap:" +
          t +
          " " +
          e.name +
          "/" +
          e.clockRate +
          (1 !== i ? "/" + i : "") +
          "\r\n"
        );
      }),
      (t.parseExtmap = function(e) {
        const t = e.substring(9).split(" ");
        return {
          id: parseInt(t[0], 10),
          direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
          uri: t[1],
          attributes: t.slice(2).join(" ")
        };
      }),
      (t.writeExtmap = function(e) {
        return (
          "a=extmap:" +
          (e.id || e.preferredId) +
          (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") +
          " " +
          e.uri +
          (e.attributes ? " " + e.attributes : "") +
          "\r\n"
        );
      }),
      (t.parseFmtp = function(e) {
        const t = {};
        let i;
        const s = e.substring(e.indexOf(" ") + 1).split(";");
        for (let e = 0; e < s.length; e++)
          (i = s[e].trim().split("=")), (t[i[0].trim()] = i[1]);
        return t;
      }),
      (t.writeFmtp = function(e) {
        let t = "",
          i = e.payloadType;
        if (
          (void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType),
          e.parameters && Object.keys(e.parameters).length)
        ) {
          const s = [];
          Object.keys(e.parameters).forEach(t => {
            void 0 !== e.parameters[t]
              ? s.push(t + "=" + e.parameters[t])
              : s.push(t);
          }),
            (t += "a=fmtp:" + i + " " + s.join(";") + "\r\n");
        }
        return t;
      }),
      (t.parseRtcpFb = function(e) {
        const t = e.substring(e.indexOf(" ") + 1).split(" ");
        return { type: t.shift(), parameter: t.join(" ") };
      }),
      (t.writeRtcpFb = function(e) {
        let t = "",
          i = e.payloadType;
        return (
          void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType),
          e.rtcpFeedback &&
            e.rtcpFeedback.length &&
            e.rtcpFeedback.forEach(e => {
              t +=
                "a=rtcp-fb:" +
                i +
                " " +
                e.type +
                (e.parameter && e.parameter.length ? " " + e.parameter : "") +
                "\r\n";
            }),
          t
        );
      }),
      (t.parseSsrcMedia = function(e) {
        const t = e.indexOf(" "),
          i = { ssrc: parseInt(e.substring(7, t), 10) },
          s = e.indexOf(":", t);
        return (
          s > -1
            ? ((i.attribute = e.substring(t + 1, s)),
              (i.value = e.substring(s + 1)))
            : (i.attribute = e.substring(t + 1)),
          i
        );
      }),
      (t.parseSsrcGroup = function(e) {
        const t = e.substring(13).split(" ");
        return { semantics: t.shift(), ssrcs: t.map(e => parseInt(e, 10)) };
      }),
      (t.getMid = function(e) {
        const i = t.matchPrefix(e, "a=mid:")[0];
        if (i) return i.substring(6);
      }),
      (t.parseFingerprint = function(e) {
        const t = e.substring(14).split(" ");
        return { algorithm: t[0].toLowerCase(), value: t[1].toUpperCase() };
      }),
      (t.getDtlsParameters = function(e, i) {
        return {
          role: "auto",
          fingerprints: t
            .matchPrefix(e + i, "a=fingerprint:")
            .map(t.parseFingerprint)
        };
      }),
      (t.writeDtlsParameters = function(e, t) {
        let i = "a=setup:" + t + "\r\n";
        return (
          e.fingerprints.forEach(e => {
            i += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n";
          }),
          i
        );
      }),
      (t.parseCryptoLine = function(e) {
        const t = e.substring(9).split(" ");
        return {
          tag: parseInt(t[0], 10),
          cryptoSuite: t[1],
          keyParams: t[2],
          sessionParams: t.slice(3)
        };
      }),
      (t.writeCryptoLine = function(e) {
        return (
          "a=crypto:" +
          e.tag +
          " " +
          e.cryptoSuite +
          " " +
          ("object" == typeof e.keyParams
            ? t.writeCryptoKeyParams(e.keyParams)
            : e.keyParams) +
          (e.sessionParams ? " " + e.sessionParams.join(" ") : "") +
          "\r\n"
        );
      }),
      (t.parseCryptoKeyParams = function(e) {
        if (0 !== e.indexOf("inline:")) return null;
        const t = e.substring(7).split("|");
        return {
          keyMethod: "inline",
          keySalt: t[0],
          lifeTime: t[1],
          mkiValue: t[2] ? t[2].split(":")[0] : void 0,
          mkiLength: t[2] ? t[2].split(":")[1] : void 0
        };
      }),
      (t.writeCryptoKeyParams = function(e) {
        return (
          e.keyMethod +
          ":" +
          e.keySalt +
          (e.lifeTime ? "|" + e.lifeTime : "") +
          (e.mkiValue && e.mkiLength
            ? "|" + e.mkiValue + ":" + e.mkiLength
            : "")
        );
      }),
      (t.getCryptoParameters = function(e, i) {
        return t.matchPrefix(e + i, "a=crypto:").map(t.parseCryptoLine);
      }),
      (t.getIceParameters = function(e, i) {
        const s = t.matchPrefix(e + i, "a=ice-ufrag:")[0],
          r = t.matchPrefix(e + i, "a=ice-pwd:")[0];
        return s && r
          ? { usernameFragment: s.substring(12), password: r.substring(10) }
          : null;
      }),
      (t.writeIceParameters = function(e) {
        let t =
          "a=ice-ufrag:" +
          e.usernameFragment +
          "\r\na=ice-pwd:" +
          e.password +
          "\r\n";
        return e.iceLite && (t += "a=ice-lite\r\n"), t;
      }),
      (t.parseRtpParameters = function(e) {
        const i = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: [],
            rtcp: []
          },
          s = t.splitLines(e)[0].split(" ");
        i.profile = s[2];
        for (let r = 3; r < s.length; r++) {
          const n = s[r],
            a = t.matchPrefix(e, "a=rtpmap:" + n + " ")[0];
          if (a) {
            const s = t.parseRtpMap(a),
              r = t.matchPrefix(e, "a=fmtp:" + n + " ");
            switch (
              ((s.parameters = r.length ? t.parseFmtp(r[0]) : {}),
              (s.rtcpFeedback = t
                .matchPrefix(e, "a=rtcp-fb:" + n + " ")
                .map(t.parseRtcpFb)),
              i.codecs.push(s),
              s.name.toUpperCase())
            ) {
              case "RED":
              case "ULPFEC":
                i.fecMechanisms.push(s.name.toUpperCase());
            }
          }
        }
        t.matchPrefix(e, "a=extmap:").forEach(e => {
          i.headerExtensions.push(t.parseExtmap(e));
        });
        const r = t.matchPrefix(e, "a=rtcp-fb:* ").map(t.parseRtcpFb);
        return (
          i.codecs.forEach(e => {
            r.forEach(t => {
              e.rtcpFeedback.find(
                e => e.type === t.type && e.parameter === t.parameter
              ) || e.rtcpFeedback.push(t);
            });
          }),
          i
        );
      }),
      (t.writeRtpDescription = function(e, i) {
        let s = "";
        (s += "m=" + e + " "),
          (s += i.codecs.length > 0 ? "9" : "0"),
          (s += " " + (i.profile || "UDP/TLS/RTP/SAVPF") + " "),
          (s +=
            i.codecs
              .map(e =>
                void 0 !== e.preferredPayloadType
                  ? e.preferredPayloadType
                  : e.payloadType
              )
              .join(" ") + "\r\n"),
          (s += "c=IN IP4 0.0.0.0\r\n"),
          (s += "a=rtcp:9 IN IP4 0.0.0.0\r\n"),
          i.codecs.forEach(e => {
            (s += t.writeRtpMap(e)),
              (s += t.writeFmtp(e)),
              (s += t.writeRtcpFb(e));
          });
        let r = 0;
        return (
          i.codecs.forEach(e => {
            e.maxptime > r && (r = e.maxptime);
          }),
          r > 0 && (s += "a=maxptime:" + r + "\r\n"),
          i.headerExtensions &&
            i.headerExtensions.forEach(e => {
              s += t.writeExtmap(e);
            }),
          s
        );
      }),
      (t.parseRtpEncodingParameters = function(e) {
        const i = [],
          s = t.parseRtpParameters(e),
          r = -1 !== s.fecMechanisms.indexOf("RED"),
          n = -1 !== s.fecMechanisms.indexOf("ULPFEC"),
          a = t
            .matchPrefix(e, "a=ssrc:")
            .map(e => t.parseSsrcMedia(e))
            .filter(e => "cname" === e.attribute),
          o = a.length > 0 && a[0].ssrc;
        let c;
        const d = t.matchPrefix(e, "a=ssrc-group:FID").map(e =>
          e
            .substring(17)
            .split(" ")
            .map(e => parseInt(e, 10))
        );
        d.length > 0 && d[0].length > 1 && d[0][0] === o && (c = d[0][1]),
          s.codecs.forEach(e => {
            if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
              let t = {
                ssrc: o,
                codecPayloadType: parseInt(e.parameters.apt, 10)
              };
              o && c && (t.rtx = { ssrc: c }),
                i.push(t),
                r &&
                  ((t = JSON.parse(JSON.stringify(t))),
                  (t.fec = { ssrc: o, mechanism: n ? "red+ulpfec" : "red" }),
                  i.push(t));
            }
          }),
          0 === i.length && o && i.push({ ssrc: o });
        let l = t.matchPrefix(e, "b=");
        return (
          l.length &&
            ((l =
              0 === l[0].indexOf("b=TIAS:")
                ? parseInt(l[0].substring(7), 10)
                : 0 === l[0].indexOf("b=AS:")
                ? 1e3 * parseInt(l[0].substring(5), 10) * 0.95 - 16e3
                : void 0),
            i.forEach(e => {
              e.maxBitrate = l;
            })),
          i
        );
      }),
      (t.parseRtcpParameters = function(e) {
        const i = {},
          s = t
            .matchPrefix(e, "a=ssrc:")
            .map(e => t.parseSsrcMedia(e))
            .filter(e => "cname" === e.attribute)[0];
        s && ((i.cname = s.value), (i.ssrc = s.ssrc));
        const r = t.matchPrefix(e, "a=rtcp-rsize");
        (i.reducedSize = r.length > 0), (i.compound = 0 === r.length);
        const n = t.matchPrefix(e, "a=rtcp-mux");
        return (i.mux = n.length > 0), i;
      }),
      (t.writeRtcpParameters = function(e) {
        let t = "";
        return (
          e.reducedSize && (t += "a=rtcp-rsize\r\n"),
          e.mux && (t += "a=rtcp-mux\r\n"),
          void 0 !== e.ssrc &&
            e.cname &&
            (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"),
          t
        );
      }),
      (t.parseMsid = function(e) {
        let i;
        const s = t.matchPrefix(e, "a=msid:");
        if (1 === s.length)
          return (
            (i = s[0].substring(7).split(" ")), { stream: i[0], track: i[1] }
          );
        const r = t
          .matchPrefix(e, "a=ssrc:")
          .map(e => t.parseSsrcMedia(e))
          .filter(e => "msid" === e.attribute);
        return r.length > 0
          ? ((i = r[0].value.split(" ")), { stream: i[0], track: i[1] })
          : void 0;
      }),
      (t.parseSctpDescription = function(e) {
        const i = t.parseMLine(e),
          s = t.matchPrefix(e, "a=max-message-size:");
        let r;
        s.length > 0 && (r = parseInt(s[0].substring(19), 10)),
          isNaN(r) && (r = 65536);
        const n = t.matchPrefix(e, "a=sctp-port:");
        if (n.length > 0)
          return {
            port: parseInt(n[0].substring(12), 10),
            protocol: i.fmt,
            maxMessageSize: r
          };
        const a = t.matchPrefix(e, "a=sctpmap:");
        if (a.length > 0) {
          const e = a[0].substring(10).split(" ");
          return {
            port: parseInt(e[0], 10),
            protocol: e[1],
            maxMessageSize: r
          };
        }
      }),
      (t.writeSctpDescription = function(e, t) {
        let i = [];
        return (
          (i =
            "DTLS/SCTP" !== e.protocol
              ? [
                  "m=" +
                    e.kind +
                    " 9 " +
                    e.protocol +
                    " " +
                    t.protocol +
                    "\r\n",
                  "c=IN IP4 0.0.0.0\r\n",
                  "a=sctp-port:" + t.port + "\r\n"
                ]
              : [
                  "m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n",
                  "c=IN IP4 0.0.0.0\r\n",
                  "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"
                ]),
          void 0 !== t.maxMessageSize &&
            i.push("a=max-message-size:" + t.maxMessageSize + "\r\n"),
          i.join("")
        );
      }),
      (t.generateSessionId = function() {
        return Math.random()
          .toString()
          .substr(2, 22);
      }),
      (t.writeSessionBoilerplate = function(e, i, s) {
        let r;
        const n = void 0 !== i ? i : 2;
        r = e || t.generateSessionId();
        return (
          "v=0\r\no=" +
          (s || "thisisadapterortc") +
          " " +
          r +
          " " +
          n +
          " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
        );
      }),
      (t.getDirection = function(e, i) {
        const s = t.splitLines(e);
        for (let e = 0; e < s.length; e++)
          switch (s[e]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return s[e].substring(2);
          }
        return i ? t.getDirection(i) : "sendrecv";
      }),
      (t.getKind = function(e) {
        return t
          .splitLines(e)[0]
          .split(" ")[0]
          .substring(2);
      }),
      (t.isRejected = function(e) {
        return "0" === e.split(" ", 2)[1];
      }),
      (t.parseMLine = function(e) {
        const i = t
          .splitLines(e)[0]
          .substring(2)
          .split(" ");
        return {
          kind: i[0],
          port: parseInt(i[1], 10),
          protocol: i[2],
          fmt: i.slice(3).join(" ")
        };
      }),
      (t.parseOLine = function(e) {
        const i = t
          .matchPrefix(e, "o=")[0]
          .substring(2)
          .split(" ");
        return {
          username: i[0],
          sessionId: i[1],
          sessionVersion: parseInt(i[2], 10),
          netType: i[3],
          addressType: i[4],
          address: i[5]
        };
      }),
      (t.isValidSDP = function(e) {
        if ("string" != typeof e || 0 === e.length) return !1;
        const i = t.splitLines(e);
        for (let e = 0; e < i.length; e++)
          if (i[e].length < 2 || "=" !== i[e].charAt(1)) return !1;
        return !0;
      }),
      (e.exports = t);
  })(gx);
  var _x = gx.exports,
    Tx = s(_x),
    Sx = t({ __proto__: null, default: Tx }, [_x]);
  function vx(e) {
    if (
      !e.RTCIceCandidate ||
      (e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype)
    )
      return;
    const t = e.RTCIceCandidate;
    (e.RTCIceCandidate = function(e) {
      if (
        ("object" == typeof e &&
          e.candidate &&
          0 === e.candidate.indexOf("a=") &&
          ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(
            2
          )),
        e.candidate && e.candidate.length)
      ) {
        const i = new t(e),
          s = Tx.parseCandidate(e.candidate),
          r = Object.assign(i, s);
        return (
          (r.toJSON = function() {
            return {
              candidate: r.candidate,
              sdpMid: r.sdpMid,
              sdpMLineIndex: r.sdpMLineIndex,
              usernameFragment: r.usernameFragment
            };
          }),
          r
        );
      }
      return new t(e);
    }),
      (e.RTCIceCandidate.prototype = t.prototype),
      OU(
        e,
        "icecandidate",
        t => (
          t.candidate &&
            Object.defineProperty(t, "candidate", {
              value: new e.RTCIceCandidate(t.candidate),
              writable: "false"
            }),
          t
        )
      );
  }
  function Rx(e) {
    !e.RTCIceCandidate ||
      (e.RTCIceCandidate && "relayProtocol" in e.RTCIceCandidate.prototype) ||
      OU(e, "icecandidate", e => {
        if (e.candidate) {
          const t = Tx.parseCandidate(e.candidate.candidate);
          "relay" === t.type &&
            (e.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[
              t.priority >> 24
            ]);
        }
        return e;
      });
  }
  function yx(e, t) {
    if (!e.RTCPeerConnection) return;
    "sctp" in e.RTCPeerConnection.prototype ||
      Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
        get() {
          return void 0 === this._sctp ? null : this._sctp;
        }
      });
    const i = function(e) {
        if (!e || !e.sdp) return !1;
        const t = Tx.splitSections(e.sdp);
        return (
          t.shift(),
          t.some(e => {
            const t = Tx.parseMLine(e);
            return (
              t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
            );
          })
        );
      },
      s = function(e) {
        const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
        if (null === t || t.length < 2) return -1;
        const i = parseInt(t[1], 10);
        return i != i ? -1 : i;
      },
      r = function(e) {
        let i = 65536;
        return (
          "firefox" === t.browser &&
            (i =
              t.version < 57
                ? -1 === e
                  ? 16384
                  : 2147483637
                : t.version < 60
                ? 57 === t.version
                  ? 65535
                  : 65536
                : 2147483637),
          i
        );
      },
      n = function(e, i) {
        let s = 65536;
        "firefox" === t.browser && 57 === t.version && (s = 65535);
        const r = Tx.matchPrefix(e.sdp, "a=max-message-size:");
        return (
          r.length > 0
            ? (s = parseInt(r[0].substr(19), 10))
            : "firefox" === t.browser && -1 !== i && (s = 2147483637),
          s
        );
      },
      a = e.RTCPeerConnection.prototype.setRemoteDescription;
    e.RTCPeerConnection.prototype.setRemoteDescription = function() {
      if (((this._sctp = null), "chrome" === t.browser && t.version >= 76)) {
        const { sdpSemantics: e } = this.getConfiguration();
        "plan-b" === e &&
          Object.defineProperty(this, "sctp", {
            get() {
              return void 0 === this._sctp ? null : this._sctp;
            },
            enumerable: !0,
            configurable: !0
          });
      }
      if (i(arguments[0])) {
        const e = s(arguments[0]),
          t = r(e),
          i = n(arguments[0], e);
        let a;
        a =
          0 === t && 0 === i
            ? Number.POSITIVE_INFINITY
            : 0 === t || 0 === i
            ? Math.max(t, i)
            : Math.min(t, i);
        const o = {};
        Object.defineProperty(o, "maxMessageSize", { get: () => a }),
          (this._sctp = o);
      }
      return a.apply(this, arguments);
    };
  }
  function Ax(e) {
    if (
      !e.RTCPeerConnection ||
      !("createDataChannel" in e.RTCPeerConnection.prototype)
    )
      return;
    function t(e, t) {
      const i = e.send;
      e.send = function() {
        const s = arguments[0],
          r = s.length || s.size || s.byteLength;
        if ("open" === e.readyState && t.sctp && r > t.sctp.maxMessageSize)
          throw new TypeError(
            "Message too large (can send a maximum of " +
              t.sctp.maxMessageSize +
              " bytes)"
          );
        return i.apply(e, arguments);
      };
    }
    const i = e.RTCPeerConnection.prototype.createDataChannel;
    (e.RTCPeerConnection.prototype.createDataChannel = function() {
      const e = i.apply(this, arguments);
      return t(e, this), e;
    }),
      OU(e, "datachannel", e => (t(e.channel, e.target), e));
  }
  function Ix(e) {
    if (
      !e.RTCPeerConnection ||
      "connectionState" in e.RTCPeerConnection.prototype
    )
      return;
    const t = e.RTCPeerConnection.prototype;
    Object.defineProperty(t, "connectionState", {
      get() {
        return (
          { completed: "connected", checking: "connecting" }[
            this.iceConnectionState
          ] || this.iceConnectionState
        );
      },
      enumerable: !0,
      configurable: !0
    }),
      Object.defineProperty(t, "onconnectionstatechange", {
        get() {
          return this._onconnectionstatechange || null;
        },
        set(e) {
          this._onconnectionstatechange &&
            (this.removeEventListener(
              "connectionstatechange",
              this._onconnectionstatechange
            ),
            delete this._onconnectionstatechange),
            e &&
              this.addEventListener(
                "connectionstatechange",
                (this._onconnectionstatechange = e)
              );
        },
        enumerable: !0,
        configurable: !0
      }),
      ["setLocalDescription", "setRemoteDescription"].forEach(e => {
        const i = t[e];
        t[e] = function() {
          return (
            this._connectionstatechangepoly ||
              ((this._connectionstatechangepoly = e => {
                const t = e.target;
                if (t._lastConnectionState !== t.connectionState) {
                  t._lastConnectionState = t.connectionState;
                  const i = new Event("connectionstatechange", e);
                  t.dispatchEvent(i);
                }
                return e;
              }),
              this.addEventListener(
                "iceconnectionstatechange",
                this._connectionstatechangepoly
              )),
            i.apply(this, arguments)
          );
        };
      });
  }
  function Cx(e, t) {
    if (!e.RTCPeerConnection) return;
    if ("chrome" === t.browser && t.version >= 71) return;
    if ("safari" === t.browser && t.version >= 605) return;
    const i = e.RTCPeerConnection.prototype.setRemoteDescription;
    e.RTCPeerConnection.prototype.setRemoteDescription = function(t) {
      if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
        const i = t.sdp
          .split("\n")
          .filter(e => "a=extmap-allow-mixed" !== e.trim())
          .join("\n");
        e.RTCSessionDescription && t instanceof e.RTCSessionDescription
          ? (arguments[0] = new e.RTCSessionDescription({
              type: t.type,
              sdp: i
            }))
          : (t.sdp = i);
      }
      return i.apply(this, arguments);
    };
  }
  function bx(e, t) {
    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
    const i = e.RTCPeerConnection.prototype.addIceCandidate;
    i &&
      0 !== i.length &&
      (e.RTCPeerConnection.prototype.addIceCandidate = function() {
        return arguments[0]
          ? (("chrome" === t.browser && t.version < 78) ||
              ("firefox" === t.browser && t.version < 68) ||
              "safari" === t.browser) &&
            arguments[0] &&
            "" === arguments[0].candidate
            ? Promise.resolve()
            : i.apply(this, arguments)
          : (arguments[1] && arguments[1].apply(null), Promise.resolve());
      });
  }
  function Ox(e, t) {
    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
    const i = e.RTCPeerConnection.prototype.setLocalDescription;
    i &&
      0 !== i.length &&
      (e.RTCPeerConnection.prototype.setLocalDescription = function() {
        let e = arguments[0] || {};
        if ("object" != typeof e || (e.type && e.sdp))
          return i.apply(this, arguments);
        if (((e = { type: e.type, sdp: e.sdp }), !e.type))
          switch (this.signalingState) {
            case "stable":
            case "have-local-offer":
            case "have-remote-pranswer":
              e.type = "offer";
              break;
            default:
              e.type = "answer";
          }
        if (e.sdp || ("offer" !== e.type && "answer" !== e.type))
          return i.apply(this, [e]);
        return ("offer" === e.type ? this.createOffer : this.createAnswer)
          .apply(this)
          .then(e => i.apply(this, [e]));
      });
  }
  var Dx = Object.freeze({
    __proto__: null,
    removeExtmapAllowMixed: Cx,
    shimAddIceCandidateNullOrEmpty: bx,
    shimConnectionState: Ix,
    shimMaxMessageSize: yx,
    shimParameterlessSetLocalDescription: Ox,
    shimRTCIceCandidate: vx,
    shimRTCIceCandidateRelayProtocol: Rx,
    shimSendThrowTypeError: Ax
  });
  !(function(
    { window: e } = {},
    t = { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }
  ) {
    const i = LU,
      s = (function(e) {
        const t = { browser: null, version: null };
        if (void 0 === e || !e.navigator)
          return (t.browser = "Not a browser."), t;
        const { navigator: i } = e;
        if (i.mozGetUserMedia)
          (t.browser = "firefox"),
            (t.version = bU(i.userAgent, /Firefox\/(\d+)\./, 1));
        else if (
          i.webkitGetUserMedia ||
          (!1 === e.isSecureContext && e.webkitRTCPeerConnection)
        )
          (t.browser = "chrome"),
            (t.version = bU(i.userAgent, /Chrom(e|ium)\/(\d+)\./, 2));
        else {
          if (
            !e.RTCPeerConnection ||
            !i.userAgent.match(/AppleWebKit\/(\d+)\./)
          )
            return (t.browser = "Not a supported browser."), t;
          (t.browser = "safari"),
            (t.version = bU(i.userAgent, /AppleWebKit\/(\d+)\./, 1)),
            (t.supportsUnifiedPlan =
              e.RTCRtpTransceiver &&
              "currentDirection" in e.RTCRtpTransceiver.prototype);
        }
        return t;
      })(e),
      r = {
        browserDetails: s,
        commonShim: Dx,
        extractVersion: bU,
        disableLog: DU,
        disableWarnings: wU,
        sdp: Sx
      };
    switch (s.browser) {
      case "chrome":
        if (!qU || !YU || !t.shimChrome)
          return i("Chrome shim is not included in this adapter release."), r;
        if (null === s.version)
          return i("Chrome shim can not determine version, not shimming."), r;
        i("adapter.js shimming chrome."),
          (r.browserShim = qU),
          bx(e, s),
          Ox(e),
          FU(e, s),
          BU(e),
          YU(e, s),
          VU(e),
          WU(e, s),
          GU(e),
          jU(e),
          HU(e),
          $U(e, s),
          vx(e),
          Rx(e),
          Ix(e),
          yx(e, s),
          Ax(e),
          Cx(e, s);
        break;
      case "firefox":
        if (!ax || !JU || !t.shimFirefox)
          return i("Firefox shim is not included in this adapter release."), r;
        i("adapter.js shimming firefox."),
          (r.browserShim = ax),
          bx(e, s),
          Ox(e),
          XU(e, s),
          JU(e, s),
          zU(e),
          ex(e),
          QU(e),
          ZU(e),
          tx(e),
          ix(e),
          sx(e),
          rx(e),
          nx(e),
          vx(e),
          Ix(e),
          yx(e, s),
          Ax(e);
        break;
      case "safari":
        if (!mx || !t.shimSafari)
          return i("Safari shim is not included in this adapter release."), r;
        i("adapter.js shimming safari."),
          (r.browserShim = mx),
          bx(e, s),
          Ox(e),
          ux(e),
          fx(e),
          dx(e),
          ox(e),
          cx(e),
          px(e),
          lx(e),
          Ex(e),
          vx(e),
          Rx(e),
          yx(e, s),
          Ax(e),
          Cx(e, s);
        break;
      default:
        i("Unsupported browser!");
    }
  })({ window: "undefined" == typeof window ? void 0 : window });
  const wx = {
    getDisplayMedia: !1,
    getStreamFromExtension: !1,
    supportUnifiedPlan: !1,
    supportMinBitrate: !1,
    supportSetRtpSenderParameters: !1,
    supportDualStream: !0,
    webAudioMediaStreamDest: !1,
    supportReplaceTrack: !1,
    supportWebGL: !1,
    webAudioWithAEC: !1,
    supportRequestFrame: !1,
    supportShareAudio: !1,
    supportDualStreamEncoding: !1,
    supportDataChannel: !1,
    supportPCSetConfiguration: !1,
    supportWebRTCEncodedTransform: !1,
    supportWebRTCInsertableStream: !1,
    supportRequestVideoFrameCallback: !1,
    supportWebCrypto: !1
  };
  function Lx() {
    return wx;
  }
  function Nx() {
    return (
      "setSinkId" in HTMLAudioElement.prototype &&
      (!WM("RESTRICTION_SET_PLAYBACK_DEVICE") || ((CP() || OP()) && !HP()))
    );
  }
  function Px() {
    return !wx.supportUnifiedPlan || (WM("CHROME_FORCE_PLAN_B") && KP());
  }
  let kx = (function(e) {
    return (
      (e.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start"),
      (e.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end"),
      (e.IOS_INTERRUPTION_START = "ios-interruption-start"),
      (e.IOS_INTERRUPTION_END = "ios-interruption-end"),
      (e.STATE_CHANGE = "state-change"),
      e
    );
  })({});
  function Mx(e, t, i) {
    return { sampleRate: e, stereo: t, bitrate: i };
  }
  function Ux(e, t, i, s, r) {
    return { width: e, height: t, frameRate: i, bitrateMin: s, bitrateMax: r };
  }
  const xx = {
    "90p": Ux(160, 90),
    "90p_1": Ux(160, 90),
    "120p": Ux(160, 120, 15, 30, 65),
    "120p_1": Ux(160, 120, 15, 30, 65),
    "120p_3": Ux(120, 120, 15, 30, 50),
    "120p_4": Ux(212, 120),
    "180p": Ux(320, 180, 15, 30, 140),
    "180p_1": Ux(320, 180, 15, 30, 140),
    "180p_3": Ux(180, 180, 15, 30, 100),
    "180p_4": Ux(240, 180, 15, 30, 120),
    "240p": Ux(320, 240, 15, 40, 200),
    "240p_1": Ux(320, 240, 15, 40, 200),
    "240p_3": Ux(240, 240, 15, 40, 140),
    "240p_4": Ux(424, 240, 15, 40, 220),
    "360p": Ux(640, 360, 15, 80, 400),
    "360p_1": Ux(640, 360, 15, 80, 400),
    "360p_3": Ux(360, 360, 15, 80, 260),
    "360p_4": Ux(640, 360, 30, 80, 600),
    "360p_6": Ux(360, 360, 30, 80, 400),
    "360p_7": Ux(480, 360, 15, 80, 320),
    "360p_8": Ux(480, 360, 30, 80, 490),
    "360p_9": Ux(640, 360, 15, 80, 800),
    "360p_10": Ux(640, 360, 24, 80, 800),
    "360p_11": Ux(640, 360, 24, 80, 1e3),
    "480p": Ux(640, 480, 15, 100, 500),
    "480p_1": Ux(640, 480, 15, 100, 500),
    "480p_2": Ux(640, 480, 30, 100, 1e3),
    "480p_3": Ux(480, 480, 15, 100, 400),
    "480p_4": Ux(640, 480, 30, 100, 750),
    "480p_6": Ux(480, 480, 30, 100, 600),
    "480p_8": Ux(848, 480, 15, 100, 610),
    "480p_9": Ux(848, 480, 30, 100, 930),
    "480p_10": Ux(640, 480, 10, 100, 400),
    "720p": Ux(1280, 720, 15, 120, 1130),
    "720p_auto": Ux(1280, 720, 30, 900, 3e3),
    "720p_1": Ux(1280, 720, 15, 120, 1130),
    "720p_2": Ux(1280, 720, 30, 120, 2e3),
    "720p_3": Ux(1280, 720, 30, 120, 1710),
    "720p_5": Ux(960, 720, 15, 120, 910),
    "720p_6": Ux(960, 720, 30, 120, 1380),
    "1080p": Ux(1920, 1080, 15, 120, 2080),
    "1080p_1": Ux(1920, 1080, 15, 120, 2080),
    "1080p_2": Ux(1920, 1080, 30, 120, 3e3),
    "1080p_3": Ux(1920, 1080, 30, 120, 3150),
    "1080p_5": Ux(1920, 1080, 60, 120, 4780),
    "1440p": Ux(2560, 1440, 30, 120, 4850),
    "1440p_1": Ux(2560, 1440, 30, 120, 4850),
    "1440p_2": Ux(2560, 1440, 60, 120, 7350),
    "4k": Ux(3840, 2160, 30, 120, 8910),
    "4k_1": Ux(3840, 2160, 30, 120, 8910),
    "4k_3": Ux(3840, 2160, 60, 120, 13500)
  };
  function Fx(e) {
    return (
      e || (e = "480p_1"), "string" == typeof e ? Object.assign({}, xx[e]) : e
    );
  }
  const Bx = {
    speech_low_quality: Mx(16e3, !1),
    speech_standard: Mx(32e3, !1, 18),
    music_standard: Mx(48e3, !1),
    standard_stereo: Mx(48e3, !0, 56),
    high_quality: Mx(48e3, !1, 128),
    high_quality_stereo: Mx(48e3, !0, 192)
  };
  const Vx = [];
  function Gx(e) {
    return ZP(e, "mediaSource", ["screen", "window", "application"]), !0;
  }
  let jx = (function(e) {
      return (
        (e.NEED_RENEGOTIATE = "@need_renegotiate"),
        (e.NEED_REPLACE_TRACK = "@need_replace_track"),
        (e.NEED_REPLACE_MIXING_TRACK = "@need_replace_mixing_track"),
        (e.NEED_CLOSE = "@need_close"),
        (e.NEED_ENABLE_TRACK = "@need_enable_track"),
        (e.NEED_DISABLE_TRACK = "@need_disable_track"),
        (e.NEED_SESSION_ID = "@need_sid"),
        (e.SET_OPTIMIZATION_MODE = "@set_optimization_mode"),
        (e.GET_STATS = "@get_stats"),
        (e.GET_RTC_STATS = "@get_rtc_stats"),
        (e.GET_LOW_VIDEO_TRACK = "@get_low_video_track"),
        (e.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp"),
        (e.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder"),
        (e.NEED_UPDATE_VIDEO_SEND_PARAMETERS =
          "@need_update_video_send_parameters"),
        (e.NEED_MUTE_TRACK = "@need_mute_track"),
        (e.NEED_UNMUTE_TRACK = "@need_unmute_track"),
        e
      );
    })({}),
    Hx = (function(e) {
      return (
        (e.SCREEN_TRACK = "screen_track"),
        (e.CUSTOM_TRACK = "custome_track"),
        (e.LOW_STREAM = "low_stream"),
        (e.SCREEN_LOW_TRACK = "screen_low_track"),
        e
      );
    })({});
  let Kx = (function(e) {
    return (
      (e[(e.HIGH_STREAM = 0)] = "HIGH_STREAM"),
      (e[(e.LOW_STREAM = 1)] = "LOW_STREAM"),
      e
    );
  })({});
  !(function(e) {
    (e[(e.HIGH_STREAM = 0)] = "HIGH_STREAM"),
      (e[(e.LOW_STREAM = 1)] = "LOW_STREAM"),
      (e[(e.HIGH_STREAM_LAYER1 = 4)] = "HIGH_STREAM_LAYER1"),
      (e[(e.HIGH_STREAM_LAYER2 = 5)] = "HIGH_STREAM_LAYER2"),
      (e[(e.HIGH_STREAM_LAYER3 = 6)] = "HIGH_STREAM_LAYER3"),
      (e[(e.HIGH_STREAM_LAYER4 = 7)] = "HIGH_STREAM_LAYER4"),
      (e[(e.HIGH_STREAM_LAYER5 = 8)] = "HIGH_STREAM_LAYER5"),
      (e[(e.HIGH_STREAM_LAYER6 = 9)] = "HIGH_STREAM_LAYER6");
  })({}),
    (function(e) {
      (e[(e.DISABLE = 0)] = "DISABLE"),
        (e[(e.LOW_STREAM = 1)] = "LOW_STREAM"),
        (e[(e.AUDIO_ONLY = 2)] = "AUDIO_ONLY"),
        (e[(e.HIGH_STREAM_LAYER1 = 3)] = "HIGH_STREAM_LAYER1"),
        (e[(e.HIGH_STREAM_LAYER2 = 4)] = "HIGH_STREAM_LAYER2"),
        (e[(e.HIGH_STREAM_LAYER3 = 5)] = "HIGH_STREAM_LAYER3"),
        (e[(e.HIGH_STREAM_LAYER4 = 6)] = "HIGH_STREAM_LAYER4"),
        (e[(e.HIGH_STREAM_LAYER5 = 7)] = "HIGH_STREAM_LAYER5"),
        (e[(e.HIGH_STREAM_LAYER6 = 8)] = "HIGH_STREAM_LAYER6");
    })({});
  let Wx = (function(e) {
      return (
        (e.TRANSCEIVER_UPDATED = "transceiver-updated"),
        (e.SEI_TO_SEND = "sei-to-send"),
        (e.SEI_RECEIVED = "sei-received"),
        (e.TRACK_UPDATED = "track-updated"),
        e
      );
    })({}),
    Yx = (function(e) {
      return (
        (e.SOURCE_STATE_CHANGE = "source-state-change"),
        (e.TRACK_ENDED = "track-ended"),
        (e.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload"),
        (e.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status"),
        (e.CLOSED = "closed"),
        e
      );
    })({}),
    $x = (function(e) {
      return (
        (e.FIRST_FRAME_DECODED = "first-frame-decoded"),
        (e.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status"),
        (e.VIDEO_STATE_CHANGED = "video-state-changed"),
        e
      );
    })({}),
    qx = (function(e) {
      return (e.AUDIO = "audio"), (e.VIDEO = "video"), (e.DATA = "data"), e;
    })({}),
    Xx = (function(e) {
      return (
        (e.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change"),
        (e.RECEIVE_TRACK_BUFFER = "receive_track_buffer"),
        (e.ON_AUDIO_BUFFER = "on_audio_buffer"),
        (e.UPDATE_SOURCE = "update_source"),
        e
      );
    })({});
  !(function(e) {
    e.UPDATE_TRACK_SOURCE = "update-track-source";
  })({});
  const zx = {
      sendVolumeLevel: 0,
      sendBitrate: 0,
      sendBytes: 0,
      sendPackets: 0,
      sendPacketsLost: 0,
      sendJitterMs: 0,
      sendRttMs: 0,
      currentPacketLossRate: 0
    },
    Jx = {
      sendBytes: 0,
      sendBitrate: 0,
      sendPackets: 0,
      sendPacketsLost: 0,
      sendJitterMs: 0,
      sendRttMs: 0,
      sendResolutionHeight: 0,
      sendResolutionWidth: 0,
      captureResolutionHeight: 0,
      captureResolutionWidth: 0,
      targetSendBitrate: 0,
      totalDuration: 0,
      totalFreezeTime: 0,
      currentPacketLossRate: 0
    },
    Qx = {
      transportDelay: 0,
      end2EndDelay: 0,
      receiveBitrate: 0,
      receiveLevel: 0,
      receiveBytes: 0,
      receiveDelay: 0,
      receivePackets: 0,
      receivePacketsLost: 0,
      receivePacketsDiscarded: 0,
      totalDuration: 0,
      totalFreezeTime: 0,
      freezeRate: 0,
      packetLossRate: 0,
      currentPacketLossRate: 0,
      publishDuration: -1
    },
    Zx = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 },
    eF = {
      transportDelay: 0,
      end2EndDelay: 0,
      receiveBitrate: 0,
      receiveBytes: 0,
      receiveDelay: 0,
      receivePackets: 0,
      receivePacketsLost: 0,
      receiveResolutionHeight: 0,
      receiveResolutionWidth: 0,
      totalDuration: 0,
      totalFreezeTime: 0,
      freezeRate: 0,
      packetLossRate: 0,
      currentPacketLossRate: 0,
      publishDuration: -1
    };
  let tF = (function(e) {
      return (e.ON_TRACK = "on_track"), (e.ON_NODE = "on_node"), e;
    })({}),
    iF = (function(e) {
      return (
        (e.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints"),
        (e.REQUEST_CONSTRAINTS = "request_constraints"),
        e
      );
    })({}),
    sF = (function(e) {
      return (
        (e.IDLE = "IDLE"), (e.INITING = "INITING"), (e.INITEND = "INITEND"), e
      );
    })({}),
    rF = (function(e) {
      return (
        (e.STATE_CHANGE = "state_change"),
        (e.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged"),
        (e.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged"),
        (e.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged"),
        e
      );
    })({}),
    nF = (function(e) {
      return (
        (e.NONE = "none"),
        (e.INIT = "init"),
        (e.CANPLAY = "canplay"),
        (e.PLAYING = "playing"),
        (e.PAUSED = "paused"),
        (e.SUSPEND = "suspend"),
        (e.STALLED = "stalled"),
        (e.WAITING = "waiting"),
        (e.ERROR = "error"),
        (e.DESTROYED = "destroyed"),
        (e.ABORT = "abort"),
        (e.ENDED = "ended"),
        (e.EMPTIED = "emptied"),
        (e.LOADEDDATA = "loadeddata"),
        e
      );
    })({}),
    aF = (function(e) {
      return (
        (e[(e.VideoStateStopped = 0)] = "VideoStateStopped"),
        (e[(e.VideoStateStarting = 1)] = "VideoStateStarting"),
        (e[(e.VideoStateDecoding = 2)] = "VideoStateDecoding"),
        (e[(e.VideoStateFrozen = 3)] = "VideoStateFrozen"),
        e
      );
    })({});
  const oF = {
    uninit: 100,
    none: 110,
    init: 120,
    loadeddata: 130,
    canplay: 200,
    playing: 210,
    paused: 220,
    suspend: 300,
    stalled: 310,
    waiting: 320,
    error: 330,
    destroyed: 340,
    abort: 350,
    ended: 360,
    emptied: 370
  };
  function cF(e, t, i, s, r) {
    var n = {};
    return (
      Object.keys(s).forEach(function(e) {
        n[e] = s[e];
      }),
      (n.enumerable = !!n.enumerable),
      (n.configurable = !!n.configurable),
      ("value" in n || n.initializer) && (n.writable = !0),
      (n = i
        .slice()
        .reverse()
        .reduce(function(i, s) {
          return s(e, t, i) || i;
        }, n)),
      r &&
        void 0 !== n.initializer &&
        ((n.value = n.initializer ? n.initializer.call(r) : void 0),
        (n.initializer = void 0)),
      void 0 === n.initializer ? (Object.defineProperty(e, t, n), null) : n
    );
  }
  function dF(e, t, i) {
    return (
      (t = (function(e) {
        var t = (function(e, t) {
          if ("object" != typeof e || !e) return e;
          var i = e[Symbol.toPrimitive];
          if (void 0 !== i) {
            var s = i.call(e, "string");
            if ("object" != typeof s) return s;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(e);
        })(e);
        return "symbol" == typeof t ? t : t + "";
      })(t)) in e
        ? Object.defineProperty(e, t, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
          })
        : (e[t] = i),
      e
    );
  }
  function lF(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function hF(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? lF(Object(i), !0).forEach(function(t) {
            dF(e, t, i[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
        : lF(Object(i)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
          });
    }
    return e;
  }
  !(function(e) {
    (e.OPEN = "open"),
      (e.MESSAGE = "message"),
      (e.CLOSE = "close"),
      (e.CLOSING = "closing"),
      (e.ERROR = "error");
  })({});
  class uF extends uk {
    set _mediaStreamTrack(e) {
      e !== this.mediaStreamTrack &&
        (this.safeEmit(Wx.TRACK_UPDATED, e), (this.mediaStreamTrack = e));
    }
    get _mediaStreamTrack() {
      return this.mediaStreamTrack;
    }
    constructor(e, t) {
      super(),
        dF(this, "trackMediaType", void 0),
        dF(this, "_ID", void 0),
        dF(this, "_rtpTransceiver", void 0),
        dF(this, "_lowRtpTransceiver", void 0),
        dF(this, "_hints", []),
        dF(this, "_isClosed", !1),
        dF(this, "_originMediaStreamTrack", void 0),
        dF(this, "mediaStreamTrack", void 0),
        dF(this, "_external", {}),
        (this._ID = t || Yk(8, "track-")),
        (this._originMediaStreamTrack = e),
        (this.mediaStreamTrack = e),
        (function(e) {
          Vx.includes(e) || Vx.push(e);
        })(this);
    }
    toString() {
      return this._ID;
    }
    getTrackId() {
      return this._ID;
    }
    getMediaStreamTrack(e) {
      return (
        e ||
          xk(() => {
            var e;
            yU.reportApiInvoke(null, {
              name: Ek.GET_MEDIA_STREAM_TRACK,
              options: [],
              tag: mk.TRACER
            }).onSuccess(
              (null === (e = this._mediaStreamTrack) || void 0 === e
                ? void 0
                : e.label) || ""
            );
          }, this.mediaStreamTrack.id || this.getTrackId()),
        this._mediaStreamTrack
      );
    }
    getRTCRtpTransceiver(e) {
      return e === Kx.LOW_STREAM
        ? this._lowRtpTransceiver
        : this._rtpTransceiver;
    }
    getMediaStreamTrackSettings() {
      return this.getMediaStreamTrack(!0).getSettings();
    }
    close() {
      (this._isClosed = !0),
        (this._lowRtpTransceiver = void 0),
        (this._rtpTransceiver = void 0),
        (function(e) {
          const t = Vx.indexOf(e);
          -1 !== t && Vx.splice(t, 1);
        })(this),
        this.emit(Yx.CLOSED),
        this.removeAllListeners(Wx.SEI_RECEIVED);
    }
    _updateRtpTransceiver(e, t) {
      if (t === Kx.LOW_STREAM) {
        if (this._lowRtpTransceiver === e) return;
        this._lowRtpTransceiver = e;
      } else {
        if (this._rtpTransceiver === e) return;
        this._rtpTransceiver = e;
      }
      this.emit(Wx.TRANSCEIVER_UPDATED, e, t);
    }
  }
  class pF extends uF {
    get isExternalTrack() {
      return this._isExternalTrack;
    }
    get muted() {
      return this._muted;
    }
    get enabled() {
      return this._enabled;
    }
    get processorContext() {
      return this._processorContext;
    }
    constructor(e, t) {
      super(e, t),
        dF(this, "_enabled", !0),
        dF(this, "_muted", !1),
        dF(this, "_isExternalTrack", !1),
        dF(this, "_isClosed", !1),
        dF(this, "_enabledMutex", void 0),
        dF(this, "processor", void 0),
        dF(this, "_processorContext", void 0),
        dF(this, "_handleTrackEnded", () => {
          this.onTrackEnded();
        }),
        (this._enabledMutex = new sM("".concat(this.getTrackId()))),
        e.addEventListener("ended", this._handleTrackEnded);
    }
    getTrackLabel() {
      var e, t;
      return null !==
        (e =
          null === (t = this._originMediaStreamTrack) || void 0 === t
            ? void 0
            : t.label) && void 0 !== e
        ? e
        : "";
    }
    close() {
      this._isClosed ||
        (this.stop(),
        this._originMediaStreamTrack.stop(),
        this._mediaStreamTrack !== this._originMediaStreamTrack &&
          (this._mediaStreamTrack.stop(), (this._mediaStreamTrack = null)),
        (this._originMediaStreamTrack = null),
        (this._enabledMutex = null),
        EU.debug("[".concat(this.getTrackId(), "] close")),
        this.emit(jx.NEED_CLOSE),
        super.close());
    }
    async _updateOriginMediaStreamTrack(e, t) {
      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      (this._isExternalTrack = i),
        e !== this._originMediaStreamTrack &&
          (this._originMediaStreamTrack &&
            (this._originMediaStreamTrack.removeEventListener(
              "ended",
              this._handleTrackEnded
            ),
            t && this._originMediaStreamTrack.stop()),
          e.addEventListener("ended", this._handleTrackEnded),
          (this._originMediaStreamTrack = e),
          this._muted && (this._originMediaStreamTrack.enabled = !1),
          (this._mediaStreamTrack = this._originMediaStreamTrack),
          this._updatePlayerSource(),
          await bk(this, jx.NEED_REPLACE_TRACK, this),
          this.processor &&
            this._processorContext &&
            this.processor.updateInput({
              track: this._originMediaStreamTrack,
              context: this._processorContext
            }));
    }
    _getDefaultPlayerConfig() {
      return {};
    }
    onTrackEnded() {
      EU.debug("[".concat(this.getTrackId(), "] track ended")),
        this.safeEmit(Yx.TRACK_ENDED);
    }
    stateCheck(e, t) {
      if (
        (EU.debug(
          "check track state, [muted: "
            .concat(this._muted, ", enabled: ")
            .concat(this._enabled, "] to [")
            .concat(e, ": ")
            .concat(t, "]")
        ),
        QP(t, e),
        this._enabled && this._muted && "enabled" === e && !1 === t)
      )
        throw new JP(
          zP.TRACK_STATE_UNREACHABLE,
          "cannot set enabled while the track is muted"
        ).print("error", EU);
      if (!this._enabled && !this._muted && "muted" === e && !0 === t)
        throw new JP(
          zP.TRACK_STATE_UNREACHABLE,
          "cannot set muted while the track is disabled"
        ).print("error", EU);
    }
    getProcessorStats() {
      return (
        (this._processorContext && this._processorContext.gatherStats()) || []
      );
    }
    getProcessorUsage() {
      return this._processorContext
        ? this._processorContext.gatherUsage()
        : Promise.resolve([]);
    }
  }
  const fF = window.AudioContext || window.webkitAudioContext;
  let EF = null;
  const mF = new (class extends uk {
    constructor() {
      super(...arguments),
        dF(this, "prevState", void 0),
        dF(this, "curState", void 0),
        dF(this, "currentTime", void 0),
        dF(this, "currentTimeStuckAt", void 0),
        dF(this, "interruptDetectorTrack", void 0),
        dF(this, "onLocalAudioTrackMute", () => {
          EU.info("ios15-interruption-start"),
            this.emit(kx.IOS_15_16_INTERRUPTION_START);
        }),
        dF(this, "onLocalAudioTrackUnmute", async () => {
          EU.info("ios15-interruption-end"),
            "running" !== this.curState || this.duringInterruption
              ? EU.info("ios15-interruption-end-canceled")
              : (EF && (await EF.suspend()),
                this.emit(kx.IOS_15_16_INTERRUPTION_END));
        });
    }
    get duringInterruption() {
      return "running" === this.prevState && "interrupted" === this.curState;
    }
    bindInterruptDetectorTrack(e) {
      EU.debug("webaudio bindInterruptDetectorTrack ".concat(e.getTrackId())),
        this.interruptDetectorTrack ||
          ((this.interruptDetectorTrack = e),
          (this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute),
          (this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute));
    }
    unbindInterruptDetectorTrack(e) {
      EU.debug("webaudio unbindInterruptDetectorTrack ".concat(e.getTrackId())),
        this.interruptDetectorTrack &&
          this.interruptDetectorTrack === e &&
          (this.interruptDetectorTrack._mediaStreamTrack &&
            ((this.interruptDetectorTrack._mediaStreamTrack.onmute = null),
            (this.interruptDetectorTrack._mediaStreamTrack.onunmute = null)),
          (this.interruptDetectorTrack = void 0));
    }
  })();
  function gF() {
    if (!EF) {
      if (
        ((function() {
          if (!fF)
            return void EU.error("your browser is not support web audio");
          EU.info("create audio context");
          const e = hF({}, WM("WEBAUDIO_INIT_OPTIONS"));
          EU.debug("audio context init option:", JSON.stringify(e)),
            (EF = new fF(e)),
            (mF.curState = EF.state),
            (EF.onstatechange = () => {
              (mF.prevState = mF.curState),
                (mF.curState = EF ? EF.state : void 0);
              const { prevState: e, curState: t } = mF,
                i = "running" === t,
                s = "interrupted" === t,
                r = "running" === e,
                n = "suspended" === e,
                a = "interrupted" === e,
                o = vP().osVersion;
              (wP() || GP()) &&
                r &&
                s &&
                (EU.info("ios".concat(o, "-interruption-start")),
                mF.emit(kx.IOS_INTERRUPTION_START)),
                (wP() || GP()) &&
                  (n || a) &&
                  i &&
                  (EU.info("ios".concat(o, "-interruption-end")),
                  mF.emit(kx.IOS_INTERRUPTION_END)),
                e !== t && mF.emit(kx.STATE_CHANGE, t, e);
            }),
            setInterval(() => {
              var e;
              const t =
                null === (e = EF) || void 0 === e ? void 0 : e.currentTime;
              mF.currentTime !== t
                ? (mF.currentTimeStuckAt &&
                    (EU.debug("AudioContext current time resume at ".concat(t)),
                    (mF.currentTimeStuckAt = void 0)),
                  (mF.currentTime = t))
                : (t !== mF.currentTimeStuckAt &&
                    (yU
                      .reportApiInvoke(null, {
                        name: "WEB_AUDIO_CURRENT_TIME_STUCK",
                        options: { currentTime: t },
                        tag: mk.TRACER
                      })
                      .onSuccess(),
                    EU.warning(
                      "AudioContext current time stuck at ".concat(t)
                    )),
                  (mF.currentTimeStuckAt = t));
            }, 5e3),
            (async function(e) {
              const t = [
                "click",
                "contextmenu",
                "auxclick",
                "dblclick",
                "mousedown",
                "mouseup",
                "touchend",
                "keydown",
                "keyup"
              ];
              let i,
                s = !1,
                r = !1,
                n = !1;
              function a(t) {
                "running" === e.state
                  ? o(!1)
                  : wP() || GP()
                  ? "suspended" === e.state &&
                    (o(!0), t && e.resume().then(c, c))
                  : "closed" !== e.state && (o(!0), t && e.resume().then(c, c));
              }
              function o(e) {
                if (s !== e) {
                  s = e;
                  for (let i = 0, s = t; i < s.length; i += 1) {
                    const t = s[i];
                    e
                      ? window.addEventListener(t, d, {
                          capture: !0,
                          passive: !0
                        })
                      : window.removeEventListener(t, d, {
                          capture: !0,
                          passive: !0
                        });
                  }
                }
              }
              function c() {
                a(!1);
              }
              function d() {
                a(!0);
              }
              function l(e) {
                if (!n)
                  if (i.paused)
                    if (e) {
                      let t;
                      h(!1), (n = !0);
                      try {
                        (t = i.play()),
                          t
                            ? t.then(u, u)
                            : (i.addEventListener("playing", u),
                              i.addEventListener("abort", u),
                              i.addEventListener("error", u));
                      } catch (e) {
                        u();
                      }
                    } else h(!0);
                  else h(!1);
              }
              function h(e) {
                if (r !== e) {
                  r = e;
                  for (let i = 0, s = t; i < s.length; i++) {
                    const t = s[i];
                    e
                      ? window.addEventListener(t, p, {
                          capture: !0,
                          passive: !0
                        })
                      : window.removeEventListener(t, p, {
                          capture: !0,
                          passive: !0
                        });
                  }
                }
              }
              function u() {
                i.removeEventListener("playing", u),
                  i.removeEventListener("abort", u),
                  i.removeEventListener("error", u),
                  (n = !1),
                  l(!1);
              }
              function p() {
                l(!0);
              }
              if (wP()) {
                const t = e.createMediaStreamDestination(),
                  s = document.createElement("div");
                (s.innerHTML = "<audio x-webkit-airplay='deny'></audio>"),
                  (i = s.children.item(0)),
                  (i.controls = !1),
                  (i.disableRemotePlayback = !0),
                  (i.preload = "auto"),
                  (i.srcObject = t.stream),
                  l(!0);
              }
              mF.on(kx.STATE_CHANGE, function() {
                a(!0);
              }),
                a(!1);
            })(EF);
        })(),
        !EF)
      )
        throw new JP(zP.NOT_SUPPORTED, "can not create audio context");
      return EF;
    }
    return EF;
  }
  function _F(e) {
    if (
      (function() {
        if (null !== TF) return TF;
        const e = gF(),
          t = e.createBufferSource(),
          i = e.createGain(),
          s = e.createGain();
        t.connect(i), t.connect(s), t.disconnect(i);
        let r = !1;
        try {
          t.disconnect(i);
        } catch (e) {
          r = !0;
        }
        return t.disconnect(), (TF = r), r;
      })()
    )
      return;
    const t = e.connect,
      i = e.disconnect;
    (e.connect = (i, s, r) => (
      e._inputNodes || (e._inputNodes = []),
      e._inputNodes.includes(i) ||
        (i instanceof AudioNode
          ? (e._inputNodes.push(i), t.call(e, i, s, r))
          : t.call(e, i, s)),
      e
    )),
      (e.disconnect = (s, r, n) => {
        i.call(e), s ? Lk(e._inputNodes, s) : (e._inputNodes = []);
        for (const i of e._inputNodes) t.call(e, i);
      });
  }
  let TF = null;
  function SF(e, t) {
    let i = !1;
    const s = 1 / t;
    if (WM("DISABLE_WEBAUDIO")) {
      const t = window.setInterval(() => {
        i ? window.clearInterval(t) : e(performance.now() / 1e3);
      }, 1e3 * s);
    } else {
      const t = gF();
      let r = t.createGain();
      (r.gain.value = 0), r.connect(t.destination);
      const n = () => {
        if (i) return void (r = null);
        const a = t.createOscillator();
        (a.onended = n),
          a.connect(r),
          a.start(0),
          a.stop(t.currentTime + s),
          e(t.currentTime);
      };
      n();
    }
    return () => {
      i = !0;
    };
  }
  class vF {
    constructor() {
      dF(this, "context", void 0),
        dF(this, "analyserNode", void 0),
        dF(this, "sourceNode", void 0),
        (this.context = gF()),
        (this.analyserNode = this.context.createAnalyser()),
        (this.analyserNode.fftSize = 2048),
        (this.analyserNode.smoothingTimeConstant = 0.4);
    }
    updateSource(e) {
      if (e !== this.sourceNode) {
        if (this.sourceNode)
          try {
            this.sourceNode.disconnect(this.analyserNode);
          } catch (e) {}
        (this.sourceNode = e), null == e || e.connect(this.analyserNode);
      }
    }
    getVolumeLevel() {
      if (!this.sourceNode) return 0;
      if (
        (!this.context ||
          wP() ||
          GP() ||
          ("running" !== this.context.state && this.context.resume()),
        !this.analyserNode)
      )
        return 0;
      const e = new Float32Array(this.analyserNode.fftSize);
      if (this.analyserNode.getFloatTimeDomainData)
        this.analyserNode.getFloatTimeDomainData(e);
      else {
        const t = new Uint8Array(this.analyserNode.fftSize);
        this.analyserNode.getByteTimeDomainData(t);
        for (let i = 0; i < e.length; ++i) e[i] = t[i] / 128 - 1;
      }
      const t = e.reduce((e, t) => e + t * t, 0) / e.length;
      return Math.max(10 * Math.log10(t) + 100, 0) / 100;
    }
    getAnalyserNode() {
      return this.analyserNode;
    }
    rebuildAnalyser() {
      try {
        var e, t;
        null === (e = this.sourceNode) ||
          void 0 === e ||
          e.disconnect(this.analyserNode),
          (this.analyserNode = this.context.createAnalyser()),
          (this.analyserNode.fftSize = 2048),
          (this.analyserNode.smoothingTimeConstant = 0.4),
          null === (t = this.sourceNode) ||
            void 0 === t ||
            t.connect(this.analyserNode);
      } catch (e) {
        EU.warning("rebuild analyser node failed.");
      }
    }
    destroy() {
      this.updateSource(void 0);
    }
  }
  class RF extends uk {
    get processSourceNode() {
      return this.sourceNode;
    }
    set processedNode(e) {
      var t;
      if (!this.isDestroyed && this._processedNode !== e) {
        try {
          var i;
          null === (i = this.sourceNode) ||
            void 0 === i ||
            i.disconnect(this.outputNode);
        } catch (e) {}
        null === (t = this._processedNode) || void 0 === t || t.disconnect(),
          (this._processedNode = e),
          this.connect();
      }
    }
    get processedNode() {
      return this._processedNode;
    }
    constructor() {
      super(),
        dF(this, "outputNode", void 0),
        dF(this, "outputTrack", void 0),
        dF(this, "isPlayed", !1),
        dF(this, "sourceNode", void 0),
        dF(this, "context", void 0),
        dF(this, "audioBufferNode", void 0),
        dF(this, "destNode", void 0),
        dF(this, "audioOutputLevel", 0),
        dF(this, "volumeLevelAnalyser", void 0),
        dF(this, "_processedNode", void 0),
        dF(this, "playNode", void 0),
        dF(this, "isDestroyed", !1),
        dF(this, "onNoAudioInput", void 0),
        dF(this, "isNoAudioInput", !1),
        dF(this, "_noAudioInputCount", 0),
        (this.context = gF()),
        (this.playNode = this.context.destination),
        (this.outputNode = this.context.createGain()),
        _F(this.outputNode),
        (this.volumeLevelAnalyser = new vF());
    }
    startGetAudioBuffer(e) {
      this.audioBufferNode ||
        ((this.audioBufferNode = this.context.createScriptProcessor(e)),
        this.outputNode.connect(this.audioBufferNode),
        this.audioBufferNode.connect(this.context.destination),
        (this.audioBufferNode.onaudioprocess = e => {
          this.emit(
            Xx.ON_AUDIO_BUFFER,
            (function(e) {
              for (let t = 0; t < e.outputBuffer.numberOfChannels; t += 1) {
                const i = e.outputBuffer.getChannelData(t);
                for (let e = 0; e < i.length; e += 1) i[e] = 0;
              }
              return e.inputBuffer;
            })(e)
          );
        }));
    }
    stopGetAudioBuffer() {
      this.audioBufferNode &&
        ((this.audioBufferNode.onaudioprocess = null),
        this.outputNode.disconnect(this.audioBufferNode),
        (this.audioBufferNode = void 0));
    }
    createOutputTrack() {
      if (!Lx().webAudioMediaStreamDest)
        throw new JP(
          zP.NOT_SUPPORTED,
          "your browser is not support audio processor"
        );
      return (
        (this.destNode && this.outputTrack) ||
          ((this.destNode = this.context.createMediaStreamDestination()),
          this.outputNode.connect(this.destNode),
          (this.outputTrack = this.destNode.stream.getAudioTracks()[0])),
        this.outputTrack
      );
    }
    play(e) {
      "running" !== this.context.state &&
        Pk(() => {
          mF.emit("autoplay-failed");
        }),
        (this.isPlayed = !0),
        (this.playNode = e || this.context.destination),
        this.outputNode.connect(this.playNode);
    }
    stop() {
      if (this.isPlayed)
        try {
          this.outputNode.disconnect(this.playNode);
        } catch (e) {}
      this.isPlayed = !1;
    }
    getAccurateVolumeLevel() {
      return this.volumeLevelAnalyser.getVolumeLevel();
    }
    async checkHasAudioInput() {
      let e =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      if (e > 5)
        return (
          (this.isNoAudioInput = !0),
          this.onNoAudioInput && this.onNoAudioInput(),
          !1
        );
      wP() || GP()
        ? "suspended" === this.context.state && this.context.resume()
        : "running" !== this.context.state && this.context.resume();
      const t = this.volumeLevelAnalyser.getAnalyserNode();
      let i;
      t.getFloatTimeDomainData
        ? ((i = new Float32Array(t.fftSize)), t.getFloatTimeDomainData(i))
        : ((i = new Uint8Array(t.fftSize)), t.getByteTimeDomainData(i));
      let s = !1;
      for (let e = 0; e < i.length; e++) 0 !== i[e] && (s = !0);
      return s
        ? ((this.isNoAudioInput = !1), !0)
        : (await Wk(200), (await this.checkHasAudioInput(e ? e + 1 : 1)) && s);
    }
    getAudioVolume() {
      return this.outputNode.gain.value;
    }
    setVolume(e) {
      this.outputNode.gain.setValueAtTime(e, this.context.currentTime);
    }
    destroy() {
      this.disconnect(),
        this.stop(),
        (this.isDestroyed = !0),
        (this.onNoAudioInput = void 0);
    }
    disconnect() {
      var e, t;
      null === (e = this.processedNode) || void 0 === e || e.disconnect(),
        null === (t = this.sourceNode) || void 0 === t || t.disconnect(),
        this.outputNode && this.outputNode.disconnect();
    }
    connect() {
      var e;
      this.processedNode
        ? null === (e = this.processedNode) ||
          void 0 === e ||
          e.connect(this.outputNode)
        : this.sourceNode && this.sourceNode.connect(this.outputNode),
        this.volumeLevelAnalyser.updateSource(this.outputNode);
    }
  }
  class yF extends RF {
    get isFreeze() {
      return !1;
    }
    constructor(e, t, i) {
      var s;
      if (
        (super(),
        dF(this, "sourceNode", void 0),
        dF(this, "track", void 0),
        dF(this, "clonedTrack", void 0),
        dF(this, "audioElement", void 0),
        dF(this, "isCurrentTrackCloned", !1),
        dF(this, "isRemoteTrack", !1),
        dF(this, "originVolumeLevelAnalyser", void 0),
        dF(this, "rebuildWebAudio", async () => {
          if (
            (EU.debug("ready to rebuild web audio, state:", this.context.state),
            this.isNoAudioInput && (await this.checkHasAudioInput()),
            !this.isNoAudioInput || this.isDestroyed)
          )
            return (
              document.body.removeEventListener(
                "click",
                this.rebuildWebAudio,
                !0
              ),
              void EU.debug(
                "rebuild web audio success, current volume status",
                this.getAccurateVolumeLevel()
              )
            );
          this.context.resume().then(() => EU.info("resume success")),
            EU.debug("rebuild web audio because of ios 12 bugs"),
            this.disconnect();
          const e = this.track;
          (this.track = this.track.clone()),
            this.isCurrentTrackCloned
              ? e.stop()
              : (this.isCurrentTrackCloned = !0);
          const t = new MediaStream([this.track]);
          (this.sourceNode = this.context.createMediaStreamSource(t)),
            _F(this.sourceNode),
            this.volumeLevelAnalyser.rebuildAnalyser();
          const i = this.outputNode.gain.value;
          (this.outputNode = this.context.createGain()),
            this.outputNode.gain.setValueAtTime(i, this.context.currentTime),
            _F(this.outputNode),
            this.emit(Xx.UPDATE_SOURCE),
            this.connect(),
            (this.audioElement.srcObject = t),
            this.isPlayed && this.play(this.playNode),
            this.checkHasAudioInput();
        }),
        "audio" !== e.kind)
      )
        throw new JP(zP.UNEXPECTED_ERROR);
      this.track = e;
      const r = new MediaStream([this.track]);
      if (
        ((this.isRemoteTrack = !!t),
        (this.sourceNode = this.context.createMediaStreamSource(r)),
        _F(this.sourceNode),
        i)
      ) {
        const e = i.clone();
        (e.enabled = !0),
          (this.clonedTrack = e),
          EU.debug(
            "create an unmuted track "
              .concat(e.id, " from the original track ")
              .concat(i.id, " to get the volume")
          );
        const t = this.context.createMediaStreamSource(new MediaStream([e]));
        _F(t),
          (this.originVolumeLevelAnalyser = new vF()),
          this.originVolumeLevelAnalyser.updateSource(t);
      }
      this.connect(),
        (this.audioElement = document.createElement("audio")),
        (this.audioElement.srcObject = r);
      const n = vP();
      t &&
        n.os === mP.IOS &&
        Number(
          null === (s = n.osVersion) || void 0 === s ? void 0 : s.split(".")[0]
        ) < 15 &&
        (mF.on(kx.STATE_CHANGE, () => {
          "suspended" === this.context.state
            ? document.body.addEventListener("click", this.rebuildWebAudio, !0)
            : "running" === this.context.state && this.rebuildWebAudio();
        }),
        this.checkHasAudioInput().then(e => {
          e ||
            document.body.addEventListener("click", this.rebuildWebAudio, !0);
        }));
    }
    updateTrack(e) {
      this.sourceNode.disconnect(),
        (this.track = e),
        (this.isCurrentTrackCloned = !1);
      const t = new MediaStream([e]);
      (this.sourceNode = this.context.createMediaStreamSource(t)),
        _F(this.sourceNode),
        this.processedNode || this.sourceNode.connect(this.outputNode),
        this.emit(Xx.UPDATE_SOURCE),
        (this.audioElement.srcObject = t);
    }
    destroy() {
      var e;
      (this.audioElement.srcObject = null),
        this.audioElement.remove(),
        mF.off("state-change", this.rebuildWebAudio),
        null === (e = this.originVolumeLevelAnalyser) ||
          void 0 === e ||
          e.destroy(),
        (this.clonedTrack = void 0),
        super.destroy();
    }
    createMediaStreamSourceNode(e) {
      return this.context.createMediaStreamSource(new MediaStream([e]));
    }
    updateOriginTrack(e) {
      const t = e.clone();
      (t.enabled = !0),
        this.clonedTrack && (this.clonedTrack.stop(), (this.clonedTrack = t)),
        EU.debug(
          "create an unmuted track "
            .concat(t.id, " from the original track ")
            .concat(e.id, " to get the volume")
        );
      const i = this.context.createMediaStreamSource(new MediaStream([t]));
      _F(i),
        this.originVolumeLevelAnalyser &&
          this.originVolumeLevelAnalyser.updateSource(i);
    }
    getOriginVolumeLevel() {
      return this.originVolumeLevelAnalyser
        ? this.originVolumeLevelAnalyser.getVolumeLevel()
        : this.getAccurateVolumeLevel();
    }
  }
  async function AF(e, t, i) {
    const s = (e, t) =>
        e
          ? "number" != typeof e
            ? e.max || e.exact || e.ideal || e.min || t
            : e
          : t,
      r = {
        audio: !!i && { mandatory: { chromeMediaSource: "desktop" } },
        video: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: e,
            maxHeight: s(t.height, 1080),
            maxWidth: s(t.width, 1920)
          }
        }
      };
    return (
      t.frameRate && "number" != typeof t.frameRate
        ? ((r.video.mandatory.maxFrameRate = t.frameRate.max),
          (r.video.mandatory.minFrameRate = t.frameRate.min))
        : "number" == typeof t.frameRate &&
          (r.video.mandatory.maxFrameRate = t.frameRate),
      await navigator.mediaDevices.getUserMedia(r)
    );
  }
  async function IF(e, t) {
    const i = await (async function(e) {
        let t = ["window", "screen"];
        ("application" !== e && "window" !== e) || (t = ["window"]),
          "screen" === e && (t = ["screen"]);
        const i = fk();
        if (!i)
          throw (console.error(
            "failed to fetch electron, please mount it to window"
          ),
          new JP(zP.ELECTRON_IS_NULL));
        let s = null;
        try {
          var r;
          s =
            (null === (r = i.desktopCapturer) || void 0 === r
              ? void 0
              : r.getSources({ types: t })) ||
            i.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t });
        } catch (e) {
          s = null;
        }
        (s && s.then) ||
          (s = new Promise((e, s) => {
            i.desktopCapturer.getSources({ types: t }, (t, i) => {
              t ? s(t) : e(i);
            });
          }));
        try {
          return await s;
        } catch (e) {
          throw new JP(
            zP.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR,
            e.toString()
          );
        }
      })(e.mediaSource),
      { sourceId: s, audio: r } = await (function(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return new Promise((i, s) => {
          const r = document.createElement("div");
          (r.innerText = "share screen"),
            r.setAttribute(
              "style",
              "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;"
            );
          const n = document.createElement("div");
          n.setAttribute(
            "style",
            "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;"
          );
          const a = document.createElement("div");
          (a.innerText =
            "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share."),
            a.setAttribute("style", "height: 12%;");
          const o = document.createElement("div");
          o.setAttribute(
            "style",
            "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;"
          );
          const c = document.createElement("div");
          c.setAttribute(
            "style",
            "display: flex; justify-content: space-between; padding: 16px 0;"
          );
          const d = document.createElement("button");
          (d.innerHTML = "cancel"),
            d.setAttribute("style", "width: 85px;"),
            (d.onclick = () => {
              document.body.removeChild(u);
              const e = new Error("NotAllowedError");
              (e.name = "NotAllowedError"), s(e);
            });
          let l = t;
          const h = document.createElement("div");
          if (t) {
            const e = document.createElement("input");
            e.setAttribute("type", "checkbox");
            const t = document.createElement("span");
            e.setAttribute("style", "margin-right: 6px;"),
              (t.innerText = "Share audio"),
              (e.checked = l),
              (e.onchange = () => {
                l = e.checked;
              }),
              h.appendChild(e),
              h.appendChild(t);
          }
          c.appendChild(h),
            c.appendChild(d),
            n.appendChild(a),
            n.appendChild(o),
            n.appendChild(c);
          const u = document.createElement("div");
          u.setAttribute(
            "style",
            "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"
          ),
            u.appendChild(r),
            u.appendChild(n),
            document.body.appendChild(u),
            e.map(e => {
              if (e.id) {
                const t = document.createElement("div");
                t.setAttribute(
                  "style",
                  "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;"
                );
                let s = e.thumbnail;
                try {
                  const { width: e } = s.getSize();
                  e > 1920 && (s = s.resize({ width: 1920 }));
                } catch (e) {
                  throw (e &&
                    e.message.startsWith("Illegal invocation") &&
                    console.error(
                      "Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"
                    ),
                  e);
                }
                (t.innerHTML =
                  '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' +
                  s.toDataURL() +
                  ' /></div><span style="\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' +
                  e.name.replace(/[\u00A0-\u9999<>\&]/g, function(e) {
                    return "&#" + e.charCodeAt(0) + ";";
                  }) +
                  "</span>"),
                  (t.onclick = () => {
                    document.body.removeChild(u),
                      i({ sourceId: e.id, audio: l });
                  }),
                  o.appendChild(t);
              }
            });
        });
      })(i, t);
    return await AF(s, e, r);
  }
  const CF = new sM("safari");
  let bF = !1,
    OF = !1;
  async function DF(e, t) {
    let i = 0,
      s = null;
    for (; i < 2; )
      try {
        s = await wF(e, t, i > 0);
        break;
      } catch (e) {
        if (e instanceof JP)
          throw (EU.error("[".concat(t, "] ").concat(e.toString())), e);
        const s = LF(e.name || e.code || e, e.message);
        if (s.code === zP.MEDIA_OPTION_INVALID) {
          EU.debug("[".concat(t, "] detect media option invalid, retry")),
            (i += 1),
            await Wk(500);
          continue;
        }
        throw (EU.error("[".concat(t, "] ").concat(s.toString())), s);
      }
    if (!s)
      throw new JP(
        zP.UNEXPECTED_ERROR,
        "can not find stream after getUserMedia"
      );
    return s;
  }
  async function wF(e, t, i) {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
      throw new JP(zP.NOT_SUPPORTED, "can not find getUserMedia");
    i &&
      (e.video && (delete e.video.width, delete e.video.height),
      e.screen && (delete e.screen.width, delete e.screen.height));
    const s = Lx(),
      r = new MediaStream();
    if (
      (e.audioSource && r.addTrack(e.audioSource),
      e.videoSource && r.addTrack(e.videoSource),
      !e.audio && !e.video && !e.screen)
    )
      return EU.debug("Using Video Source/ Audio Source"), r;
    if (e.screen)
      if (fk())
        e.screen.sourceId
          ? NF(r, await AF(e.screen.sourceId, e.screen, !!e.screenAudio))
          : NF(r, await IF(e.screen, !!e.screenAudio));
      else if (CP() && e.screen.extensionId && e.screen.mandatory) {
        if (!s.getStreamFromExtension)
          throw new JP(
            zP.NOT_SUPPORTED,
            "This browser does not support screen sharing"
          );
        EU.debug(
          "[".concat(
            t,
            '] Screen access on chrome stable, looking for extension"'
          )
        );
        const i = await ((a = e.screen.extensionId),
        (o = t),
        new Promise((e, t) => {
          try {
            chrome.runtime.sendMessage(a, { getStream: !0 }, i => {
              if (!i || !i.streamId)
                return (
                  EU.error(
                    "[".concat(
                      o,
                      "] No response from Chrome Plugin. Plugin not installed properly"
                    ),
                    i
                  ),
                  void t(
                    new JP(
                      zP.CHROME_PLUGIN_NO_RESPONSE,
                      "No response from Chrome Plugin. Plugin not installed properly"
                    )
                  )
                );
              e(i.streamId);
            });
          } catch (e) {
            EU.error(
              "["
                .concat(o, "] AgoraRTC screensharing plugin is not accessible(")
                .concat(a, ")"),
              e.toString()
            ),
              t(new JP(zP.CHROME_PLUGIN_NOT_INSTALL));
          }
        }));
        (e.screen.mandatory.chromeMediaSourceId = i),
          NF(
            r,
            await navigator.mediaDevices.getUserMedia({
              video: { mandatory: e.screen.mandatory }
            })
          );
      } else if (s.getDisplayMedia) {
        var n;
        e.screen.mediaSource && Gx(e.screen.mediaSource);
        const i = {
            width: e.screen.width,
            height: e.screen.height,
            frameRate: e.screen.frameRate,
            displaySurface:
              null !== (n = e.screen.displaySurface) && void 0 !== n
                ? n
                : "screen" === e.screen.mediaSource
                ? "monitor"
                : e.screen.mediaSource
          },
          {
            selfBrowserSurface: s,
            surfaceSwitching: a,
            systemAudio: o,
            preferCurrentTab: c
          } = e.screen,
          d = {
            selfBrowserSurface: s,
            surfaceSwitching: a,
            systemAudio: o,
            preferCurrentTab: c
          };
        !s && delete d.selfBrowserSurface,
          !a && delete d.surfaceSwitching,
          !o && delete d.systemAudio,
          !c && delete d.preferCurrentTab,
          EU.debug(
            "[".concat(t, "] getDisplayMedia:"),
            JSON.stringify({ video: i, audio: e.screenAudio, controls: d })
          ),
          NF(
            r,
            await navigator.mediaDevices.getDisplayMedia(
              hF({ video: i, audio: e.screenAudio }, d)
            )
          );
      } else {
        if (!DP())
          throw (EU.error(
            "[".concat(t, "] This browser does not support screenSharing")
          ),
          new JP(
            zP.NOT_SUPPORTED,
            "This browser does not support screen sharing"
          ));
        {
          e.screen.mediaSource && Gx(e.screen.mediaSource);
          const i = {
            video: {
              mediaSource: e.screen.mediaSource,
              width: e.screen.width,
              height: e.screen.height,
              frameRate: e.screen.frameRate
            }
          };
          EU.debug("[".concat(t, "] getUserMedia: ").concat(JSON.stringify(i))),
            NF(r, await navigator.mediaDevices.getUserMedia(i));
        }
      }
    var a, o;
    if (!e.video && !e.audio) return r;
    let c = { video: e.video, audio: e.audio },
      d = WM("MEDIA_DEVICE_CONSTRAINTS");
    if (d)
      try {
        "string" == typeof d && (d = JSON.parse(d)), (c = Qk(c, d));
      } catch (e) {}
    EU.debug("[".concat(t, "] GetUserMedia"), JSON.stringify(c)), vP();
    let l,
      h = null;
    (bP() || wP() || IP()) && (h = await CF.lock());
    try {
      l = await navigator.mediaDevices.getUserMedia(c);
    } catch (e) {
      throw (h && h(), e);
    }
    return c.audio && (bF = !0), c.video && (OF = !0), NF(r, l), h && h(), r;
  }
  function LF(e, t) {
    switch (e) {
      case "Starting video failed":
      case "OverconstrainedError":
      case "TrackStartError":
        return new JP(zP.MEDIA_OPTION_INVALID, "".concat(e, ": ").concat(t));
      case "NotFoundError":
      case "DevicesNotFoundError":
        return new JP(zP.DEVICE_NOT_FOUND, "".concat(e, ": ").concat(t));
      case "NotSupportedError":
        return new JP(zP.NOT_SUPPORTED, "".concat(e, ": ").concat(t));
      case "NotReadableError":
        return new JP(zP.NOT_READABLE, "".concat(e, ": ").concat(t));
      case "InvalidStateError":
      case "NotAllowedError":
      case "PERMISSION_DENIED":
      case "PermissionDeniedError":
        return new JP(zP.PERMISSION_DENIED, "".concat(e, ": ").concat(t));
      case "ConstraintNotSatisfiedError":
        return new JP(
          zP.CONSTRAINT_NOT_SATISFIED,
          "".concat(e, ": ").concat(t)
        );
      default:
        return (
          EU.error("getUserMedia unexpected error", e),
          new JP(zP.UNEXPECTED_ERROR, "".concat(e, ": ").concat(t))
        );
    }
  }
  function NF(e, t) {
    const i = e.getVideoTracks()[0],
      s = e.getAudioTracks()[0],
      r = t.getVideoTracks()[0],
      n = t.getAudioTracks()[0];
    n && (s && e.removeTrack(s), e.addTrack(n)),
      r && (i && e.removeTrack(i), e.addTrack(r));
  }
  const PF = new (class extends uk {
    get state() {
      return this._state;
    }
    set state(e) {
      e !== this._state && (this.emit(rF.STATE_CHANGE, e), (this._state = e));
    }
    constructor() {
      super(),
        dF(this, "_state", sF.IDLE),
        dF(this, "isAccessMicrophonePermission", !1),
        dF(this, "isAccessCameraPermission", !1),
        dF(this, "lastAccessMicrophonePermission", !1),
        dF(this, "lastAccessCameraPermission", !1),
        dF(this, "checkdeviceMatched", !1),
        dF(this, "deviceInfoMap", new Map()),
        this.init()
          .then(() => {
            navigator.mediaDevices.addEventListener &&
              navigator.mediaDevices.addEventListener(
                "devicechange",
                this.updateDevicesInfo.bind(this)
              ),
              window.setInterval(() => {
                (WM("ENUMERATE_DEVICES_INTERVAL") ||
                  ((WP() || yP() === mP.HARMONY_OS) && KP())) &&
                  this.updateDevicesInfo();
              }, WM("ENUMERATE_DEVICES_INTERVAL_TIME"));
          })
          .catch(e => EU.error(e.toString()));
    }
    async enumerateDevices(e, t) {
      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
        throw new JP(zP.NOT_SUPPORTED, "enumerateDevices() not supported.");
      const s = await navigator.mediaDevices.enumerateDevices(),
        r = this.checkMediaDeviceInfoIsOk(s);
      let n = !this.isAccessMicrophonePermission && e,
        a = !this.isAccessCameraPermission && t;
      r.audio && (n = !1), r.video && (a = !1);
      let o = null,
        c = null,
        d = null;
      if (!i && (n || a)) {
        if (
          (CF.isLocked &&
            (EU.debug("[device manager] wait GUM lock"),
            (await CF.lock())(),
            EU.debug("[device manager] GUM unlock")),
          bF && ((n = !1), (this.isAccessMicrophonePermission = !0)),
          OF && ((a = !1), (this.isAccessCameraPermission = !0)),
          EU.debug(
            "[device manager] check media device permissions",
            e,
            t,
            n,
            a
          ),
          n && a)
        ) {
          try {
            d = await navigator.mediaDevices.getUserMedia({
              audio: !0,
              video: !0
            });
          } catch (e) {
            const t = LF(e.name || e.code || e, e.message);
            if (t.code === zP.PERMISSION_DENIED) throw t;
            EU.warning("getUserMedia failed in getDevices", t);
          }
          (this.isAccessCameraPermission = !0),
            (this.isAccessMicrophonePermission = !0);
        } else if (n) {
          try {
            o = await navigator.mediaDevices.getUserMedia({ audio: e });
          } catch (e) {
            const t = LF(e.name || e.code || e, e.message);
            if (t.code === zP.PERMISSION_DENIED) throw t;
            EU.warning("getUserMedia failed in getDevices", t);
          }
          this.isAccessMicrophonePermission = !0;
        } else if (a) {
          try {
            c = await navigator.mediaDevices.getUserMedia({ video: t });
          } catch (e) {
            const t = LF(e.name || e.code || e, e.message);
            if (t.code === zP.PERMISSION_DENIED) throw t;
            EU.warning("getUserMedia failed in getDevices", t);
          }
          this.isAccessCameraPermission = !0;
        }
        EU.debug("[device manager] mic permission", e, "cam permission", t);
      }
      try {
        const e = await navigator.mediaDevices.enumerateDevices();
        return (
          o && o.getTracks().forEach(e => e.stop()),
          c && c.getTracks().forEach(e => e.stop()),
          d && d.getTracks().forEach(e => e.stop()),
          (o = null),
          (c = null),
          (d = null),
          e
        );
      } catch (e) {
        return (
          o && o.getTracks().forEach(e => e.stop()),
          c && c.getTracks().forEach(e => e.stop()),
          d && d.getTracks().forEach(e => e.stop()),
          (o = null),
          (c = null),
          (d = null),
          new JP(zP.ENUMERATE_DEVICES_FAILED, e.toString()).throw()
        );
      }
    }
    async getRecordingDevices() {
      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      return (await this.enumerateDevices(!0, !1, e)).filter(
        e => "audioinput" === e.kind
      );
    }
    async getCamerasDevices() {
      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      return (await this.enumerateDevices(!1, !0, e)).filter(
        e => "videoinput" === e.kind
      );
    }
    async getSpeakers() {
      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      return (await this.enumerateDevices(!0, !1, e)).filter(
        e => "audiooutput" === e.kind
      );
    }
    searchDeviceIdByName(e) {
      let t = null;
      return (
        this.deviceInfoMap.forEach(i => {
          i.device.label === e && (t = i.device.deviceId);
        }),
        t
      );
    }
    async getDeviceById(e) {
      const t = (await this.enumerateDevices(!0, !0, !0)).find(
        t => t.deviceId === e
      );
      if (!t) throw new JP(zP.DEVICE_NOT_FOUND, "deviceId: ".concat(e));
      return t;
    }
    async init() {
      this.state = sF.INITING;
      try {
        await this.updateDevicesInfo(), (this.state = sF.INITEND);
      } catch (e) {
        if (
          ((this.state = sF.IDLE),
          !("boolean" == typeof isSecureContext
            ? isSecureContext
            : "https:" === location.protocol ||
              "file:" === location.protocol ||
              "localhost" === location.hostname ||
              "127.0.0.1" === location.hostname ||
              "::1" === location.hostname))
        )
          throw new JP(
            zP.WEB_SECURITY_RESTRICT,
            "Your context is limited by web security, please try using https protocol or localhost."
          );
        throw (EU.warning(
          "Device Detection functionality cannot start properly.",
          e.toString()
        ),
        e);
      }
    }
    async updateDevicesInfo() {
      const e = await this.enumerateDevices(!0, !0, !0),
        t = Date.now(),
        i = [];
      if (e[0] && e[0].label && !1 === this.checkdeviceMatched) {
        this.checkdeviceMatched = !0;
        const t = e.find(
            e => "audioinput" === e.kind && "default" === e.deviceId
          ),
          i = e.find(e => "audiooutput" === e.kind && "default" === e.deviceId);
        t && i
          ? i.groupId === t.groupId
            ? EU.debug(
                "[device-check] default input "
                  .concat(t.label, " and output ")
                  .concat(i.label, " is the same group")
              )
            : EU.debug(
                "[device-check] default input "
                  .concat(t.label, " and output ")
                  .concat(i.label, " is not the same group")
              )
          : EU.debug("[device-check] default input or output not found");
      }
      const s = this.checkMediaDeviceInfoIsOk(e);
      if (
        (e.forEach(e => {
          if (!e.deviceId) return;
          const s = this.deviceInfoMap.get(
            "".concat(e.kind, "_").concat(e.deviceId)
          );
          if ("ACTIVE" !== (s ? s.state : "INACTIVE")) {
            const s = { initAt: t, updateAt: t, device: e, state: "ACTIVE" };
            this.deviceInfoMap.set(
              "".concat(e.kind, "_").concat(e.deviceId),
              s
            ),
              i.push(s);
          }
          s && (s.updateAt = t);
        }),
        this.deviceInfoMap.forEach((e, s) => {
          "ACTIVE" === e.state &&
            e.updateAt !== t &&
            ((e.state = "INACTIVE"), i.push(e));
        }),
        this.state !== sF.INITEND)
      )
        return (
          s.audio &&
            ((this.lastAccessMicrophonePermission = !0),
            (this.isAccessMicrophonePermission = !0)),
          void (
            s.video &&
            ((this.lastAccessCameraPermission = !0),
            (this.isAccessCameraPermission = !0))
          )
        );
      i.forEach(e => {
        switch (e.device.kind) {
          case "audioinput":
            this.lastAccessMicrophonePermission &&
              this.isAccessMicrophonePermission &&
              this.emit(rF.RECORDING_DEVICE_CHANGED, e);
            break;
          case "videoinput":
            this.lastAccessCameraPermission &&
              this.isAccessCameraPermission &&
              this.emit(rF.CAMERA_DEVICE_CHANGED, e);
            break;
          case "audiooutput":
            this.lastAccessMicrophonePermission &&
              this.isAccessMicrophonePermission &&
              this.emit(rF.PLAYOUT_DEVICE_CHANGED, e);
        }
      }),
        s.audio &&
          ((this.lastAccessMicrophonePermission = !0),
          (this.isAccessMicrophonePermission = !0)),
        s.video &&
          ((this.lastAccessCameraPermission = !0),
          (this.isAccessCameraPermission = !0));
    }
    checkMediaDeviceInfoIsOk(e) {
      const t = e.filter(e => "audioinput" === e.kind),
        i = e.filter(e => "videoinput" === e.kind),
        s = { audio: !1, video: !1 };
      for (const e of t)
        if (e.label && e.deviceId) {
          s.audio = !0;
          break;
        }
      for (const e of i)
        if (e.label && e.deviceId) {
          s.video = !0;
          break;
        }
      return s;
    }
  })();
  let kF = !1;
  const MF = new (class extends uk {
    constructor() {
      super(...arguments),
        dF(this, "onAutoplayFailed", void 0),
        dF(this, "onAudioAutoplayFailed", void 0);
    }
  })();
  function UF() {
    if (kF)
      return (
        MF.onAutoplayFailed && MF.onAutoplayFailed(), MF.emit("autoplay-failed")
      );
    const e = t => {
      t.preventDefault(),
        (kF = !1),
        YP()
          ? document.body.removeEventListener("click", e, !0)
          : (document.body.removeEventListener("touchstart", e, !0),
            document.body.removeEventListener("mousedown", e, !0));
    };
    (kF = !0),
      YP()
        ? document.body.addEventListener("click", e, !0)
        : (document.body.addEventListener("touchstart", e, !0),
          document.body.addEventListener("mousedown", e, !0)),
      EU.info(
        "detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"
      ),
      MF.onAutoplayFailed
        ? MF.onAutoplayFailed()
        : MF.onAudioAutoplayFailed
        ? EU.warning(
            "AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."
          )
        : EU.warning(
            "We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."
          ),
      MF.emit("autoplay-failed");
  }
  function xF(e, t, i, s) {
    if (!e) return;
    const r = yU.getBaseInfoBySessionId(e);
    if (!r) return;
    const n = r.info,
      a = Date.now(),
      o = hF(
        hF({}, n),
        {},
        {
          vid: void 0 === n.vid ? 0 : Number(n.vid),
          lts: a,
          elapse: a - r.startTime,
          cbRegistered:
            MF.onAutoplayFailed || MF.onAudioAutoplayFailed ? 1 : -1,
          errorMsg: i,
          mediaType: t,
          trackId: s,
          extend: void 0
        }
      );
    yU.send({ type: SU.AUTOPLAY_FAILED, data: o }, !0);
  }
  const FF = [
      "play",
      "playing",
      "loadeddata",
      "canplay",
      "pause",
      "stalled",
      "suspend",
      "waiting",
      "abort",
      "emptied",
      "ended",
      "error"
    ],
    BF = new (class {
      constructor() {
        dF(this, "onAutoplayFailed", void 0),
          dF(this, "elementMap", new Map()),
          dF(this, "elementStateMap", new Map()),
          dF(this, "elementsNeedToResume", []),
          dF(this, "sinkIdMap", new Map()),
          dF(this, "autoResumeAfterInterruption", e => {
            Array.from(this.elementMap.entries()).forEach(t => {
              let [i, s] = t;
              const r = this.elementStateMap.get(i),
                n = s.srcObject.getAudioTracks()[0],
                a = n && n.readyState;
              if (
                (EU.debug(
                  "resume after interrupted, ele: "
                    .concat(r, " audio: ")
                    .concat(a, " ")
                    .concat(e)
                ),
                "live" === a)
              ) {
                if (e) return s.pause(), void s.play();
                if ("running" === mF.curState)
                  return FP()
                    ? (s.pause(), void s.play())
                    : void (r && "paused" === r && s.play());
              }
            });
          }),
          dF(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            Array.from(this.elementMap.entries()).forEach(e => {
              let [t, i] = e;
              const s = i.srcObject.getAudioTracks()[0];
              s &&
                "live" === s.readyState &&
                (EU.debug(
                  "auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"
                ),
                i.pause(),
                i.play());
            });
          }),
          this.autoResumeAudioElement(),
          mF.on(kx.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption),
          mF.on(
            kx.IOS_15_16_INTERRUPTION_END,
            this.autoResumeAfterInterruptionOnIOS15_16
          ),
          mF.on(kx.STATE_CHANGE, () => {
            wP() &&
              "suspended" === mF.prevState &&
              "running" === mF.curState &&
              this.autoResumeAfterInterruption();
          });
      }
      async setSinkID(e, t) {
        const i = this.elementMap.get(e);
        if ((this.sinkIdMap.set(e, t), i))
          try {
            await i.setSinkId(t);
          } catch (e) {
            throw new JP(
              zP.PERMISSION_DENIED,
              "can not set sink id: " + e.toString()
            );
          }
      }
      play(e, t, i, s) {
        if (this.elementMap.has(t)) return;
        const r = document.createElement("audio");
        (r.autoplay = !0),
          (r.srcObject = new MediaStream([e])),
          this.bindAudioElementEvents(t, r),
          this.elementMap.set(t, r),
          this.elementStateMap.set(t, nF.INIT),
          this.setVolume(t, i);
        const n = this.sinkIdMap.get(t);
        if (n)
          try {
            r.setSinkId(n).catch(e => {
              EU.warning("[".concat(t, "] set sink id failed"), e.toString());
            });
          } catch (e) {
            EU.warning("[".concat(t, "] set sink id failed"), e.toString());
          }
        const a = r.play();
        a &&
          a.then &&
          a.catch(e => {
            s && xF(s, "audio", e.message, t),
              EU.warning("audio element play warning", e.toString()),
              this.elementMap.has(t) &&
                "NotAllowedError" === e.name &&
                (EU.warning("detected audio element autoplay failed"),
                this.elementsNeedToResume.push(r),
                Pk(() => {
                  this.onAutoplayFailed && this.onAutoplayFailed(), UF();
                }));
          });
      }
      updateTrack(e, t) {
        const i = this.elementMap.get(e);
        i && (i.srcObject = new MediaStream([t]));
      }
      isPlaying(e) {
        return (
          this.elementMap.has(e) && "playing" === this.elementStateMap.get(e)
        );
      }
      setVolume(e, t) {
        const i = this.elementMap.get(e);
        i && ((t = Math.max(0, Math.min(100, t))), (i.volume = t / 100));
      }
      stop(e) {
        const t = this.elementMap.get(e);
        if ((this.sinkIdMap.delete(e), !t)) return;
        const i = this.elementsNeedToResume.indexOf(t);
        this.elementsNeedToResume.splice(i, 1),
          (t.srcObject = null),
          t.remove(),
          this.elementMap.delete(e),
          this.elementStateMap.delete(e);
      }
      bindAudioElementEvents(e, t) {
        FF.forEach(i => {
          t.addEventListener(i, i => {
            const s = this.elementStateMap.get(e),
              r = "pause" === i.type ? "paused" : i.type;
            if (
              (EU.debug(
                "["
                  .concat(e, "] audio-element-status change ")
                  .concat(s, " => ")
                  .concat(r)
              ),
              "error" === i.type)
            ) {
              const i = null == t ? void 0 : t.error;
              i &&
                EU.error(
                  "["
                    .concat(e, "] media error, code: ")
                    .concat(i.code, ", message: ")
                    .concat(i.message)
                );
            }
            this.elementStateMap.set(e, r);
          });
        });
      }
      getPlayerState(e) {
        return this.elementStateMap.get(e) || "uninit";
      }
      autoResumeAudioElement() {
        const e = () => {
          this.elementsNeedToResume.forEach(e => {
            e.play()
              .then(e => {
                EU.debug("Auto resume audio element success");
              })
              .catch(e => {
                EU.warning("Auto resume audio element failed!", e);
              });
          }),
            (this.elementsNeedToResume = []);
        };
        new Promise(e => {
          document.body ? e() : window.addEventListener("load", () => e());
        }).then(() => {
          YP()
            ? document.body.addEventListener("click", e, !0)
            : (document.body.addEventListener("touchstart", e, !0),
              document.body.addEventListener("mousedown", e, !0));
        });
      }
    })();
  function VF() {
    return function(e, t, i) {
      const s = i.value;
      return (
        "function" == typeof s &&
          (i.value = function() {
            this._isClosed &&
              new JP(
                zP.INVALID_OPERATION,
                "[".concat(this.getTrackId(), "] cannot operate a closed track")
              ).print("warning", EU);
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
              t[i] = arguments[i];
            const r = s.apply(this, t);
            return r instanceof Promise
              ? new Promise((e, t) => {
                  r.then(e).catch(t);
                })
              : r;
          }),
        i
      );
    };
  }
  class GF extends uk {
    constructor(e) {
      super(),
        dF(this, "name", "VideoProcessorDestination"),
        dF(this, "ID", "0"),
        dF(this, "_source", void 0),
        dF(this, "videoContext", void 0),
        dF(this, "inputTrack", void 0),
        (this.videoContext = e);
    }
    get kind() {
      return "video";
    }
    get enabled() {
      return !0;
    }
    pipe() {
      throw new JP(
        zP.NOT_SUPPORTED,
        "VideoProcessor cannot pipe to any other Processor"
      );
    }
    unpipe() {
      throw new JP(
        zP.NOT_SUPPORTED,
        "VideoProcessor cannot unpipe to any other Processor"
      );
    }
    enable() {}
    disable() {}
    updateInput(e) {
      if (e.context !== this.videoContext)
        throw new Error(
          "ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination)."
        );
      e.track &&
        e.track !== this.inputTrack &&
        ((this.videoContext.chained = !0),
        (this.inputTrack = e.track),
        this.emit(tF.ON_TRACK, e.track));
    }
    reset() {
      (this.inputTrack = void 0),
        (this.videoContext.chained = !1),
        this.emit(tF.ON_TRACK, void 0);
    }
  }
  class jF extends uk {
    set chained(e) {
      this._chained = e;
    }
    get chained() {
      return this._chained;
    }
    constructor(e, t) {
      super(),
        dF(this, "constraintsMap", new Map()),
        dF(this, "statsRegistry", []),
        dF(this, "usageRegistry", []),
        dF(this, "trackId", void 0),
        dF(this, "direction", void 0),
        dF(this, "_chained", !1),
        (this.trackId = e),
        (this.direction = t);
    }
    async getConstraints() {
      return await Ck(this, iF.REQUEST_CONSTRAINTS);
    }
    async requestApplyConstraints(e, t) {
      return (
        EU.info(
          "processor "
            .concat(t.name, " requestApplyConstraints for ")
            .concat(this.trackId)
        ),
        e && this.constraintsMap.set(t, e),
        bk(
          this,
          iF.REQUEST_UPDATE_CONSTRAINTS,
          Array.from(this.constraintsMap.values())
        )
      );
    }
    async requestRevertConstraints(e) {
      if (this.constraintsMap.has(e))
        return (
          EU.info(
            "processor "
              .concat(e.name, " requestRevertConstraints for ")
              .concat(this.trackId)
          ),
          this.constraintsMap.delete(e),
          bk(
            this,
            iF.REQUEST_UPDATE_CONSTRAINTS,
            Array.from(this.constraintsMap.values())
          )
        );
    }
    registerStats(e, t, i) {
      this.statsRegistry.find(
        i =>
          i.processorID === e.ID && i.processorName === e.name && i.type === t
      ) ||
        this.statsRegistry.push({
          processorName: e.name,
          processorID: e.ID,
          type: t,
          cb: i
        });
    }
    unregisterStats(e, t) {
      const i = this.statsRegistry.findIndex(
        i =>
          i.processorID === e.ID && i.processorName === e.name && i.type === t
      );
      -1 !== i && this.statsRegistry.splice(i, 1);
    }
    gatherStats() {
      const e = [];
      for (const { processorID: t, processorName: i, type: s, cb: r } of this
        .statsRegistry)
        try {
          const n = r();
          e.push({ processorID: t, processorName: i, type: s, stats: n });
        } catch (e) {
          EU.error(new JP(zP.UNEXPECTED_ERROR, e.message));
        }
      return e;
    }
    registerUsage(e, t) {
      this.usageRegistry.find(
        t => t.processorID === e.ID && t.processorName === e.name
      ) ||
        this.usageRegistry.push({
          processorID: e.ID,
          processorName: e.name,
          cb: t
        });
    }
    unregisterUsage(e) {
      const t = this.usageRegistry.findIndex(
        t => t.processorID === e.ID && t.processorName === e.name
      );
      -1 !== t && this.usageRegistry.splice(t, 1);
    }
    async gatherUsage() {
      const e = [];
      if (!this.chained) return [];
      for (const { cb: t } of this.usageRegistry)
        try {
          let i = t();
          i instanceof Promise && (i = await i),
            e.push(hF(hF({}, i), {}, { direction: this.direction }));
        } catch (e) {
          EU.error("gather extension usage error", e);
        }
      return e;
    }
    getDirection() {
      return this.direction;
    }
  }
  class HF extends uk {
    constructor(e) {
      super(),
        dF(this, "name", "AudioProcessorDestination"),
        dF(this, "ID", "0"),
        dF(this, "inputTrack", void 0),
        dF(this, "inputNode", void 0),
        dF(this, "audioProcessorContext", void 0),
        dF(this, "_source", void 0),
        (this.audioProcessorContext = e);
    }
    get kind() {
      return "audio";
    }
    get enabled() {
      return !0;
    }
    pipe() {
      throw new JP(
        zP.NOT_SUPPORTED,
        "AudioProcessorDestination cannot pipe to any other Processor"
      );
    }
    unpipe() {
      throw new JP(
        zP.NOT_SUPPORTED,
        "AudioProcessor cannot unpipe to any other Processor"
      );
    }
    enable() {}
    disable() {}
    reset() {
      (this.inputTrack = void 0),
        (this.inputNode = void 0),
        (this.audioProcessorContext.chained = !1),
        this.emit(tF.ON_TRACK, void 0),
        this.emit(tF.ON_NODE, void 0);
    }
    updateInput(e) {
      if (e.context !== this.audioProcessorContext)
        throw new Error(
          "ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination)."
        );
      e.track &&
        this.inputTrack !== e.track &&
        ((this.audioProcessorContext.chained = !0),
        (this.inputTrack = e.track),
        this.emit(tF.ON_TRACK, this.inputTrack)),
        e.node &&
          this.inputNode !== e.node &&
          ((this.audioProcessorContext.chained = !0),
          (this.inputNode = e.node),
          this.emit(tF.ON_NODE, this.inputNode));
    }
  }
  class KF extends uk {
    set chained(e) {
      this._chained = e;
    }
    get chained() {
      return this._chained;
    }
    constructor(e, t, i) {
      super(),
        dF(this, "constraintsMap", new Map()),
        dF(this, "statsRegistry", []),
        dF(this, "audioContext", void 0),
        dF(this, "trackId", void 0),
        dF(this, "direction", void 0),
        dF(this, "usageRegistry", []),
        dF(this, "_chained", !1),
        (this.audioContext = e),
        (this.trackId = t),
        (this.direction = i);
    }
    async getConstraints() {
      return Ck(this, iF.REQUEST_CONSTRAINTS);
    }
    getAudioContext() {
      return this.audioContext;
    }
    async requestApplyConstraints(e, t) {
      return (
        EU.info(
          "processor "
            .concat(t.name, " requestApplyConstraints for ")
            .concat(this.trackId)
        ),
        e && this.constraintsMap.set(t, e),
        bk(
          this,
          iF.REQUEST_UPDATE_CONSTRAINTS,
          Array.from(this.constraintsMap.values())
        )
      );
    }
    async requestRevertConstraints(e) {
      if (this.constraintsMap.has(e))
        return (
          this.constraintsMap.delete(e),
          bk(
            this,
            iF.REQUEST_UPDATE_CONSTRAINTS,
            Array.from(this.constraintsMap.values())
          )
        );
    }
    registerStats(e, t, i) {
      this.statsRegistry.find(
        i =>
          i.processorID === e.ID && i.processorName === e.name && i.type === t
      ) ||
        this.statsRegistry.push({
          processorName: e.name,
          processorID: e.ID,
          type: t,
          cb: i
        });
    }
    unregisterStats(e, t) {
      const i = this.statsRegistry.findIndex(
        i =>
          i.processorID === e.ID && i.processorName === e.name && i.type === t
      );
      -1 !== i && this.statsRegistry.splice(i, 1);
    }
    gatherStats() {
      const e = [];
      for (const { processorID: t, processorName: i, type: s, cb: r } of this
        .statsRegistry)
        try {
          const n = r();
          e.push({ processorID: t, processorName: i, type: s, stats: n });
        } catch (e) {
          EU.error(new JP(zP.UNEXPECTED_ERROR, e.message));
        }
      return e;
    }
    registerUsage(e, t) {
      this.usageRegistry.find(
        t => t.processorID === e.ID && t.processorName === e.name
      ) ||
        this.usageRegistry.push({
          processorID: e.ID,
          processorName: e.name,
          cb: t
        });
    }
    unregisterUsage(e) {
      const t = this.usageRegistry.findIndex(
        t => t.processorID === e.ID && t.processorName === e.name
      );
      -1 !== t && this.usageRegistry.splice(t, 1);
    }
    async gatherUsage() {
      const e = [];
      if (!this.chained) return [];
      for (const { cb: t } of this.usageRegistry)
        try {
          let i = t();
          i instanceof Promise && (i = await i),
            e.push(hF(hF({}, i), {}, { direction: this.direction }));
        } catch (e) {
          EU.error("gather extension usage error", e);
        }
      return e;
    }
    getDirection() {
      return this.direction;
    }
  }
  class WF extends uk {
    get isPlayed() {
      return !0;
    }
    get isFreeze() {
      return !1;
    }
    constructor() {
      super(),
        dF(this, "context", void 0),
        dF(this, "processSourceNode", void 0),
        dF(this, "outputTrack", void 0),
        dF(this, "processedNode", void 0),
        dF(this, "clonedTrack", void 0),
        dF(this, "outputNode", void 0),
        (this.outputNode = new YF());
    }
    setVolume() {}
    createOutputTrack() {
      throw new JP(
        zP.NOT_SUPPORTED,
        "can not create output MediaStreamTrack when WebAudio disabled"
      );
    }
    getOriginVolumeLevel() {
      return 0;
    }
    getAccurateVolumeLevel() {
      return 0;
    }
    stopGetAudioBuffer() {}
    startGetAudioBuffer() {}
    play() {}
    stop() {}
    destroy() {}
    updateTrack() {}
    updateOriginTrack() {}
    createMediaStreamSourceNode() {}
  }
  class YF {
    disconnect() {}
    connect() {}
  }
  function $F(e) {
    return new Promise((t, i) => {
      let s = !1;
      const r = document.createElement("video");
      r.setAttribute("autoplay", ""),
        r.setAttribute("muted", ""),
        (r.muted = !0),
        (r.autoplay = !0),
        r.setAttribute("playsinline", ""),
        r.setAttribute(
          "style",
          "position: fixed; top: 0; left: 0; width: 1px; height: 1px"
        ),
        document.body.appendChild(r);
      const n = wP() ? "canplay" : "playing";
      r.addEventListener(n, () => {
        const e = r.videoWidth,
          i = r.videoHeight;
        (!e && DP()) || ((s = !0), (r.srcObject = null), r.remove(), t([e, i]));
      }),
        (r.srcObject = new MediaStream([e])),
        r.play().catch(qk),
        setTimeout(() => {
          s ||
            ((r.srcObject = null),
            r.remove(),
            t([r.videoWidth, r.videoHeight]));
        }, 4e3);
    });
  }
  function qF(e) {
    const t = {};
    e.facingMode && (t.facingMode = e.facingMode),
      e.cameraId && (t.deviceId = { exact: e.cameraId });
    const i = Fx(e.encoderConfig);
    return (
      null != i.width && (t.width = i.width),
      null != i.height && (t.height = i.height),
      !(
        window.navigator.appVersion &&
        null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) &&
        window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35
      ) &&
        i.frameRate &&
        (t.frameRate = i.frameRate),
      OP() && "object" == typeof t.frameRate && (t.frameRate.max = 60),
      DP() && (t.frameRate = { ideal: 30, max: 30 }),
      t
    );
  }
  const XF = e => {
      const t = e._encoderConfig;
      if (!t) return;
      const {
        frameRate: i,
        width: s,
        height: r
      } = e.getMediaStreamTrackSettings();
      let { frameRate: n = i, width: a = s, height: o = r } = t;
      if (!n || !a || !o) return;
      (a = eM(a)), (o = eM(o)), (n = eM(n));
      const { max: c, min: d } = (function(e, t, i) {
          const s =
            200 * Math.pow(i / 15, 0.6) * Math.pow((e * t) / 640 / 360, 0.75);
          return { min: Math.floor(s), max: Math.floor(4 * s) };
        })(a, o, n),
        { bitrateMax: l, bitrateMin: h } = t || {};
      l ||
        EU.debug(
          "calculate bitrate: [w: "
            .concat(a, ", h: ")
            .concat(o, ", fps: ")
            .concat(n, "] => [brMax: ")
            .concat(l, ", brMin: ")
            .concat(h, "]")
        );
      const { maxFramerate: u } = WM("ENCODER_CONFIG_LIMIT");
      return (
        u && "number" == typeof u && (n = Math.min(n, u)),
        {
          frameRate: n,
          bitrateMax: l || c,
          bitrateMin: h || d,
          scaleResolutionDownBy: 1,
          scale: 0
        }
      );
    },
    zF = e => {
      const t = document.createElement("canvas");
      return (
        (t.width = 2),
        (t.height = 2),
        new Promise((i, s) => {
          t.toBlob(
            async e => {
              if ((t.remove(), e)) {
                const s = await JF(e);
                i({ buffer: s, width: t.width, height: t.height });
              } else s(new JP(zP.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            },
            e,
            1
          );
        })
      );
    },
    JF = async e => {
      const t = await e.arrayBuffer();
      return new Uint8Array(t);
    };
  var QF,
    ZF,
    eB,
    tB,
    iB,
    sB,
    rB,
    nB,
    aB,
    oB,
    cB,
    dB,
    lB,
    hB,
    uB,
    pB,
    fB,
    EB,
    mB,
    gB,
    _B,
    TB,
    SB,
    vB,
    RB,
    yB,
    AB,
    IB,
    CB,
    bB,
    OB,
    DB,
    wB,
    LB,
    NB,
    PB,
    kB,
    MB,
    UB,
    xB;
  let FB =
      ((QF = RU({ argsMap: (e, t) => [e.getTrackId(), t], throttleTime: 300 })),
      (ZF = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (eB = VF()),
      (tB = rM("LocalAudioTrack", "_enabledMutex")),
      (iB = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (sB = VF()),
      (rB = rM("LocalAudioTrack", "_enabledMutex")),
      (nB = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (aB = VF()),
      (oB = VF()),
      (cB = VF()),
      (dB = RU({ argsMap: e => [e.getTrackId()] })),
      (lB = VF()),
      (hB = RU({ argsMap: e => [e.getTrackId()] })),
      (uB = VF()),
      (pB = RU({ argsMap: e => [e.getTrackId()] })),
      (fB = RU({ argsMap: (e, t) => [e.getTrackId(), t.name] })),
      (EB = RU({ argsMap: e => [e.getTrackId()] })),
      cF(
        (mB = class extends pF {
          get _source() {
            return this.initWebAudio();
          }
          set _source(e) {
            this._trackSource = e;
          }
          get processorContext() {
            return (
              this._processorContext ||
                (this._processorContext = this.initProcessor().processorContext),
              this._processorContext
            );
          }
          get processorDestination() {
            return (
              this._processorDestination ||
                (this._processorDestination = this.initProcessor().processorDestination),
              this._processorDestination
            );
          }
          get isPlaying() {
            return this._useAudioElement
              ? BF.isPlaying(this.getTrackId())
              : this._source.isPlayed;
          }
          get __className__() {
            return "LocalAudioTrack";
          }
          constructor(e, t, i, s) {
            super(e, i),
              dF(this, "trackMediaType", qx.AUDIO),
              dF(this, "_encoderConfig", void 0),
              dF(this, "_trackSource", void 0),
              dF(this, "metadata", []),
              dF(this, "_enabled", !0),
              dF(this, "_volume", 100),
              dF(this, "_useAudioElement", !0),
              dF(this, "_bypassWebAudio", !1),
              dF(this, "processor", void 0),
              dF(this, "_processorContext", void 0),
              dF(this, "_processorDestination", void 0),
              dF(this, "_getOriginVolumeLevel", void 0),
              (this._encoderConfig = t),
              (this._getOriginVolumeLevel = !!s),
              (this._trackSource = new WF()),
              WM("DISABLE_WEBAUDIO") && (this._bypassWebAudio = !0),
              WM("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") &&
                (this._useAudioElement = !1),
              bP() && !EF
                ? setTimeout(() => this.initWebAudio())
                : this.initWebAudio();
          }
          setVolume(e) {
            ek(e, "volume", 0, 1e3),
              (this._volume = e),
              this._source.setVolume(e / 100),
              this._useAudioElement && BF.setVolume(this.getTrackId(), e);
            try {
              if (this._bypassWebAudio)
                return void EU.debug(
                  "[".concat(
                    this.getTrackId(),
                    "] setVolume returned because no pass through WebAudio."
                  )
                );
              const e = this._source.createOutputTrack();
              this._mediaStreamTrack !== e &&
                ((this._mediaStreamTrack = e),
                bk(this, jx.NEED_REPLACE_TRACK, this)
                  .then(() => {
                    EU.debug(
                      "[".concat(
                        this.getTrackId(),
                        "] replace web audio track success"
                      )
                    );
                  })
                  .catch(e => {
                    EU.warning(
                      "[".concat(
                        this.getTrackId(),
                        "] replace web audio track failed"
                      ),
                      e
                    );
                  }));
            } catch (e) {}
          }
          getVolumeLevel() {
            return this._muted && this.enabled && this._getOriginVolumeLevel
              ? this._source.getOriginVolumeLevel()
              : this._source.getAccurateVolumeLevel();
          }
          async setPlaybackDevice(e) {
            if (!this._useAudioElement || !Nx())
              throw new JP(
                zP.NOT_SUPPORTED,
                "your browser does not support setting the audio output device"
              );
            await BF.setSinkID(this.getTrackId(), e);
          }
          async setEnabled(e, t, i) {
            return this._setEnabled(e, t, i);
          }
          async _setEnabled(e, t, i) {
            if (!i) {
              if (e === this._enabled) return;
              this.stateCheck("enabled", e);
            }
            if (
              (EU.info("[".concat(this.getTrackId(), "] start setEnabled"), e),
              e)
            ) {
              this._originMediaStreamTrack.enabled = !0;
              try {
                i || (this._enabled = !0),
                  await bk(this, jx.NEED_ENABLE_TRACK, this),
                  EU.info(
                    "["
                      .concat(this.getTrackId(), "] setEnabled to ")
                      .concat(e, " success")
                  );
              } catch (e) {
                throw (i || (this._enabled = !1),
                EU.error(
                  "[".concat(this.getTrackId(), "] setEnabled to true error"),
                  e.toString()
                ),
                e);
              }
            } else {
              (this._originMediaStreamTrack.enabled = !1),
                i || (this._enabled = !1);
              try {
                await bk(this, jx.NEED_DISABLE_TRACK, this);
              } catch (e) {
                throw (i || (this._enabled = !0),
                EU.error(
                  "[".concat(this.getTrackId(), "] setEnabled to false error"),
                  e.toString()
                ),
                e);
              }
            }
          }
          async setMuted(e) {
            e !== this._muted &&
              (this.stateCheck("muted", e),
              (this._muted = e),
              (this._originMediaStreamTrack.enabled = !e),
              EU.debug(
                "[".concat(this.getTrackId(), "] start set muted: ").concat(e)
              ),
              e
                ? await bk(this, jx.NEED_MUTE_TRACK, this)
                : await bk(this, jx.NEED_UNMUTE_TRACK, this));
          }
          getStats() {
            xk(() => {
              EU.warning(
                "[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead"
              );
            }, "localAudioTrackGetStatsWarning");
            return Ok(this, jx.GET_STATS) || hF({}, zx);
          }
          setAudioFrameCallback(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 4096;
            if (!e)
              return (
                this._source.removeAllListeners(Xx.ON_AUDIO_BUFFER),
                void this._source.stopGetAudioBuffer()
              );
            this._source.startGetAudioBuffer(t),
              this._source.removeAllListeners(Xx.ON_AUDIO_BUFFER),
              this._source.on(Xx.ON_AUDIO_BUFFER, t => e(t));
          }
          play() {
            EU.debug("[".concat(this.getTrackId(), "] start audio playback")),
              this._useAudioElement
                ? (EU.debug(
                    "[".concat(
                      this.getTrackId(),
                      "] start audio playback in element"
                    )
                  ),
                  BF.play(
                    this._mediaStreamTrack,
                    this.getTrackId(),
                    this._volume
                  ))
                : this._source.play();
          }
          stop() {
            EU.debug("[".concat(this.getTrackId(), "] stop audio playback")),
              this._useAudioElement
                ? BF.stop(this.getTrackId())
                : this._source.stop();
          }
          close() {
            super.close(),
              this._processorDestination &&
                this.unbindProcessorDestinationEvents(
                  this._processorDestination
                ),
              this._processorContext &&
                this.unbindProcessorContextEvents(this._processorContext),
              this.unpipe(),
              this._processorDestination &&
                this._processorDestination._source &&
                this._processorDestination._source.unpipe(),
              this._source.destroy();
          }
          _updatePlayerSource() {
            let e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            EU.debug(
              "[".concat(this.getTrackId(), "] update player source track")
            ),
              e && this._source.updateTrack(this._mediaStreamTrack),
              this._useAudioElement &&
                BF.updateTrack(this.getTrackId(), this._mediaStreamTrack);
          }
          async _updateOriginMediaStreamTrack(e, t) {
            this._originMediaStreamTrack !== e &&
              (this._originMediaStreamTrack &&
                (this._originMediaStreamTrack.removeEventListener(
                  "ended",
                  this._handleTrackEnded
                ),
                t && this._originMediaStreamTrack.stop()),
              e.addEventListener("ended", this._handleTrackEnded),
              (this._originMediaStreamTrack = e),
              this._muted && (this._originMediaStreamTrack.enabled = !1),
              this.processor &&
                this._processorContext &&
                this.processor.updateInput({
                  track: e,
                  context: this._processorContext
                }),
              this._mediaStreamTrack !== this._source.outputTrack
                ? ((this._mediaStreamTrack = this._originMediaStreamTrack),
                  this._updatePlayerSource(),
                  await bk(this, jx.NEED_REPLACE_TRACK, this))
                : this._source.updateTrack(this._originMediaStreamTrack),
              this._getOriginVolumeLevel && this._source.updateOriginTrack(e));
          }
          renewMediaStreamTrack(e) {
            return Promise.resolve(void 0);
          }
          pipe(e) {
            if (this._bypassWebAudio)
              throw new JP(
                zP.INVALID_OPERATION,
                "Can not process AudioTrack when bypassWebAudio set to true."
              );
            if (this.processor === e) return e;
            if (e._source)
              throw new JP(
                zP.INVALID_OPERATION,
                "Processor ".concat(
                  e.name,
                  " already piped, please call unpipe beforehand."
                )
              );
            return (
              this.unpipe(),
              (this.processor = e),
              (this.processor._source = this),
              e.updateInput({
                track: this._originMediaStreamTrack,
                node: this._source.processSourceNode,
                context: this.processorContext
              }),
              e
            );
          }
          unpipe() {
            var e;
            if (!this.processor) return;
            const t = this.processor;
            null === (e = this._source.processSourceNode) ||
              void 0 === e ||
              e.disconnect(),
              (this.processor._source = !1),
              (this.processor = void 0),
              t.reset();
          }
          bindProcessorDestinationEvents(e) {
            e.on(tF.ON_TRACK, async e => {
              e
                ? e !== this._mediaStreamTrack &&
                  ((this._mediaStreamTrack = e),
                  this._updatePlayerSource(!1),
                  (this._source.processedNode = this._source.createMediaStreamSourceNode(
                    e
                  )),
                  await bk(this, jx.NEED_REPLACE_TRACK, this))
                : this._mediaStreamTrack !== this._originMediaStreamTrack &&
                  ((this._mediaStreamTrack = this._originMediaStreamTrack),
                  this._updatePlayerSource(),
                  await bk(this, jx.NEED_REPLACE_TRACK, this));
            }),
              e.on(tF.ON_NODE, e => {
                this._source.processedNode = e;
              });
          }
          unbindProcessorDestinationEvents(e) {
            e.removeAllListeners(tF.ON_TRACK), e.removeAllListeners(tF.ON_NODE);
          }
          bindProcessorContextEvents(e) {
            e.on(iF.REQUEST_CONSTRAINTS, async e => {
              e(this._originMediaStreamTrack.getSettings());
            });
          }
          unbindProcessorContextEvents(e) {
            e.removeAllListeners(iF.REQUEST_CONSTRAINTS);
          }
          initWebAudio() {
            return (
              this._trackSource instanceof WF &&
                (this._trackSource = new yF(
                  this._mediaStreamTrack,
                  !1,
                  this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0
                )),
              this._trackSource
            );
          }
          initProcessor() {
            const e = new KF(this._source.context, this.getTrackId(), "local"),
              t = new HF(e);
            return (
              (this._processorContext = e),
              (this._processorDestination = t),
              this.bindProcessorContextEvents(e),
              this.bindProcessorDestinationEvents(t),
              this._source.on(Xx.UPDATE_SOURCE, () => {
                this.processor &&
                  this.processor.updateInput({
                    node: this._source.processSourceNode,
                    context: e
                  });
              }),
              this._useAudioElement &&
                ((this._useAudioElement = !1),
                this.isPlaying &&
                  (BF.stop(this.getTrackId()), this._source.play()),
                bk(this, jx.NEED_REPLACE_MIXING_TRACK, this)
                  .then(() => {
                    EU.debug(
                      "[".concat(
                        this.getTrackId(),
                        "] replace from origin track to web audio track success"
                      )
                    );
                  })
                  .catch(e => {
                    EU.warning(
                      "[".concat(
                        this.getTrackId(),
                        "] replace from origin track to web audio track failed"
                      ),
                      e
                    );
                  })),
              { processorContext: e, processorDestination: t }
            );
          }
        }).prototype,
        "setVolume",
        [QF],
        Object.getOwnPropertyDescriptor(mB.prototype, "setVolume"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "setPlaybackDevice",
        [ZF, eB],
        Object.getOwnPropertyDescriptor(mB.prototype, "setPlaybackDevice"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "setEnabled",
        [tB, iB, sB],
        Object.getOwnPropertyDescriptor(mB.prototype, "setEnabled"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "setMuted",
        [rB, nB, aB],
        Object.getOwnPropertyDescriptor(mB.prototype, "setMuted"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "getStats",
        [oB],
        Object.getOwnPropertyDescriptor(mB.prototype, "getStats"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "setAudioFrameCallback",
        [cB],
        Object.getOwnPropertyDescriptor(mB.prototype, "setAudioFrameCallback"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "play",
        [dB, lB],
        Object.getOwnPropertyDescriptor(mB.prototype, "play"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "stop",
        [hB, uB],
        Object.getOwnPropertyDescriptor(mB.prototype, "stop"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "close",
        [pB],
        Object.getOwnPropertyDescriptor(mB.prototype, "close"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "pipe",
        [fB],
        Object.getOwnPropertyDescriptor(mB.prototype, "pipe"),
        mB.prototype
      ),
      cF(
        mB.prototype,
        "unpipe",
        [EB],
        Object.getOwnPropertyDescriptor(mB.prototype, "unpipe"),
        mB.prototype
      ),
      mB),
    BB =
      ((gB = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (_B = VF()),
      (TB = rM("MicrophoneAudioTrack", "_enabledMutex")),
      (SB = RU({ argsMap: (e, t, i) => [e.getTrackId(), t, i] })),
      (vB = VF()),
      (RB = RU({ argsMap: e => [e.getTrackId()] })),
      cF(
        (yB = class extends FB {
          get __className__() {
            return "MicrophoneAudioTrack";
          }
          constructor(e, t, i, s) {
            super(
              e,
              t.encoderConfig
                ? (function(e) {
                    return "string" == typeof e ? Object.assign({}, Bx[e]) : e;
                  })(t.encoderConfig)
                : {},
              s,
              WM("GET_VOLUME_OF_MUTED_AUDIO_TRACK")
            ),
              dF(this, "_config", void 0),
              dF(this, "_deviceName", "default"),
              dF(this, "_constraints", void 0),
              dF(this, "_originalConstraints", void 0),
              dF(this, "_enabled", !0),
              (this._config = t),
              (this._constraints = i),
              (this._originalConstraints = i),
              (this._deviceName = e.label),
              "boolean" == typeof t.bypassWebAudio &&
                (this._bypassWebAudio = t.bypassWebAudio),
              (FP() || BP()) && mF.bindInterruptDetectorTrack(this);
          }
          async setDevice(e) {
            if (
              (EU.info(
                "["
                  .concat(this.getTrackId(), "] start set device to ")
                  .concat(e)
              ),
              this._enabled)
            )
              try {
                const t = await PF.getDeviceById(e),
                  i = {};
                (i.audio = hF({}, this._constraints)),
                  (i.audio.deviceId = { exact: e }),
                  this._originMediaStreamTrack.stop();
                let s = null;
                try {
                  s = await DF(i, this.getTrackId());
                } catch (e) {
                  throw (EU.error(
                    "[".concat(this.getTrackId(), "] setDevice failed"),
                    e.toString()
                  ),
                  (s = await DF(
                    { audio: this._constraints },
                    this.getTrackId()
                  )),
                  await this._updateOriginMediaStreamTrack(
                    s.getAudioTracks()[0],
                    !1
                  ),
                  e);
                }
                await this._updateOriginMediaStreamTrack(
                  s.getAudioTracks()[0],
                  !1
                ),
                  (this._deviceName = t.label),
                  (this._config.microphoneId = e),
                  (this._constraints.deviceId = { exact: e });
              } catch (e) {
                throw (EU.error(
                  "[".concat(this.getTrackId(), "] setDevice error"),
                  e.toString()
                ),
                e);
              }
            else
              try {
                const t = await PF.getDeviceById(e);
                (this._deviceName = t.label),
                  (this._config.microphoneId = e),
                  (this._constraints.deviceId = { exact: e });
              } catch (e) {
                throw (EU.error(
                  "[".concat(this.getTrackId(), "] setDevice error"),
                  e.toString()
                ),
                e);
              }
            EU.info(
              "["
                .concat(this.getTrackId(), "] set device to ")
                .concat(e, " success")
            );
          }
          async setEnabled(e, t, i) {
            if (t)
              return (
                EU.debug(
                  "[".concat(
                    this.getTrackId(),
                    "] setEnabled false (do not close microphone)"
                  )
                ),
                await super._setEnabled(e)
              );
            if (!i) {
              if (e === this._enabled) return;
              this.stateCheck("enabled", e);
            }
            if (
              (EU.info("[".concat(this.getTrackId(), "] start setEnabled"), e),
              WM("AUTO_RESET_AUDIO_ROUTE") && (wP() || GP()))
            ) {
              const t = navigator.audioSession;
              t && (e || (t.type = "playback"), (t.type = "auto"));
            }
            if (!e) {
              var s;
              (this._originMediaStreamTrack.onended = null),
                this._originMediaStreamTrack.stop(),
                null === (s = this._source.clonedTrack) ||
                  void 0 === s ||
                  s.stop(),
                i || (this._enabled = !1);
              try {
                await bk(this, jx.NEED_DISABLE_TRACK, this);
              } catch (e) {
                throw (EU.error(
                  "[".concat(this.getTrackId(), "] setEnabled false failed"),
                  e.toString()
                ),
                e);
              }
              return;
            }
            const r = hF({}, this._constraints),
              n = PF.searchDeviceIdByName(this._deviceName);
            n && !r.deviceId && (r.deviceId = n);
            try {
              i || (this._enabled = !0);
              const e = await DF(
                { audio: this._constraints },
                this.getTrackId()
              );
              await this._updateOriginMediaStreamTrack(
                e.getAudioTracks()[0],
                !1
              ),
                await bk(this, jx.NEED_ENABLE_TRACK, this);
            } catch (e) {
              throw (i || (this._enabled = !1),
              EU.error(
                "[".concat(this.getTrackId(), "] setEnabled true failed"),
                e.toString()
              ),
              e);
            }
            EU.info("[".concat(this.getTrackId(), "] setEnabled success"));
          }
          close() {
            super.close(),
              (FP() || BP()) && mF.unbindInterruptDetectorTrack(this);
          }
          onTrackEnded() {
            if (
              (wP() || GP()) &&
              this._enabled &&
              !this._isClosed &&
              mF.duringInterruption
            ) {
              const e = async () => {
                mF.off(kx.IOS_INTERRUPTION_END, e),
                  this._enabled &&
                    !this._isClosed &&
                    (EU.debug(
                      "[".concat(
                        this.getTrackId(),
                        "] try capture microphone media device for interrupted iOS device."
                      )
                    ),
                    await this.setEnabled(!1),
                    await this.setEnabled(!0));
              };
              mF.on(kx.IOS_INTERRUPTION_END, e);
            } else
              EU.debug("[".concat(this.getTrackId(), "] track ended")),
                this.safeEmit(Yx.TRACK_ENDED);
          }
          async renewMediaStreamTrack(e) {
            const t = e || this._constraints,
              i = PF.searchDeviceIdByName(this._deviceName);
            if (
              (i && !t.deviceId && (t.deviceId = i),
              (this._constraints = t),
              this._enabled)
            ) {
              this._originMediaStreamTrack.stop();
              const e = await DF(
                { audio: this._constraints },
                this.getTrackId()
              );
              await this._updateOriginMediaStreamTrack(
                e.getAudioTracks()[0],
                !0
              );
            }
          }
          bindProcessorContextEvents(e) {
            super.bindProcessorContextEvents(e),
              e.on(iF.REQUEST_UPDATE_CONSTRAINTS, async (e, t, i) => {
                try {
                  const i = Object.assign({}, this._originalConstraints, ...e);
                  await this.renewMediaStreamTrack(i), t();
                } catch (e) {
                  i(e);
                }
              });
          }
          unbindProcessorContextEvents(e) {
            super.unbindProcessorContextEvents(e),
              e.removeAllListeners(iF.REQUEST_UPDATE_CONSTRAINTS);
          }
        }).prototype,
        "setDevice",
        [gB, _B],
        Object.getOwnPropertyDescriptor(yB.prototype, "setDevice"),
        yB.prototype
      ),
      cF(
        yB.prototype,
        "setEnabled",
        [TB, SB, vB],
        Object.getOwnPropertyDescriptor(yB.prototype, "setEnabled"),
        yB.prototype
      ),
      cF(
        yB.prototype,
        "close",
        [RB],
        Object.getOwnPropertyDescriptor(yB.prototype, "close"),
        yB.prototype
      ),
      yB);
  (AB = RU({ argsMap: (e, t) => [e.getTrackId(), t, e.duration] })),
    (IB = VF()),
    (CB = RU({ argsMap: e => [e.getTrackId()] })),
    (bB = VF()),
    (OB = RU({ argsMap: e => [e.getTrackId()] })),
    (DB = VF()),
    (wB = RU({ argsMap: e => [e.getTrackId()] })),
    (LB = VF()),
    (NB = RU({ argsMap: e => [e.getTrackId()] })),
    (PB = VF()),
    (kB = RU({ argsMap: e => [e.getTrackId()] })),
    (MB = RU({ argsMap: e => [e.getTrackId()] })),
    (UB = VF()),
    cF(
      (xB = class extends FB {
        get __className__() {
          return "BufferSourceAudioTrack";
        }
        constructor(e, t, i, s) {
          super(t.createOutputTrack(), i, s),
            dF(this, "source", void 0),
            dF(this, "_bufferSource", void 0),
            (this._useAudioElement = !1),
            (this.source = e),
            (this._bufferSource = t),
            this._bufferSource.on(Xx.AUDIO_SOURCE_STATE_CHANGE, e => {
              this.safeEmit(Yx.SOURCE_STATE_CHANGE, e);
            });
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e) {}
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        get playbackSpeed() {
          return this._bufferSource.playbackSpeed;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e) {
          e && this._bufferSource.updateOptions(e),
            this._bufferSource.startProcessAudioBuffer();
        }
        pauseProcessAudioBuffer() {
          this._bufferSource.pauseProcessAudioBuffer();
        }
        seekAudioBuffer(e) {
          this._bufferSource.seekAudioBuffer(e);
        }
        resumeProcessAudioBuffer() {
          this._bufferSource.resumeProcessAudioBuffer();
        }
        stopProcessAudioBuffer() {
          this._bufferSource.stopProcessAudioBuffer();
        }
        close() {
          (this.source = null), this._bufferSource.destroy(), super.close();
        }
        setAudioBufferPlaybackSpeed(e) {
          ek(e, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e);
        }
      }).prototype,
      "startProcessAudioBuffer",
      [AB, IB],
      Object.getOwnPropertyDescriptor(xB.prototype, "startProcessAudioBuffer"),
      xB.prototype
    ),
    cF(
      xB.prototype,
      "pauseProcessAudioBuffer",
      [CB, bB],
      Object.getOwnPropertyDescriptor(xB.prototype, "pauseProcessAudioBuffer"),
      xB.prototype
    ),
    cF(
      xB.prototype,
      "seekAudioBuffer",
      [OB, DB],
      Object.getOwnPropertyDescriptor(xB.prototype, "seekAudioBuffer"),
      xB.prototype
    ),
    cF(
      xB.prototype,
      "resumeProcessAudioBuffer",
      [wB, LB],
      Object.getOwnPropertyDescriptor(xB.prototype, "resumeProcessAudioBuffer"),
      xB.prototype
    ),
    cF(
      xB.prototype,
      "stopProcessAudioBuffer",
      [NB, PB],
      Object.getOwnPropertyDescriptor(xB.prototype, "stopProcessAudioBuffer"),
      xB.prototype
    ),
    cF(
      xB.prototype,
      "close",
      [kB],
      Object.getOwnPropertyDescriptor(xB.prototype, "close"),
      xB.prototype
    ),
    cF(
      xB.prototype,
      "setAudioBufferPlaybackSpeed",
      [MB, UB],
      Object.getOwnPropertyDescriptor(
        xB.prototype,
        "setAudioBufferPlaybackSpeed"
      ),
      xB.prototype
    );
  class VB extends FB {
    get __className__() {
      return "MixingAudioTrack";
    }
    get isActive() {
      for (const e of this.trackList)
        if (e._enabled && !e._isClosed && !e.muted) return !0;
      return !1;
    }
    constructor() {
      const e = gF().createMediaStreamDestination();
      super(e.stream.getAudioTracks()[0], void 0, Yk(8, "track-mix-")),
        dF(this, "trackList", void 0),
        dF(this, "destNode", void 0),
        (this._useAudioElement = !1);
      try {
        this._mediaStreamTrack = this._source.createOutputTrack();
      } catch (e) {}
      (this.destNode = e), (this.trackList = []);
    }
    hasAudioTrack(e) {
      return -1 !== this.trackList.indexOf(e);
    }
    addAudioTrack(e) {
      -1 === this.trackList.indexOf(e)
        ? (EU.debug("add ".concat(e.getTrackId(), " to mixing track")),
          e._source.outputNode.connect(this.destNode),
          this.trackList.push(e),
          this.updateEncoderConfig())
        : EU.debug("track ".concat(e.getTrackId(), " is already added"));
    }
    removeAudioTrack(e) {
      if (-1 !== this.trackList.indexOf(e)) {
        EU.debug("remove ".concat(e.getTrackId(), " from mixing track"));
        try {
          e._source.outputNode.disconnect(this.destNode);
        } catch (e) {}
        Lk(this.trackList, e), this.updateEncoderConfig();
      }
    }
    updateEncoderConfig() {
      const e = {};
      this.trackList.forEach(t => {
        t._encoderConfig &&
          ((t._encoderConfig.bitrate || 0) > (e.bitrate || 0) &&
            (e.bitrate = t._encoderConfig.bitrate),
          (t._encoderConfig.sampleRate || 0) > (e.sampleRate || 0) &&
            (e.sampleRate = t._encoderConfig.sampleRate),
          (t._encoderConfig.sampleSize || 0) > (e.sampleSize || 0) &&
            (e.sampleSize = t._encoderConfig.sampleSize),
          t._encoderConfig.stereo && (e.stereo = !0));
      }),
        (this._encoderConfig = e);
    }
    _updateRtpTransceiver(e) {
      this._rtpTransceiver !== e &&
        ((this._rtpTransceiver = e),
        this.trackList.forEach(t => {
          t instanceof VB
            ? t.emit(Wx.TRANSCEIVER_UPDATED, e)
            : t._updateRtpTransceiver(e);
        }));
    }
  }
  class GB {
    get rendFrameRate() {
      if (
        this.renderStats &&
        this.renderStats.curTs !== this.renderStats.lastTs
      ) {
        const e = this.renderStats.curTs - this.renderStats.lastTs,
          t = (this.renderStats.renderNum - this.renderStats.lastRenderNum) / e;
        return (
          (this.renderStats.lastRenderNum = this.renderStats.renderNum),
          (this.renderStats.lastTs = this.renderStats.curTs),
          t
        );
      }
      return 0;
    }
    get videoElementStatus() {
      return this._videoElementStatus;
    }
    set videoElementStatus(e) {
      e !== this._videoElementStatus &&
        (EU.debug(
          "["
            .concat(this.trackId, "] video-element-status change ")
            .concat(this._videoElementStatus, " => ")
            .concat(e)
        ),
        (this._videoElementStatus = e));
    }
    get videoState() {
      return this._videoState;
    }
    set videoState(e) {
      var t;
      e !== this._videoState &&
        ((this._videoState = e),
        null === (t = this.onVideoStateChanged) ||
          void 0 === t ||
          t.call(this, this.videoState));
    }
    constructor(e) {
      dF(this, "trackId", void 0),
        dF(this, "config", void 0),
        dF(this, "onFirstVideoFrameDecoded", void 0),
        dF(this, "onVideoStateChanged", void 0),
        dF(this, "freezeTimeCounterList", []),
        dF(this, "renderFreezeAccTime", 0),
        dF(this, "isKeepLastFrame", !1),
        dF(this, "timeUpdatedCount", 0),
        dF(this, "freezeTime", 0),
        dF(this, "playbackTime", 0),
        dF(this, "lastTimeUpdatedTime", 0),
        dF(this, "autoplayFailed", !1),
        dF(this, "videoTrack", void 0),
        dF(this, "videoElement", void 0),
        dF(this, "cacheVideoElement", void 0),
        dF(this, "renderStats", void 0),
        dF(this, "_videoState", aF.VideoStateStopped),
        dF(this, "videoElementCheckInterval", void 0),
        dF(this, "videoElementFreezeTimeout", void 0),
        dF(this, "_videoElementStatus", nF.NONE),
        dF(this, "isGettingVideoDimensions", !1),
        dF(this, "startGetVideoDimensions", () => {
          const e = () => {
            if (
              ((this.isGettingVideoDimensions = !0),
              this.videoElement.videoWidth * this.videoElement.videoHeight > 4)
            )
              return (
                EU.debug(
                  "[".concat(this.trackId, "] current video dimensions:"),
                  this.videoElement.videoWidth,
                  this.videoElement.videoHeight
                ),
                void (this.isGettingVideoDimensions = !1)
              );
            setTimeout(e, 500);
          };
          !this.isGettingVideoDimensions && e();
        }),
        dF(this, "autoResumeAfterInterruption", () => {
          this.videoTrack &&
            "live" === this.videoTrack.readyState &&
            "running" === mF.curState &&
            (EU.debug(
              "[track-"
                .concat(
                  this.trackId,
                  "] video element paused, auto resume for "
                )
                .concat(AP())
            ),
            VP()
              ? ((this.videoElement.srcObject = null),
                (this.videoElement.srcObject = new MediaStream([
                  this.videoTrack
                ])),
                this.videoElement.play())
              : (this.videoElement.pause(), this.videoElement.play()));
        }),
        dF(this, "handleVideoEvents", e => {
          switch (e.type) {
            case "play":
            case "playing":
              this.startGetVideoDimensions(),
                (this.videoElementStatus = nF.PLAYING);
              break;
            case "loadeddata":
              if (
                ((this.videoState = aF.VideoStateStarting),
                this.onFirstVideoFrameDecoded &&
                  this.onFirstVideoFrameDecoded(),
                this.cacheVideoElement)
              ) {
                try {
                  (this.cacheVideoElement.srcObject = null),
                    this.cacheVideoElement.remove();
                } catch (e) {}
                this.cacheVideoElement = void 0;
              }
              break;
            case "canplay":
              this.videoElementStatus = nF.CANPLAY;
              break;
            case "stalled":
              this.videoElementStatus = nF.STALLED;
              break;
            case "suspend":
              this.videoElementStatus = nF.SUSPEND;
              break;
            case "pause":
              (this.videoElementStatus = nF.PAUSED),
                wP() ||
                  GP() ||
                  (bP() && this.autoplayFailed) ||
                  !this.videoTrack ||
                  "live" !== this.videoTrack.readyState ||
                  (EU.debug(
                    "[track-".concat(
                      this.trackId,
                      "] video element paused, auto resume"
                    )
                  ),
                  this.videoElement.play());
              break;
            case "waiting":
              this.videoElementStatus = nF.WAITING;
              break;
            case "abort":
              this.videoElementStatus = nF.ABORT;
              break;
            case "ended":
              this.videoElementStatus = nF.ENDED;
              break;
            case "emptied":
              this.videoElementStatus = nF.EMPTIED;
              break;
            case "error": {
              const e = this.videoElement.error;
              e &&
                ((this.videoElementStatus = nF.ERROR),
                EU.error(
                  "["
                    .concat(this.trackId, "] media error: ")
                    .concat(e.message, " (")
                    .concat(e.code, ")")
                ));
              break;
            }
            case "timeupdate": {
              const e = performance.now();
              if (((this.timeUpdatedCount += 1), this.timeUpdatedCount < 10))
                return void (this.lastTimeUpdatedTime = e);
              const t = e - this.lastTimeUpdatedTime,
                i = this.lastTimeUpdatedTime;
              if (
                ((this.lastTimeUpdatedTime = e),
                GV.lastVisibleTime < GV.lastHiddenTime ||
                  i < GV.lastHiddenTime ||
                  i < GV.lastVisibleTime)
              )
                return;
              for (
                t > WM("VIDEO_FREEZE_DURATION") && (this.freezeTime += t),
                  this.playbackTime += t;
                this.playbackTime >= 6e3;

              ) {
                this.playbackTime -= 6e3;
                const e = Math.min(6e3, this.freezeTime);
                this.freezeTimeCounterList.push(e),
                  (this.freezeTime = Math.max(0, this.freezeTime - 6e3));
              }
              break;
            }
          }
        }),
        dF(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
          this.videoTrack &&
            "live" === this.videoTrack.readyState &&
            (EU.debug(
              "[track-"
                .concat(
                  this.trackId,
                  "] video element paused, auto resume for "
                )
                .concat(AP())
            ),
            VP()
              ? ((this.videoElement.srcObject = null),
                (this.videoElement.srcObject = new MediaStream([
                  this.videoTrack
                ])),
                this.videoElement.play())
              : (this.videoElement.pause(), this.videoElement.play()));
        }),
        (this.trackId = e.trackId),
        (this.config = e),
        e.element instanceof HTMLVideoElement
          ? (this.videoElement = e.element)
          : (this.videoElement = document.createElement("video")),
        mF.on(kx.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption),
        mF.on(
          kx.IOS_15_16_INTERRUPTION_END,
          this.autoResumeAfterInterruptionOnIOS15_16
        );
    }
    getVideoElement() {
      return this.videoElement;
    }
    getContainerElement() {
      var e;
      return null !== (e = this.videoElement.parentElement) && void 0 !== e
        ? e
        : void 0;
    }
    updateConfig(e) {
      (this.config = e),
        (this.trackId = e.trackId),
        e.element !== this.videoElement &&
          (this.destroy(), (this.videoElement = e.element)),
        this.videoTrack && this.initVideoElement();
    }
    updateVideoTrack(e) {
      this.videoTrack !== e && ((this.videoTrack = e), this.initVideoElement());
    }
    play(e) {
      const t = this.videoElement.play();
      t &&
        t.catch &&
        t.catch(t => {
          e && xF(e, "video", t.message, this.trackId),
            "NotAllowedError" === t.name
              ? (EU.warning("detected video element autoplay failed", t),
                (this.autoplayFailed = !0),
                this.handleAutoPlayFailed())
              : EU.warning("[".concat(this.trackId, "] play warning: "), t);
        });
      const i = vP();
      if (
        (("Safari" === i.name && 15 === Number(i.version)) || FP()) &&
        t &&
        t.then
      ) {
        const e = () => {
          this.config.mirror &&
            (this.videoElement.style.transform = "rotateY(180deg)");
        };
        t.then(e).catch(e);
      }
    }
    getCurrentFrame() {
      const e = document.createElement("canvas");
      (e.width = this.videoElement.videoWidth),
        (e.height = this.videoElement.videoHeight);
      const t = e.getContext("2d");
      if (!t)
        return EU.error("create canvas context failed!"), new ImageData(2, 2);
      t.drawImage(this.videoElement, 0, 0, e.width, e.height);
      const i = t.getImageData(0, 0, e.width, e.height);
      return e.remove(), i;
    }
    async getCurrentFrameToUint8Array(e) {
      let t =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      const i = document.createElement("canvas");
      (i.width = this.videoElement.videoWidth),
        (i.height = this.videoElement.videoHeight);
      const s = i.getContext("2d");
      return s
        ? (s.drawImage(this.videoElement, 0, 0, i.width, i.height),
          new Promise((s, r) => {
            i.toBlob(
              async e => {
                if ((i.remove(), e)) {
                  const t = await JF(e);
                  s({ buffer: t, width: i.width, height: i.height });
                } else r(new JP(zP.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
              },
              e,
              t < 0 ? 0.1 : t > 1 ? 1 : t
            );
          }))
        : await zF(e);
    }
    destroy() {
      (this.renderStats = void 0),
        mF.off(kx.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption),
        mF.off(
          kx.IOS_15_16_INTERRUPTION_END,
          this.autoResumeAfterInterruptionOnIOS15_16
        ),
        (this.videoElement.srcObject = null),
        this.resetVideoElement(),
        (this.freezeTimeCounterList = []),
        (this.videoState = aF.VideoStateStopped);
    }
    initVideoElement() {
      if (
        ((this.videoElementStatus = nF.INIT),
        !this.videoElementCheckInterval &&
          (jB.forEach(e => {
            this.videoElement.addEventListener(e, this.handleVideoEvents);
          }),
          (this.videoElementCheckInterval = window.setInterval(() => {
            (function(e) {
              return e !== document.body && document.body.contains(e);
            })(this.videoElement) || (this.videoElementStatus = nF.DESTROYED);
          }, 1e3)),
          WM("ENABLE_VIDEO_FRAME_CALLBACK")))
      ) {
        var e, t;
        let i;
        const s = () => {
            "visible" === document.visibilityState &&
              (document.removeEventListener("visibilitychange", s),
              (this.videoElementFreezeTimeout = window.setTimeout(
                r,
                WM("VIDEO_FREEZE_DURATION")
              )));
          },
          r = () => {
            (this.videoElementFreezeTimeout = void 0),
              this.videoState === aF.VideoStateDecoding &&
                ("visible" === document.visibilityState
                  ? (this.videoState = aF.VideoStateFrozen)
                  : document.addEventListener("visibilitychange", s));
          },
          n = (e, t) => {
            if (this.videoElementStatus === nF.PLAYING) {
              if (
                (this.renderStats
                  ? (this.renderStats.renderNum++,
                    (this.renderStats.curTs = t.mediaTime))
                  : (this.renderStats = {
                      lastTs: t.mediaTime,
                      curTs: t.mediaTime,
                      lastRenderNum: 0,
                      renderNum: 0
                    }),
                i)
              ) {
                const e = t.presentationTime - i.presentationTime;
                this.videoState === aF.VideoStateStarting &&
                  (this.videoState = aF.VideoStateDecoding),
                  this.videoState === aF.VideoStateDecoding &&
                    this.onVideoStateChanged &&
                    (this.videoElementFreezeTimeout &&
                      window.clearTimeout(this.videoElementFreezeTimeout),
                    (this.videoElementFreezeTimeout = window.setTimeout(
                      r,
                      WM("VIDEO_FREEZE_DURATION")
                    ))),
                  e < WM("VIDEO_FREEZE_DURATION") &&
                    this.videoState === aF.VideoStateFrozen &&
                    (this.videoState = aF.VideoStateDecoding),
                  e > WM("VIDEO_FREEZE_DURATION") &&
                    GV.lastVisibleTime >= GV.lastHiddenTime &&
                    i.timestamp > GV.lastVisibleTime &&
                    i.timestamp > GV.lastHiddenTime &&
                    (this.renderFreezeAccTime += e);
              }
              i = hF(hF({}, t), {}, { timestamp: e });
            }
            var s, a;
            WM("ENABLE_VIDEO_FRAME_CALLBACK") &&
              (null ===
                (s = (a = this.videoElement).requestVideoFrameCallback) ||
                void 0 === s ||
                s.call(a, n));
          };
        null === (e = (t = this.videoElement).requestVideoFrameCallback) ||
          void 0 === e ||
          e.call(t, n);
      }
      (this.videoElement.controls = !1),
        this.videoElement.setAttribute("playsinline", ""),
        WP() &&
          !WM("HIDE_NO_POSTER") &&
          (this.videoElement.poster = "noposter");
      const i = vP();
      ("Safari" === i.name && 15 === Number(i.version)) ||
        FP() ||
        !this.config.mirror ||
        (this.videoElement.style.transform = "rotateY(180deg)"),
        this.config.fit
          ? (this.videoElement.style.objectFit = this.config.fit)
          : (this.videoElement.style.objectFit = "cover"),
        this.videoElement.setAttribute("muted", ""),
        (this.videoElement.muted = !0),
        this.videoElement.srcObject &&
        this.videoElement.srcObject instanceof MediaStream
          ? this.videoElement.srcObject.getVideoTracks()[0] !==
              this.videoTrack &&
            ((this.videoElement.srcObject = this.videoTrack
              ? new MediaStream([this.videoTrack])
              : null),
            DP() && this.videoElement.load())
          : ((this.videoElement.srcObject = this.videoTrack
              ? new MediaStream([this.videoTrack])
              : null),
            DP() && this.videoElement.load());
      const s = this.videoElement.play();
      void 0 !== s &&
        s.catch(e => {
          EU.debug(
            "[".concat(this.trackId, "] playback interrupted"),
            e.toString()
          );
        });
    }
    resetVideoElement() {
      jB.forEach(e => {
        this.videoElement &&
          this.videoElement.removeEventListener(e, this.handleVideoEvents);
      }),
        this.videoElementCheckInterval &&
          (window.clearInterval(this.videoElementCheckInterval),
          (this.videoElementCheckInterval = void 0)),
        (this.videoElementStatus = nF.NONE);
    }
    handleAutoPlayFailed() {
      const e = t => {
        t.preventDefault(),
          this.videoElement
            .play()
            .then(() => {
              EU.debug(
                "["
                  .concat(this.trackId, "] Video element for trackId:")
                  .concat(this.trackId, " autoplay resumed.")
              );
            })
            .catch(e => {
              EU.error(e);
            }),
          (this.autoplayFailed = !1),
          YP()
            ? document.body.removeEventListener("click", e, !0)
            : (document.body.removeEventListener("touchstart", e, !0),
              document.body.removeEventListener("mousedown", e, !0));
      };
      YP()
        ? document.body.addEventListener("click", e, !0)
        : (document.body.addEventListener("touchstart", e, !0),
          document.body.addEventListener("mousedown", e, !0)),
        UF();
    }
  }
  const jB = [
    "play",
    "playing",
    "loadeddata",
    "canplay",
    "pause",
    "stalled",
    "suspend",
    "waiting",
    "abort",
    "emptied",
    "ended",
    "timeupdate",
    "error"
  ];
  class HB extends GB {
    constructor(e) {
      super(e),
        dF(this, "container", void 0),
        dF(this, "slot", void 0),
        (this.slot = e.element),
        this.updateConfig(e);
    }
    updateConfig(e) {
      (this.config = e), (this.trackId = e.trackId);
      const t = e.element;
      t !== this.slot && (this.destroy(), (this.slot = t)),
        this.createElements();
    }
    updateVideoTrack(e) {
      this.videoTrack !== e && ((this.videoTrack = e), this.createElements());
    }
    play(e) {
      var t;
      null !== (t = this.container) &&
        void 0 !== t &&
        t.contains(this.videoElement) &&
        super.play(e);
    }
    getCurrentFrame() {
      var e;
      return null !== (e = this.container) &&
        void 0 !== e &&
        e.contains(this.videoElement)
        ? super.getCurrentFrame()
        : new ImageData(2, 2);
    }
    async getCurrentFrameToUint8Array(e) {
      var t;
      let i =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      return null !== (t = this.container) &&
        void 0 !== t &&
        t.contains(this.videoElement)
        ? await super.getCurrentFrameToUint8Array(e, i)
        : await zF(e);
    }
    destroy() {
      if (
        (super.destroy(),
        this.videoElement.remove(),
        (this.videoElement = document.createElement("video")),
        this.container)
      ) {
        try {
          this.container.remove(), this.slot.removeChild(this.container);
        } catch (e) {}
        this.container = void 0;
      }
    }
    createElements() {
      this.container || (this.container = document.createElement("div")),
        (this.container.id = "agora-video-player-".concat(this.trackId)),
        (this.container.style.width = "100%"),
        (this.container.style.height = "100%"),
        (this.container.style.position = "relative"),
        (this.container.style.overflow = "hidden"),
        this.videoTrack
          ? ((this.container.style.backgroundColor = "black"),
            WM("KEEP_LAST_FRAME") &&
              this.isKeepLastFrame &&
              this.videoElement.paused &&
              this.resetVideoElement(),
            this.mountedVideoElement())
          : this.unmountedVideoElement(),
        this.slot.appendChild(this.container);
    }
    mountedVideoElement() {
      var e;
      !this.container ||
        (null !== (e = this.container) &&
          void 0 !== e &&
          e.contains(this.videoElement)) ||
        this.container.appendChild(this.videoElement),
        super.initVideoElement(),
        (this.videoElement.id = "video_".concat(this.trackId)),
        (this.videoElement.className = "agora_video_player"),
        (this.videoElement.style.width = "100%"),
        (this.videoElement.style.height = "100%"),
        (this.videoElement.style.position = "absolute"),
        (this.videoElement.style.left = "0"),
        (this.videoElement.style.top = "0");
    }
    unmountedVideoElement() {
      var e;
      if (
        null !== (e = this.container) &&
        void 0 !== e &&
        e.contains(this.videoElement)
      ) {
        super.resetVideoElement();
        try {
          this.container && this.container.removeChild(this.videoElement);
        } catch (e) {}
        this.videoElement = document.createElement("video");
      }
    }
    resetVideoElement() {
      var e;
      null !== (e = this.container) &&
        void 0 !== e &&
        e.contains(this.videoElement) &&
        (super.resetVideoElement(),
        (this.cacheVideoElement = this.videoElement),
        (this.videoElement = document.createElement("video")));
    }
    getContainerElement() {
      return this.container;
    }
  }
  var KB,
    WB,
    YB,
    $B,
    qB,
    XB,
    zB,
    JB,
    QB,
    ZB,
    eV,
    tV,
    iV,
    sV,
    rV,
    nV,
    aV,
    oV,
    cV,
    dV,
    lV,
    hV,
    uV,
    pV,
    fV,
    EV,
    mV,
    gV,
    _V,
    TV,
    SV,
    vV,
    RV,
    yV;
  let AV =
      ((KB = RU({
        argsMap: (e, t, i) => [
          e.getTrackId(),
          "string" == typeof t
            ? t
            : t instanceof HTMLVideoElement
            ? "HTMLVideoElement"
            : "HTMLElement",
          i
        ]
      })),
      (WB = VF()),
      (YB = RU({ argsMap: e => [e.getTrackId()] })),
      ($B = rM("LocalVideoTrack", "_enabledMutex")),
      (qB = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (XB = VF()),
      (zB = rM("LocalVideoTrack", "_enabledMutex")),
      (JB = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (QB = VF()),
      (ZB = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (eV = VF()),
      (tV = VF()),
      (iV = RU({ argsMap: (e, t, i) => [e.getTrackId(), t, i] })),
      (sV = VF()),
      (rV = VF()),
      (nV = VF()),
      (aV = VF()),
      (oV = VF()),
      (cV = VF()),
      (dV = VF()),
      (lV = RU({ argsMap: (e, t) => [e.getTrackId(), t.name] })),
      (hV = RU({ argsMap: e => [e.getTrackId()] })),
      (uV = RU({ argsMap: e => [e.getTrackId()] })),
      (pV = RU({ argsMap: (e, t, i) => [e.getTrackId(), t.label, i] })),
      (fV = class e extends pF {
        get videoHeight() {
          if (bP()) {
            const { height: e } = this._mediaStreamTrack.getSettings();
            return (this._videoHeight = e), this._videoHeight;
          }
          return this._videoHeight;
        }
        get videoWidth() {
          if (bP()) {
            const { width: e } = this._mediaStreamTrack.getSettings();
            return (this._videoWidth = e), this._videoWidth;
          }
          return this._videoWidth;
        }
        get isPlaying() {
          return !(
            !this._player || this._player.videoElementStatus !== nF.PLAYING
          );
        }
        get processorDestination() {
          return this._processorDestination;
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e) {
          this._processorContext = e;
        }
        get __className__() {
          return "LocalVideoTrack";
        }
        constructor(e, t, i, s, r, n) {
          if (
            (super(e, r),
            dF(this, "trackMediaType", qx.VIDEO),
            dF(this, "_player", void 0),
            dF(this, "isUseScaleResolutionDownBy", !1),
            dF(this, "_videoVisibleTimer", null),
            dF(this, "_previousVideoVisibleStatus", void 0),
            dF(
              this,
              "_clearPreviousVideoVisibleStatus",
              () => (this._previousVideoVisibleStatus = void 0)
            ),
            dF(this, "_encoderConfig", void 0),
            dF(this, "_scalabilityMode", {
              numSpatialLayers: 1,
              numTemporalLayers: 1
            }),
            dF(this, "_optimizationMode", void 0),
            dF(this, "_videoHeight", void 0),
            dF(this, "_videoWidth", void 0),
            dF(this, "_forceBitrateLimit", void 0),
            dF(this, "_enabled", !0),
            dF(this, "_processorDestination", void 0),
            dF(this, "_processorContext", void 0),
            bP())
          ) {
            const { width: t, height: i } = e.getSettings();
            (this._videoWidth = t), (this._videoHeight = i);
          } else this.updateMediaStreamTrackResolution();
          if (
            ((this._encoderConfig = t),
            (this._scalabilityMode = i),
            (this._optimizationMode = s),
            (this._hints = n || []),
            -1 === this._hints.indexOf(Hx.SCREEN_TRACK))
          )
            this.updateBitrateFromProfile();
          else if (PP(gP.CHROME, 115) && -1 !== yP().indexOf("Windows")) {
            const t = (function(e, t) {
              if (
                "VideoFrame" in window &&
                "TransformStream" in window &&
                Lx().supportWebRTCInsertableStream
              ) {
                const i = new MediaStreamTrackProcessor(e),
                  s = new MediaStreamTrackGenerator({ kind: "video" });
                let r,
                  n,
                  a = Date.now();
                const o = () => {
                  c && (clearInterval(c), (c = void 0)),
                    r && (r.close(), (r = void 0)),
                    e.stop(),
                    (n = void 0),
                    s.removeEventListener("ended", o);
                };
                let c = window.setInterval(
                  () => {
                    if (n && r && Date.now() - a > (null != t ? t : 1e3))
                      try {
                        "live" === s.readyState ? n.enqueue(r.clone()) : o();
                      } catch (e) {
                        o();
                      }
                  },
                  null != t ? t : 1e3
                );
                const d = new TransformStream({
                  transform: (e, t) => {
                    "live" === s.readyState
                      ? ((n = t),
                        (a = Date.now()),
                        void 0 === r
                          ? ((r = e), t.enqueue(e.clone()))
                          : (t.enqueue(r), (r = e)))
                      : e.close();
                  }
                });
                return (
                  s.addEventListener("ended", o),
                  i.readable.pipeThrough(d).pipeTo(s.writable),
                  s
                );
              }
            })(e);
            t &&
              (EU.info("local screen video track begin to inject frame"),
              (this._mediaStreamTrack = t));
          }
          t &&
            -1 !== this._hints.indexOf(Hx.CUSTOM_TRACK) &&
            this.setEncoderConfiguration(t),
            (this._processorContext = new jF(this.getTrackId(), "local")),
            (this._processorDestination = new GF(this.processorContext)),
            this.bindProcessorDestinationEvents();
        }
        play(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e) {
            const t = document.getElementById(e);
            t
              ? (e = t)
              : (EU.warning(
                  "["
                    .concat(this.getTrackId(), '] can not find "#')
                    .concat(e, '" element, use document.body')
                ),
                (e = document.body));
          }
          EU.debug(
            "["
              .concat(this.getTrackId(), "] start video playback in ")
              .concat(
                e instanceof HTMLVideoElement
                  ? "HTMLVideoElement"
                  : "HTMLElement"
              ),
            JSON.stringify(t)
          );
          const i = hF(
            hF(hF({}, this._getDefaultPlayerConfig()), t),
            {},
            { trackId: this.getTrackId(), element: e }
          );
          this._player
            ? this._player.updateConfig(i)
            : (e instanceof HTMLVideoElement
                ? (this._player = new GB(i))
                : (this._player = new HB(i)),
              this._player.updateVideoTrack(this._mediaStreamTrack)),
            this._player.play(),
            this._videoVisibleTimer &&
              window.clearInterval(this._videoVisibleTimer),
            this._clearPreviousVideoVisibleStatus(),
            (this._videoVisibleTimer = window.setInterval(() => {
              try {
                const e = this.getVideoElementVisibleStatus();
                this.safeEmit(Yx.VIDEO_ELEMENT_VISIBLE_STATUS, e);
              } catch (e) {}
            }, WM("CHECK_VIDEO_VISIBLE_INTERVAL")));
        }
        stop() {
          this._player &&
            (this._videoVisibleTimer &&
              (window.clearInterval(this._videoVisibleTimer),
              (this._videoVisibleTimer = null)),
            this._clearPreviousVideoVisibleStatus(),
            this._player.destroy(),
            (this._player = void 0),
            EU.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        async setEnabled(e, t) {
          if (!t) {
            if (e === this._enabled) return;
            this.stateCheck("enabled", e);
          }
          if (
            (EU.info("[".concat(this.getTrackId(), "] start setEnabled"), e),
            !e)
          ) {
            this._originMediaStreamTrack.enabled = !1;
            try {
              await bk(this, jx.NEED_DISABLE_TRACK, this);
            } catch (e) {
              throw (EU.error(
                "[".concat(this.getTrackId(), "] setEnabled to false error"),
                e.toString()
              ),
              e);
            }
            return (
              t || (this._enabled = !1),
              void EU.info(
                "[".concat(this.getTrackId(), "] setEnabled to false success")
              )
            );
          }
          this._originMediaStreamTrack.enabled = !0;
          try {
            await bk(this, jx.NEED_ENABLE_TRACK, this);
          } catch (e) {
            throw (EU.error(
              "[".concat(this.getTrackId(), "] setEnabled to true error"),
              e.toString()
            ),
            e);
          }
          EU.info(
            "[".concat(this.getTrackId(), "] setEnabled to true success")
          ),
            t || (this._enabled = !0);
        }
        async setMuted(e) {
          e !== this._muted &&
            (this.stateCheck("muted", e),
            (this._muted = e),
            (this._originMediaStreamTrack.enabled = !e),
            EU.debug(
              "[".concat(this.getTrackId(), "] start set muted: ").concat(e)
            ),
            e
              ? await bk(this, jx.NEED_MUTE_TRACK, this)
              : await bk(this, jx.NEED_UNMUTE_TRACK, this));
        }
        async setEncoderConfiguration(e, t) {
          if (!this._enabled)
            throw new JP(
              zP.TRACK_IS_DISABLED,
              "can not set encoder configuration when track is disabled"
            );
          if (
            ((e = Fx(e)),
            this._forceBitrateLimit &&
              ((e.bitrateMax = this._forceBitrateLimit.max_bitrate
                ? this._forceBitrateLimit.max_bitrate
                : e.bitrateMax),
              (e.bitrateMin = this._forceBitrateLimit.min_bitrate
                ? this._forceBitrateLimit.min_bitrate
                : e.bitrateMin)),
            e.width || e.height || e.frameRate)
          ) {
            const t = qF({ encoderConfig: e });
            (bP() || wP() || GP()) && (t.deviceId = void 0),
              EU.debug(
                "[".concat(
                  this.getTrackId(),
                  "] setEncoderConfiguration applyConstraints"
                ),
                JSON.stringify(e),
                JSON.stringify(t)
              );
            try {
              await this._originMediaStreamTrack.applyConstraints(t),
                this.updateMediaStreamTrackResolution();
            } catch (e) {
              const t = new JP(zP.UNEXPECTED_ERROR, e.toString());
              throw (EU.error(
                "[".concat(this.getTrackId(), "] applyConstraints error"),
                t.toString()
              ),
              t);
            }
          }
          (this._encoderConfig = e),
            -1 === this._hints.indexOf(Hx.SCREEN_TRACK) &&
              this.updateBitrateFromProfile();
          try {
            await bk(this, jx.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e) {
            return e.throw(EU);
          }
        }
        getStats() {
          xk(() => {
            EU.warning(
              "[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead"
            );
          }, "localVideoTrackGetStatsWarning");
          return Ok(this, jx.GET_STATS) || hF({}, Jx);
        }
        async setBeautyEffect(e) {
          EU.error(
            "LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect"
          );
        }
        getCurrentFrameData() {
          return this._player
            ? this._player.getCurrentFrame()
            : new ImageData(2, 2);
        }
        async getCurrentFrameImage(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return this._player
            ? this._player.getCurrentFrameToUint8Array(e, t)
            : await zF(e);
        }
        async setBitrateLimit(e) {
          EU.debug(
            "["
              .concat(this.getTrackId(), "] set bitrate limit, ")
              .concat(JSON.stringify(e))
          ),
            e &&
              ((this._forceBitrateLimit = e),
              this._encoderConfig &&
                (this._encoderConfig.bitrateMax
                  ? (this._encoderConfig.bitrateMax =
                      this._encoderConfig.bitrateMax < e.max_bitrate
                        ? this._encoderConfig.bitrateMax
                        : e.max_bitrate)
                  : (this._encoderConfig.bitrateMax = e.max_bitrate),
                this._encoderConfig.bitrateMin,
                (this._encoderConfig.bitrateMin = e.min_bitrate)));
        }
        async setOptimizationMode(e) {
          if ("motion" !== e && "detail" !== e && "balanced" !== e)
            return void EU.error(
              zP.INVALID_PARAMS,
              "optimization mode must be motion, detail or balanced"
            );
          const t = this._optimizationMode;
          try {
            (this._optimizationMode = e),
              await bk(this, jx.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);
          } catch (e) {
            throw ((this._optimizationMode = t),
            EU.error(
              "[".concat(this.getTrackId(), "] set optimization mode failed"),
              e.toString()
            ),
            e);
          }
          EU.info(
            "["
              .concat(this.getTrackId(), "] set optimization mode success (")
              .concat(e, ")")
          );
        }
        setScalabiltyMode(e) {
          if (1 === e.numSpatialLayers && 1 !== e.numTemporalLayers)
            return (
              EU.error(
                zP.INVALID_PARAMS,
                "scalability mode currently not supported, no SVC."
              ),
              void (this._scalabilityMode = {
                numSpatialLayers: 1,
                numTemporalLayers: 1
              })
            );
          (this._scalabilityMode = e),
            EU.info(
              "["
                .concat(this.getTrackId(), "] set scalability mode success (")
                .concat(e, ")")
            );
        }
        updateMediaStreamTrackResolution() {
          $F(this._originMediaStreamTrack)
            .then(e => {
              let [t, i] = e;
              (this._videoHeight = i), (this._videoWidth = t);
            })
            .catch(qk);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        async setSenderConfiguration(e) {
          if (!this._enabled)
            throw new JP(
              zP.TRACK_IS_DISABLED,
              "can not set encoder configuration when track is disabled"
            );
          EU.debug(
            "[".concat(
              this.getTrackId(),
              "] setSenderConfiguration applyConstraints"
            ),
            JSON.stringify(e)
          ),
            (e = Fx(e)),
            this._forceBitrateLimit &&
              ((e.bitrateMax = this._forceBitrateLimit.max_bitrate
                ? this._forceBitrateLimit.max_bitrate
                : e.bitrateMax),
              (e.bitrateMin = this._forceBitrateLimit.min_bitrate
                ? this._forceBitrateLimit.min_bitrate
                : e.bitrateMin)),
            (this._encoderConfig = e),
            -1 === this._hints.indexOf(Hx.SCREEN_TRACK) &&
              this.updateBitrateFromProfile();
          try {
            await bk(this, jx.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e) {
            return e.throw(EU);
          }
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig) return;
          const {
            width: e,
            height: t,
            frameRate: i
          } = this.getMediaStreamTrackSettings();
          if (!e || !t || !i) return;
          const { bitrateMax: s, bitrateMin: r } = this._encoderConfig;
          if (null == r || null == s) {
            const { max: n, min: a } = (function(e, t, i, s, r) {
              const n = WM("BITRATE_ADAPTER_TYPE");
              if ("DEFAULT_BITRATE" === n) return { min: s, max: r };
              if (void 0 === r) {
                const a = Math.floor(
                  200 *
                    Math.pow(i / 15, 0.6) *
                    Math.pow((e * t) / 640 / 360, 0.75)
                );
                (r = "STANDARD_BITRATE" === n ? 4 * a : 2 * a),
                  (s = null != s ? s : a);
              } else s = null != s ? s : Math.floor(r / 10);
              return { min: s, max: r };
            })(e, t, i, r, s);
            (this._encoderConfig.bitrateMin = a),
              (this._encoderConfig.bitrateMax = n),
              EU.debug(
                "["
                  .concat(
                    this.getTrackId(),
                    "] update bitrate from profile, [w: "
                  )
                  .concat(e, ", h: ")
                  .concat(t, ", fps: ")
                  .concat(i, "] => [brMax: ")
                  .concat(n, ", brMin: ")
                  .concat(a, "]")
              );
          }
        }
        getVideoElementVisibleStatus() {
          try {
            var e, t;
            const i =
                null == this || null === (e = this._player) || void 0 === e
                  ? void 0
                  : e.getContainerElement(),
              s = {
                track: this,
                element:
                  null == this || null === (t = this._player) || void 0 === t
                    ? void 0
                    : t.getVideoElement(),
                slot: null == i ? void 0 : i.parentElement
              },
              { element: r, slot: n } = s;
            if (
              this.isPlaying &&
              r instanceof HTMLVideoElement &&
              n instanceof HTMLElement
            ) {
              const e = ck.checkOneElementVisible(r),
                t = Object.assign({}, e);
              if (t.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t.visible;
                const e = yU.reportApiInvoke(null, {
                  tag: mk.TRACER,
                  name: Ek.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE,
                  options: [this.getTrackId()]
                });
                t.visible
                  ? e.onSuccess("Video is visible")
                  : e.onSuccess("Invisible because of ".concat(t.reason));
              }
              return t;
            }
            return;
          } catch (e) {
            throw new JP(zP.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);
          }
        }
        async renewMediaStreamTrack(e) {}
        pipe(e) {
          if (this.processor === e) return e;
          if (e._source)
            throw new JP(
              zP.INVALID_OPERATION,
              "Processor ".concat(
                e.name,
                " already piped, please call unpipe beforehand."
              )
            );
          return (
            this.unpipe(),
            (this.processor = e),
            (this.processor._source = this),
            e.updateInput({
              track: this._originMediaStreamTrack,
              context: this.processorContext
            }),
            e
          );
        }
        unpipe() {
          if (!this.processor) return;
          const e = this.processor;
          (this.processor._source = void 0),
            (this.processor = void 0),
            e.reset();
        }
        close() {
          super.close(),
            this.unbindProcessorDestinationEvents(),
            this.unbindProcessorContextEvents(),
            this.unpipe(),
            this.processorDestination._source &&
              this.processorDestination._source.unpipe();
        }
        clone(t) {
          let i =
              !(arguments.length > 1 && void 0 !== arguments[1]) ||
              arguments[1],
            s = this._encoderConfig;
          t && (s = hF(hF({}, s), Fx(t))), (s = Mk(s));
          const r = Yk(8, "track-video-cloned-"),
            n = new e(
              i ? this._mediaStreamTrack.clone() : this._mediaStreamTrack,
              s,
              Mk(this._scalabilityMode),
              this._optimizationMode,
              r,
              Mk(this._hints)
            );
          return (
            t && s && n.setEncoderConfiguration(s),
            EU.debug(
              "clone video track from "
                .concat(this.getTrackId(), " to ")
                .concat(r, ", clone ")
                .concat(i)
            ),
            n
          );
        }
        async replaceTrack(e, t) {
          if (!(e instanceof MediaStreamTrack))
            throw new JP(
              zP.INVALID_PARAMS,
              "track should be an instance of MediaStreamTrack"
            );
          if ("video" !== e.kind)
            throw new JP(
              zP.INVALID_PARAMS,
              "track should be a video MediaStreamTrack"
            );
          await this._updateOriginMediaStreamTrack(e, t, !0),
            this.updateMediaStreamTrackResolution();
        }
        sendSeiData(e) {
          if (
            (xk(() => {
              yU.reportApiInvoke(null, {
                name: Ek.LOCAL_VIDEO_SEND_SEI_DATA,
                options: [],
                tag: mk.TRACER
              }).onSuccess("");
            }, this._mediaStreamTrack.id || this.getTrackId()),
            !WM("ENABLE_VIDEO_SEI") || !WM("ENABLE_ENCODED_TRANSFORM"))
          )
            return void EU.warning(
              'To send/receive SEI, please call AgoraRTC.setParameter("ENABLE_VIDEO_SEI", true) before instantiate IAgoraRtcClient'
            );
          if (e instanceof Uint8Array == 0)
            return new JP(
              zP.INVALID_PARAMS,
              "Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument."
            ).throw();
          const t = this.getRTCRtpTransceiver();
          if (!t)
            return void EU.warning(
              "Video track is not published, SEI can not be send"
            );
          const i = t.sender.getParameters();
          if (0 === i.codecs.length) return;
          const s = i.codecs[0].mimeType.toLocaleLowerCase();
          "video/h264" === s
            ? this.safeEmit("sei-to-send", e)
            : EU.warning("SEI is not supported by ".concat(s));
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(tF.ON_TRACK, async e => {
            e
              ? e !== this._mediaStreamTrack &&
                ((this._mediaStreamTrack = e),
                this._updatePlayerSource(),
                await bk(this, jx.NEED_REPLACE_TRACK, this))
              : this._mediaStreamTrack !== this._originMediaStreamTrack &&
                ((this._mediaStreamTrack = this._originMediaStreamTrack),
                this._updatePlayerSource(),
                await bk(this, jx.NEED_REPLACE_TRACK, this));
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(tF.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(
            iF.REQUEST_UPDATE_CONSTRAINTS
          ),
            this.processorContext.removeAllListeners(iF.REQUEST_CONSTRAINTS);
        }
      }),
      cF(
        fV.prototype,
        "play",
        [KB, WB],
        Object.getOwnPropertyDescriptor(fV.prototype, "play"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "stop",
        [YB],
        Object.getOwnPropertyDescriptor(fV.prototype, "stop"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "setEnabled",
        [$B, qB, XB],
        Object.getOwnPropertyDescriptor(fV.prototype, "setEnabled"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "setMuted",
        [zB, JB, QB],
        Object.getOwnPropertyDescriptor(fV.prototype, "setMuted"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "setEncoderConfiguration",
        [ZB, eV],
        Object.getOwnPropertyDescriptor(
          fV.prototype,
          "setEncoderConfiguration"
        ),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "getStats",
        [tV],
        Object.getOwnPropertyDescriptor(fV.prototype, "getStats"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "setBeautyEffect",
        [iV, sV],
        Object.getOwnPropertyDescriptor(fV.prototype, "setBeautyEffect"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "getCurrentFrameData",
        [rV],
        Object.getOwnPropertyDescriptor(fV.prototype, "getCurrentFrameData"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "getCurrentFrameImage",
        [nV],
        Object.getOwnPropertyDescriptor(fV.prototype, "getCurrentFrameImage"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "setBitrateLimit",
        [aV],
        Object.getOwnPropertyDescriptor(fV.prototype, "setBitrateLimit"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "setOptimizationMode",
        [oV],
        Object.getOwnPropertyDescriptor(fV.prototype, "setOptimizationMode"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "setScalabiltyMode",
        [cV],
        Object.getOwnPropertyDescriptor(fV.prototype, "setScalabiltyMode"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "updateMediaStreamTrackResolution",
        [dV],
        Object.getOwnPropertyDescriptor(
          fV.prototype,
          "updateMediaStreamTrackResolution"
        ),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "pipe",
        [lV],
        Object.getOwnPropertyDescriptor(fV.prototype, "pipe"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "unpipe",
        [hV],
        Object.getOwnPropertyDescriptor(fV.prototype, "unpipe"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "close",
        [uV],
        Object.getOwnPropertyDescriptor(fV.prototype, "close"),
        fV.prototype
      ),
      cF(
        fV.prototype,
        "replaceTrack",
        [pV],
        Object.getOwnPropertyDescriptor(fV.prototype, "replaceTrack"),
        fV.prototype
      ),
      fV),
    IV =
      ((EV = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (mV = VF()),
      (gV = rM("CameraVideoTrack", "_enabledMutex")),
      (_V = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (TV = VF()),
      (SV = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (vV = VF()),
      (RV = RU({ argsMap: e => [e.getTrackId()] })),
      (yV = class e extends AV {
        get __className__() {
          return "CameraVideoTrack";
        }
        constructor(e, t, i, s, r, n) {
          super(e, Fx(t.encoderConfig), s, r, n),
            dF(this, "_config", void 0),
            dF(this, "_originalConstraints", void 0),
            dF(this, "_constraints", void 0),
            dF(this, "_enabled", !0),
            dF(this, "_deviceName", "default"),
            dF(this, "tryResumeVideoForIOS15_16WeChat", async () => {
              (FP() || BP()) &&
                !(function() {
                  const e = vP();
                  if (e.os !== mP.IOS || !e.osVersion) return !1;
                  const t = e.osVersion.split(".");
                  return 15 === Number(t[0]) && Number(t[1]) >= 2;
                })() &&
                jP() &&
                this._enabled &&
                !this._isClosed &&
                (EU.debug(
                  "[".concat(
                    this.getTrackId(),
                    "] try capture camera media device for interrupted iOS 15 device on WeChat."
                  )
                ),
                await this.renewMediaStreamTrack());
            }),
            (this._config = t),
            (this._originalConstraints = i),
            (this._constraints = i),
            (this._deviceName = e.label),
            (this._encoderConfig = Fx(this._config.encoderConfig)),
            mF.on(
              kx.IOS_15_16_INTERRUPTION_END,
              this.tryResumeVideoForIOS15_16WeChat
            ),
            mF.on(
              kx.IOS_INTERRUPTION_END,
              this.tryResumeVideoForIOS15_16WeChat
            ),
            this.bindProcessorContextEvents();
        }
        async setDevice(e) {
          return "string" == typeof e
            ? this._setDeviceById(e)
            : e.deviceId
            ? this._setDeviceById(e.deviceId)
            : e.facingMode
            ? this._setDeviceByFacingModel(e.facingMode)
            : void 0;
        }
        async _setDeviceById(e) {
          if (
            (EU.info(
              "[".concat(this.getTrackId(), "] set device to ").concat(e)
            ),
            this._enabled)
          )
            try {
              const t = await PF.getDeviceById(e),
                i = {};
              (i.video = hF({}, this._constraints)),
                (i.video.deviceId = { exact: e }),
                (i.video.facingMode = void 0),
                this._originMediaStreamTrack.stop();
              let s = null;
              try {
                s = await DF(i, this.getTrackId());
              } catch (e) {
                throw (EU.error(
                  "[".concat(this.getTrackId(), "] setDevice failed"),
                  e.toString()
                ),
                (s = await DF({ video: this._constraints }, this.getTrackId())),
                await this._updateOriginMediaStreamTrack(
                  s.getVideoTracks()[0],
                  !1
                ),
                e);
              }
              await this._updateOriginMediaStreamTrack(
                s.getVideoTracks()[0],
                !1
              ),
                this.updateMediaStreamTrackResolution(),
                (this._deviceName = t.label),
                (this._config.cameraId = e),
                (this._constraints.deviceId = { exact: e });
            } catch (e) {
              throw (EU.error(
                "[".concat(this.getTrackId(), "] setDevice error"),
                e.toString()
              ),
              e);
            }
          else
            try {
              const t = await PF.getDeviceById(e);
              (this._deviceName = t.label),
                (this._config.cameraId = e),
                (this._constraints.deviceId = { exact: e });
            } catch (e) {
              throw (EU.error(
                "[".concat(this.getTrackId(), "] setDevice error"),
                e.toString()
              ),
              e);
            }
          EU.info("[".concat(this.getTrackId(), "] setDevice success"));
        }
        async _setDeviceByFacingModel(e) {
          EU.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e));
          const t = {
            video: hF(
              hF({}, this._constraints),
              {},
              { deviceId: void 0, facingMode: { exact: e } }
            )
          };
          if (this._enabled) {
            this._originMediaStreamTrack.stop();
            let e = null;
            try {
              e = await DF(t, this.getTrackId());
            } catch (t) {
              throw (EU.error(
                "[".concat(
                  this.getTrackId(),
                  "] setDeviceByFacingModel failed"
                ),
                t.toString()
              ),
              (e = await DF({ video: this._constraints }, this.getTrackId())),
              await this._updateOriginMediaStreamTrack(
                e.getVideoTracks()[0],
                !1
              ),
              t);
            }
            await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1),
              this.updateMediaStreamTrackResolution();
          }
          (this._deviceName = ""),
            (this._config.facingMode = e),
            (this._config.cameraId = void 0),
            (this._constraints = hF({}, t.video)),
            EU.info(
              "[".concat(this.getTrackId(), "] setDeviceByFacingModel success")
            );
        }
        async setEnabled(e, t) {
          if (!t) {
            if (e === this._enabled) return;
            this.stateCheck("enabled", e);
          }
          if (
            (EU.info("[".concat(this.getTrackId(), "] start setEnabled"), e), e)
          ) {
            try {
              if (this.isExternalTrack)
                this._originMediaStreamTrack.enabled = !0;
              else {
                const e = await DF(
                  { video: this._constraints },
                  this.getTrackId()
                );
                await this._updateOriginMediaStreamTrack(
                  e.getVideoTracks()[0],
                  !1
                );
              }
              await bk(this, jx.NEED_ENABLE_TRACK, this);
            } catch (e) {
              throw (EU.error(
                "[".concat(this.getTrackId(), "] setEnabled true error"),
                e.toString()
              ),
              e);
            }
            this.updateMediaStreamTrackResolution(),
              EU.info(
                "[".concat(this.getTrackId(), "] setEnabled to true success")
              ),
              t || (this._enabled = !0);
          } else {
            this.isExternalTrack
              ? (this._originMediaStreamTrack.enabled = !1)
              : ((this._originMediaStreamTrack.onended = null),
                this._originMediaStreamTrack.stop()),
              t || (this._enabled = !1);
            try {
              await bk(this, jx.NEED_DISABLE_TRACK, this);
            } catch (e) {
              throw (EU.error(
                "[".concat(this.getTrackId(), "] setEnabled to false error"),
                e.toString()
              ),
              e);
            }
            EU.info(
              "[".concat(this.getTrackId(), "] setEnabled to false success")
            );
          }
        }
        async setEncoderConfiguration(e, t) {
          if (!this._enabled)
            throw new JP(
              zP.TRACK_IS_DISABLED,
              "can not set encoder configuration when track is disabled"
            );
          (e = Fx(e)),
            this._forceBitrateLimit &&
              ((e.bitrateMax =
                this._forceBitrateLimit.max_bitrate || e.bitrateMax),
              (e.bitrateMin =
                this._forceBitrateLimit.min_bitrate || e.bitrateMin));
          const i = kk(this._config);
          i.encoderConfig = e;
          const s = qF(i);
          (bP() || wP() || GP()) && (s.deviceId = void 0),
            EU.debug(
              "[".concat(
                this.getTrackId(),
                "] setEncoderConfiguration applyConstraints"
              ),
              JSON.stringify(e),
              JSON.stringify(s)
            );
          try {
            await this._originMediaStreamTrack.applyConstraints(s),
              this.updateMediaStreamTrackResolution();
          } catch (e) {
            const t = new JP(zP.UNEXPECTED_ERROR, e.toString());
            throw (EU.error(
              "[".concat(this.getTrackId(), "] applyConstraints error"),
              t.toString()
            ),
            t);
          }
          (this._config = i),
            (this._constraints = s),
            (this._originalConstraints = s),
            (this._encoderConfig = e),
            -1 === this._hints.indexOf(Hx.SCREEN_TRACK) &&
              this.updateBitrateFromProfile();
          try {
            await bk(this, jx.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e) {
            return e.throw(EU);
          }
        }
        _getDefaultPlayerConfig() {
          return { mirror: !0, fit: "cover" };
        }
        onTrackEnded() {
          if (
            (wP() || GP()) &&
            this._enabled &&
            !this._isClosed &&
            mF.duringInterruption
          ) {
            const e = async () => {
              mF.off(kx.IOS_INTERRUPTION_END, e),
                this._enabled &&
                  !this._isClosed &&
                  (EU.debug(
                    "[".concat(
                      this.getTrackId(),
                      "] try capture camera media device for interrupted iOS device."
                    )
                  ),
                  await this.setEnabled(!1),
                  await this.setEnabled(!0));
            };
            mF.on(kx.IOS_INTERRUPTION_END, e);
          } else
            EU.debug("[".concat(this.getTrackId(), "] track ended")),
              this.safeEmit(Yx.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e) {
          const t = e || this._constraints,
            i = PF.searchDeviceIdByName(this._deviceName);
          if (
            (i && !t.deviceId && (t.deviceId = { exact: i }), this._enabled)
          ) {
            const e = await DF({ video: t }, this.getTrackId());
            (this._constraints = t),
              await this._updateOriginMediaStreamTrack(
                e.getVideoTracks()[0],
                !0
              ),
              this.updateMediaStreamTrackResolution();
          }
        }
        close() {
          super.close(),
            mF.off(
              kx.IOS_15_16_INTERRUPTION_END,
              this.tryResumeVideoForIOS15_16WeChat
            ),
            mF.off(
              kx.IOS_INTERRUPTION_END,
              this.tryResumeVideoForIOS15_16WeChat
            );
        }
        clone(t) {
          let i =
              !(arguments.length > 1 && void 0 !== arguments[1]) ||
              arguments[1],
            s = this._encoderConfig;
          t && (s = hF(hF({}, s), Fx(t))), (s = Mk(s));
          const r = Yk(8, "track-cam-cloned-"),
            n = new e(
              i ? this._mediaStreamTrack.clone() : this._mediaStreamTrack,
              Mk(hF(hF({}, this._config), {}, { encoderConfig: s })),
              Mk(this._constraints),
              Mk(this._scalabilityMode),
              this._optimizationMode,
              r
            );
          return (
            t && s && n.setEncoderConfiguration(s),
            EU.debug(
              "clone track from "
                .concat(this.getTrackId(), " to ")
                .concat(r, ", clone ")
                .concat(i)
            ),
            n
          );
        }
        bindProcessorContextEvents() {
          this.processorContext.on(
            iF.REQUEST_UPDATE_CONSTRAINTS,
            async (e, t, i) => {
              try {
                const i = Object.assign({}, this._originalConstraints, ...e);
                await this.renewMediaStreamTrack(i), t();
              } catch (e) {
                i(e);
              }
            }
          ),
            this.processorContext.on(iF.REQUEST_CONSTRAINTS, async e => {
              e(this._originMediaStreamTrack.getSettings());
            });
        }
      }),
      cF(
        yV.prototype,
        "setDevice",
        [EV, mV],
        Object.getOwnPropertyDescriptor(yV.prototype, "setDevice"),
        yV.prototype
      ),
      cF(
        yV.prototype,
        "setEnabled",
        [gV, _V, TV],
        Object.getOwnPropertyDescriptor(yV.prototype, "setEnabled"),
        yV.prototype
      ),
      cF(
        yV.prototype,
        "setEncoderConfiguration",
        [SV, vV],
        Object.getOwnPropertyDescriptor(
          yV.prototype,
          "setEncoderConfiguration"
        ),
        yV.prototype
      ),
      cF(
        yV.prototype,
        "close",
        [RV],
        Object.getOwnPropertyDescriptor(yV.prototype, "close"),
        yV.prototype
      ),
      yV);
  var CV, bV, OV, DV, wV, LV, NV, PV, kV, MV, UV, xV;
  class FV extends uF {
    getUserId() {
      return this._userId;
    }
    constructor(e, t, i, s) {
      super(
        e,
        "track-"
          .concat(e.kind, "-")
          .concat(t, "-")
          .concat(s.clientId, "_")
          .concat(Yk(5, ""))
      ),
        dF(this, "_userId", void 0),
        dF(this, "_uintId", void 0),
        dF(this, "_isDestroyed", !1),
        dF(this, "store", void 0),
        dF(this, "processor", void 0),
        dF(this, "processorContext", void 0),
        (this._userId = t),
        (this._uintId = i),
        (this.store = s);
    }
    _updateOriginMediaStreamTrack(e) {
      (this._originMediaStreamTrack = e),
        (this._mediaStreamTrack = e),
        this._updatePlayerSource(),
        this.processor &&
          this.processor.updateInput({
            track: this._originMediaStreamTrack,
            context: this.processorContext
          });
    }
    _destroy() {
      (this._isDestroyed = !0),
        EU.info("[".concat(this.getTrackId(), "] is destroyed")),
        this.stop(),
        super.close();
    }
    getProcessorStats() {
      return this.processorContext.gatherStats();
    }
    getProcessorUsage() {
      return this.processorContext.gatherUsage();
    }
  }
  let BV =
      ((CV = RU({
        argsMap: (e, t, i) => [
          e.getTrackId(),
          "string" == typeof t
            ? t
            : t instanceof HTMLVideoElement
            ? "HTMLVideoElement"
            : "HTMLElement",
          i
        ]
      })),
      (bV = RU({ argsMap: e => [e.getTrackId()] })),
      (OV = RU({ argsMap: (e, t) => [e.getTrackId(), t.name] })),
      (DV = RU({ argsMap: e => [e.getTrackId()] })),
      cF(
        (wV = class extends FV {
          get isPlaying() {
            return !(
              !this._player || this._player.videoElementStatus !== nF.PLAYING
            );
          }
          get __className__() {
            return "RemoteVideoTrack";
          }
          constructor(e, t, i, s) {
            super(e, t, i, s),
              dF(this, "_videoVisibleTimer", null),
              dF(this, "_previousVideoVisibleStatus", void 0),
              dF(
                this,
                "_clearPreviousVideoVisibleStatus",
                () => (this._previousVideoVisibleStatus = void 0)
              ),
              dF(this, "trackMediaType", qx.VIDEO),
              dF(this, "_videoWidth", void 0),
              dF(this, "_videoHeight", void 0),
              dF(this, "_player", void 0),
              dF(this, "processorDestination", void 0),
              dF(this, "processorContext", void 0),
              this.updateMediaStreamTrackResolution(),
              (this.processorContext = new jF(this.getTrackId(), "remote")),
              (this.processorDestination = new GF(this.processorContext)),
              this.bindProcessorDestinationEvents();
          }
          getStats() {
            return (
              xk(() => {
                EU.warning(
                  "[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead"
                );
              }, "remoteVideoTrackGetStatsWarning"),
              Ok(this, jx.GET_STATS) || hF({}, eF)
            );
          }
          play(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            if ("string" == typeof e) {
              const t = document.getElementById(e);
              t
                ? (e = t)
                : (EU.warning(
                    "["
                      .concat(this.getTrackId(), '] can not find "#')
                      .concat(e, '" element, use document.body')
                  ),
                  (e = document.body));
            }
            EU.debug(
              "["
                .concat(this.getTrackId(), "] start video playback in ")
                .concat(
                  e instanceof HTMLVideoElement
                    ? "HTMLVideoElement"
                    : "HTMLElement"
                ),
              JSON.stringify(t)
            );
            const i = hF(
              hF({ fit: "cover" }, t),
              {},
              { trackId: this.getTrackId(), element: e }
            );
            this._player
              ? this._player.updateConfig(i)
              : (e instanceof HTMLVideoElement
                  ? (this._player = new GB(i))
                  : (this._player = new HB(i)),
                this._player.updateVideoTrack(this._mediaStreamTrack),
                (this._player.onFirstVideoFrameDecoded = () => {
                  this.store.subscribe(
                    this.getUserId(),
                    "video",
                    void 0,
                    void 0,
                    Date.now()
                  ),
                    this.safeEmit($x.FIRST_FRAME_DECODED);
                }),
                (this._player.onVideoStateChanged = e => {
                  this.safeEmit($x.VIDEO_STATE_CHANGED, e);
                })),
              this._player.play(this.store.sessionId || void 0),
              this._videoVisibleTimer &&
                window.clearInterval(this._videoVisibleTimer),
              this._clearPreviousVideoVisibleStatus(),
              (this._videoVisibleTimer = window.setInterval(() => {
                try {
                  const e = this.getVideoElementVisibleStatus();
                  this.safeEmit($x.VIDEO_ELEMENT_VISIBLE_STATUS, e);
                } catch (e) {}
              }, WM("CHECK_VIDEO_VISIBLE_INTERVAL")));
          }
          stop() {
            this._player &&
              (this._videoVisibleTimer &&
                (window.clearInterval(this._videoVisibleTimer),
                (this._videoVisibleTimer = null)),
              this._clearPreviousVideoVisibleStatus(),
              this._player.destroy(),
              (this._player = void 0),
              EU.debug("[".concat(this.getTrackId(), "] stop video playback")));
          }
          getCurrentFrameData() {
            return this._player
              ? this._player.getCurrentFrame()
              : new ImageData(2, 2);
          }
          updateMediaStreamTrackResolution() {
            $F(this._originMediaStreamTrack)
              .then(e => {
                let [t, i] = e;
                (this._videoHeight = i), (this._videoWidth = t);
              })
              .catch(qk);
          }
          _updatePlayerSource() {
            EU.debug(
              "[".concat(this.getTrackId(), "] update player source track")
            ),
              this._player &&
                this._player.updateVideoTrack(this._mediaStreamTrack);
          }
          getVideoElementVisibleStatus() {
            try {
              var e, t;
              const i =
                  null == this || null === (e = this._player) || void 0 === e
                    ? void 0
                    : e.getContainerElement(),
                s = {
                  track: this,
                  element:
                    null == this || null === (t = this._player) || void 0 === t
                      ? void 0
                      : t.getVideoElement(),
                  slot: null == i ? void 0 : i.parentElement
                },
                { element: r, slot: n } = s;
              if (
                this.isPlaying &&
                r instanceof HTMLVideoElement &&
                n instanceof HTMLElement
              ) {
                const e = ck.checkOneElementVisible(r),
                  t = Object.assign({}, e);
                if (t.visible !== this._previousVideoVisibleStatus) {
                  this._previousVideoVisibleStatus = t.visible;
                  const e = yU.reportApiInvoke(null, {
                    tag: mk.TRACER,
                    name: Ek.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE,
                    options: [this.getTrackId()]
                  });
                  t.visible
                    ? e.onSuccess("Video is visible")
                    : e.onSuccess("Invisible because of ".concat(t.reason));
                }
                return t;
              }
              return;
            } catch (e) {
              throw new JP(zP.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);
            }
          }
          pipe(e) {
            if (this.processor === e) return e;
            if (e._source)
              throw new JP(
                zP.INVALID_OPERATION,
                "Processor ".concat(
                  e.name,
                  " already piped, please call unpipe beforehand."
                )
              );
            return (
              this.unpipe(),
              (this.processor = e),
              (this.processor._source = this),
              e.updateInput({
                track: this._originMediaStreamTrack,
                context: this.processorContext
              }),
              e
            );
          }
          unpipe() {
            if (!this.processor) return;
            const e = this.processor;
            (this.processor._source = void 0),
              (this.processor = void 0),
              e.reset();
          }
          bindProcessorDestinationEvents() {
            this.processorDestination.on(tF.ON_TRACK, async e => {
              e
                ? e !== this._mediaStreamTrack &&
                  ((this._mediaStreamTrack = e), this._updatePlayerSource())
                : this._mediaStreamTrack !== this._originMediaStreamTrack &&
                  ((this._mediaStreamTrack = this._originMediaStreamTrack),
                  this._updatePlayerSource());
            });
          }
          unbindProcessorDestinationEvents() {
            this.processorDestination.removeAllListeners(tF.ON_TRACK);
          }
          _destroy() {
            super._destroy(), this.unbindProcessorDestinationEvents();
          }
          _onSei(e) {
            this.emit(Wx.SEI_RECEIVED, e);
          }
        }).prototype,
        "play",
        [CV],
        Object.getOwnPropertyDescriptor(wV.prototype, "play"),
        wV.prototype
      ),
      cF(
        wV.prototype,
        "stop",
        [bV],
        Object.getOwnPropertyDescriptor(wV.prototype, "stop"),
        wV.prototype
      ),
      cF(
        wV.prototype,
        "pipe",
        [OV],
        Object.getOwnPropertyDescriptor(wV.prototype, "pipe"),
        wV.prototype
      ),
      cF(
        wV.prototype,
        "unpipe",
        [DV],
        Object.getOwnPropertyDescriptor(wV.prototype, "unpipe"),
        wV.prototype
      ),
      wV),
    VV =
      ((LV = RU({ argsMap: (e, t) => [e.getTrackId(), t], throttleTime: 300 })),
      (NV = RU({ argsMap: (e, t) => [e.getTrackId(), t] })),
      (PV = RU({ argsMap: e => [e.getTrackId()] })),
      (kV = RU({ argsMap: e => [e.getTrackId()] })),
      (MV = RU({ argsMap: (e, t) => [e.getTrackId(), t.name] })),
      (UV = RU({ argsMap: e => [e.getTrackId()] })),
      cF(
        (xV = class extends FV {
          get isPlaying() {
            return this._useAudioElement
              ? BF.isPlaying(this.getTrackId())
              : this._source.isPlayed;
          }
          get __className__() {
            return "RemoteAudioTrack";
          }
          constructor(e, t, i, s) {
            super(e, t, i, s),
              dF(this, "trackMediaType", qx.AUDIO),
              dF(this, "_source", void 0),
              dF(this, "_useAudioElement", !0),
              dF(this, "_volume", 100),
              dF(this, "processorContext", void 0),
              dF(this, "processorDestination", void 0),
              dF(this, "_played", !1),
              dF(this, "_bypassWebAudio", !1),
              WM("DISABLE_WEBAUDIO")
                ? ((this._source = new WF()),
                  (this._bypassWebAudio = !0),
                  (this._useAudioElement = !0))
                : ((this._source = new yF(e, !0)),
                  WM("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") &&
                    (this._useAudioElement = !1)),
              this._source.once(Xx.RECEIVE_TRACK_BUFFER, () => {
                this.safeEmit($x.FIRST_FRAME_DECODED);
              }),
              (this.processorContext = new KF(
                this._source.context,
                this.getTrackId(),
                "remote"
              )),
              (this.processorDestination = new HF(this.processorContext)),
              this.bindProcessorDestinationEvents(),
              this._source.on(Xx.UPDATE_SOURCE, () => {
                this.processor &&
                  this.processor.updateInput({
                    node: this._source.processSourceNode,
                    context: this.processorContext
                  });
              });
          }
          setAudioFrameCallback(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 4096;
            if (!e)
              return (
                this._source.removeAllListeners(Xx.ON_AUDIO_BUFFER),
                void this._source.stopGetAudioBuffer()
              );
            this._source.startGetAudioBuffer(t),
              this._source.removeAllListeners(Xx.ON_AUDIO_BUFFER),
              this._source.on(Xx.ON_AUDIO_BUFFER, t => e(t));
          }
          setVolume(e) {
            (this._volume = e),
              this._useAudioElement
                ? BF.setVolume(this.getTrackId(), e)
                : this._source.setVolume(e / 100);
          }
          async setPlaybackDevice(e) {
            if (!this._useAudioElement || !Nx())
              throw new JP(
                zP.NOT_SUPPORTED,
                "your browser does not support setting the audio output device"
              );
            await BF.setSinkID(this.getTrackId(), e);
          }
          getVolumeLevel() {
            return this._source.getAccurateVolumeLevel();
          }
          getStats() {
            return (
              xk(() => {
                EU.warning(
                  "[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead"
                );
              }, "remoteAudioTrackGetStatsWarning"),
              Ok(this, jx.GET_STATS) || hF({}, Qx)
            );
          }
          play() {
            EU.debug("[".concat(this.getTrackId(), "] start audio playback")),
              (this._played = !0),
              this._useAudioElement
                ? (EU.debug(
                    "[".concat(this.getTrackId(), "] use audio element to play")
                  ),
                  BF.play(
                    this._mediaStreamTrack,
                    this.getTrackId(),
                    this._volume,
                    this.store.sessionId || void 0
                  ))
                : this._source.play();
          }
          stop() {
            EU.debug("[".concat(this.getTrackId(), "] stop audio playback")),
              (this._played = !1),
              this._useAudioElement
                ? BF.stop(this.getTrackId())
                : this._source.stop();
          }
          _destroy() {
            super._destroy(),
              (this._played = !1),
              this.unbindProcessorDestinationEvents(),
              this._source.destroy();
          }
          _isFreeze() {
            return this._source.isFreeze;
          }
          _updatePlayerSource() {
            let e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            EU.debug(
              "[".concat(this.getTrackId(), "] update player source track")
            ),
              e && this._source.updateTrack(this._mediaStreamTrack),
              this._useAudioElement &&
                BF.updateTrack(this.getTrackId(), this._mediaStreamTrack);
          }
          pipe(e) {
            if (this._bypassWebAudio)
              throw new JP(
                zP.NOT_SUPPORTED,
                "can not pipe extension when WebAudio disabled"
              );
            if (this.processor === e) return e;
            if (e._source)
              throw new JP(
                zP.INVALID_OPERATION,
                "Processor ".concat(
                  e.name,
                  " already piped, please call unpipe beforehand."
                )
              );
            return (
              this.unpipe(),
              (this.processor = e),
              (this.processor._source = this),
              e.updateInput({
                track: this._originMediaStreamTrack,
                node: this._source.processSourceNode,
                context: this.processorContext
              }),
              e
            );
          }
          unpipe() {
            var e;
            if (this._bypassWebAudio)
              throw new JP(
                zP.NOT_SUPPORTED,
                "can not unpipe extension when WebAudio disabled"
              );
            if (!this.processor) return;
            const t = this.processor;
            null === (e = this._source.processSourceNode) ||
              void 0 === e ||
              e.disconnect(),
              (this.processor._source = !1),
              (this.processor = void 0),
              t.reset();
          }
          bindProcessorDestinationEvents() {
            this.processorDestination.on(tF.ON_TRACK, async e => {
              e
                ? e !== this._mediaStreamTrack &&
                  ((this._mediaStreamTrack = e),
                  this._updatePlayerSource(!1),
                  (this._source.processedNode = this._source.createMediaStreamSourceNode(
                    e
                  )))
                : this._mediaStreamTrack !== this._originMediaStreamTrack &&
                  ((this._mediaStreamTrack = this._originMediaStreamTrack),
                  this._updatePlayerSource());
            }),
              this.processorDestination.on(tF.ON_NODE, e => {
                this._source.processedNode = e;
                const t = !e;
                this._useAudioElement !== t &&
                  (this._played
                    ? (this.stop(), (this._useAudioElement = t), this.play())
                    : (this._useAudioElement = t));
              });
          }
          unbindProcessorDestinationEvents() {
            this.processorDestination.removeAllListeners(tF.ON_TRACK),
              this.processorDestination.removeAllListeners(tF.ON_NODE);
          }
        }).prototype,
        "setVolume",
        [LV],
        Object.getOwnPropertyDescriptor(xV.prototype, "setVolume"),
        xV.prototype
      ),
      cF(
        xV.prototype,
        "setPlaybackDevice",
        [NV],
        Object.getOwnPropertyDescriptor(xV.prototype, "setPlaybackDevice"),
        xV.prototype
      ),
      cF(
        xV.prototype,
        "play",
        [PV],
        Object.getOwnPropertyDescriptor(xV.prototype, "play"),
        xV.prototype
      ),
      cF(
        xV.prototype,
        "stop",
        [kV],
        Object.getOwnPropertyDescriptor(xV.prototype, "stop"),
        xV.prototype
      ),
      cF(
        xV.prototype,
        "pipe",
        [MV],
        Object.getOwnPropertyDescriptor(xV.prototype, "pipe"),
        xV.prototype
      ),
      cF(
        xV.prototype,
        "unpipe",
        [UV],
        Object.getOwnPropertyDescriptor(xV.prototype, "unpipe"),
        xV.prototype
      ),
      xV);
  const GV = new (class extends uk {
    get visibility() {
      return document.visibilityState;
    }
    get lastHiddenTime() {
      return this._lastHiddenTime;
    }
    get lastVisibleTime() {
      return this._lastVisibleTime;
    }
    constructor() {
      super(),
        dF(this, "_lastHiddenTime", 0),
        dF(this, "_lastVisibleTime", 0),
        document.addEventListener("visibilitychange", () => {
          "hidden" === document.visibilityState
            ? (this._lastHiddenTime = performance.now())
            : (this._lastVisibleTime = performance.now()),
            EU.debug("current web page is ".concat(document.visibilityState)),
            this.emit("VISIBILITY_CHANGE", document.visibilityState);
        });
    }
  })();
  var jV = (function(e) {
    return (
      (e[(e.AUDIO_LEVEL = 1)] = "AUDIO_LEVEL"),
      (e[(e.METADATA = 2)] = "METADATA"),
      (e[(e.AUDIO_64_BIT_PTS = 3)] = "AUDIO_64_BIT_PTS"),
      e
    );
  })(jV || {});
  const HV = new Map();
  (window.cache = HV),
    (function() {
      const e = vP();
      (wx.getDisplayMedia = !(
        !navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia
      )),
        (wx.getStreamFromExtension =
          e.name === gP.CHROME && Number(e.version) > 34),
        (wx.supportUnifiedPlan = (function() {
          if (!window.RTCRtpTransceiver) return !1;
          if (!("currentDirection" in RTCRtpTransceiver.prototype)) return !1;
          const e = new RTCPeerConnection();
          let t = !1;
          try {
            e.addTransceiver("audio"), (t = !0);
          } catch (e) {}
          return e.close(), t;
        })()),
        (wx.supportMinBitrate = e.name === gP.CHROME || e.name === gP.EDGE),
        (wx.supportSetRtpSenderParameters = (function() {
          const e = vP();
          return (
            !!(
              window.RTCRtpSender &&
              window.RTCRtpSender.prototype.setParameters &&
              window.RTCRtpSender.prototype.getParameters
            ) &&
            (!!KP() ||
              !(!bP() && !IP()) ||
              (e.name === gP.FIREFOX && Number(e.version) >= 64))
          );
        })()),
        e.name === gP.SAFARI &&
          (Number(e.version) >= 14
            ? (wx.supportDualStream = !0)
            : (wx.supportDualStream = !1)),
        (wx.webAudioMediaStreamDest = (function() {
          const e = vP();
          return !(e.name === gP.SAFARI && Number(e.version) < 12);
        })()),
        (wx.supportReplaceTrack =
          !!window.RTCRtpSender &&
          "function" == typeof RTCRtpSender.prototype.replaceTrack),
        (wx.supportWebGL = "undefined" != typeof WebGLRenderingContext),
        (wx.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack),
        KP() || (wx.webAudioWithAEC = !0),
        (wx.supportShareAudio = (function() {
          const e = vP();
          return (
            (e.os === mP.WIN_10 ||
              e.os === mP.WIN_81 ||
              e.os === mP.WIN_7 ||
              e.os === mP.LINUX ||
              e.os === mP.MAC_OS ||
              e.os === mP.CHROMIUM_OS) &&
            e.name === gP.CHROME &&
            Number(e.version) >= 74
          );
        })()),
        (wx.supportDataChannel = !!(
          LP(76) ||
          (function(e) {
            const t = vP();
            return (
              !(t.name !== gP.FIREFOX || !t.osVersion) && Number(t.version) >= e
            );
          })(68) ||
          kP(14)
        )),
        (wx.supportPCSetConfiguration = (function() {
          const e = window.RTCPeerConnection;
          return (
            !DP() && !!e && e.prototype.setConfiguration instanceof Function
          );
        })()),
        (wx.supportWebRTCEncodedTransform = (function() {
          const e = vP();
          return (
            ("Chrome" === e.name && Number(e.version) >= 87) ||
            ("Safari" === e.name && Number(e.version) >= 15)
          );
        })()),
        (wx.supportWebRTCInsertableStream = (function() {
          const e = vP();
          return (
            (e.name === gP.CHROME || e.name === gP.EDGE) &&
            Number(e.version) >= 94 &&
            "MediaStreamTrackGenerator" in window &&
            "MediaStreamTrackProcessor" in window
          );
        })()),
        (wx.supportRequestVideoFrameCallback =
          "requestVideoFrameCallback" in HTMLVideoElement.prototype),
        (wx.supportWebCrypto =
          "undefined" != typeof window &&
          void 0 !== window.crypto &&
          void 0 !== window.crypto.subtle),
        Pk(() => {
          (wx.supportDualStreamEncoding = (function() {
            const e = vP();
            return (
              !!WM("DISABLE_WEBAUDIO") ||
              ("Safari" === e.name && Number(e.version) >= 14) ||
                !!(
                  "Chrome" === e.name &&
                  /Windows/i.test(e.os || "") &&
                  Number(e.version) >= 100 &&
                  WM("CHROME_DUAL_STREAM_USE_ENCODING")
                )
            );
          })()),
            EU.debug("browser ua: ", navigator.userAgent),
            EU.info("browser info: ", e),
            EU.info("browser compatibility: ", wx);
        });
    })(),
    /*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */
    (function() {
      var e;
      function t(e) {
        var t = 0;
        return function() {
          return t < e.length ? { done: !1, value: e[t++] } : { done: !0 };
        };
      }
      var s =
        "function" == typeof Object.defineProperties
          ? Object.defineProperty
          : function(e, t, i) {
              return (
                e == Array.prototype ||
                  e == Object.prototype ||
                  (e[t] = i.value),
                e
              );
            };
      var r,
        n = (function(e) {
          e = [
            "object" == typeof globalThis && globalThis,
            e,
            "object" == typeof window && window,
            "object" == typeof self && self,
            "object" == typeof i && i
          ];
          for (var t = 0; t < e.length; ++t) {
            var s = e[t];
            if (s && s.Math == Math) return s;
          }
          throw Error("Cannot find global object");
        })(this);
      function a(e, t) {
        if (t)
          e: {
            var i = n;
            e = e.split(".");
            for (var r = 0; r < e.length - 1; r++) {
              var a = e[r];
              if (!(a in i)) break e;
              i = i[a];
            }
            (t = t((r = i[(e = e[e.length - 1])]))) != r &&
              null != t &&
              s(i, e, { configurable: !0, writable: !0, value: t });
          }
      }
      function o(e) {
        return (
          ((e = { next: e })[Symbol.iterator] = function() {
            return this;
          }),
          e
        );
      }
      function c(e) {
        var i =
          "undefined" != typeof Symbol && Symbol.iterator && e[Symbol.iterator];
        return i ? i.call(e) : { next: t(e) };
      }
      if (
        (a("Symbol", function(e) {
          function t(e, t) {
            (this.A = e),
              s(this, "description", {
                configurable: !0,
                writable: !0,
                value: t
              });
          }
          if (e) return e;
          t.prototype.toString = function() {
            return this.A;
          };
          var i = "jscomp_symbol_" + ((1e9 * Math.random()) >>> 0) + "_",
            r = 0;
          return function e(s) {
            if (this instanceof e)
              throw new TypeError("Symbol is not a constructor");
            return new t(i + (s || "") + "_" + r++, s);
          };
        }),
        a("Symbol.iterator", function(e) {
          if (e) return e;
          e = Symbol("Symbol.iterator");
          for (
            var i = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(
                " "
              ),
              r = 0;
            r < i.length;
            r++
          ) {
            var a = n[i[r]];
            "function" == typeof a &&
              "function" != typeof a.prototype[e] &&
              s(a.prototype, e, {
                configurable: !0,
                writable: !0,
                value: function() {
                  return o(t(this));
                }
              });
          }
          return e;
        }),
        "function" == typeof Object.setPrototypeOf)
      )
        r = Object.setPrototypeOf;
      else {
        var d;
        e: {
          var l = {};
          try {
            (l.__proto__ = { a: !0 }), (d = l.a);
            break e;
          } catch (e) {}
          d = !1;
        }
        r = d
          ? function(e, t) {
              if (((e.__proto__ = t), e.__proto__ !== t))
                throw new TypeError(e + " is not extensible");
              return e;
            }
          : null;
      }
      var h = r;
      function u() {
        (this.m = !1),
          (this.j = null),
          (this.v = void 0),
          (this.h = 1),
          (this.u = this.C = 0),
          (this.l = null);
      }
      function p(e) {
        if (e.m) throw new TypeError("Generator is already running");
        e.m = !0;
      }
      function f(e, t) {
        return (e.h = 3), { value: t };
      }
      function E(e) {
        (this.g = new u()), (this.G = e);
      }
      function m(e, t, i, s) {
        try {
          var r = t.call(e.g.j, i);
          if (!(r instanceof Object))
            throw new TypeError("Iterator result " + r + " is not an object");
          if (!r.done) return (e.g.m = !1), r;
          var n = r.value;
        } catch (t) {
          return (e.g.j = null), e.g.s(t), g(e);
        }
        return (e.g.j = null), s.call(e.g, n), g(e);
      }
      function g(e) {
        for (; e.g.h; )
          try {
            var t = e.G(e.g);
            if (t) return (e.g.m = !1), { value: t.value, done: !1 };
          } catch (t) {
            (e.g.v = void 0), e.g.s(t);
          }
        if (((e.g.m = !1), e.g.l)) {
          if (((t = e.g.l), (e.g.l = null), t.F)) throw t.D;
          return { value: t.return, done: !0 };
        }
        return { value: void 0, done: !0 };
      }
      function _(e) {
        (this.next = function(t) {
          return e.o(t);
        }),
          (this.throw = function(t) {
            return e.s(t);
          }),
          (this.return = function(t) {
            return (function(e, t) {
              p(e.g);
              var i = e.g.j;
              return i
                ? m(
                    e,
                    "return" in i
                      ? i.return
                      : function(e) {
                          return { value: e, done: !0 };
                        },
                    t,
                    e.g.return
                  )
                : (e.g.return(t), g(e));
            })(e, t);
          }),
          (this[Symbol.iterator] = function() {
            return this;
          });
      }
      function T(e, t) {
        return (t = new _(new E(t))), h && e.prototype && h(t, e.prototype), t;
      }
      if (
        ((u.prototype.o = function(e) {
          this.v = e;
        }),
        (u.prototype.s = function(e) {
          (this.l = { D: e, F: !0 }), (this.h = this.C || this.u);
        }),
        (u.prototype.return = function(e) {
          (this.l = { return: e }), (this.h = this.u);
        }),
        (E.prototype.o = function(e) {
          return (
            p(this.g),
            this.g.j
              ? m(this, this.g.j.next, e, this.g.o)
              : (this.g.o(e), g(this))
          );
        }),
        (E.prototype.s = function(e) {
          return (
            p(this.g),
            this.g.j
              ? m(this, this.g.j.throw, e, this.g.o)
              : (this.g.s(e), g(this))
          );
        }),
        a("Array.prototype.entries", function(e) {
          return (
            e ||
            function() {
              return (function(e, t) {
                e instanceof String && (e += "");
                var i = 0,
                  s = !1,
                  r = {
                    next: function() {
                      if (!s && i < e.length) {
                        var r = i++;
                        return { value: t(r, e[r]), done: !1 };
                      }
                      return (s = !0), { done: !0, value: void 0 };
                    }
                  };
                return (
                  (r[Symbol.iterator] = function() {
                    return r;
                  }),
                  r
                );
              })(this, function(e, t) {
                return [e, t];
              });
            }
          );
        }),
        "undefined" != typeof Blob &&
          ("undefined" == typeof FormData || !FormData.prototype.keys))
      ) {
        var S = function(e, t) {
            for (var i = 0; i < e.length; i++) t(e[i]);
          },
          v = function(e) {
            return e.replace(/\r?\n|\r/g, "\r\n");
          },
          R = function(e, t, i) {
            return t instanceof Blob
              ? ((i =
                  void 0 !== i
                    ? String(i + "")
                    : "string" == typeof t.name
                    ? t.name
                    : "blob"),
                (t.name === i &&
                  "[object Blob]" !== Object.prototype.toString.call(t)) ||
                  (t = new File([t], i)),
                [String(e), t])
              : [String(e), String(t)];
          },
          y = function(e, t) {
            if (e.length < t)
              throw new TypeError(
                t + " argument required, but only " + e.length + " present."
              );
          },
          A =
            "object" == typeof globalThis
              ? globalThis
              : "object" == typeof window
              ? window
              : "object" == typeof self
              ? self
              : this,
          I = A.FormData,
          C = A.XMLHttpRequest && A.XMLHttpRequest.prototype.send,
          b = A.Request && A.fetch,
          O = A.navigator && A.navigator.sendBeacon,
          D = A.Element && A.Element.prototype,
          w = A.Symbol && Symbol.toStringTag;
        w &&
          (Blob.prototype[w] || (Blob.prototype[w] = "Blob"),
          "File" in A && !File.prototype[w] && (File.prototype[w] = "File"));
        try {
          new File([], "");
        } catch (e) {
          A.File = function(e, t, i) {
            return (
              (e = new Blob(e, i || {})),
              Object.defineProperties(e, {
                name: { value: t },
                lastModified: {
                  value: +(i && void 0 !== i.lastModified
                    ? new Date(i.lastModified)
                    : new Date())
                },
                toString: {
                  value: function() {
                    return "[object File]";
                  }
                }
              }),
              w && Object.defineProperty(e, w, { value: "File" }),
              e
            );
          };
        }
        var L = function(e) {
            return e
              .replace(/\n/g, "%0A")
              .replace(/\r/g, "%0D")
              .replace(/"/g, "%22");
          },
          N = function(e) {
            this.i = [];
            var t = this;
            e &&
              S(e.elements, function(e) {
                if (
                  e.name &&
                  !e.disabled &&
                  "submit" !== e.type &&
                  "button" !== e.type &&
                  !e.matches("form fieldset[disabled] *")
                )
                  if ("file" === e.type) {
                    var i =
                      e.files && e.files.length
                        ? e.files
                        : [
                            new File([], "", {
                              type: "application/octet-stream"
                            })
                          ];
                    S(i, function(i) {
                      t.append(e.name, i);
                    });
                  } else
                    "select-multiple" === e.type || "select-one" === e.type
                      ? S(e.options, function(i) {
                          !i.disabled &&
                            i.selected &&
                            t.append(e.name, i.value);
                        })
                      : "checkbox" === e.type || "radio" === e.type
                      ? e.checked && t.append(e.name, e.value)
                      : ((i = "textarea" === e.type ? v(e.value) : e.value),
                        t.append(e.name, i));
              });
          };
        if (
          (((e = N.prototype).append = function(e, t, i) {
            y(arguments, 2), this.i.push(R(e, t, i));
          }),
          (e.delete = function(e) {
            y(arguments, 1);
            var t = [];
            (e = String(e)),
              S(this.i, function(i) {
                i[0] !== e && t.push(i);
              }),
              (this.i = t);
          }),
          (e.entries = function e() {
            var t,
              i = this;
            return T(e, function(e) {
              if ((1 == e.h && (t = 0), 3 != e.h))
                return (
                  t < i.i.length
                    ? (e = f(e, i.i[t]))
                    : ((e.h = 0), (e = void 0)),
                  e
                );
              t++, (e.h = 2);
            });
          }),
          (e.forEach = function(e, t) {
            y(arguments, 1);
            for (var i = c(this), s = i.next(); !s.done; s = i.next()) {
              var r = c(s.value);
              (s = r.next().value), (r = r.next().value), e.call(t, r, s, this);
            }
          }),
          (e.get = function(e) {
            y(arguments, 1);
            var t = this.i;
            e = String(e);
            for (var i = 0; i < t.length; i++)
              if (t[i][0] === e) return t[i][1];
            return null;
          }),
          (e.getAll = function(e) {
            y(arguments, 1);
            var t = [];
            return (
              (e = String(e)),
              S(this.i, function(i) {
                i[0] === e && t.push(i[1]);
              }),
              t
            );
          }),
          (e.has = function(e) {
            y(arguments, 1), (e = String(e));
            for (var t = 0; t < this.i.length; t++)
              if (this.i[t][0] === e) return !0;
            return !1;
          }),
          (e.keys = function e() {
            var t,
              i,
              s,
              r,
              n = this;
            return T(e, function(e) {
              if ((1 == e.h && ((t = c(n)), (i = t.next())), 3 != e.h))
                return i.done
                  ? void (e.h = 0)
                  : ((s = i.value), (r = c(s)), f(e, r.next().value));
              (i = t.next()), (e.h = 2);
            });
          }),
          (e.set = function(e, t, i) {
            y(arguments, 2), (e = String(e));
            var s = [],
              r = R(e, t, i),
              n = !0;
            S(this.i, function(t) {
              t[0] === e ? n && (n = !s.push(r)) : s.push(t);
            }),
              n && s.push(r),
              (this.i = s);
          }),
          (e.values = function e() {
            var t,
              i,
              s,
              r,
              n = this;
            return T(e, function(e) {
              if ((1 == e.h && ((t = c(n)), (i = t.next())), 3 != e.h))
                return i.done
                  ? void (e.h = 0)
                  : ((s = i.value), (r = c(s)).next(), f(e, r.next().value));
              (i = t.next()), (e.h = 2);
            });
          }),
          (N.prototype._asNative = function() {
            for (
              var e = new I(), t = c(this), i = t.next();
              !i.done;
              i = t.next()
            ) {
              var s = c(i.value);
              (i = s.next().value), (s = s.next().value), e.append(i, s);
            }
            return e;
          }),
          (N.prototype._blob = function() {
            var e = "----formdata-polyfill-" + Math.random(),
              t = [],
              i = "--" + e + '\r\nContent-Disposition: form-data; name="';
            return (
              this.forEach(function(e, s) {
                return "string" == typeof e
                  ? t.push(i + L(v(s)) + '"\r\n\r\n' + v(e) + "\r\n")
                  : t.push(
                      i +
                        L(v(s)) +
                        '"; filename="' +
                        L(e.name) +
                        '"\r\nContent-Type: ' +
                        (e.type || "application/octet-stream") +
                        "\r\n\r\n",
                      e,
                      "\r\n"
                    );
              }),
              t.push("--" + e + "--"),
              new Blob(t, { type: "multipart/form-data; boundary=" + e })
            );
          }),
          (N.prototype[Symbol.iterator] = function() {
            return this.entries();
          }),
          (N.prototype.toString = function() {
            return "[object FormData]";
          }),
          D &&
            !D.matches &&
            (D.matches =
              D.matchesSelector ||
              D.mozMatchesSelector ||
              D.msMatchesSelector ||
              D.oMatchesSelector ||
              D.webkitMatchesSelector ||
              function(e) {
                for (
                  var t = (e = (
                    this.document || this.ownerDocument
                  ).querySelectorAll(e)).length;
                  0 <= --t && e.item(t) !== this;

                );
                return -1 < t;
              }),
          w && (N.prototype[w] = "FormData"),
          C)
        ) {
          var P = A.XMLHttpRequest.prototype.setRequestHeader;
          (A.XMLHttpRequest.prototype.setRequestHeader = function(e, t) {
            P.call(this, e, t),
              "content-type" === e.toLowerCase() && (this.B = !0);
          }),
            (A.XMLHttpRequest.prototype.send = function(e) {
              e instanceof N
                ? ((e = e._blob()),
                  this.B || this.setRequestHeader("Content-Type", e.type),
                  C.call(this, e))
                : C.call(this, e);
            });
        }
        b &&
          (A.fetch = function(e, t) {
            return (
              t && t.body && t.body instanceof N && (t.body = t.body._blob()),
              b.call(this, e, t)
            );
          }),
          O &&
            (A.navigator.sendBeacon = function(e, t) {
              return t instanceof N && (t = t._asNative()), O.call(this, e, t);
            }),
          (A.FormData = N);
      }
    })();
  const KV = ["CHINA", "GLOBAL"];
  const WV = [
      [0, 1, 2, 3, 4, 5, 5],
      [0, 2, 2, 3, 4, 5, 5],
      [0, 3, 3, 3, 4, 5, 5],
      [0, 4, 4, 4, 4, 5, 5],
      [0, 5, 5, 5, 5, 5, 5]
    ],
    YV = [],
    $V = [];
  function qV(e, t) {
    return !!t && YV.some(i => i.uid === e && i.channelName === t);
  }
  function XV() {
    return $V.length > 0;
  }
  function zV(e, t) {
    (this.v = e), (this.k = t);
  }
  function JV(e, t, i, s, r) {
    var n = {};
    return (
      Object.keys(s).forEach(function(e) {
        n[e] = s[e];
      }),
      (n.enumerable = !!n.enumerable),
      (n.configurable = !!n.configurable),
      ("value" in n || n.initializer) && (n.writable = !0),
      (n = i
        .slice()
        .reverse()
        .reduce(function(i, s) {
          return s(e, t, i) || i;
        }, n)),
      r &&
        void 0 !== n.initializer &&
        ((n.value = n.initializer ? n.initializer.call(r) : void 0),
        (n.initializer = void 0)),
      void 0 === n.initializer ? (Object.defineProperty(e, t, n), null) : n
    );
  }
  function QV(e) {
    var t = {},
      i = !1;
    function s(t, s) {
      return (
        (i = !0),
        (s = new Promise(function(i) {
          i(e[t](s));
        })),
        { done: !1, value: new zV(s, 1) }
      );
    }
    return (
      (t[
        ("undefined" != typeof Symbol && Symbol.iterator) || "@@iterator"
      ] = function() {
        return this;
      }),
      (t.next = function(e) {
        return i ? ((i = !1), e) : s("next", e);
      }),
      "function" == typeof e.throw &&
        (t.throw = function(e) {
          if (i) throw ((i = !1), e);
          return s("throw", e);
        }),
      "function" == typeof e.return &&
        (t.return = function(e) {
          return i ? ((i = !1), e) : s("return", e);
        }),
      t
    );
  }
  function ZV(e) {
    var t,
      i,
      s,
      r = 2;
    for (
      "undefined" != typeof Symbol &&
      ((i = Symbol.asyncIterator), (s = Symbol.iterator));
      r--;

    ) {
      if (i && null != (t = e[i])) return t.call(e);
      if (s && null != (t = e[s])) return new eG(t.call(e));
      (i = "@@asyncIterator"), (s = "@@iterator");
    }
    throw new TypeError("Object is not async iterable");
  }
  function eG(e) {
    function t(e) {
      if (Object(e) !== e)
        return Promise.reject(new TypeError(e + " is not an object."));
      var t = e.done;
      return Promise.resolve(e.value).then(function(e) {
        return { value: e, done: t };
      });
    }
    return (
      (eG = function(e) {
        (this.s = e), (this.n = e.next);
      }),
      (eG.prototype = {
        s: null,
        n: null,
        next: function() {
          return t(this.n.apply(this.s, arguments));
        },
        return: function(e) {
          var i = this.s.return;
          return void 0 === i
            ? Promise.resolve({ value: e, done: !0 })
            : t(i.apply(this.s, arguments));
        },
        throw: function(e) {
          var i = this.s.return;
          return void 0 === i
            ? Promise.reject(e)
            : t(i.apply(this.s, arguments));
        }
      }),
      new eG(e)
    );
  }
  function tG(e) {
    return new zV(e, 0);
  }
  function iG(e, t, i) {
    return (
      (t = (function(e) {
        var t = (function(e, t) {
          if ("object" != typeof e || !e) return e;
          var i = e[Symbol.toPrimitive];
          if (void 0 !== i) {
            var s = i.call(e, t || "default");
            if ("object" != typeof s) return s;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t ? String : Number)(e);
        })(e, "string");
        return "symbol" == typeof t ? t : t + "";
      })(t)) in e
        ? Object.defineProperty(e, t, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
          })
        : (e[t] = i),
      e
    );
  }
  function sG(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function rG(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? sG(Object(i), !0).forEach(function(t) {
            iG(e, t, i[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
        : sG(Object(i)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
          });
    }
    return e;
  }
  function nG(e) {
    return function() {
      return new aG(e.apply(this, arguments));
    };
  }
  function aG(e) {
    var t, i;
    function s(t, i) {
      try {
        var n = e[t](i),
          a = n.value,
          o = a instanceof zV;
        Promise.resolve(o ? a.v : a).then(
          function(i) {
            if (o) {
              var c = "return" === t ? "return" : "next";
              if (!a.k || i.done) return s(c, i);
              i = e[c](i).value;
            }
            r(n.done ? "return" : "normal", i);
          },
          function(e) {
            s("throw", e);
          }
        );
      } catch (e) {
        r("throw", e);
      }
    }
    function r(e, r) {
      switch (e) {
        case "return":
          t.resolve({ value: r, done: !0 });
          break;
        case "throw":
          t.reject(r);
          break;
        default:
          t.resolve({ value: r, done: !1 });
      }
      (t = t.next) ? s(t.key, t.arg) : (i = null);
    }
    (this._invoke = function(e, r) {
      return new Promise(function(n, a) {
        var o = { key: e, arg: r, resolve: n, reject: a, next: null };
        i ? (i = i.next = o) : ((t = i = o), s(e, r));
      });
    }),
      "function" != typeof e.return && (this.return = void 0);
  }
  (aG.prototype[
    ("function" == typeof Symbol && Symbol.asyncIterator) || "@@asyncIterator"
  ] = function() {
    return this;
  }),
    (aG.prototype.next = function(e) {
      return this._invoke("next", e);
    }),
    (aG.prototype.throw = function(e) {
      return this._invoke("throw", e);
    }),
    (aG.prototype.return = function(e) {
      return this._invoke("return", e);
    });
  let oG = (function(e) {
      return (
        (e[(e.ACCESS_POINT = 101)] = "ACCESS_POINT"),
        (e[(e.UNILBS = 201)] = "UNILBS"),
        (e[(e.STRING_UID_ALLOCATOR = 901)] = "STRING_UID_ALLOCATOR"),
        e
      );
    })({}),
    cG = (function(e) {
      return (
        (e[(e.IIIEGAL_APPID = 1)] = "IIIEGAL_APPID"),
        (e[(e.IIIEGAL_UID = 2)] = "IIIEGAL_UID"),
        (e[(e.INTERNAL_ERROR = 3)] = "INTERNAL_ERROR"),
        e
      );
    })({}),
    dG = (function(e) {
      return (
        (e[(e.INVALID_VENDOR_KEY = 5)] = "INVALID_VENDOR_KEY"),
        (e[(e.INVALID_CHANNEL_NAME = 7)] = "INVALID_CHANNEL_NAME"),
        (e[(e.INTERNAL_ERROR = 8)] = "INTERNAL_ERROR"),
        (e[(e.NO_AUTHORIZED = 9)] = "NO_AUTHORIZED"),
        (e[(e.DYNAMIC_KEY_TIMEOUT = 10)] = "DYNAMIC_KEY_TIMEOUT"),
        (e[(e.NO_ACTIVE_STATUS = 11)] = "NO_ACTIVE_STATUS"),
        (e[(e.DYNAMIC_KEY_EXPIRED = 13)] = "DYNAMIC_KEY_EXPIRED"),
        (e[(e.STATIC_USE_DYNAMIC_KEY = 14)] = "STATIC_USE_DYNAMIC_KEY"),
        (e[(e.DYNAMIC_USE_STATIC_KEY = 15)] = "DYNAMIC_USE_STATIC_KEY"),
        (e[(e.USER_OVERLOAD = 16)] = "USER_OVERLOAD"),
        (e[(e.FORBIDDEN_REGION = 18)] = "FORBIDDEN_REGION"),
        (e[(e.CANNOT_MEET_AREA_DEMAND = 19)] = "CANNOT_MEET_AREA_DEMAND"),
        e
      );
    })({}),
    lG = (function(e) {
      return (
        (e[(e.NO_FLAG_SET = 100)] = "NO_FLAG_SET"),
        (e[(e.FLAG_SET_BUT_EMPTY = 101)] = "FLAG_SET_BUT_EMPTY"),
        (e[(e.INVALID_FALG_SET = 102)] = "INVALID_FALG_SET"),
        (e[(e.FLAG_SET_BUT_NO_RE = 103)] = "FLAG_SET_BUT_NO_RE"),
        (e[(e.INVALID_SERVICE_ID = 104)] = "INVALID_SERVICE_ID"),
        (e[(e.NO_SERVICE_AVAILABLE = 200)] = "NO_SERVICE_AVAILABLE"),
        (e[(e.NO_SERVICE_AVAILABLE_P2P = 201)] = "NO_SERVICE_AVAILABLE_P2P"),
        (e[(e.NO_SERVICE_AVAILABLE_VOICE = 202)] =
          "NO_SERVICE_AVAILABLE_VOICE"),
        (e[(e.NO_SERVICE_AVAILABLE_WEBRTC = 203)] =
          "NO_SERVICE_AVAILABLE_WEBRTC"),
        (e[(e.NO_SERVICE_AVAILABLE_CDS = 204)] = "NO_SERVICE_AVAILABLE_CDS"),
        (e[(e.NO_SERVICE_AVAILABLE_CDN = 205)] = "NO_SERVICE_AVAILABLE_CDN"),
        (e[(e.NO_SERVICE_AVAILABLE_TDS = 206)] = "NO_SERVICE_AVAILABLE_TDS"),
        (e[(e.NO_SERVICE_AVAILABLE_REPORT = 207)] =
          "NO_SERVICE_AVAILABLE_REPORT"),
        (e[(e.NO_SERVICE_AVAILABLE_APP_CENTER = 208)] =
          "NO_SERVICE_AVAILABLE_APP_CENTER"),
        (e[(e.NO_SERVICE_AVAILABLE_ENV0 = 209)] = "NO_SERVICE_AVAILABLE_ENV0"),
        (e[(e.NO_SERVICE_AVAILABLE_VOET = 210)] = "NO_SERVICE_AVAILABLE_VOET"),
        (e[(e.NO_SERVICE_AVAILABLE_STRING_UID = 211)] =
          "NO_SERVICE_AVAILABLE_STRING_UID"),
        (e[(e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212)] =
          "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS"),
        (e[(e.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213)] =
          "NO_SERVICE_AVAILABLE_UNILBS_FLV"),
        e
      );
    })({}),
    hG = (function(e) {
      return (
        (e[(e.K_TIMESTAMP_EXPIRED = 2)] = "K_TIMESTAMP_EXPIRED"),
        (e[(e.K_CHANNEL_PERMISSION_INVALID = 3)] =
          "K_CHANNEL_PERMISSION_INVALID"),
        (e[(e.K_CERTIFICATE_INVALID = 4)] = "K_CERTIFICATE_INVALID"),
        (e[(e.K_CHANNEL_NAME_EMPTY = 5)] = "K_CHANNEL_NAME_EMPTY"),
        (e[(e.K_CHANNEL_NOT_FOUND = 6)] = "K_CHANNEL_NOT_FOUND"),
        (e[(e.K_TICKET_INVALID = 7)] = "K_TICKET_INVALID"),
        (e[(e.K_CHANNEL_CONFLICTED = 8)] = "K_CHANNEL_CONFLICTED"),
        (e[(e.K_SERVICE_NOT_READY = 9)] = "K_SERVICE_NOT_READY"),
        (e[(e.K_SERVICE_TOO_HEAVY = 10)] = "K_SERVICE_TOO_HEAVY"),
        (e[(e.K_UID_BANNED = 14)] = "K_UID_BANNED"),
        (e[(e.K_IP_BANNED = 15)] = "K_IP_BANNED"),
        (e[(e.K_CHANNEL_BANNED = 16)] = "K_CHANNEL_BANNED"),
        (e[(e.DATASTREAM2_NOT_AVAILABLE = 27)] = "DATASTREAM2_NOT_AVAILABLE"),
        (e[(e.K_AUTO_REBALANCE = 28)] = "K_AUTO_REBALANCE"),
        (e[(e.WARN_NO_AVAILABLE_CHANNEL = 103)] = "WARN_NO_AVAILABLE_CHANNEL"),
        (e[(e.WARN_LOOKUP_CHANNEL_TIMEOUT = 104)] =
          "WARN_LOOKUP_CHANNEL_TIMEOUT"),
        (e[(e.WARN_LOOKUP_CHANNEL_REJECTED = 105)] =
          "WARN_LOOKUP_CHANNEL_REJECTED"),
        (e[(e.WARN_OPEN_CHANNEL_TIMEOUT = 106)] = "WARN_OPEN_CHANNEL_TIMEOUT"),
        (e[(e.WARN_OPEN_CHANNEL_REJECTED = 107)] =
          "WARN_OPEN_CHANNEL_REJECTED"),
        (e[(e.WARN_REQUEST_DEFERRED = 108)] = "WARN_REQUEST_DEFERRED"),
        (e[(e.ERR_DYNAMIC_KEY_TIMEOUT = 109)] = "ERR_DYNAMIC_KEY_TIMEOUT"),
        (e[(e.ERR_NO_AUTHORIZED = 110)] = "ERR_NO_AUTHORIZED"),
        (e[(e.ERR_VOM_SERVICE_UNAVAILABLE = 111)] =
          "ERR_VOM_SERVICE_UNAVAILABLE"),
        (e[(e.ERR_NO_CHANNEL_AVAILABLE_CODE = 112)] =
          "ERR_NO_CHANNEL_AVAILABLE_CODE"),
        (e[(e.ERR_MASTER_VOCS_UNAVAILABLE = 114)] =
          "ERR_MASTER_VOCS_UNAVAILABLE"),
        (e[(e.ERR_INTERNAL_ERROR = 115)] = "ERR_INTERNAL_ERROR"),
        (e[(e.ERR_NO_ACTIVE_STATUS = 116)] = "ERR_NO_ACTIVE_STATUS"),
        (e[(e.ERR_INVALID_UID = 117)] = "ERR_INVALID_UID"),
        (e[(e.ERR_DYNAMIC_KEY_EXPIRED = 118)] = "ERR_DYNAMIC_KEY_EXPIRED"),
        (e[(e.ERR_STATIC_USE_DYANMIC_KE = 119)] = "ERR_STATIC_USE_DYANMIC_KE"),
        (e[(e.ERR_DYNAMIC_USE_STATIC_KE = 120)] = "ERR_DYNAMIC_USE_STATIC_KE"),
        (e[(e.ERR_NO_VOCS_AVAILABLE = 2e3)] = "ERR_NO_VOCS_AVAILABLE"),
        (e[(e.ERR_NO_VOS_AVAILABLE = 2001)] = "ERR_NO_VOS_AVAILABLE"),
        (e[(e.ERR_JOIN_CHANNEL_TIMEOUT = 2002)] = "ERR_JOIN_CHANNEL_TIMEOUT"),
        (e[(e.ERR_REPEAT_JOIN_CHANNEL = 2003)] = "ERR_REPEAT_JOIN_CHANNEL"),
        (e[(e.ERR_JOIN_BY_MULTI_IP = 2004)] = "ERR_JOIN_BY_MULTI_IP"),
        (e[(e.ERR_NOT_JOINED = 2011)] = "ERR_NOT_JOINED"),
        (e[(e.ERR_REPEAT_JOIN_REQUEST = 2012)] = "ERR_REPEAT_JOIN_REQUEST"),
        (e[(e.ERR_INVALID_VENDOR_KEY = 2013)] = "ERR_INVALID_VENDOR_KEY"),
        (e[(e.ERR_INVALID_CHANNEL_NAME = 2014)] = "ERR_INVALID_CHANNEL_NAME"),
        (e[(e.ERR_INVALID_STRINGUID = 2015)] = "ERR_INVALID_STRINGUID"),
        (e[(e.ERR_TOO_MANY_USERS = 2016)] = "ERR_TOO_MANY_USERS"),
        (e[(e.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017)] =
          "ERR_SET_CLIENT_ROLE_TIMEOUT"),
        (e[(e.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018)] =
          "ERR_SET_CLIENT_ROLE_NO_PERMISSION"),
        (e[(e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019)] =
          "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE"),
        (e[(e.ERR_PUBLISH_REQUEST_INVALID = 2020)] =
          "ERR_PUBLISH_REQUEST_INVALID"),
        (e[(e.ERR_SUBSCRIBE_REQUEST_INVALID = 2021)] =
          "ERR_SUBSCRIBE_REQUEST_INVALID"),
        (e[(e.ERR_NOT_SUPPORTED_MESSAGE = 2022)] = "ERR_NOT_SUPPORTED_MESSAGE"),
        (e[(e.ERR_ILLEAGAL_PLUGIN = 2023)] = "ERR_ILLEAGAL_PLUGIN"),
        (e[(e.ERR_REJOIN_TOKEN_INVALID = 2024)] = "ERR_REJOIN_TOKEN_INVALID"),
        (e[(e.ERR_REJOIN_USER_NOT_JOINED = 2025)] =
          "ERR_REJOIN_USER_NOT_JOINED"),
        (e[(e.ERR_INVALID_OPTIONAL_INFO = 2027)] = "ERR_INVALID_OPTIONAL_INFO"),
        (e[(e.ILLEGAL_AES_PASSWORD = 2028)] = "ILLEGAL_AES_PASSWORD"),
        (e[(e.ILLEGAL_CLIENT_ROLE_LEVEL = 2029)] = "ILLEGAL_CLIENT_ROLE_LEVEL"),
        (e[(e.ERR_TOO_MANY_BROADCASTERS = 2031)] = "ERR_TOO_MANY_BROADCASTERS"),
        (e[(e.ERR_TOO_MANY_SUBSCRIBERS = 2032)] = "ERR_TOO_MANY_SUBSCRIBERS"),
        (e[(e.ERR_LICENSE_MISSING = 32769)] = "ERR_LICENSE_MISSING"),
        (e[(e.ERR_LICENSE_EXPIRED = 32771)] = "ERR_LICENSE_EXPIRED"),
        (e[(e.ERR_LICENSE_MINUTES_EXCEEDED = 32773)] =
          "ERR_LICENSE_MINUTES_EXCEEDED"),
        (e[(e.ERR_LICENSE_PERIOD_INVALID = 32774)] =
          "ERR_LICENSE_PERIOD_INVALID"),
        (e[(e.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778)] =
          "ERR_LICENSE_MULTIPLE_SDK_SERVICE"),
        (e[(e.ERR_LICENSE_ILLEGAL = 32783)] = "ERR_LICENSE_ILLEGAL"),
        (e[(e.ERR_TEST_RECOVER = 9e3)] = "ERR_TEST_RECOVER"),
        (e[(e.ERR_TEST_TRYNEXT = 9001)] = "ERR_TEST_TRYNEXT"),
        (e[(e.ERR_TEST_RETRY = 9002)] = "ERR_TEST_RETRY"),
        e
      );
    })({}),
    uG = (function(e) {
      return (
        (e.CONNECTING = "connecting"),
        (e.CONNECTED = "connected"),
        (e.RECONNECTING = "reconnecting"),
        (e.CLOSED = "closed"),
        e
      );
    })({}),
    pG = (function(e) {
      return (
        (e.WS_CONNECTED = "ws_connected"),
        (e.WS_RECONNECTING = "ws_reconnecting"),
        (e.WS_CLOSED = "ws_closed"),
        (e.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection"),
        (e.ON_BINARY_DATA = "on_binary_data"),
        (e.REQUEST_RECOVER = "request_recover"),
        (e.REQUEST_JOIN_INFO = "request_join_info"),
        (e.REQUEST_REJOIN_INFO = "req_rejoin_info"),
        (e.IS_P2P_DISCONNECTED = "is_p2p_dis"),
        (e.DISCONNECT_P2P = "dis_p2p"),
        (e.ABORT_P2P_EXECUTION = "abort_p2p_execution"),
        (e.NEED_RENEW_SESSION = "need-sid"),
        (e.REPORT_JOIN_GATEWAY = "report_join_gateway"),
        (e.REQUEST_TIMEOUT = "request_timeout"),
        (e.REQUEST_SUCCESS = "request_success"),
        (e.JOIN_RESPONSE = "join_response"),
        (e.PRE_CONNECT_PC = "pre_connect_pc"),
        (e.P2P_CONNECTION = "p2p_connection"),
        (e.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update"),
        (e.P2P_SUBSCRIBE = "p2p_subscribe"),
        (e.P2P_UNSUBSCRIBE = "p2p_unsubscribe"),
        (e.P2P_EXCHANGE_SDP = "p2p_exchange_sdp"),
        (e.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream"),
        (e.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream"),
        (e.RECOVER_NOTIFICATION = "recover_notification"),
        e
      );
    })({}),
    fG = (function(e) {
      return (
        (e.PING = "ping"),
        (e.PING_BACK = "ping_back"),
        (e.JOIN = "join_v3"),
        (e.REJOIN = "rejoin_v3"),
        (e.LEAVE = "leave"),
        (e.SET_CLIENT_ROLE = "set_client_role"),
        (e.PUBLISH = "publish"),
        (e.PUBLISH_DATASTREAM = "publish_datastream"),
        (e.UNPUBLISH = "unpublish"),
        (e.UNPUBLISH_DATASTREAM = "unpublish_datastream"),
        (e.SUBSCRIBE = "subscribe"),
        (e.PRE_SUBSCRIBE = "pre_subscribe"),
        (e.SUBSCRIBE_DATASTREAM = "subscribe_datastream"),
        (e.SUBSCRIBE_STREAMS = "subscribe_streams"),
        (e.UNSUBSCRIBE = "unsubscribe"),
        (e.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream"),
        (e.UNSUBSCRIBE_STREAMS = "unsubscribe_streams"),
        (e.SUBSCRIBE_CHANGE = "subscribe_change"),
        (e.TRAFFIC_STATS = "traffic_stats"),
        (e.RENEW_TOKEN = "renew_token"),
        (e.SWITCH_VIDEO_STREAM = "switch_video_stream"),
        (e.DEFAULT_VIDEO_STREAM = "default_video_stream"),
        (e.SET_FALLBACK_OPTION = "set_fallback_option"),
        (e.GATEWAY_INFO = "gateway_info"),
        (e.CONTROL = "control"),
        (e.SEND_METADATA = "send_metadata"),
        (e.DATA_STREAM = "data_stream"),
        (e.PICK_SVC_LAYER = "pick_svc_layer"),
        (e.RESTART_ICE = "restart_ice"),
        (e.CONNECT_PC = "connect_pc"),
        (e.SET_VIDEO_PROFILE = "set_video_profile"),
        (e.SET_PARAMETER = "set_parameter"),
        (e.SET_RTM2_FLAG = "set_rtm2_flag"),
        e
      );
    })({}),
    EG = (function(e) {
      return (
        (e.WRTC_STATS = "wrtc_stats"),
        (e.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length"),
        (e.DENOISER_STATS = "denoiser_stats"),
        (e.EXTENSION_USAGE_STATS = "extension_usage_stats"),
        e
      );
    })({}),
    mG = (function(e) {
      return (
        (e.ON_USER_ONLINE = "on_user_online"),
        (e.ON_USER_OFFLINE = "on_user_offline"),
        (e.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update"),
        (e.ON_PUBLISH_STREAM = "on_publish_stream"),
        (e.ON_UPLINK_STATS = "on_uplink_stats"),
        (e.ON_P2P_LOST = "on_p2p_lost"),
        (e.ON_REMOVE_STREAM = "on_remove_stream"),
        (e.ON_ADD_AUDIO_STREAM = "on_add_audio_stream"),
        (e.ON_ADD_VIDEO_STREAM = "on_add_video_stream"),
        (e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire"),
        (e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire"),
        (e.ON_USER_BANNED = "on_user_banned"),
        (e.ON_USER_LICENSE_BANNED = "on_user_license_banned"),
        (e.ON_NOTIFICATION = "on_notification"),
        (e.ON_CRYPT_ERROR = "on_crypt_error"),
        (e.MUTE_AUDIO = "mute_audio"),
        (e.MUTE_VIDEO = "mute_video"),
        (e.UNMUTE_AUDIO = "unmute_audio"),
        (e.UNMUTE_VIDEO = "unmute_video"),
        (e.ON_P2P_OK = "on_p2p_ok"),
        (e.RECEIVE_METADATA = "receive_metadata"),
        (e.ON_DATA_STREAM = "on_data_stream"),
        (e.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change"),
        (e.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update"),
        (e.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info"),
        (e.ENABLE_LOCAL_VIDEO = "enable_local_video"),
        (e.DISABLE_LOCAL_VIDEO = "disable_local_video"),
        (e.ENABLE_LOCAL_AUDIO = "enable_local_audio"),
        (e.DISABLE_LOCAL_AUDIO = "disable_local_audio"),
        (e.ON_PUBLISHED_USER_LIST = "on_published_user_list"),
        e
      );
    })({}),
    gG = (function(e) {
      return (e.SEND_ONLY = "SEND_ONLY"), (e.RECEIVE_ONLY = "RECEIVE_ONLY"), e;
    })({}),
    _G = (function(e) {
      return (
        (e.CONNECTED = "websocket:connected"),
        (e.RECONNECTING = "websocket:reconnecting"),
        (e.WILL_RECONNECT = "websocket:will_reconnect"),
        (e.CLOSED = "websocket:closed"),
        (e.FAILED = "websocket:failed"),
        (e.ON_MESSAGE = "websocket:on_message"),
        (e.REQUEST_NEW_URLS = "websocket:request_new_urls"),
        (e.RECONNECT_CREATE_CONNECTION =
          "websocket:reconnect_create_connection"),
        (e.ON_TOKEN_PRIVILEGE_DID_EXPIRE =
          "websocket:on_token_privilege_did_expire"),
        e
      );
    })({});
  function TG(e) {
    if (
      "string" != typeof e ||
      !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(
        e
      )
    )
      throw (EU.error("Invalid Channel Name ".concat(e)),
      new AU(
        zP.INVALID_PARAMS,
        "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,"
      ));
  }
  function SG(e) {
    if (
      !((t = e),
      ("number" == typeof t &&
        Math.floor(t) === t &&
        0 <= t &&
        t <= 4294967295) ||
        nk(e, 1, 255))
    )
      throw new AU(
        zP.INVALID_PARAMS,
        "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]"
      );
    var t;
    "string" == typeof e &&
      EU.warn(
        "You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID."
      );
  }
  let vG = (function(e) {
      return (e.TRANSCODE = "mix_streaming"), (e.RAW = "raw_streaming"), e;
    })({}),
    RG = (function(e) {
      return (e.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager"), e;
    })({});
  function yG(e) {
    if (!e.channelName)
      throw new AU(zP.INVALID_PARAMS, "invalid channelName in info");
    if ("number" != typeof e.uid)
      throw new AU(
        zP.INVALID_PARAMS,
        "invalid uid in info, uid must be a number"
      );
    return (
      e.token && ik(e.token, "info.token", 1, 2047),
      SG(e.uid),
      TG(e.channelName),
      !0
    );
  }
  let AG = (function(e) {
      return (
        (e.RELAY_STATE_IDLE = "RELAY_STATE_IDLE"),
        (e.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING"),
        (e.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING"),
        (e.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE"),
        e
      );
    })({}),
    IG = (function(e) {
      return (
        (e.High = "high"),
        (e.Low = "low"),
        (e.Audio = "audio"),
        (e.Screen = "screen"),
        (e.ScreenLow = "screen_low"),
        e
      );
    })({}),
    CG = (function(e) {
      return (
        (e.DISCONNECT = "disconnect"),
        (e.CONNECTION_STATE_CHANGE = "connection-state-change"),
        (e.NETWORK_QUALITY = "network-quality"),
        (e.STREAM_TYPE_CHANGE = "stream-type-change"),
        (e.IS_P2P_DISCONNECTED = "is-p2p-dis"),
        (e.DISCONNECT_P2P = "dis-p2p"),
        (e.REQUEST_NEW_GATEWAY_LIST = "req-gate-url"),
        (e.NEED_RENEW_SESSION = "need-sid"),
        (e.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params"),
        (e.JOIN_RESPONSE = "join-response"),
        (e.RESET_CONNECTION_EVENTS = "reset-connection-events"),
        (e.PRE_CONNECT_PC = "pre-connect_pc"),
        (e.UPDATE_GATEWAY_CONFIG = "update-gateway-config"),
        e
      );
    })({}),
    bG = (function(e) {
      return (
        (e.P2P_DISCONNECTED = "P2P_DISCONNECTED"),
        (e.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED"),
        (e.TIMEOUT = "TIMEOUT"),
        (e.UNKNOWN_REASON = "UNKNOWN_REASON"),
        e
      );
    })({}),
    OG = (function(e) {
      return (
        (e[(e.Nothing = 0)] = "Nothing"),
        (e[(e.Audio = 1)] = "Audio"),
        (e[(e.LwoVideo = 2)] = "LwoVideo"),
        (e[(e.Video = 4)] = "Video"),
        (e[(e.Data = 8)] = "Data"),
        (e[(e.DataStream0 = 256)] = "DataStream0"),
        (e[(e.DataStream1 = 512)] = "DataStream1"),
        (e[(e.DataStream2 = 1024)] = "DataStream2"),
        (e[(e.DataStream3 = 2048)] = "DataStream3"),
        (e[(e.DataStream4 = 4096)] = "DataStream4"),
        (e[(e.DataStream5 = 8192)] = "DataStream5"),
        (e[(e.DataStream6 = 16384)] = "DataStream6"),
        (e[(e.DataStream7 = 32768)] = "DataStream7"),
        e
      );
    })({}),
    DG = (function(e) {
      return (
        (e.CHINA = "CHINA"),
        (e.ASIA = "ASIA"),
        (e.NORTH_AMERICA = "NORTH_AMERICA"),
        (e.EUROPE = "EUROPE"),
        (e.JAPAN = "JAPAN"),
        (e.INDIA = "INDIA"),
        (e.KOREA = "KOREA"),
        (e.HKMC = "HKMC"),
        (e.US = "US"),
        (e.OCEANIA = "OCEANIA"),
        (e.SOUTH_AMERICA = "SOUTH_AMERICA"),
        (e.AFRICA = "AFRICA"),
        (e.OVERSEA = "OVERSEA"),
        (e.GLOBAL = "GLOBAL"),
        (e.EXTENSIONS = "EXTENSIONS"),
        e
      );
    })({});
  const wG = [
    DG.AFRICA,
    DG.ASIA,
    DG.CHINA,
    DG.EUROPE,
    DG.GLOBAL,
    DG.INDIA,
    DG.JAPAN,
    DG.NORTH_AMERICA,
    DG.OCEANIA,
    DG.OVERSEA,
    DG.SOUTH_AMERICA
  ];
  let LG = (function(e) {
    return (
      (e.CHINA = "CN"),
      (e.ASIA = "AS"),
      (e.NORTH_AMERICA = "NA"),
      (e.EUROPE = "EU"),
      (e.JAPAN = "JP"),
      (e.INDIA = "IN"),
      (e.KOREA = "KR"),
      (e.HKMC = "HK"),
      (e.US = "US"),
      (e.OCEANIA = "OC"),
      (e.SOUTH_AMERICA = "SA"),
      (e.AFRICA = "AF"),
      (e.OVERSEA = "OVERSEA"),
      (e.GLOBAL = "GLOBAL"),
      (e.EXTENSIONS = "GLOBAL"),
      e
    );
  })({});
  const NG = {
    CHINA: {},
    ASIA: {
      CODE: LG.ASIA,
      WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"],
      PROXY_CS: ["proxy-ap-web-asia.agora.io"],
      CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-asia.agora.io",
        "sua-ap-web-asia2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"],
      PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"]
    },
    NORTH_AMERICA: {
      CODE: LG.NORTH_AMERICA,
      WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"],
      PROXY_CS: ["proxy-ap-web-america.agora.io"],
      CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-america.agora.io",
        "sua-ap-web-america2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"],
      PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"]
    },
    EUROPE: {
      CODE: LG.EUROPE,
      WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"],
      PROXY_CS: ["proxy-ap-web-europe.agora.io"],
      CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-europe.agora.io",
        "sua-ap-web-europe.agora.io"
      ],
      UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"],
      PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"]
    },
    JAPAN: {
      CODE: LG.JAPAN,
      WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"],
      PROXY_CS: ["proxy-ap-web-japan.agora.io"],
      CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-japan.agora.io",
        "sua-ap-web-japan2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-japan.agora.io", "uap-ap-web-japan2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"],
      PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"]
    },
    INDIA: {
      CODE: LG.INDIA,
      WEBCS_DOMAIN: ["ap-web-1-india.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"],
      PROXY_CS: ["proxy-ap-web-india.agora.io"],
      CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-india.agora.io",
        "sua-ap-web-india2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-india.agora.io"],
      PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"]
    },
    KOREA: {
      CODE: LG.KOREA,
      WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"],
      PROXY_CS: ["proxy-ap-web-korea.agora.io"],
      CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-korea.agora.io",
        "sua-ap-web-korea2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"],
      PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"]
    },
    HKMC: {
      CODE: LG.HKMC,
      WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"],
      PROXY_CS: ["proxy-ap-web-hkmc.agora.io"],
      CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-hkmc.agora.io",
        "sua-ap-web-hkmc2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"],
      PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"]
    },
    US: {
      CODE: LG.US,
      WEBCS_DOMAIN: ["ap-web-1-us.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"],
      PROXY_CS: ["proxy-ap-web-us.agora.io"],
      CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"],
      ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"],
      UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-us.agora.io"],
      PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"]
    },
    OVERSEA: {
      CODE: LG.OVERSEA,
      WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"],
      PROXY_CS: ["proxy-ap-web-oversea.agora.io"],
      CDS_AP: ["cds-ap-web-oversea.agora.io"],
      ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"],
      UAP_AP: ["uap-ap-web-oversea.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"],
      PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"]
    },
    GLOBAL: {
      CODE: LG.GLOBAL,
      WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"],
      PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
      CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"],
      ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"],
      UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice.agora.io"],
      PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"]
    },
    OCEANIA: {
      CODE: LG.OCEANIA,
      WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"],
      PROXY_CS: ["proxy-ap-web-oceania.agora.io"],
      CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-oceania.agora.io",
        "sua-ap-web-oceania2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"],
      PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"]
    },
    SOUTH_AMERICA: {
      CODE: LG.SOUTH_AMERICA,
      WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"],
      PROXY_CS: ["proxy-ap-web-south-america.agora.io"],
      CDS_AP: [
        "cds-ap-web-south-america.agora.io",
        "cds-ap-web-south-america2.agora.io"
      ],
      ACCOUNT_REGISTER: [
        "sua-ap-web-south-america.agora.io",
        "sua-ap-web-south-america2.agora.io"
      ],
      UAP_AP: [
        "uap-ap-web-south-america.agora.io",
        "uap-ap-web-south-america2.agora.io"
      ],
      EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"],
      PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"]
    },
    AFRICA: {
      CODE: LG.AFRICA,
      WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"],
      PROXY_CS: ["proxy-ap-web-africa.agora.io"],
      CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"],
      ACCOUNT_REGISTER: [
        "sua-ap-web-africa.agora.io",
        "sua-ap-web-africa2.agora.io"
      ],
      UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"],
      EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"],
      EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"],
      LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"],
      PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"]
    },
    EXTENSIONS: {}
  };
  UM &&
    (NG.CHINA = {
      CODE: LG.CHINA,
      WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"],
      WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"],
      PROXY_CS: ["proxy-web.ap.sd-rtn.com"],
      CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"],
      ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"],
      UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"],
      EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"],
      EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"],
      LOG_UPLOAD_SERVER: ["logservice-china.agora.io"],
      PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"]
    });
  let PG = (function(e) {
    return (
      (e.UPDATE_BITRATE_LIMIT = "update_bitrate_limit"),
      (e.UPDATE_CLIENT_ROLE_OPTIONS = "update_client_role_options"),
      e
    );
  })({});
  function kG(e) {
    return (
      !!e &&
      !(!e.uplink || !e.id) &&
        void 0 !== e.uplink.max_bitrate && void 0 !== e.uplink.min_bitrate
    );
  }
  class MG extends uk {
    constructor(e, t) {
      super(),
        (this.onICEConnectionStateChange = void 0),
        (this.onConnectionStateChange = void 0),
        (this.onDTLSTransportStateChange = void 0),
        (this.onDTLSTransportError = void 0),
        (this.onICETransportStateChange = void 0),
        (this.onFirstAudioReceived = void 0),
        (this.onFirstVideoReceived = void 0),
        (this.onFirstAudioDecoded = void 0),
        (this.onFirstVideoDecoded = void 0),
        (this.onFirstVideoDecodedTimeout = void 0),
        (this.onSelectedLocalCandidateChanged = void 0),
        (this.onSelectedRemoteCandidateChanged = void 0),
        (this.onICECandidateError = void 0),
        (this.getLocalVideoStats = void 0);
    }
  }
  class UG extends MG {
    constructor(e, t) {
      super(e, t), (this.establishPromise = void 0);
    }
  }
  let xG = (function(e) {
      return (e.VIDEO = "video"), (e.AUDIO = "audio"), e;
    })({}),
    FG = (function(e) {
      return (
        (e.UDP_RELAY = "udp_relay"),
        (e.UDP_TCP_RELAY = "udp_tcp_relay"),
        (e.TCP_RELAY = "tcp_relay"),
        (e.RELAY = "relay"),
        e
      );
    })({}),
    BG = (function(e) {
      return (
        (e[(e.FIRST_CONNECTION = 0)] = "FIRST_CONNECTION"),
        (e[(e.UDP_TCP_RESTART = 1)] = "UDP_TCP_RESTART"),
        (e[(e.RELAY_RESTART = 2)] = "RELAY_RESTART"),
        (e[(e.TCP_RESTART = 3)] = "TCP_RESTART"),
        (e[(e.OLD_FIRST_CONNECTION = 10)] = "OLD_FIRST_CONNECTION"),
        (e[(e.OLD_RESTART = 11)] = "OLD_RESTART"),
        (e[(e.DISCONNECTED_OR_FAILED = 20)] = "DISCONNECTED_OR_FAILED"),
        e
      );
    })({});
  const VG = ["disconnected", "failed"];
  let GG = (function(e) {
      return (
        (e.LocalVideoTrack = "videoTrack"),
        (e.LocalAudioTrack = "audioTrack"),
        (e.LocalVideoLowTrack = "videoLowTrack"),
        e
      );
    })({}),
    jG = (function(e) {
      return (
        (e.New = "new"),
        (e.Connected = "connected"),
        (e.Reconnecting = "reconnecting"),
        (e.Disconnected = "disconnected"),
        e
      );
    })({}),
    HG = (function(e) {
      return (
        (e.AudioMetadata = "audioMetadata"),
        (e.StateChange = "stateChange"),
        (e.IceConnectionStateChange = "iceConnectionStateChange"),
        (e.RequestMuteLocal = "requestMuteLocal"),
        (e.RequestUnmuteLocal = "requestUnmuteLocal"),
        (e.RequestRePublish = "requestRePublish"),
        (e.RequestRePublishDataChannel = "requestRePublishDataChannel"),
        (e.RequestReSubscribe = "requestReSubscribe"),
        (e.RequestUploadStats = "requestUploadStats"),
        (e.RequestUpload = "requestUpload"),
        (e.MediaReconnectStart = "MediaReconnectStart"),
        (e.MediaReconnectEnd = "MediaReconnectEnd"),
        (e.NeedSignalRTT = "NeedSignalRTT"),
        (e.RequestRestartICE = "RequestRestartIce"),
        (e.PeerConnectionStateChange = "PeerConnectionStateChange"),
        (e.RequestReconnect = "RequestReconnect"),
        (e.RequestReconnectPC = "RequestReconnectPC"),
        (e.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC"),
        (e.P2PLost = "P2PLost"),
        (e.UpdateVideoEncoder = "UpdateVideoEncoder"),
        (e.ConnectionTypeChange = "ConnectionTypeChange"),
        (e.RequestLowStreamParameter = "RequestLowStreamParameter"),
        (e.QueryClientConnectionState = "QueryClientConnectionState"),
        (e.LocalCandidate = "LocalCandidate"),
        (e.RequestP2PMuteLocal = "requestP2PMuteLocal"),
        (e.RequestP2PUnPublish = "RequestP2PUnPublish"),
        (e.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote"),
        (e.RequestP2PMuteRemote = "RequestP2PMuteRemote"),
        (e.RequestP2PRestartICE = "RequestP2PRestartICE"),
        e
      );
    })({}),
    KG = (function(e) {
      return (
        (e.CONNECTING = "CONNECTING"),
        (e.RECONNECTING = "RECONNECTING"),
        (e.CONNECTED = "CONNECTED"),
        (e.CLOSED = "CLOSED"),
        e
      );
    })({}),
    WG = (function(e) {
      return (
        (e.CONNECTION_STATE_CHANGE = "connection-state-change"),
        (e.STATE_CHANGE = "state-change"),
        (e.INSPECT_RESULT = "inspect-result"),
        (e.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track"),
        (e.REQUEST_NEW_WORKER_URL = "request-new-worker-url"),
        e
      );
    })({}),
    YG = (function(e) {
      return (
        (e.CONNECTED = "transmitter:connected"),
        (e.RECONNECTING = "transmitter:reconnecting"),
        (e.WILL_RECONNECT = "transmitter:will_reconnect"),
        (e.CLOSED = "transmitter:closed"),
        (e.FAILED = "transmitter:failed"),
        (e.ON_MESSAGE = "transmitter:on_message"),
        (e.REQUEST_NEW_URLS = "transmitter:request_new_urls"),
        (e.RECONNECT_CREATE_CONNECTION =
          "transmitter:reconnect_create_connection"),
        (e.ON_TOKEN_PRIVILEGE_DID_EXPIRE =
          "transmitter:on_token_privilege_did_expire"),
        (e.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel"),
        (e.FAILBACK = "transmitter:failback"),
        (e.PRE_CONNECT_PC = "transmitter:pre_connect_pc"),
        e
      );
    })({}),
    $G = (function(e) {
      return (
        (e.CAMERA_CHANGED = "camera-changed"),
        (e.MICROPHONE_CHANGED = "microphone-changed"),
        (e.PLAYBACK_DEVICE_CHANGED = "playback-device-changed"),
        (e.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed"),
        (e.AUTOPLAY_FAILED = "autoplay-failed"),
        (e.AUDIO_CONTEXT_STATE_CHANGED = "audio-context-state-changed"),
        (e.SECURITY_POLICY_VIOLATION = "security-policy-violation"),
        e
      );
    })({}),
    qG = (function(e) {
      return (
        (e.CONNECTING = "CONNECTING"),
        (e.RECONNECTING = "RECONNECTING"),
        (e.CONNECTED = "CONNECTED"),
        (e.CLOSED = "CLOSED"),
        e
      );
    })({}),
    XG = (function(e) {
      return (
        (e.CONNECTION_STATE_CHANGE = "connection-state-change"),
        (e.STATE_CHANGE = "state-change"),
        (e.INSPECT_RESULT = "inspect-result"),
        (e.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track"),
        (e.REQUEST_NEW_WORKER_URL = "request-new-worker-url"),
        e
      );
    })({}),
    zG = (function(e) {
      return (
        (e.CALL = "call"),
        (e.CANDIDATE = "candidate"),
        (e.PUBLISH = "publish"),
        (e.UNPUBLISH = "unpublish"),
        (e.CONTROL = "control"),
        (e.RESTART_ICE = "restart_ice"),
        (e.ACK = "ack"),
        (e.RESPONSE = "response"),
        (e.JOIN = "join"),
        (e.CHECK = "check"),
        e
      );
    })({}),
    JG = (function(e) {
      return (
        (e.MUTE_LOCAL_AUDIO = "mute_local_audio"),
        (e.MUTE_LOCAL_VIDEO = "mute_local_video"),
        (e.UNMUTE_LOCAL_AUDIO = "unmute_local_audio"),
        (e.UNMUTE_LOCAL_VIDEO = "unmute_local_video"),
        e
      );
    })({});
  const QG = {
    [oG.ACCESS_POINT]: {
      [lG.NO_FLAG_SET]: { desc: "flag is zero", retry: !1 },
      [lG.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: !1 },
      [lG.INVALID_FALG_SET]: { desc: "invalid flag", retry: !1 },
      [lG.FLAG_SET_BUT_NO_RE]: {
        desc: "flag set unilbs but no request",
        retry: !1
      },
      [lG.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: !1 },
      [lG.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: !0 },
      [lG.NO_SERVICE_AVAILABLE_P2P]: {
        desc: "no unilbs p2p service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_VOICE]: {
        desc: "no unilbs voice service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_WEBRTC]: {
        desc: "no unilbs webrtc service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_CDS]: {
        desc: "no cds service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_CDN]: {
        desc: "no cdn dispatcher service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_TDS]: {
        desc: "no tds service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_REPORT]: {
        desc: "no unilbs report service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_APP_CENTER]: {
        desc: "no app center service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_ENV0]: {
        desc: "no unilbs sig env0 service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_VOET]: {
        desc: "no unilbs voet service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_STRING_UID]: {
        desc: "no string uid service available",
        retry: !0
      },
      [lG.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: {
        desc: "no webrtc unilbs service available",
        retry: !0
      }
    },
    [oG.UNILBS]: {
      [dG.INVALID_VENDOR_KEY]: {
        desc: "invalid vendor key, can not find appid",
        retry: !1
      },
      [dG.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: !1 },
      [dG.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: !1 },
      [dG.NO_AUTHORIZED]: {
        desc: "invalid token, authorized failed",
        retry: !1
      },
      [dG.DYNAMIC_KEY_TIMEOUT]: {
        desc: "dynamic key or token timeout",
        retry: !1
      },
      [dG.NO_ACTIVE_STATUS]: { desc: "no active status", retry: !1 },
      [dG.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: !1 },
      [dG.STATIC_USE_DYNAMIC_KEY]: {
        desc: "static use dynamic key",
        retry: !1
      },
      [dG.DYNAMIC_USE_STATIC_KEY]: {
        desc: "dynamic use static key",
        retry: !1
      },
      [dG.USER_OVERLOAD]: { desc: "amount of users over load", retry: !1 },
      [dG.FORBIDDEN_REGION]: {
        desc: "the request is forbidden in this area",
        retry: !1
      },
      [dG.CANNOT_MEET_AREA_DEMAND]: {
        desc: "unable to allocate services in this area",
        retry: !1
      }
    },
    [oG.STRING_UID_ALLOCATOR]: {
      [cG.IIIEGAL_APPID]: { desc: "invalid appid", retry: !1 },
      [cG.IIIEGAL_UID]: { desc: "invalid string uid", retry: !1 },
      [cG.INTERNAL_ERROR]: {
        desc: "string uid allocator internal error",
        retry: !0
      }
    }
  };
  function ZG(e) {
    const t = QG[Math.floor(e / 1e4)];
    if (!t) return { desc: "unknown error", retry: !1 };
    const i = t[e % 1e4];
    if (!i) {
      if (Math.floor(e / 1e4) === oG.ACCESS_POINT) {
        const t = e % 1e4;
        if ("1" === t.toString()[0]) return { desc: e.toString(), retry: !1 };
        if ("2" === t.toString()[0]) return { desc: e.toString(), retry: !0 };
      }
      return { desc: "unknown error", retry: !1 };
    }
    return i;
  }
  const ej = {
    [hG.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" },
    [hG.K_CHANNEL_PERMISSION_INVALID]: {
      desc: "K_CHANNEL_PERMISSION_INVALID",
      action: "failed"
    },
    [hG.K_CERTIFICATE_INVALID]: {
      desc: "K_CERTIFICATE_INVALID",
      action: "failed"
    },
    [hG.K_CHANNEL_NAME_EMPTY]: {
      desc: "K_CHANNEL_NAME_EMPTY",
      action: "failed"
    },
    [hG.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" },
    [hG.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" },
    [hG.K_CHANNEL_CONFLICTED]: {
      desc: "K_CHANNEL_CONFLICTED",
      action: "failed"
    },
    [hG.K_SERVICE_NOT_READY]: {
      desc: "K_SERVICE_NOT_READY",
      action: "tryNext"
    },
    [hG.K_SERVICE_TOO_HEAVY]: {
      desc: "K_SERVICE_TOO_HEAVY",
      action: "tryNext"
    },
    [hG.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" },
    [hG.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" },
    [hG.DATASTREAM2_NOT_AVAILABLE]: {
      desc: "DATASTREAM2_NOT_AVAILABLE",
      action: "quit"
    },
    [hG.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" },
    [hG.ERR_INVALID_VENDOR_KEY]: {
      desc: "ERR_INVALID_VENDOR_KEY",
      action: "failed"
    },
    [hG.ERR_INVALID_CHANNEL_NAME]: {
      desc: "ERR_INVALID_CHANNEL_NAME",
      action: "failed"
    },
    [hG.WARN_NO_AVAILABLE_CHANNEL]: {
      desc: "WARN_NO_AVAILABLE_CHANNEL",
      action: "failed"
    },
    [hG.WARN_LOOKUP_CHANNEL_TIMEOUT]: {
      desc: "WARN_LOOKUP_CHANNEL_TIMEOUT",
      action: "tryNext"
    },
    [hG.WARN_LOOKUP_CHANNEL_REJECTED]: {
      desc: "WARN_LOOKUP_CHANNEL_REJECTED",
      action: "failed"
    },
    [hG.WARN_OPEN_CHANNEL_TIMEOUT]: {
      desc: "WARN_OPEN_CHANNEL_TIMEOUT",
      action: "tryNext"
    },
    [hG.WARN_OPEN_CHANNEL_REJECTED]: {
      desc: "WARN_OPEN_CHANNEL_REJECTED",
      action: "failed"
    },
    [hG.WARN_REQUEST_DEFERRED]: {
      desc: "WARN_REQUEST_DEFERRED",
      action: "failed"
    },
    [hG.ERR_DYNAMIC_KEY_TIMEOUT]: {
      desc: "ERR_DYNAMIC_KEY_TIMEOUT",
      action: "failed"
    },
    [hG.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" },
    [hG.ERR_VOM_SERVICE_UNAVAILABLE]: {
      desc: "ERR_VOM_SERVICE_UNAVAILABLE",
      action: "tryNext"
    },
    [hG.ERR_NO_CHANNEL_AVAILABLE_CODE]: {
      desc: "ERR_NO_CHANNEL_AVAILABLE_CODE",
      action: "failed"
    },
    [hG.ERR_MASTER_VOCS_UNAVAILABLE]: {
      desc: "ERR_MASTER_VOCS_UNAVAILABLE",
      action: "tryNext"
    },
    [hG.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" },
    [hG.ERR_NO_ACTIVE_STATUS]: {
      desc: "ERR_NO_ACTIVE_STATUS",
      action: "failed"
    },
    [hG.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" },
    [hG.ERR_DYNAMIC_KEY_EXPIRED]: {
      desc: "ERR_DYNAMIC_KEY_EXPIRED",
      action: "failed"
    },
    [hG.ERR_STATIC_USE_DYANMIC_KE]: {
      desc: "ERR_STATIC_USE_DYANMIC_KE",
      action: "failed"
    },
    [hG.ERR_DYNAMIC_USE_STATIC_KE]: {
      desc: "ERR_DYNAMIC_USE_STATIC_KE",
      action: "failed"
    },
    [hG.ERR_NO_VOCS_AVAILABLE]: {
      desc: "ERR_NO_VOCS_AVAILABLE",
      action: "tryNext"
    },
    [hG.ERR_NO_VOS_AVAILABLE]: {
      desc: "ERR_NO_VOS_AVAILABLE",
      action: "tryNext"
    },
    [hG.ERR_JOIN_CHANNEL_TIMEOUT]: {
      desc: "ERR_JOIN_CHANNEL_TIMEOUT",
      action: "tryNext"
    },
    [hG.ERR_JOIN_BY_MULTI_IP]: {
      desc: "ERR_JOIN_BY_MULTI_IP",
      action: "recover"
    },
    [hG.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" },
    [hG.ERR_REPEAT_JOIN_REQUEST]: {
      desc: "ERR_REPEAT_JOIN_REQUEST",
      action: "quit"
    },
    [hG.ERR_REPEAT_JOIN_CHANNEL]: {
      desc: "ERR_REPEAT_JOIN_CHANNEL",
      action: "quit"
    },
    [hG.ERR_INVALID_STRINGUID]: {
      desc: "ERR_INVALID_STRINGUID",
      action: "failed"
    },
    [hG.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" },
    [hG.ERR_SET_CLIENT_ROLE_TIMEOUT]: {
      desc: "ERR_SET_CLIENT_ROLE_TIMEOUT",
      action: "failed"
    },
    [hG.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: {
      desc: "ERR_SET_CLIENT_ROLE_TIMEOUT",
      action: "failed"
    },
    [hG.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: {
      desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE",
      action: "success"
    },
    [hG.ERR_PUBLISH_REQUEST_INVALID]: {
      desc: "ERR_PUBLISH_REQUEST_INVALID",
      action: "failed"
    },
    [hG.ERR_SUBSCRIBE_REQUEST_INVALID]: {
      desc: "ERR_SUBSCRIBE_REQUEST_INVALID",
      action: "failed"
    },
    [hG.ERR_NOT_SUPPORTED_MESSAGE]: {
      desc: "ERR_NOT_SUPPORTED_MESSAGE",
      action: "failed"
    },
    [hG.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" },
    [hG.ILLEGAL_CLIENT_ROLE_LEVEL]: {
      desc: "ILLEGAL_CLIENT_ROLE_LEVEL",
      action: "failed"
    },
    [hG.ERR_REJOIN_TOKEN_INVALID]: {
      desc: "ERR_REJOIN_TOKEN_INVALID",
      action: "failed"
    },
    [hG.ERR_REJOIN_USER_NOT_JOINED]: {
      desc: "ERR_REJOIN_NOT_JOINED",
      action: "failed"
    },
    [hG.ERR_INVALID_OPTIONAL_INFO]: {
      desc: "ERR_INVALID_OPTIONAL_INFO",
      action: "quit"
    },
    [hG.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" },
    [hG.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" },
    [hG.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" },
    [hG.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" },
    [hG.ERR_TOO_MANY_BROADCASTERS]: {
      desc: "ERR_TOO_MANY_BROADCASTERS",
      action: "failed"
    },
    [hG.ERR_TOO_MANY_SUBSCRIBERS]: {
      desc: "ERR_TOO_MANY_SUBSCRIBERS",
      action: "failed"
    },
    [hG.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" },
    [hG.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" },
    [hG.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" },
    [hG.ERR_LICENSE_MINUTES_EXCEEDED]: {
      desc: "ERR_LICENSE_MINUTES_EXCEEDED",
      action: "quit"
    },
    [hG.ERR_LICENSE_PERIOD_INVALID]: {
      desc: "ERR_LICENSE_PERIOD_INVALID",
      action: "quit"
    },
    [hG.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: {
      desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE",
      action: "quit"
    }
  };
  function tj(e) {
    const t = ej[e];
    return t || { desc: "UNKNOWN_ERROR_".concat(e), action: "failed" };
  }
  function ij(e, t) {
    if ("string" == typeof e) return e;
    const { proxy: i, host: s, port: r } = e;
    if (t) {
      const e = WM("JOIN_GATEWAY_FALLBACK_PORT") || 443;
      return 443 === e
        ? "wss://".concat(s, "/ws/?p=").concat(Number(r) + 150)
        : "wss://"
            .concat(s, ":")
            .concat(e, "/ws/?p=")
            .concat(Number(r) + 150);
    }
    return i
      ? "wss://"
          .concat(i, "/ws/?h=")
          .concat(s, "&p=")
          .concat(r)
      : "wss://".concat(s, ":").concat(r);
  }
  const sj = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/,
    rj = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/,
    nj = /wss:\/\/(.+):([0-9]+)\/?/,
    aj = /wss:\/\/(.[^\/]+)\/?/;
  let oj = 0;
  class cj {
    constructor(e, t) {
      (this.id = 0),
        (this.store = void 0),
        (this.recordIndex = void 0),
        (this.websockets = []),
        (this.try443PortDuration = 2e3),
        (this.forceCloseWSDuration = 5e3),
        (this.try443PortTimeout = null),
        (this.forceCloseTimeout = null),
        (this.isTry443PortFailed = !1),
        (this.isNormalPortFailed = !1),
        (this.useDoubleDomain = !1),
        (this.useProxy = !1),
        (this.startTime = Date.now()),
        (this.id = ++oj),
        (this.try443PortDuration =
          WM("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3),
        (this.forceCloseWSDuration = e || 5e3),
        (this.store = t);
    }
    closeAllWebsockets() {
      this.websockets.forEach(e => {
        (e.onopen = null), (e.onclose = null), (e.onmessage = null), e.close();
      }),
        (this.websockets.length = 0);
    }
    clearTimeout() {
      this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout),
        this.try443PortTimeout && clearTimeout(this.try443PortTimeout),
        (this.forceCloseTimeout = null),
        (this.try443PortTimeout = null);
    }
    logger() {
      var e;
      const t = Date.now() - this.startTime;
      for (var i = arguments.length, s = new Array(i), r = 0; r < i; r++)
        s[r] = arguments[r];
      EU.debug(
        "[choose-best-ws "
          .concat(
            null === (e = this.store) || void 0 === e ? void 0 : e.clientId,
            " "
          )
          .concat(this.id, "] ")
          .concat(t, "ms:"),
        ...s
      );
    }
    createWebSocket(e, t, i) {
      this.logger("createWebSocket:", e, {
        isTry443Port: t,
        hasTimeoutDetection: i
      });
      const s = WM("GATEWAY_DOMAINS"),
        r = Date.now(),
        n = [],
        a = s.find(t => e.host.includes(t));
      a || (this.useDoubleDomain = !1);
      const o = [];
      if (this.useDoubleDomain)
        s.forEach(i => {
          o.push(ij(rG(rG({}, e), {}, { host: e.host.replace(a, i) }), t));
        });
      else {
        const i = rG({}, e);
        if (t && a) {
          const e = s.find(e => e !== a);
          e && (i.host = i.host.replace(a, e));
        }
        o.push(ij(i, t));
      }
      try {
        o.forEach(e => {
          const t = new WebSocket(e);
          (t.binaryType = "arraybuffer"),
            n.push(t),
            this.logger("ws is connecting:", t.url);
        });
      } catch (s) {
        if (
          (this.logger("ws create failed"),
          n.forEach(e => e.close()),
          (n.length = 0),
          this.useDoubleDomain)
        )
          return (this.useDoubleDomain = !1), this.createWebSocket(e, t, i);
        if (!t && 443 !== Number(e.port)) return this.createWebSocket(e, !0, i);
        throw new AU(
          zP.WS_ERR,
          "init websocket failed! Error: ".concat(s.toString())
        );
      }
      const c = uP();
      this.store &&
        this.store.recordJoinChannelService(
          { urls: n.map(e => e.url), service: "gateway" },
          this.recordIndex
        ),
        n.forEach(e => {
          (e.onopen = () => {
            this.logger(
              "onopen: ws "
                .concat(e.url, " open cost ")
                .concat(Date.now() - r, "ms")
            ),
              this.websockets.forEach(t => {
                t !== e &&
                  ((t.onopen = null),
                  (t.onclose = null),
                  (t.onmessage = null),
                  t.close(),
                  this.logger("close backup websocket: ".concat(t.url)));
              }),
              (this.websockets.length = 0),
              c.resolve(e);
          }),
            (e.onclose = i => {
              this.logger(
                "onclose: ws "
                  .concat(e.url, " closed cost ")
                  .concat(Date.now() - r, "ms state: ")
                  .concat(e.readyState)
              );
              const s = n.every(
                e =>
                  e.readyState === WebSocket.CLOSED ||
                  e.readyState === WebSocket.CLOSING
              );
              this.logger(
                ""
                  .concat(t ? "443" : "47xx", " websocket closed, all failed: ")
                  .concat(s)
              ),
                s && (t || this.isTry443PortFailed || this.useProxy)
                  ? (this.logger(
                      "onclose: all websocket is closed, ".concat(i.reason)
                    ),
                    c.reject({ code: i.code, reason: bG.A_ROUND_WS_FAILED }))
                  : !t &&
                    s &&
                    !this.isNormalPortFailed &&
                    this.try443PortTimeout &&
                    (this.logger("all 47xx websocket is closed, try 443 port"),
                    this.clearTimeout(),
                    l()),
                t
                  ? (this.isTry443PortFailed = s)
                  : (this.isNormalPortFailed = s);
            }),
            (e.onmessage = t =>
              this.logger("".concat(e.url, " onmessage: ").concat(t.data)));
        }),
        this.websockets.push(...n);
      const d = () => {
          this.websockets.forEach(
            e => e.readyState !== WebSocket.OPEN && e.close()
          );
        },
        l = () => {
          if (c.isResolved) return d();
          vP().os === mP.MAC_OS && DP() && d(),
            this.createWebSocket(e, !0, !0)
              .then(e => {
                c.resolve(e);
              })
              .catch(e => {
                this.isNormalPortFailed && c.reject(e),
                  this.logger("try 443 port to create ws failed");
              }),
            (this.forceCloseTimeout = window.setTimeout(() => {
              this.logger(
                "5s timeout close un-opens, isWebsocket created: ",
                c.isResolved
              ),
                (this.forceCloseTimeout = null),
                d();
            }, this.forceCloseWSDuration));
        };
      return (
        i ||
          (() => {
            if (t || this.useProxy)
              return (
                this.logger(
                  "add 5s timeout at ".concat(
                    t ? "try-443" : "proxy",
                    " condition"
                  )
                ),
                (this.forceCloseTimeout = window.setTimeout(() => {
                  (this.forceCloseTimeout = null), d();
                }, this.forceCloseWSDuration))
              );
            this.try443PortTimeout = window.setTimeout(() => {
              this.logger("2s timeout, isWebsocket created: ", c.isResolved),
                (this.try443PortTimeout = null),
                l();
            }, this.try443PortDuration);
          })(),
        c.promise
      );
    }
    chooseBestWebsocket(e, t, i, s) {
      return (
        (this.useDoubleDomain = !!t),
        "string" == typeof e &&
          (e = (function(e) {
            let t, i, s;
            return (
              ([, t, i, s] = e.match(sj) || []),
              t || ([, i, s] = e.match(rj) || []),
              (i && s) || ([, i, s] = e.match(nj) || []),
              (i && s) || ([, i] = e.match(aj) || []),
              i || EU.warning("un-destructible url: ", e),
              { proxy: t, host: i, port: s || "443" }
            );
          })(e)),
        (this.recordIndex = s),
        (this.useProxy = !!e.proxy),
        i &&
          this.useProxy &&
          (EU.warn("cannot use 443 only when use proxy"), (i = !1)),
        this.createWebSocket(e, !!i, !1).finally(() => this.clearTimeout())
      );
    }
  }
  class dj extends uk {
    get url() {
      return (this.websocket && this.websocket.url) || null;
    }
    get reconnectMode() {
      return this._reconnectMode;
    }
    set reconnectMode(e) {
      ["tryNext", "recover"].includes(e) && this.resetReconnectCount(e),
        (this._reconnectMode = e);
    }
    get state() {
      return this._state;
    }
    set state(e) {
      e !== this._state &&
        ((this._state = e),
        "reconnecting" === this._state
          ? this.emit(_G.RECONNECTING, this.reconnectReason)
          : "connected" === this._state
          ? this.emit(_G.CONNECTED)
          : "closed" === this._state
          ? this.emit(_G.CLOSED)
          : "failed" === this._state && this.emit(_G.FAILED));
    }
    resetReconnectCount(e) {
      EU.debug("websocket reset reconnect count, reason: " + e),
        (this.reconnectCount = 0);
    }
    constructor(e, t) {
      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
        s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
        r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
        n = arguments.length > 5 ? arguments[5] : void 0;
      super(),
        (this.connectionID = 0),
        (this.currentURLIndex = 0),
        (this.urls = []),
        (this._reconnectMode = "tryNext"),
        (this.reconnectReason = void 0),
        (this._initMutex = void 0),
        (this.name = void 0),
        (this._state = "closed"),
        (this.reconnectInterrupter = void 0),
        (this.websocket = void 0),
        (this.retryConfig = void 0),
        (this.reconnectCount = 0),
        (this.forceCloseTimeout = 5e3),
        (this.onlineReconnectListener = void 0),
        (this.useCompress = void 0),
        (this.tryDoubleDomain = !1),
        (this.use443PortOnly = !1),
        (this.wsInflateLength = 0),
        (this.wsDeflateLength = 0),
        (this.closeEstablishingWs = () => {}),
        (this.store = void 0),
        (this.joinGatewayRecordIndex = void 0),
        (this.store = n),
        (this.name = e),
        (this.retryConfig = rG({}, t)),
        (this.useCompress = i),
        (this.tryDoubleDomain = s),
        (this.use443PortOnly = r),
        (this._initMutex = new sM("websocket", n ? n.clientId : void 0));
      const { timeout: a, timeoutFactor: o } = t,
        c = Math.max(300, Math.floor((3 * a) / 5)),
        d = Math.max(1.2, Math.floor(8 * o) / 10);
      Ak.ONLINE &&
        ((this.retryConfig.timeout = c), (this.retryConfig.timeoutFactor = d)),
        wk.on(Ik.NETWORK_STATE_CHANGE, (e, t) => {
          e !== t &&
            (this.resetReconnectCount(
              "network state change: ".concat(t, " -> ").concat(e)
            ),
            e === Ak.ONLINE
              ? ((this.retryConfig.timeout = c),
                (this.retryConfig.timeoutFactor = d))
              : ((this.retryConfig.timeout = a),
                (this.retryConfig.timeoutFactor = o)));
        });
    }
    getConnection() {
      return this.websocket || void 0;
    }
    async init(e) {
      let t =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
      const i = await this._initMutex.lock();
      (this._reconnectMode = "tryNext"),
        (this.forceCloseTimeout = t),
        (this.urls = e),
        (this.state = "connecting");
      try {
        const e = uP(),
          t = this.urls[this.currentURLIndex];
        WM("ENABLE_PREALLOC_PC") && this.emit(YG.PRE_CONNECT_PC),
          this.createWebSocketConnection(t)
            .then(e.resolve)
            .catch(e.reject),
          this.once(_G.CLOSED, () => {
            e.reject(new JP(zP.WS_DISCONNECT));
          }),
          this.once(_G.CONNECTED, e.resolve),
          await e.promise;
      } catch (e) {
      } finally {
        i();
      }
    }
    close(e, t) {
      if (
        ((this.currentURLIndex = 0),
        this.resetReconnectCount("close"),
        this.reconnectInterrupter && this.reconnectInterrupter(),
        this.websocket)
      ) {
        (this.websocket.onclose = null),
          (this.websocket.onopen = null),
          (this.websocket.onmessage = null);
        const e = this.websocket;
        t ? setTimeout(() => e.close(), 500) : e.close(),
          (this.websocket = void 0);
      }
      (this.state = e ? "failed" : "closed"),
        this.closeEstablishingWs && this.closeEstablishingWs();
    }
    reconnect(e, t) {
      if (!this.websocket)
        return void EU.warning(
          "[".concat(this.name, "] can not reconnect, no websocket")
        );
      void 0 !== e && (this.reconnectMode = e),
        EU.debug("[".concat(this.name, "] reconnect is triggered initiative")),
        "number" == typeof this.joinGatewayRecordIndex &&
          this.store &&
          this.store.recordJoinChannelService(
            { status: "error", errors: [new Error(t)] },
            this.joinGatewayRecordIndex
          );
      const i = this.websocket.onclose;
      (this.websocket.onclose = null),
        this.websocket.close(),
        i && i.bind(this.websocket)({ code: 9999, reason: t });
    }
    sendMessage(e) {
      let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN)
        throw new JP(zP.WS_ABORT, "websocket is not ready");
      try {
        t || (e = JSON.stringify(e)), this.websocket.send(e);
      } catch (e) {
        throw new JP(zP.WS_ERR, "send websocket message error" + e.toString());
      }
    }
    setWsInflateData(e) {
      (this.wsDeflateLength = this.wsDeflateLength + e.originLength),
        (this.wsInflateLength = this.wsInflateLength + e.compressedLength);
    }
    getWsInflateData() {
      const e = this.wsInflateLength,
        t = this.wsDeflateLength;
      return (
        this.clearWsInflateData(), { wsInflateLength: e, wsDeflateLength: t }
      );
    }
    clearWsInflateData() {
      (this.wsInflateLength = 0), (this.wsDeflateLength = 0);
    }
    async createWebSocketConnection(e) {
      var t;
      const i = uP();
      (this.connectionID += 1), (this.joinGatewayRecordIndex = void 0);
      const s = e => {
          var t;
          null === (t = this.store) || void 0 === t || t.signalChannelOpen(),
            EU.debug("[".concat(this.name, "] websocket opened:"), e),
            (this.reconnectMode = "retry"),
            (this.state = "connected"),
            this.resetReconnectCount("opened"),
            i.resolve();
        },
        r = async e => {
          var t;
          if (
            (EU.debug(
              "["
                .concat(this.name, "] websocket close ")
                .concat(
                  null === (t = this.websocket) || void 0 === t
                    ? void 0
                    : t.url,
                  ", code: "
                )
                .concat(e.code, ", reason: ")
                .concat(e.reason, ", current mode: ")
                .concat(this.reconnectMode)
            ),
            this.reconnectCount >= this.retryConfig.maxRetryCount)
          )
            i.reject(
              new JP(zP.WS_DISCONNECT, "websocket close: ".concat(e.code))
            ),
              this.close();
          else {
            "connected" === this.state &&
              ((this.reconnectReason = e.reason),
              (this.state = "reconnecting"));
            const t =
                Ok(this, _G.WILL_RECONNECT, this.reconnectMode, e.reason) ||
                this.reconnectMode,
              s = await this.reconnectWithAction(t);
            if ("closed" === this.state)
              return void EU.debug(
                "[".concat(
                  this.connectionID,
                  "] ws is closed, no need to reconnect"
                )
              );
            if (!s)
              return (
                i.reject(
                  new JP(
                    zP.WS_DISCONNECT,
                    "websocket reconnect failed: ".concat(e.code)
                  )
                ),
                this.close(!0)
              );
            i.resolve();
          }
        },
        n = e => {
          this.emit(_G.ON_MESSAGE, e);
        },
        a = e => {
          EU.warn("[".concat(this.connectionID, "] ws open error ").concat(e));
        };
      this.websocket &&
        ((this.websocket.onclose = null), this.websocket.close()),
        WM("GATEWAY_WSS_ADDRESS") &&
          this.name.startsWith("gateway") &&
          (e = WM("GATEWAY_WSS_ADDRESS")),
        EU.debug("[".concat(this.name, "] start connect, url:"), e);
      const o =
        null === (t = this.store) || void 0 === t
          ? void 0
          : t.recordJoinChannelService({
              startTs: Date.now(),
              status: "pending",
              service: "gateway"
            });
      try {
        var c;
        const t = await this.chooseBestWebsocketConnection(e);
        (this.websocket = t),
          s && s(this.websocket.url),
          (this.websocket.onclose = r),
          (this.websocket.onmessage = n),
          (this.websocket.onerror = a),
          null === (c = this.store) ||
            void 0 === c ||
            c.recordJoinChannelService(
              { endTs: Date.now(), status: "success" },
              o
            ),
          (this.joinGatewayRecordIndex = o);
      } catch (e) {
        const t = "closed" === this.state,
          s = e instanceof JP,
          n = s && e.code === zP.WS_ABORT,
          a = s && e.code === zP.WS_ERR,
          c = s ? e.message : e && (e.reason || e.toString());
        EU.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c)),
          this.store &&
            this.store.recordJoinChannelService(
              {
                endTs: Date.now(),
                status: n ? "aborted" : "error",
                errors: [e]
              },
              o
            ),
          t || a
            ? (i.reject(
                t
                  ? new JP(zP.WS_DISCONNECT, "websocket is closed: ".concat(c))
                  : new JP(zP.WS_ERR, "init websocket failed: ".concat(c))
              ),
              a &&
                EU.error(
                  "[".concat(this.name, "] init websocket failed: ").concat(c)
                ))
            : r && r(e);
      }
      return i.promise;
    }
    async reconnectWithAction(e) {
      let t =
        !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      if (this.reconnectCount >= this.retryConfig.maxRetryCount) return !1;
      if (0 === this.urls.length) return !1;
      if ("closed" === this.state) return !1;
      EU.warning("[choose-best-ws] action: =>", e),
        this.onlineReconnectListener ||
          wk.isOnline ||
          !wk.onlineWaiter ||
          (this.onlineReconnectListener = wk.onlineWaiter.then(() => {
            this.onlineReconnectListener = void 0;
          }));
      let i = !0;
      if (((this.reconnectInterrupter = () => (i = !1)), t)) {
        const t = aM(this.reconnectCount, this.retryConfig);
        EU.debug(
          "["
            .concat(this.name, "] wait ")
            .concat(t, "ms to reconnect websocket, mode: ")
            .concat(e)
        ),
          await Promise.race([
            Wk(t),
            this.onlineReconnectListener || new Promise(() => {})
          ]);
      }
      if ("closed" === this._state || !i) return !1;
      this.reconnectCount += 1;
      const s = async (e, t) => {
        this.emit(_G.RECONNECT_CREATE_CONNECTION, t),
          await this.createWebSocketConnection(e);
      };
      try {
        if ("retry" === e) await s(this.urls[this.currentURLIndex], e);
        else if ("tryNext" === e) {
          if (
            ((this.currentURLIndex += 1),
            this.currentURLIndex >= this.urls.length)
          )
            return this.reconnectWithAction("recover", !1);
          EU.debug(
            "["
              .concat(this.name, "] websocket url length: ")
              .concat(this.urls.length, " current index: ")
              .concat(this.currentURLIndex)
          ),
            await s(this.urls[this.currentURLIndex], e);
        } else
          "recover" === e &&
            (EU.debug("[".concat(this.name, "] request new urls")),
            this.resetReconnectCount("recover mode"),
            (this.urls = await Ck(this, _G.REQUEST_NEW_URLS)),
            (this.currentURLIndex = 0),
            await s(this.urls[this.currentURLIndex], e));
      } catch (i) {
        var r;
        EU.error(
          "[".concat(this.name, "] reconnect failed ").concat(i && i.toString())
        );
        const s =
          null == i || null === (r = i.data) || void 0 === r ? void 0 : r.desc;
        return Array.isArray(s) && s.includes("dynamic key expired")
          ? (this.emit(_G.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1)
          : this.reconnectWithAction(e, t);
      }
      return !0;
    }
  }
  class lj extends dj {
    constructor(e, t) {
      super(
        e,
        t,
        arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
        arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
        arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
        arguments.length > 5 ? arguments[5] : void 0
      );
    }
    async chooseBestWebsocketConnection(e, t) {
      const i = uP(),
        s = (function(e, t) {
          return new cj(e, t);
        })(this.forceCloseTimeout, this.store);
      this.closeEstablishingWs = () => {
        EU.debug("[choose-best-ws] close establishing websockets"),
          s.closeAllWebsockets(),
          i.reject(new JP(zP.WS_ABORT, "choose best websocket aborted"));
      };
      const r = WM("GATEWAY_DOMAINS");
      return (
        EU.debug(
          "[choose-best-ws] currentDomain: ",
          e,
          ", domains: ",
          r,
          "total: ".concat(this.urls.length),
          "current: ".concat(this.currentURLIndex + 1)
        ),
        s
          .chooseBestWebsocket(e, this.tryDoubleDomain, this.use443PortOnly, t)
          .then(i.resolve)
          .catch(i.reject),
        i.promise.finally(() => {
          this.closeEstablishingWs = void 0;
        })
      );
    }
  }
  class hj extends uk {
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(e) {
      e !== this._connectionState &&
        ((this._connectionState = e),
        e === uG.CONNECTED
          ? this.emit(pG.WS_CONNECTED)
          : e === uG.RECONNECTING
          ? this.emit(pG.WS_RECONNECTING, this._websocketReconnectReason)
          : e === uG.CLOSED &&
            this.emit(pG.WS_CLOSED, this._disconnectedReason));
    }
    get currentURLIndex() {
      return this.websocket.currentURLIndex;
    }
    get url() {
      return (this.websocket && this.websocket.url) || null;
    }
    get rtt() {
      return this.rttRolling.mean();
    }
    constructor(e, t) {
      super(),
        (this._disconnectedReason = void 0),
        (this._websocketReconnectReason = void 0),
        (this._connectionState = uG.CLOSED),
        (this.reconnectToken = void 0),
        (this.websocket = void 0),
        (this.openConnectionTime = void 0),
        (this.clientId = void 0),
        (this.lastMsgTime = Date.now()),
        (this.uploadCache = []),
        (this.uploadCacheInterval = void 0),
        (this.rttRolling = new (class {
          constructor(e) {
            $P(this, "input", []), $P(this, "size", void 0), (this.size = e);
          }
          add(e) {
            this.input.push(e),
              this.input.length > this.size && this.input.splice(0, 1);
          }
          mean() {
            return 0 === this.input.length
              ? 0
              : this.input.reduce((e, t) => e + t) / this.input.length;
          }
        })(5)),
        (this.pingpongTimer = void 0),
        (this.wsInflateDataTimer = void 0),
        (this.pingpongTimeoutCount = 0),
        (this.joinResponse = void 0),
        (this.multiIpOption = void 0),
        (this.initError = void 0),
        (this.spec = void 0),
        (this.store = void 0),
        (this.onWebsocketMessage = e => {
          if (e.data instanceof ArrayBuffer)
            return void this.emit(pG.ON_BINARY_DATA, e.data);
          const t = JSON.parse(e.data);
          if (
            ((this.lastMsgTime = Date.now()),
            Object.prototype.hasOwnProperty.call(t, "_id"))
          ) {
            const e = "res-@".concat(t._id);
            this.emit(e, t._result, t._message);
          } else if (Object.prototype.hasOwnProperty.call(t, "_type")) {
            if (
              (this.emit(t._type, t._message),
              t._type === mG.ON_NOTIFICATION &&
                this.handleNotification(t._message),
              t._type === mG.ON_USER_BANNED)
            )
              switch (t._message.error_code) {
                case 14:
                  this.close(_k.UID_BANNED);
                  break;
                case 15:
                  this.close(_k.IP_BANNED);
                  break;
                case 16:
                  this.close(_k.CHANNEL_BANNED);
              }
            if (t._type === mG.ON_USER_LICENSE_BANNED)
              switch (t._message.error_code) {
                case hG.ERR_LICENSE_MISSING:
                  this.close(_k.LICENSE_MISSING);
                  break;
                case hG.ERR_LICENSE_EXPIRED:
                  this.close(_k.LICENSE_EXPIRED);
                  break;
                case hG.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(_k.LICENSE_MINUTES_EXCEEDED);
                  break;
                case hG.ERR_LICENSE_PERIOD_INVALID:
                  this.close(_k.LICENSE_PERIOD_INVALID);
                  break;
                case hG.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(_k.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case hG.ERR_LICENSE_ILLEGAL:
                  this.close(_k.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
          }
        }),
        (this.clientId = e.clientId),
        (this.spec = e),
        (this.store = t),
        (this.websocket = new lj(
          "gateway-".concat(this.clientId),
          this.spec.retryConfig,
          !0,
          WM("JOIN_GATEWAY_USE_DUAL_DOMAIN"),
          WM("JOIN_GATEWAY_USE_443PORT_ONLY"),
          t
        )),
        this.handleWebsocketEvents(),
        window.addEventListener("offline", () => {
          this.connectionState === uG.CONNECTED &&
            this.reconnect("retry", yk.OFFLINE);
        });
    }
    async request(e, t, i, s) {
      const r = Yk(6, ""),
        n = { _id: r, _type: e, _message: t },
        a = this.websocket.connectionID,
        o = () =>
          new Promise((t, i) => {
            if (this.connectionState === uG.CONNECTED) return t();
            const s = () => {
                this.off(pG.WS_CLOSED, r), t();
              },
              r = () => {
                this.off(pG.WS_CONNECTED, s), i(new AU(zP.WS_ABORT));
              };
            this.once(pG.WS_CONNECTED, s),
              this.once(pG.WS_CLOSED, r),
              (e !== fG.PUBLISH &&
                e !== fG.PUBLISH_DATASTREAM &&
                e !== fG.SUBSCRIBE &&
                e !== fG.SUBSCRIBE_DATASTREAM &&
                e !== fG.UNSUBSCRIBE &&
                e !== fG.UNSUBSCRIBE_DATASTREAM &&
                e !== fG.UNPUBLISH &&
                e !== fG.UNPUBLISH_DATASTREAM &&
                e !== fG.CONTROL &&
                e !== fG.RESTART_ICE) ||
                this.once(pG.DISCONNECT_P2P, () => {
                  i(new AU(zP.DISCONNECT_P2P));
                }),
              (e !== fG.PUBLISH && e !== fG.RESTART_ICE) ||
                this.once(pG.ABORT_P2P_EXECUTION, () => {
                  i(new AU(zP.DISCONNECT_P2P));
                });
          });
      if (
        ((this.connectionState !== uG.CONNECTING &&
          this.connectionState !== uG.RECONNECTING) ||
          e === fG.JOIN ||
          e === fG.REJOIN ||
          (await o()),
        this.websocket.sendMessage(n, !0),
        s)
      )
        return;
      const c = new Promise((i, s) => {
        let n = !1;
        const o = (s, r) => {
          (n = !0),
            i({ isSuccess: "success" === s, message: r || {} }),
            this.off(pG.WS_CLOSED, c),
            this.off(pG.WS_RECONNECTING, c),
            this.emit(pG.REQUEST_SUCCESS, e, t);
        };
        this.once("res-@".concat(r), o);
        const c = () => {
          s(new AU(zP.WS_ABORT, "type: ".concat(e))),
            this.off(pG.WS_CLOSED, c),
            this.off(pG.WS_RECONNECTING, c),
            this.off("res-@".concat(r), o);
        };
        this.once(pG.WS_CLOSED, c),
          this.once(pG.WS_RECONNECTING, c),
          Wk(WM("SIGNAL_REQUEST_TIMEOUT")).then(() => {
            this.websocket.connectionID !== a ||
              n ||
              (EU.warning(
                "["
                  .concat(this.clientId, "] ws request timeout, type: ")
                  .concat(e)
              ),
              this.emit(pG.REQUEST_TIMEOUT, e, t));
          });
      });
      let d = null;
      try {
        d = await c;
      } catch (s) {
        if (this.connectionState === uG.CLOSED || e === fG.LEAVE)
          throw new AU(zP.WS_ABORT);
        return !this.spec.forceWaitGatewayResponse || i
          ? s.throw()
          : e === fG.JOIN || e === fG.REJOIN
          ? null
          : (await o(), await this.request(e, t));
      }
      if (d.isSuccess) return d.message;
      const l = Number(d.message.error_code || d.message.code),
        h = tj(l),
        u = new AU(
          zP.UNEXPECTED_RESPONSE,
          "".concat(h.desc, ": ").concat(d.message.error_str),
          { code: l, data: d.message, desc: h.desc }
        );
      return "success" === h.action
        ? d.message
        : (EU.warning(
            "["
              .concat(this.clientId, "] [")
              .concat(
                this.websocket.connectionID,
                "] unexpected response from type "
              )
              .concat(e, ", error_code: ")
              .concat(l, ", message: ")
              .concat(h.desc, ", action: ")
              .concat(h.action)
          ),
          l === hG.ERR_TOO_MANY_BROADCASTERS
            ? e === fG.JOIN || e === fG.REJOIN
              ? ((this.initError = u), this.close(), u.throw())
              : u.throw()
            : "failed" === h.action
            ? u.throw()
            : "quit" === h.action
            ? ((this.initError = u), this.close(), u.throw())
            : (l === hG.ERR_JOIN_BY_MULTI_IP
                ? ((this.multiIpOption = d.message.option),
                  EU.warning(
                    "[".concat(this.clientId, "] detect multi ip, recover")
                  ),
                  this.reconnect("recover", yk.MULTI_IP))
                : this.reconnect(h.action, yk.SERVER_ERROR),
              e === fG.JOIN || e === fG.REJOIN
                ? null
                : await this.request(e, t)));
    }
    waitMessage(e, t) {
      return new Promise(i => {
        const s = r => {
          (!t || t(r)) && (this.off(e, s), i(r));
        };
        this.on(e, s);
      });
    }
    uploadWRTCStats(e) {
      if (!this.store.sessionId)
        return void EU.warn(
          "[".concat(this.clientId, "] no session id when upload wrtc stats")
        );
      const t = {
        lts: Date.now(),
        sid: this.store.sessionId,
        uid: this.store.intUid,
        stats: e
      };
      this.upload(EG.WRTC_STATS, t);
    }
    upload(e, t) {
      const i = { _type: e, _message: t };
      try {
        this.websocket.sendMessage(i);
      } catch (e) {
        const t = WM("MAX_UPLOAD_CACHE") || 50;
        this.uploadCache.push(i),
          this.uploadCache.length > t && this.uploadCache.splice(0, 1),
          this.uploadCache.length > 0 &&
            !this.uploadCacheInterval &&
            (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== uG.CONNECTED) return;
              const e = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length &&
                (window.clearInterval(this.uploadCacheInterval),
                (this.uploadCacheInterval = void 0)),
                this.upload(e._type, e._message);
            }, WM("UPLOAD_CACHE_INTERVAL") || 2e3));
      }
    }
    send(e, t) {
      const i = { _type: e, _message: t };
      this.websocket.sendMessage(i);
    }
    init(e) {
      return (
        (this.initError = void 0),
        (this.multiIpOption = void 0),
        (this.joinResponse = void 0),
        (this.reconnectToken = void 0),
        (this.openConnectionTime = void 0),
        new Promise((t, i) => {
          this.once(pG.WS_CONNECTED, () => t(this.joinResponse)),
            this.once(pG.WS_CLOSED, e =>
              i(this.initError || new AU(zP.WS_ABORT, e))
            ),
            (this.connectionState = uG.CONNECTING),
            this.websocket.init(e).catch(i),
            this.wsInflateDataTimer &&
              window.clearInterval(this.wsInflateDataTimer),
            (this.wsInflateDataTimer = window.setInterval(() => {
              this.handleWsInflateData();
            }, 2e4));
        })
      );
    }
    close(e) {
      this.pingpongTimer &&
        ((this.pingpongTimeoutCount = 0),
        window.clearInterval(this.pingpongTimer),
        (this.pingpongTimer = void 0)),
        this.wsInflateDataTimer &&
          (this.handleWsInflateData(),
          window.clearInterval(this.wsInflateDataTimer),
          (this.wsInflateDataTimer = void 0)),
        (this.reconnectToken = void 0),
        (this.joinResponse = void 0),
        (this._disconnectedReason = e || _k.LEAVE),
        (this.connectionState = uG.CLOSED),
        EU.debug(
          "[".concat(this.clientId, "] ") + "will close websocket in signal"
        ),
        this.websocket.close();
    }
    async join() {
      if (!this.joinResponse) {
        this.emit(pG.ABORT_P2P_EXECUTION);
        const e = await Ck(this, pG.REQUEST_JOIN_INFO),
          t = await this.request(fG.JOIN, e);
        if (!t)
          return (
            this.emit(pG.REPORT_JOIN_GATEWAY, bG.TIMEOUT, this.url || ""), !1
          );
        (this.joinResponse = t),
          this.emit(pG.JOIN_RESPONSE, this.joinResponse),
          (this.reconnectToken = this.joinResponse.rejoin_token);
      }
      return (
        (this.connectionState = uG.CONNECTED),
        this.pingpongTimer && window.clearInterval(this.pingpongTimer),
        (this.pingpongTimer = window.setInterval(
          this.handlePingPong.bind(this),
          3e3
        )),
        !0
      );
    }
    async rejoin() {
      if (!this.reconnectToken)
        throw new AU(zP.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
      const e = Dk(this, pG.REQUEST_REJOIN_INFO);
      e.token = this.reconnectToken;
      const t = await this.request(fG.REJOIN, e);
      return (
        !!t &&
        ((this.connectionState = uG.CONNECTED),
        this.pingpongTimer && window.clearInterval(this.pingpongTimer),
        (this.pingpongTimer = window.setInterval(
          this.handlePingPong.bind(this),
          3e3
        )),
        t.peers &&
          t.peers.forEach(e => {
            this.emit(mG.ON_USER_ONLINE, { uid: e.uid }),
              e.audio &&
                this.emit(mG.ON_ADD_AUDIO_STREAM, {
                  uid: e.uid,
                  uint_id: e.uint_id,
                  audio: !0,
                  ssrcId: e.audio_ssrc
                }),
              e.video &&
                this.emit(mG.ON_ADD_VIDEO_STREAM, {
                  uid: e.uid,
                  uint_id: e.uint_id,
                  video: !0,
                  ssrcId: e.video_ssrc
                }),
              e.audio_mute
                ? this.emit(mG.MUTE_AUDIO, { uid: e.uid })
                : this.emit(mG.UNMUTE_AUDIO, { uid: e.uid }),
              e.video_mute
                ? this.emit(mG.MUTE_VIDEO, { uid: e.uid })
                : this.emit(mG.UNMUTE_VIDEO, { uid: e.uid }),
              e.audio_enable_local
                ? this.emit(mG.ENABLE_LOCAL_AUDIO, { uid: e.uid })
                : this.emit(mG.DISABLE_LOCAL_AUDIO, { uid: e.uid }),
              e.video_enable_local
                ? this.emit(mG.ENABLE_LOCAL_VIDEO, { uid: e.uid })
                : this.emit(mG.DISABLE_LOCAL_VIDEO, { uid: e.uid }),
              e.audio ||
                e.video ||
                this.emit(mG.ON_REMOVE_STREAM, {
                  uid: e.uid,
                  uint_id: e.uint_id
                });
          }),
        !0)
      );
    }
    reconnect(e, t) {
      this.pingpongTimer &&
        ((this.pingpongTimeoutCount = 0),
        window.clearInterval(this.pingpongTimer),
        (this.pingpongTimer = void 0)),
        this.websocket.reconnect(e, t);
    }
    handleNotification(e) {
      EU.debug("[".concat(this.clientId, "] receive notification: "), e);
      const t = tj(e.code);
      if (
        (28 === e.code &&
          "detail" in e &&
          (EU.info(
            "[".concat(this.clientId, "] receive recover notification: "),
            e.detail
          ),
          this.emit(pG.RECOVER_NOTIFICATION, e.detail)),
        "success" !== t.action)
      ) {
        if ("failed" !== t.action)
          return "quit" === t.action
            ? ("ERR_REPEAT_JOIN_CHANNEL" === t.desc &&
                this.close(_k.UID_BANNED),
              void this.close())
            : void this.reconnect(t.action, yk.SERVER_ERROR);
        EU.error("[".concat(this.clientId, "] ignore error: "), t.desc);
      }
    }
    handlePingPong() {
      if (!this.websocket || "connected" !== this.websocket.state) return;
      this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3),
        (this.pingpongTimeoutCount += 1);
      const e = WM("PING_PONG_TIME_OUT"),
        t = Date.now();
      this.pingpongTimeoutCount >= e &&
      (EU.warning(
        "["
          .concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ")
          .concat(t - this.lastMsgTime, "ms")
      ),
      t - this.lastMsgTime > WM("WEBSOCKET_TIMEOUT_MIN"))
        ? this.reconnect("retry", yk.TIMEOUT)
        : this.request(fG.PING, void 0, !0)
            .then(() => {
              this.pingpongTimeoutCount = 0;
              const e = Date.now() - t;
              this.rttRolling.add(e),
                WM("REPORT_STATS") &&
                  this.send(fG.PING_BACK, { pingpongElapse: e });
            })
            .catch(e => {});
    }
    handleWsInflateData() {
      const {
        wsInflateLength: e,
        wsDeflateLength: t
      } = this.websocket.getWsInflateData();
      0 !== e &&
        0 !== t &&
        this.upload(EG.WS_INFLATE_DATA_LENGTH, {
          ws_deflate_length: t,
          ws_inflate_length: e
        });
    }
    handleWebsocketEvents() {
      this.websocket.on(_G.RECONNECT_CREATE_CONNECTION, e => {
        this.emit(pG.WS_RECONNECT_CREATE_CONNECTION, e);
      }),
        this.websocket.on(_G.ON_MESSAGE, this.onWebsocketMessage),
        this.websocket.on(_G.CLOSED, () => {
          this.connectionState = uG.CLOSED;
        }),
        this.websocket.on(_G.FAILED, () => {
          (this._disconnectedReason = _k.NETWORK_ERROR),
            (this.connectionState = uG.CLOSED);
        }),
        this.websocket.on(_G.RECONNECTING, e => {
          (this._websocketReconnectReason = e),
            (this.joinResponse = void 0),
            this.connectionState === uG.CONNECTED
              ? (this.connectionState = uG.RECONNECTING)
              : (this.connectionState = uG.CONNECTING);
        }),
        this.websocket.on(_G.WILL_RECONNECT, (e, t, i) => {
          const s = Dk(this, pG.IS_P2P_DISCONNECTED),
            r = s || "retry" !== e;
          s &&
            "retry" === e &&
            (EU.debug(
              "".concat(
                this.clientId,
                " reconnect mode is retry, but p2p lost, change to tryNext"
              )
            ),
            (e = "tryNext"),
            (t = bG.P2P_DISCONNECTED)),
            r &&
              (EU.debug(
                ""
                  .concat(this.clientId, " will renewSession, reconnect mode: ")
                  .concat(e)
              ),
              this.emit(
                pG.REPORT_JOIN_GATEWAY,
                t || bG.UNKNOWN_REASON,
                this.url || ""
              ),
              (this.reconnectToken = void 0),
              this.emit(pG.DISCONNECT_P2P)),
            i(e);
        }),
        this.websocket.on(_G.CONNECTED, () => {
          (this.openConnectionTime = Date.now()),
            this.reconnectToken
              ? this.rejoin().catch(e => {
                  EU.warning(
                    "[".concat(this.clientId, "] rejoin failed ").concat(e)
                  ),
                    this.reconnect("tryNext", yk.SERVER_ERROR);
                })
              : this.join().catch(e => {
                  if (
                    (this.emit(pG.REPORT_JOIN_GATEWAY, e, this.url || ""),
                    e instanceof AU)
                  ) {
                    if (
                      e.code === zP.UNEXPECTED_RESPONSE &&
                      e.data.code === hG.ERR_NO_AUTHORIZED
                    )
                      return (
                        (this.initError = new AU(
                          zP.TOKEN_EXPIRE,
                          "dynamic key expired"
                        )),
                        void this.close(_k.TOKEN_EXPIRE)
                      );
                    EU.error(
                      "[".concat(
                        this.clientId,
                        "] join gateway request failed"
                      ),
                      e.toString()
                    ),
                      this.spec.forceWaitGatewayResponse
                        ? this.reconnect("tryNext", yk.SERVER_ERROR)
                        : ((this.initError = e), this.close());
                  }
                });
        }),
        this.websocket.on(_G.REQUEST_NEW_URLS, (e, t) => {
          Ck(this, pG.REQUEST_RECOVER, this.multiIpOption)
            .then(e)
            .catch(t);
        }),
        this.websocket.on(_G.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
          this.emit(mG.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
        }),
        this.websocket.on(YG.PRE_CONNECT_PC, () => {
          this.emit(pG.PRE_CONNECT_PC);
        });
    }
  }
  let uj = (function(e) {
      return (
        (e.NATIVE_RTC = "native_rtc"),
        (e.NATIVE_RTM = "native_rtm"),
        (e.WEB_RTC = "web_rtc"),
        (e.WEB_RTM = "web_rtm"),
        e
      );
    })({}),
    pj = (function(e) {
      return (
        (e[(e.CHOOSE_SERVER = 11)] = "CHOOSE_SERVER"),
        (e[(e.CLOUD_PROXY = 18)] = "CLOUD_PROXY"),
        (e[(e.CLOUD_PROXY_5 = 20)] = "CLOUD_PROXY_5"),
        (e[(e.CLOUD_PROXY_FALLBACK = 26)] = "CLOUD_PROXY_FALLBACK"),
        e
      );
    })({});
  function fj(e) {
    return e.match(/^[\.\:\d]+$/)
      ? "".concat(e.replace(/[^\d]/g, "-"), ".").concat(WM("TURN_DOMAIN"))
      : (EU.debug(
          "Cannot recognized as ip address: ".concat(e, ", use as host")
        ),
        e);
  }
  function Ej(e, t) {
    e.addresses || (e.addresses = []);
    const i = (function(e, t) {
        if (WM("CONNECT_GATEWAY_WITHOUT_DOMAIN"))
          return e.map(e => {
            let { ip: t, port: i } = e;
            return { address: "".concat(t, ":").concat(i) };
          });
        const i = WM("GATEWAY_DOMAINS");
        let s = i[1] && t.includes(i[1]) ? 1 : 0;
        return e.map(e => {
          let { domain_prefix: t, port: r, ip: n } = e;
          if (t)
            return {
              address: ""
                .concat(t, ".")
                .concat(i[s++ % i.length], ":")
                .concat(r)
            };
          const a = /^[\.\:\d]+$/.test(n),
            o = a
              ? ""
                  .concat(n.replace(/[^\d]/g, "-"), ".")
                  .concat(i[s++ % i.length], ":")
                  .concat(r)
              : "".concat(n, ":").concat(r);
          return (
            a ||
              EU.debug(
                "Cannot recognized as ip address: ".concat(n, ", use as host")
              ),
            { ip: n, port: r, address: o }
          );
        });
      })(e.addresses, t),
      s = Array.isArray(e.detail) && e.detail[18];
    if (s && "string" == typeof s) {
      const e = s.split(";");
      for (let t = 0; t < e.length; t++) {
        const s = e[t].trim();
        i[t] && s && (i[t].ip6 = s);
      }
    }
    const r = e.detail && e.detail.candidate;
    let n;
    if (r) {
      const [e, t] = r.split(":");
      e &&
        t &&
        (n = { port: Number(t), ip: e, address: "".concat(e, ":").concat(t) });
    }
    return {
      gatewayAddrs: i,
      apGatewayAddress: n,
      uid: e.uid,
      cid: e.cid,
      cert: e.cert,
      vid: e.detail && e.detail[8],
      uni_lbs_ip: e.detail && e.detail[1],
      res: e,
      csIp: e.detail && e.detail[502]
    };
  }
  function mj(e) {
    return "number" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0;
  }
  function gj(e) {
    const t = e._encoderConfig;
    if (!t) return {};
    const i = {
      resolution:
        t.width && t.height
          ? "".concat(mj(t.width), "x").concat(mj(t.height))
          : void 0,
      maxVideoBW: t.bitrateMax,
      minVideoBW: t.bitrateMin
    };
    return (
      "number" == typeof t.frameRate
        ? ((i.maxFrameRate = t.frameRate), (i.minFrameRate = t.frameRate))
        : t.frameRate &&
          ((i.maxFrameRate =
            t.frameRate.max ||
            t.frameRate.ideal ||
            t.frameRate.exact ||
            t.frameRate.min),
          (i.minFrameRate =
            t.frameRate.min ||
            t.frameRate.ideal ||
            t.frameRate.exact ||
            t.frameRate.max)),
      i
    );
  }
  function _j(e) {
    return e >= 0 && e < 0.17
      ? 1
      : e >= 0.17 && e < 0.36
      ? 2
      : e >= 0.36 && e < 0.59
      ? 3
      : e >= 0.59 && e <= 1
      ? 4
      : e > 1
      ? 5
      : 0;
  }
  function Tj(e, t) {
    let i, s, r;
    switch (t) {
      case pj.CHOOSE_SERVER:
        (s = 4096), (r = "choose server");
        break;
      case pj.CLOUD_PROXY:
        (s = 1048576), (r = "proxy");
        break;
      case pj.CLOUD_PROXY_5:
        (s = 4194304), (r = "proxy5");
        break;
      case pj.CLOUD_PROXY_FALLBACK:
        (s = 4194310), (r = "proxy fallback");
        break;
      default:
        throw new AU(
          zP.UNEXPECTED_ERROR,
          "multi unlibs response transformer get unknown service id",
          { csIp: e.detail && e.detail[502], retry: !1 }
        );
    }
    if (
      (e.response_body.forEach(t => {
        t.buffer &&
          t.buffer.flag === s &&
          (i = {
            code: t.buffer.code,
            addresses: (t.buffer.edges_services || []).map(e =>
              rG(rG({}, e), {}, { ticket: t.buffer.cert })
            ),
            server_ts: e.enter_ts,
            uid: t.buffer.uid,
            cid: t.buffer.cid,
            cname: t.buffer.cname,
            detail: rG(rG({}, t.buffer.detail), e.detail),
            flag: t.buffer.flag,
            opid: e.opid,
            cert: t.buffer.cert
          });
      }),
      !i)
    )
      throw new AU(
        zP.MULTI_UNILBS_RESPONSE_ERROR,
        "cannot parse response ".concat(r, " from multi unilbs response"),
        { csIp: e.detail && e.detail[502] }
      );
    return i;
  }
  async function Sj(e, t) {
    return await Promise.all(
      e.addresses.map(async e => ({
        address: WM("USE_TURN_IP") ? e.ip : fj(e.ip),
        tcpport: e.port,
        udpport: e.port,
        username:
          t && WM("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext
            ? t.toString()
            : FM.username,
        password:
          t && WM("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext
            ? await hk(t.toString())
            : FM.password
      }))
    );
  }
  function vj(e, t) {
    const i = t.getMediaStreamTrack(!0).getSettings(),
      s = t.videoHeight || i.height,
      r = t.videoWidth || i.width;
    return s && r
      ? Math.max(Math.min(s, r) / Math.min(mj(e.height), mj(e.width)), 1)
      : (EU.warning(
          "can't get ori-track's height, default scale down 4 times for low stream"
        ),
        4);
  }
  function Rj(e) {
    let {
      candidateType: t,
      relayProtocol: i,
      type: s,
      address: r,
      port: n,
      protocol: a
    } = e;
    const o = { candidateType: t, relayProtocol: i, protocol: a };
    if ("local-candidate" !== s) {
      const e = r.split(".");
      e.length >= 4 && ((e[1] = "*"), (e[2] = "*")),
        (o.address = e.join(".")),
        (o.port = n);
    }
    return o;
  }
  function yj() {
    let e =
      arguments.length > 0 && void 0 !== arguments[0]
        ? arguments[0]
        : WM("SVC_MODE");
    if (WM("ENABLE_SVC"))
      return (function(e) {
        return e in CM;
      })(e)
        ? e
        : CM.L1T3;
  }
  const Aj = {
    [xG.VIDEO]: [
      {
        key: "abs-send-time",
        extensionName:
          "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"
      },
      { key: "video-orientation", extensionName: "urn:3gpp:video-orientation" },
      {
        key: "draft-holmer-rmcat-transport-wide-cc-extensions-01",
        extensionName:
          "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
      },
      {
        key: "playout-delay",
        extensionName:
          "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay"
      },
      {
        key: "video-content-type",
        extensionName:
          "http://www.webrtc.org/experiments/rtp-hdrext/video-content-type"
      },
      {
        key: "color-space",
        extensionName:
          "http://www.webrtc.org/experiments/rtp-hdrext/color-space"
      },
      {
        key: "video-timing",
        extensionName:
          "http://www.webrtc.org/experiments/rtp-hdrext/video-timing"
      }
    ],
    [xG.AUDIO]: [
      {
        key: "ssrc-audio-level",
        extensionName: "urn:ietf:params:rtp-hdrext:ssrc-audio-level"
      },
      {
        key: "draft-holmer-rmcat-transport-wide-cc-extensions-01",
        extensionName:
          "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
      },
      {
        key: "abs-send-time",
        extensionName:
          "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"
      }
    ]
  };
  function Ij(e, t, i) {
    t.forEach(t => {
      const s = Aj[e].find(e => {
        let { key: i } = e;
        return t.extensionName.includes(i);
      });
      if (!s) return;
      const r = i.find(e => {
        let { extensionName: t } = e;
        return t.includes(s.key);
      });
      r &&
        r.extensionName.includes("gdpr_forbidden") &&
        (t.extensionName = r.extensionName);
    });
  }
  function Cj(e, t) {
    t.forEach(t => {
      const i = Aj[e].find(e => {
        let { key: i } = e;
        return t.extensionName.includes(i);
      });
      t.extensionName.includes("gdpr_forbidden") &&
        i &&
        (t.extensionName = i.extensionName);
    });
  }
  function bj(e) {
    return (
      "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e ||
      e.includes("abs-send-time")
    );
  }
  function Oj(e) {
    return (
      "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" ===
        e || e.includes("draft-holmer-rmcat-transport-wide-cc-extensions-01")
    );
  }
  function Dj(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      s = arguments.length > 3 ? arguments[3] : void 0;
    const {
        filterRTX: r,
        filterVideoFec: n,
        filterAudioFec: a,
        filterAudioCodec: o,
        filterVideoCodec: c
      } = t,
      { useXR: d } = i;
    let l = [],
      h = [],
      u = [],
      p = [],
      f = !1,
      E = !1;
    if (
      (sU(e).mediaDescriptions.forEach(e => {
        (s && s !== e.attributes.direction) ||
          ("video" !== e.media.mediaType ||
            f ||
            ((h = e.attributes.payloads), (p = e.attributes.extmaps), (f = !0)),
          "audio" !== e.media.mediaType ||
            E ||
            ((l = e.attributes.payloads),
            (u = e.attributes.extmaps),
            (E = !0)));
      }),
      !p || 0 === h.length)
    )
      throw new Error("Cannot get video capabilities from SDP.");
    if (!u || 0 === l.length)
      throw new Error("Cannot get audio capabilities from SDP.");
    if (
      (h.forEach(e => {
        var t;
        null !== (t = e.rtpMap) &&
          void 0 !== t &&
          t.clockRate &&
          (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)),
          d && e.rtcpFeedbacks.push({ type: "rrtr" });
      }),
      l.forEach(e => {
        var t;
        null !== (t = e.rtpMap) &&
          void 0 !== t &&
          t.clockRate &&
          (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)),
          d && e.rtcpFeedbacks.push({ type: "rrtr" });
      }),
      r &&
        ((l = l.filter(e => {
          var t;
          return (
            "rtx" !==
            (null === (t = e.rtpMap) || void 0 === t
              ? void 0
              : t.encodingName.toLowerCase())
          );
        })),
        (h = h.filter(e => {
          var t;
          return (
            "rtx" !==
            (null === (t = e.rtpMap) || void 0 === t
              ? void 0
              : t.encodingName.toLowerCase())
          );
        }))),
      n &&
        (h = h.filter(e => {
          var t;
          return !/(red)|(ulpfec)|(flexfec)/i.test(
            (null === (t = e.rtpMap) || void 0 === t
              ? void 0
              : t.encodingName) || ""
          );
        })),
      a &&
        (l = l.filter(e => {
          var t;
          return !/(red)|(ulpfec)|(flexfec)/i.test(
            (null === (t = e.rtpMap) || void 0 === t
              ? void 0
              : t.encodingName) || ""
          );
        })),
      o &&
        (null == o ? void 0 : o.length) > 0 &&
        (l = l.filter(e => {
          var t;
          return o.includes(
            (null === (t = e.rtpMap) || void 0 === t
              ? void 0
              : t.encodingName.toLowerCase()) || ""
          );
        })),
      c && (null == c ? void 0 : c.length) > 0)
    ) {
      const e = h.filter(e => {
        var t;
        return c.includes(
          (null === (t = e.rtpMap) || void 0 === t
            ? void 0
            : t.encodingName.toLowerCase()) || ""
        );
      });
      h = e.concat(r ? [] : Gj(e, h));
    }
    const m = WM("UNSUPPORTED_VIDEO_CODEC");
    return (
      m &&
        m.length > 0 &&
        (h = h.filter(
          e => !(e.rtpMap && m.includes(e.rtpMap.encodingName.toLowerCase()))
        )),
      { audioCodecs: l, videoCodecs: h, audioExtensions: u, videoExtensions: p }
    );
  }
  function wj(e) {
    const t = sU(e);
    let i, s;
    for (const e of t.mediaDescriptions) {
      if (!i) {
        const t = e.attributes.iceUfrag,
          s = e.attributes.icePwd;
        if (!t || !s)
          throw new Error("Cannot get iceUfrag or icePwd from SDP.");
        i = { iceUfrag: t, icePwd: s };
      }
      if (!s) {
        const t = e.attributes.fingerprints;
        t.length > 0 && (s = { fingerprints: t });
      }
    }
    if (
      (!s &&
        t.attributes.fingerprints.length > 0 &&
        (s = { fingerprints: t.attributes.fingerprints }),
      !s || !i)
    )
      throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
    return { iceParameters: i, dtlsParameters: s };
  }
  function Lj(e, t, i) {
    const { cname: s } = e;
    let r = [];
    t && (r = Nj(t)),
      0 === r.length &&
        ((r = e.iceParameters.candidates.map(e => ({
          foundation: e.foundation,
          componentId: "1",
          transport: e.protocol,
          priority: e.priority.toString(),
          connectionAddress: e.ip,
          port: e.port.toString(),
          type: e.type,
          extension: {}
        }))),
        EU.debug("Using candidates from gateway."));
    const n = {
        fingerprints: e.dtlsParameters.fingerprints.map(e => ({
          hashFunction: e.algorithm,
          fingerprint: e.fingerprint
        }))
      },
      a = {
        iceUfrag: e.iceParameters.iceUfrag,
        icePwd: e.iceParameters.icePwd
      };
    let o;
    switch (e.dtlsParameters.role) {
      case "server":
        o = "passive";
        break;
      case "client":
        o = "active";
        break;
      case "auto":
        o = "actpass";
    }
    const c = Fj(e.rtpCapabilities),
      d = [];
    return (
      Array.isArray(i) &&
        i.length > 0 &&
        i.forEach(e => {
          d.push(
            {
              kind: xG.VIDEO,
              ssrcId: e.v,
              rtx: e.v_rtx,
              mslabel: "".concat(e.v, "_").concat(e.a)
            },
            {
              kind: xG.AUDIO,
              ssrcId: e.a,
              mslabel: "".concat(e.v, "_").concat(e.a)
            }
          );
        }),
      {
        dtlsParameters: n,
        iceParameters: a,
        candidates: r,
        rtpCapabilities: c,
        setup: o,
        cname: s,
        preSSRCs: d
      }
    );
  }
  function Nj(e) {
    let t = [];
    return (
      e.ip &&
        "number" == typeof e.port &&
        ((t = [
          {
            foundation: "udpcandidate",
            componentId: "1",
            transport: "udp",
            priority: "2103266323",
            connectionAddress: e.ip,
            port: e.port.toString(),
            type: "host",
            extension: {}
          }
        ]),
        EU.debug(
          "Using remote candidate from AP ".concat(e.ip, ":").concat(e.port)
        ),
        e.ip6 &&
          (t.push({
            foundation: "udpcandidate",
            componentId: "1",
            transport: "udp",
            priority: "2103266323",
            connectionAddress: e.ip6,
            port: e.port.toString(),
            type: "host",
            extension: {}
          }),
          EU.debug(
            "Using IPV6 remote candidate from AP "
              .concat(e.ip6, ":")
              .concat(e.port)
          ))),
      t
    );
  }
  function Pj(e, t, i) {
    const s = [],
      r = [];
    return (
      e.forEach(e => {
        let { ssrcId: n, rtx: a } = e;
        const o = Yk(8, "track-"),
          c = {
            ssrcId: n,
            attributes: rG(
              {
                label: o,
                mslabel: (i = i || Yk(10, "")),
                msid: "".concat(i, " ").concat(o)
              },
              t && { cname: t }
            )
          };
        if ((s.push(c), void 0 !== a)) {
          const e = {
            ssrcId: a,
            attributes: rG(
              { label: o, mslabel: i, msid: "".concat(i, " ").concat(o) },
              t && { cname: t }
            )
          };
          s.push(e), r.push({ semantic: "FID", ssrcIds: [n, a] });
        }
      }),
      e.length > 1 &&
        r.push({
          semantic: "SIM",
          ssrcIds: e.map(e => {
            let { ssrcId: t } = e;
            return t;
          })
        }),
      { ssrcs: s, ssrcGroups: r }
    );
  }
  function kj(e, t) {
    t instanceof FB &&
      e.attributes.payloads.forEach(e => {
        var i;
        const s =
          null === (i = e.rtpMap) || void 0 === i
            ? void 0
            : i.encodingName.toLowerCase();
        if (!s || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(s)) return;
        e.fmtp || (e.fmtp = { parameters: {} }),
          (e.fmtp.parameters.minptime = "10"),
          (e.fmtp.parameters.useinbandfec = "1");
        const r = t._encoderConfig;
        r &&
          "pcmu" !== s &&
          "pcma" !== s &&
          "g722" !== s &&
          (r.bitrate &&
            !DP() &&
            (e.fmtp.parameters.maxaveragebitrate = "".concat(
              Math.floor(1e3 * r.bitrate)
            )),
          r.sampleRate &&
            ((e.fmtp.parameters.maxplaybackrate = "".concat(r.sampleRate)),
            (e.fmtp.parameters["sprop-maxcapturerate"] = "".concat(
              r.sampleRate
            ))),
          r.stereo &&
            ((e.fmtp.parameters.stereo = "1"),
            (e.fmtp.parameters["sprop-stereo"] = "1")));
      });
  }
  function Mj(e, t, i) {
    if (!t) return;
    let s, r;
    if (
      ("video" === e.media.mediaType
        ? ((s = i.videoExtensions), (r = i.videoCodecs))
        : ((s = i.audioExtensions), (r = i.audioCodecs)),
      !0 === t.twcc)
    ) {
      const t = s.find(e => Oj(e.extensionName));
      if (t) {
        const i = t.extensionName;
        e.attributes.extmaps.find(e => Oj(e.extensionName)) ||
          e.attributes.extmaps.push({ entry: t.entry, extensionName: i });
        const s = (function(e, t) {
          return t.filter(
            t =>
              !!e.find(
                e =>
                  e.payloadType === t.payloadType &&
                  !!e.rtcpFeedbacks.find(e => "transport-cc" === e.type)
              )
          );
        })(r, e.attributes.payloads);
        s.forEach(e => {
          e.rtcpFeedbacks.find(e => "transport-cc" === e.type) ||
            e.rtcpFeedbacks.push({ type: "transport-cc" });
        });
      }
    } else if (!1 === t.twcc) {
      const t = e.attributes.extmaps.findIndex(e => Oj(e.extensionName));
      -1 !== t && e.attributes.extmaps.splice(t, 1),
        e.attributes.payloads.forEach(e => {
          const t = e.rtcpFeedbacks.findIndex(e => "transport-cc" === e.type);
          -1 !== t && e.rtcpFeedbacks.splice(t, 1);
        });
    }
    if (!0 === t.remb) {
      const t = s.find(e => bj(e.extensionName));
      if (t) {
        const i = t.extensionName;
        e.attributes.extmaps.find(e => e.extensionName === i) ||
          e.attributes.extmaps.push({ entry: t.entry, extensionName: i });
        const s = (function(e, t) {
          return t.filter(
            t =>
              !!e.find(
                e =>
                  e.payloadType === t.payloadType &&
                  !!e.rtcpFeedbacks.find(e => "goog-remb" === e.type)
              )
          );
        })(r, e.attributes.payloads);
        s.forEach(e => {
          e.rtcpFeedbacks.find(e => "goog-remb" === e.type) ||
            e.rtcpFeedbacks.push({ type: "goog-remb" });
        });
      }
    } else if (!1 === t.remb) {
      const t = e.attributes.extmaps.findIndex(e => bj(e.extensionName));
      -1 !== t && e.attributes.extmaps.splice(t, 1),
        e.attributes.payloads.forEach(e => {
          const t = e.rtcpFeedbacks.findIndex(e => "goog-remb" === e.type);
          -1 !== t && e.rtcpFeedbacks.splice(t, 1);
        });
    }
  }
  async function Uj() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const i = new RTCPeerConnection();
    i.addTransceiver("video", { direction: "sendonly" }),
      i.addTransceiver("audio", { direction: "sendonly" }),
      i.addTransceiver("video", { direction: "recvonly" }),
      i.addTransceiver("audio", { direction: "recvonly" });
    const s = (await i.createOffer()).sdp,
      { send: r, recv: n, sendrecv: a } = (function() {
        let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          i = arguments.length > 2 ? arguments[2] : void 0;
        const s = Dj(i, e, t, "sendonly"),
          r = Dj(i, e, t, "recvonly"),
          n = {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: []
          },
          a = {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: []
          },
          o = {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: []
          };
        if (
          (xj(s, r, "videoExtensions", n, a, o),
          xj(s, r, "videoCodecs", n, a, o),
          xj(s, r, "audioExtensions", n, a, o),
          xj(s, r, "audioCodecs", n, a, o),
          WM("RAISE_H264_BASELINE_PRIORITY"))
        ) {
          const e = [],
            t = [];
          o.videoCodecs.forEach((i, s) => {
            var r;
            if (
              "h264" ===
              (null === (r = i.rtpMap) || void 0 === r
                ? void 0
                : r.encodingName.toLocaleLowerCase())
            ) {
              var n, a;
              const r = o.videoCodecs[s + 1],
                c = r && Yj(i, r),
                d =
                  null === (n = i.fmtp) || void 0 === n
                    ? void 0
                    : n.parameters["profile-level-id"],
                l =
                  null === (a = i.fmtp) || void 0 === a
                    ? void 0
                    : a.parameters["packetization-mode"];
              !d ||
              d !== WM("FIRST_H264_PROFILE_LEVEL_ID") ||
              (WM("FIRST_PACKETIZATION_MODE") &&
                l !== WM("FIRST_PACKETIZATION_MODE"))
                ? c
                  ? t.push([i, r])
                  : t.push([i])
                : c
                ? e.push([i, r])
                : e.push([i]);
            }
          }),
            e.length > 0 &&
              t.length > 0 &&
              (EU.debug("raising H264 baseline profile priority"),
              o.videoCodecs.forEach((i, s) => {
                var r;
                if (
                  "h264" ===
                  (null === (r = i.rtpMap) || void 0 === r
                    ? void 0
                    : r.encodingName.toLocaleLowerCase())
                ) {
                  const r = Yj(i, o.videoCodecs[s + 1]),
                    n = e.shift() || t.shift() || [];
                  n.length > 0 &&
                    (r
                      ? o.videoCodecs.splice(s, 2, ...n)
                      : o.videoCodecs.splice(s, 1, ...n));
                }
              }),
              (a.videoCodecs = a.videoCodecs.filter(e => {
                var t, i;
                return !(
                  "h264" ===
                    (null === (t = e.rtpMap) || void 0 === t
                      ? void 0
                      : t.encodingName.toLocaleLowerCase()) &&
                  (null === (i = e.fmtp) || void 0 === i
                    ? void 0
                    : i.parameters["profile-level-id"]) !==
                    WM("FIRST_H264_PROFILE_LEVEL_ID")
                );
              })),
              WM("FILTER_SEND_H264_BASELINE") &&
                (n.videoCodecs = n.videoCodecs.filter(e => {
                  var t, i;
                  return !(
                    "h264" ===
                      (null === (t = e.rtpMap) || void 0 === t
                        ? void 0
                        : t.encodingName.toLocaleLowerCase()) &&
                    (null === (i = e.fmtp) || void 0 === i
                      ? void 0
                      : i.parameters["profile-level-id"]) !==
                      WM("FIRST_H264_PROFILE_LEVEL_ID")
                  );
                })));
        }
        return { send: n, recv: a, sendrecv: o };
      })(e, t, s);
    try {
      i.close();
    } catch (e) {}
    return { send: r, recv: n, sendrecv: a };
  }
  function xj(e, t, i, s, r, n) {
    if ("videoExtensions" === i || "audioExtensions" === i) {
      const a = [];
      return (
        e[i].forEach(e => {
          t[i].some((t, i) => {
            if (e.entry === t.entry && e.extensionName === t.extensionName)
              return a.push(i), !0;
          })
            ? n[i].push(e)
            : s[i].push(e);
        }),
        void t[i].forEach((e, t) => {
          -1 === a.indexOf(t) && r[i].push(e);
        })
      );
    }
    if ("videoCodecs" === i || "audioCodecs" === i) {
      const a = [];
      return (
        e[i].forEach(e => {
          t[i].some((t, i) => {
            if (
              e.payloadType === t.payloadType &&
              JSON.stringify(e) === JSON.stringify(t)
            )
              return a.push(i), !0;
          })
            ? n[i].push(e)
            : s[i].push(e);
        }),
        void t[i].forEach((e, t) => {
          -1 === a.indexOf(t) && r[i].push(e);
        })
      );
    }
  }
  function Fj(e) {
    const { send: t, recv: i, sendrecv: s } = e;
    if (!s) {
      if (!t || !i)
        throw new Error(
          "cannot merge rtp capabilities because one of send or recv is empty!"
        );
      return { send: t, recv: i };
    }
    let r, n;
    return (
      t
        ? ((r = {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: []
          }),
          (r.audioCodecs = [...t.audioCodecs, ...s.audioCodecs]),
          (r.videoCodecs = [...t.videoCodecs, ...s.videoCodecs]),
          (r.audioExtensions = [...t.audioExtensions, ...s.audioExtensions]),
          (r.videoExtensions = [...t.videoExtensions, ...s.videoExtensions]))
        : (r = s),
      i
        ? ((n = {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: []
          }),
          (n.audioCodecs = [...i.audioCodecs, ...s.audioCodecs]),
          (n.videoCodecs = [...i.videoCodecs, ...s.videoCodecs]),
          (n.audioExtensions = [...i.audioExtensions, ...s.audioExtensions]),
          (n.videoExtensions = [...i.videoExtensions, ...s.videoExtensions]))
        : (n = s),
      { send: r, recv: n }
    );
  }
  function Bj(e) {
    if ("audio" !== e.media.mediaType) return;
    e.attributes.payloads
      .filter(e => {
        var t;
        return (
          "opus" ===
          (null === (t = e.rtpMap) || void 0 === t
            ? void 0
            : t.encodingName.toLowerCase())
        );
      })
      .forEach(e => {
        e.fmtp || (e.fmtp = { parameters: {} }),
          (e.fmtp.parameters.stereo = "1"),
          (e.fmtp.parameters["sprop-stereo"] = "1");
      });
  }
  function Vj(e, t, i, s) {
    let r = [];
    if (e === xG.VIDEO) {
      if (
        (WM("H264_PROFILE_LEVEL_ID") &&
          "h264" === s &&
          (r = t.videoCodecs.filter(
            e =>
              (
                (e.rtpMap && e.rtpMap.encodingName.toLowerCase()) ||
                ""
              ).includes(s) &&
              e &&
              e.fmtp &&
              e.fmtp.parameters["profile-level-id"] ===
                WM("H264_PROFILE_LEVEL_ID")
          )),
        !Array.isArray(r) || 0 === r.length)
      ) {
        let e = [];
        const n = [],
          a = [],
          o = [];
        if (
          (i.videoCodecs.forEach(t => {
            const i = (t.rtpMap && t.rtpMap.encodingName.toLowerCase()) || "";
            i.includes(s)
              ? e.push(t)
              : i.includes("vp9")
              ? n.push(t)
              : i.includes("vp8")
              ? a.push(t)
              : i.includes("h264") && o.push(t);
          }),
          0 === e.length)
        ) {
          let t = "";
          0 !== n.length
            ? ((e = n), (t = "vp9"))
            : 0 !== a.length
            ? ((e = a), (t = "vp8"))
            : 0 !== o.length && ((e = o), (t = "h264")),
            EU.warning(
              "codec "
                .concat(
                  s,
                  " not included in rtpCapabilities, fallback to default payloads: "
                )
                .concat(t)
            );
        }
        0 !== e.length &&
          (r = t.videoCodecs.filter(t =>
            e.some(e => e.payloadType === t.payloadType)
          ));
      }
      if (
        (0 === r.length &&
          (EU.warning(
            "codec "
              .concat(
                s,
                " not included in rtpCapabilities, fallback to default payloads: "
              )
              .concat(
                t.videoCodecs[0].rtpMap && t.videoCodecs[0].rtpMap.encodingName
              )
          ),
          (r = t.videoCodecs)),
        WM("USE_PUB_RTX") || WM("USE_SUB_RTX"))
      ) {
        const e = Gj(r, t.videoCodecs);
        r = [...r, ...e];
      }
    } else (r = t.audioCodecs.filter(e => ((e.rtpMap && e.rtpMap.encodingName.toLowerCase()) || "").includes(s))), 0 === r.length && (EU.warning("codec ".concat(s, " not included in rtpCapabilities, fallback to opus")), (r = t.audioCodecs.filter(e => ((e.rtpMap && e.rtpMap.encodingName.toLowerCase()) || "").includes("opus"))));
    return r;
  }
  function Gj(e, t) {
    const i = e.map(e => e.payloadType.toString());
    return t.filter(
      e =>
        e.rtpMap &&
        "rtx" === e.rtpMap.encodingName &&
        e.fmtp &&
        e.fmtp.parameters.apt &&
        i.includes(e.fmtp && e.fmtp.parameters.apt)
    );
  }
  async function jj(e, t, i) {
    const s = t.toString(),
      r = Kj(s, "offer", "remote", "exchangeSDP");
    await e.setRemoteDescription({ type: "offer", sdp: s });
    const n = await e.createAnswer();
    if (!n.sdp) throw new Error("cannot get answer sdp");
    let a = n.sdp;
    (a = Hj(a, i || {})),
      null == r || r(a || ""),
      await e.setLocalDescription({ type: "answer", sdp: a });
  }
  function Hj(e, t, i) {
    const s = sU(e),
      { useXR: r } = t;
    return (
      s.mediaDescriptions.forEach(e => {
        e.attributes.mid &&
          ((Array.isArray(i) && !i.includes(e.attributes.mid)) ||
            ("audio" === e.media.mediaType && Bj(e),
            r &&
              ["audio", "video"].includes(e.media.mediaType) &&
              e.attributes.payloads.forEach(e => {
                -1 === e.rtcpFeedbacks.findIndex(e => "rrtr" === e.type) &&
                  e.rtcpFeedbacks.push({ type: "rrtr" });
              })));
      }),
      rU(s)
    );
  }
  function Kj(e, t, i, s) {
    if (WM("SDP_LOGGING"))
      return (
        EU.upload(
          "exchanging "
            .concat(i, " ")
            .concat(t, " SDP during P2PConnection.")
            .concat(s, "\n"),
          e
        ),
        "offer" === t
          ? e => {
              Kj(e, "answer", "local" === i ? "remote" : "local", s);
            }
          : void 0
      );
  }
  function Wj(e) {
    const t = WM("COMPATIBLE_SDP_EXTENSION");
    return !!(Array.isArray(t) && t.length > 0) && t.some(t => e.includes(t));
  }
  function Yj(e, t) {
    try {
      var i;
      return (
        (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters.apt) ===
        t.payloadType.toString()
      );
    } catch (e) {
      return !1;
    }
  }
  function $j(e, t) {
    return typeof WM(e) === t ? WM(e) : void 0;
  }
  const qj = {};
  function Xj(e) {
    const t = qj[e];
    if (!t)
      throw new JP(
        zP.INVALID_OPERATION,
        ""
          .concat(e, " not found, please use AgoraRTC.use(")
          .concat(e, "Service) to load it first")
      );
    return t;
  }
  function zj(e, t) {
    return Xj("DataStream").create(e, t);
  }
  function Jj() {
    return Xj("InterceptFrame").create();
  }
  const Qj = new Map();
  class Zj extends uk {
    get state() {
      return this._state;
    }
    set state(e) {
      if (e === this._state) return;
      const t = this._state;
      (this._state = e),
        "DISCONNECTED" === e && this._disconnectedReason
          ? this.emit(
              CG.CONNECTION_STATE_CHANGE,
              e,
              t,
              this._disconnectedReason
            )
          : this.emit(CG.CONNECTION_STATE_CHANGE, e, t);
    }
    get joinGatewayStartTime() {
      return this._joinGatewayStartTime;
    }
    set joinGatewayStartTime(e) {
      EU.debug(
        "["
          .concat(this.store.clientId, "] set joinGatewayStartTime at ")
          .concat(e)
      ),
        (this._joinGatewayStartTime = e);
    }
    constructor(e, t) {
      var i, s, r;
      super(),
        (this.store = void 0),
        (this.joinInfo = void 0),
        (this.key = void 0),
        (this.ntpOffset = 0),
        (this.signal = void 0),
        (this.role = void 0),
        (this.inChannelInfo = { joinAt: null, duration: 0 }),
        (this.spec = void 0),
        (this._state = "DISCONNECTED"),
        (this._statsCollector = void 0),
        (this._disconnectedReason = void 0),
        (this.isSignalRecover = !1),
        (this.hasChangeBGPAddress = !1),
        (this.trafficStatsInterval = void 0),
        (this.networkQualityInterval = void 0),
        (this._joinGatewayStartTime = 0),
        (this._signalTimeout = !1),
        (this._clientRoleOptions = void 0),
        (this._isProactiveJoin = !1),
        (this.store = e),
        (this.spec = t),
        (this.signal = this.store.useP2P
          ? ((i = {
              spec: rG(rG({}, t), {}, { retryConfig: t.websocketRetryConfig }),
              store: e
            }),
            null === (s = (r = Xj("P2PChannel")).createSubmodule) ||
            void 0 === s
              ? void 0
              : s.call(r, i))
          : new hj(
              rG(rG({}, t), {}, { retryConfig: t.websocketRetryConfig }),
              e
            )),
        (this._statsCollector = t.statsCollector),
        (this.role = t.role || "audience"),
        (this._clientRoleOptions = t.clientRoleOptions),
        this.handleSignalEvents();
    }
    async join(e, t, i) {
      this.store.joinGatewayStart(),
        "disabled" !== e.cloudProxyServer && (this.hasChangeBGPAddress = !0);
      const s = Date.now();
      let r = Qj.get(e.cname);
      if (
        (r || ((r = new Map()), Qj.set(e.cname, r)),
        (this._isProactiveJoin = !0),
        r.has(e.uid))
      ) {
        const t = new AU(zP.UID_CONFLICT);
        throw (yU.joinGateway(e.sid, {
          lts: s,
          succ: !1,
          ec: t.code,
          addr: null,
          uid: e.uid,
          cid: e.cid,
          firstSuccess: this._isProactiveJoin,
          avoidJoinStartTime: this.store.avoidJoinStart,
          isProxy: !!e.proxyServer,
          signalChannel: "0",
          preload: e.preload
        }),
        t);
      }
      r.set(e.uid, !0), (this.joinInfo = e), (this.key = t);
      let n = 0;
      this.joinGatewayStartTime = s;
      const a = e.proxyServer;
      try {
        EU.debug(
          "[".concat(this.store.clientId, "] use websocket join uid ").concat(n)
        );
        const t = e.gatewayAddrs.map(t => {
          let { address: i } = t;
          const [s, r] = i.split(":"),
            n = { host: s, port: r };
          return e.proxyServer && (n.proxy = e.proxyServer), n;
        });
        (n = (await this.signal.init(t)).uid),
          EU.debug(
            "["
              .concat(this.store.clientId, "] websocket join uid ")
              .concat(n, " cost ")
              .concat(Date.now() - this.joinGatewayStartTime)
          );
      } catch (t) {
        var o;
        throw (EU.error(
          "[".concat(this.store.clientId, "] User join failed"),
          t.toString()
        ),
        yU.joinGateway(e.sid, {
          lts: s,
          succ: !1,
          ec:
            (null === (o = t.data) || void 0 === o ? void 0 : o.desc) || t.code,
          errorMsg: t.message,
          addr: this.signal.url,
          uid: e.uid,
          cid: e.cid,
          firstSuccess: this._isProactiveJoin,
          avoidJoinStartTime: this.store.avoidJoinStart,
          isProxy: !!a,
          signalChannel: "0",
          preload: e.preload
        }),
        r.delete(e.uid),
        this.signal.close(),
        t);
      }
      return (
        (this.state = "CONNECTED"),
        (this.inChannelInfo.joinAt = Date.now()),
        EU.debug(
          "[".concat(this.store.clientId, "] Connected to gateway server")
        ),
        (this.trafficStatsInterval = window.setInterval(() => {
          this.updateTrafficStats().catch(e => {
            EU.warning(
              "[".concat(this.store.clientId, "] get traffic stats error"),
              e.toString()
            );
          });
        }, 3e3)),
        (this.networkQualityInterval = window.setInterval(() => {
          navigator && void 0 !== navigator.onLine && !navigator.onLine
            ? this.emit(CG.NETWORK_QUALITY, {
                downlinkNetworkQuality: 6,
                uplinkNetworkQuality: 6
              })
            : this._signalTimeout
            ? this.emit(CG.NETWORK_QUALITY, {
                downlinkNetworkQuality: 5,
                uplinkNetworkQuality: 5
              })
            : "CONNECTED" === this.state && this._statsCollector.trafficStats
            ? this.emit(CG.NETWORK_QUALITY, {
                uplinkNetworkQuality: _j(
                  this._statsCollector.trafficStats.B_unq
                ),
                downlinkNetworkQuality: _j(
                  this._statsCollector.trafficStats.B_dnq
                )
              })
            : this.emit(CG.NETWORK_QUALITY, {
                uplinkNetworkQuality: 0,
                downlinkNetworkQuality: 0
              });
        }, 2e3)),
        this.store.joinGatewayEnd(),
        n
      );
    }
    async leave() {
      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
        t = arguments.length > 1 ? arguments[1] : void 0;
      if ("DISCONNECTED" !== this.state) {
        t !== _k.FALLBACK && (this.state = "DISCONNECTING");
        try {
          e ||
            this.signal.connectionState !== uG.CONNECTED ||
            (await (function(e, t) {
              return t === 1 / 0 ? e : Promise.race([e, Kk(t)]);
            })(this.signal.request(fG.LEAVE, void 0, !0), 3e3));
        } catch (e) {
          EU.warning(
            "[".concat(this.store.clientId, "] leave request failed, ignore"),
            e
          );
        }
        this.signal.close(t),
          t !== _k.FALLBACK && (this.state = "DISCONNECTED"),
          this.reset();
      }
    }
    async publish(e, t, i) {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
        throw new AU(
          zP.INVALID_OPERATION,
          "can not publish when connection state is ".concat(this.state)
        );
      const s = {
        state: "offer",
        p2p_id: this.store.p2pId,
        ortc: t,
        mode: this.spec.mode,
        extend: WM("PUB_EXTEND"),
        twcc: !!WM("PUBLISH_TWCC"),
        rtx: !!WM("USE_PUB_RTX")
      };
      try {
        return (await this.signal.request(fG.PUBLISH, s, !0))._message;
      } catch (s) {
        if (i && s.data && s.data.code === hG.ERR_PUBLISH_REQUEST_INVALID)
          return (
            EU.warning(
              "[".concat(
                this.store.clientId,
                "] receive publish error code, retry"
              ),
              s.toString()
            ),
            await this.tryUnpubBeforeRepub(e, t),
            this.publish(e, t, !1)
          );
        throw s;
      }
    }
    async publishDataChannel(e, t, i) {
      var s;
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
        throw new AU(
          zP.INVALID_OPERATION,
          "can not publish when connection state is ".concat(this.state)
        );
      const r = {
        stream_id: t.streamId,
        ordered: t.ordered ? 1 : 0,
        max_retrans_times:
          null !== (s = t.maxRetransmits) && void 0 !== s ? s : 10,
        channel_id: t.channelId,
        metadata: t.metadata
      };
      try {
        await this.signal.request(fG.PUBLISH_DATASTREAM, r, !0);
      } catch (s) {
        if (i && s.data && s.data.code === hG.ERR_PUBLISH_REQUEST_INVALID)
          return (
            EU.warning(
              "[".concat(
                this.store.clientId,
                "] receive publish datachannels error code, retry"
              ),
              s.toString()
            ),
            await this.tryUnpubDataChannelBeforeRepub(e, t),
            this.publishDataChannel(e, t, !1)
          );
        throw s;
      }
    }
    async unpublish(e, t) {
      try {
        if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
          throw new AU(
            zP.INVALID_OPERATION,
            "can not publish when connection state is ".concat(this.state)
          );
        await this.signal.request(fG.UNPUBLISH, { stream_id: t, ortc: e }, !0);
      } catch (e) {
        EU.warning("[".concat(this.store.clientId, "] unpublish warning: "), e);
      }
    }
    async unpublishDataChannel(e) {
      try {
        if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
          throw new AU(
            zP.INVALID_OPERATION,
            "can not publish when connection state is ".concat(this.state)
          );
        await Promise.all(
          e.map(e =>
            this.signal.request(fG.UNPUBLISH_DATASTREAM, { channel_id: e }, !0)
          )
        );
      } catch (e) {
        EU.warning("unpublish datachannels warning: ", e);
      }
    }
    async presubscribe(e, t, i) {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
        throw new AU(
          zP.INVALID_OPERATION,
          "can not presubscribe when connection state is ".concat(this.state)
        );
      const s = {
        stream_id: e,
        stream_type: t,
        mode: this.spec.mode,
        codec: this.spec.codec,
        p2p_id: this.store.p2pId,
        twcc: !!WM("SUBSCRIBE_TWCC"),
        rtx: !!WM("USE_SUB_RTX") || void 0,
        extend: WM("SUB_EXTEND"),
        svc:
          Array.isArray(WM("SVC")) && 0 !== WM("SVC").length
            ? WM("SVC")
            : void 0
      };
      try {
        return await this.signal.request(fG.PRE_SUBSCRIBE, s, !0);
      } catch (s) {
        if (i && s.data && s.data.code === hG.ERR_SUBSCRIBE_REQUEST_INVALID)
          return (
            EU.warning(
              "[".concat(this.store.clientId, "] pre-subscribe error, retry"),
              s.toString()
            ),
            this.presubscribe(e, t, !1)
          );
        throw s;
      }
    }
    async subscribe(e, t, i) {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
        throw new AU(
          zP.INVALID_OPERATION,
          "can not subscribe when connection state is ".concat(this.state)
        );
      const s = {
        stream_id: e,
        stream_type: t.stream_type,
        mode: this.spec.mode,
        codec: this.spec.codec,
        p2p_id: this.store.p2pId,
        twcc: !!WM("SUBSCRIBE_TWCC"),
        rtx: !!WM("USE_SUB_RTX"),
        extend: WM("SUB_EXTEND"),
        ssrcId: t.ssrcId,
        svc:
          Array.isArray(WM("SVC")) && 0 !== WM("SVC").length
            ? WM("SVC")
            : void 0
      };
      try {
        return (await this.signal.request(fG.SUBSCRIBE, s, !0))._message;
      } catch (s) {
        if (i && s.data && s.data.code === hG.ERR_SUBSCRIBE_REQUEST_INVALID)
          return (
            EU.warning(
              "[".concat(
                this.store.clientId,
                "] receiver subscribe error code, retry"
              ),
              s.toString()
            ),
            await this.tryUnsubBeforeResub(e, t),
            await this.subscribe(e, t, !1)
          );
        throw s;
      }
    }
    async subscribeDataChannel(e, t, i) {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
        throw new AU(
          zP.INVALID_OPERATION,
          "can not subscribe datachannel when connection state is ".concat(
            this.state
          )
        );
      const s = { uid: e, stream_id: t.id, channel_id: t.datachannelId };
      try {
        return void (await this.signal.request(fG.SUBSCRIBE_DATASTREAM, s, !0));
      } catch (s) {
        if (i && s.data && s.data.code === hG.ERR_SUBSCRIBE_REQUEST_INVALID)
          return (
            EU.warning(
              "[".concat(
                this.store.clientId,
                "] receiver subscribe datachannel error code, retry"
              ),
              s.toString()
            ),
            await this.tryUnsubDataChannelBeforeResub(e, t),
            await this.subscribeDataChannel(e, t, !1)
          );
        throw s;
      }
    }
    async subscribeAll(e, t) {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
        throw new AU(
          zP.INVALID_OPERATION,
          "can not massSubscribe when connection state is ".concat(this.state)
        );
      const i = {
        p2p_id: this.store.p2pId,
        users: e,
        dtx: !1,
        rtx: !!WM("USE_SUB_RTX"),
        twcc: !!WM("SUBSCRIBE_TWCC"),
        svc:
          Array.isArray(WM("SVC")) && 0 !== WM("SVC").length
            ? WM("SVC")
            : void 0
      };
      try {
        return await this.signal.request(fG.SUBSCRIBE_STREAMS, i, !0);
      } catch (i) {
        if (t && i.data && i.data.code === hG.ERR_SUBSCRIBE_REQUEST_INVALID)
          return (
            EU.warning(
              "[".concat(
                this.store.clientId,
                "] receiver massSubscribe error code, retry"
              ),
              i.toString()
            ),
            await this.tryMassUnsubBeforeResub(e),
            await this.subscribeAll(e, !1)
          );
        throw i;
      }
    }
    async setVideoProfile(e) {
      const t = (function(e) {
        if (
          !(e.bitrateMax && e.bitrateMin && e.frameRate && e.height && e.width)
        )
          return;
        let t = e.frameRate,
          i = e.width,
          s = e.height,
          r = !0;
        return (
          "number" != typeof t &&
            ((t = t.exact || t.ideal || t.max || t.min || 0), t || (r = !1)),
          "number" != typeof i &&
            ((i = i.exact || i.ideal || i.max || i.min || 0), i || (r = !1)),
          "number" != typeof s &&
            ((s = s.exact || s.ideal || s.max || s.min || 0), t || (r = !1)),
          r
            ? {
                stream_type: 0,
                width: i,
                height: s,
                fps: t,
                start_bps: 1e3 * e.bitrateMax,
                min_bps: 1e3 * e.bitrateMin,
                target_bps: 1e3 * e.bitrateMax
              }
            : void 0
        );
      })(e);
      if (t) return this.signal.request(fG.SET_VIDEO_PROFILE, t);
      EU.debug(
        "[".concat(
          this.store.clientId,
          "] encoder config is not complete, do not report to gateway"
        )
      );
    }
    async unsubscribe(e, t) {
      try {
        await this.signal.request(
          fG.UNSUBSCRIBE,
          { p2p_id: this.store.p2pId, ortc: e, stream_id: t },
          !0
        );
      } catch (e) {
        EU.warning(
          "[".concat(this.store.clientId, "] unsubscribe warning: "),
          e
        );
      }
    }
    async unsubscribeDataChannel(e, t) {
      try {
        if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
          throw new AU(
            zP.INVALID_OPERATION,
            "can not publish when connection state is ".concat(this.state)
          );
        await Promise.all(
          e.map(e =>
            this.signal.request(
              fG.UNSUBSCRIBE_DATASTREAM,
              { stream_id: e, uid: t },
              !0
            )
          )
        );
      } catch (e) {
        EU.warning("unsubscribeDataChannel warning: ", e);
      }
    }
    async massUnsubscribe(e) {
      try {
        await this.signal.request(fG.UNSUBSCRIBE_STREAMS, e, !0);
      } catch (e) {
        EU.warning(
          "[".concat(this.store.clientId, "] massUnsubscribeAll warning: "),
          e
        );
      }
    }
    async reconnectPC(e) {
      const { iceParameters: t, dtlsParameters: i, rtpCapabilities: s } = e;
      return {
        gatewayEstablishParams: await this.signal.request(
          fG.CONNECT_PC,
          {
            p2p_id: this.store.p2pId,
            stream_id: this.store.uid,
            ortc: { iceParameters: t, dtlsParameters: i, rtpCapabilities: s }
          },
          !0
        ),
        gatewayAddress: this.getCurrentGatewayAddress()
      };
    }
    getGatewayInfo() {
      return this.signal.request(fG.GATEWAY_INFO);
    }
    async renewToken(e) {
      await this.signal.request(fG.RENEW_TOKEN, e), (this.key = e.token);
    }
    updateClientRole(e, t) {
      t && (this._clientRoleOptions = Object.assign({}, t)),
        WM("CLIENT_ROLE_OPTIONS") &&
          (EU.debug(
            "["
              .concat(this.store.clientId, "] Set roleOptions for ")
              .concat(JSON.stringify(WM("CLIENT_ROLE_OPTIONS")), " instead of ")
              .concat(JSON.stringify(this._clientRoleOptions), " ")
          ),
          (this._clientRoleOptions = Object.assign(
            {},
            WM("CLIENT_ROLE_OPTIONS")
          ))),
        (this.role = e);
    }
    async setClientRole(e, t) {
      if (
        (t && (this._clientRoleOptions = Object.assign({}, t)),
        WM("CLIENT_ROLE_OPTIONS") &&
          ((this._clientRoleOptions = Object.assign(
            {},
            WM("CLIENT_ROLE_OPTIONS")
          )),
          EU.debug(
            "["
              .concat(this.store.clientId, "] Set roleOptions for ")
              .concat(JSON.stringify(WM("CLIENT_ROLE_OPTIONS")), " instead of ")
              .concat(JSON.stringify(this._clientRoleOptions), " ")
          )),
        "CONNECTED" !== this.state)
      )
        return void (this.role = e);
      let i,
        s = 0;
      "audience" === e
        ? this._clientRoleOptions && this._clientRoleOptions.delay
          ? ((i = this._clientRoleOptions.delay), (s = 1))
          : (s =
              this._clientRoleOptions && this._clientRoleOptions.level
                ? this._clientRoleOptions.level
                : 2)
        : (s = 0),
        await this.signal.request(fG.SET_CLIENT_ROLE, {
          role: e,
          level: s,
          delay: i,
          client_ts: Date.now()
        }),
        (this.role = e);
    }
    async setRemoteVideoStreamType(e, t) {
      await this.signal.request(fG.SWITCH_VIDEO_STREAM, {
        stream_id: e,
        stream_type: t
      });
    }
    async setDefaultRemoteVideoStreamType(e) {
      await this.signal.request(fG.DEFAULT_VIDEO_STREAM, { stream_type: e });
    }
    async setStreamFallbackOption(e, t) {
      await this.signal.request(fG.SET_FALLBACK_OPTION, {
        stream_id: e,
        fallback_type: t
      });
    }
    async pickSVCLayer(e, t) {
      await this.signal.request(fG.PICK_SVC_LAYER, {
        stream_id: e,
        spatial_layer: t.spatialLayer,
        temporal_layer: t.temporalLayer
      });
    }
    async setRTM2Flag(e) {
      await this.signal.request(fG.SET_RTM2_FLAG, { rtm2_flag: e });
    }
    async sendExtensionMessage(e, t, i) {
      if (this.store.useP2P) return this.signal.sendExtensionMessage(e, t, i);
    }
    getInChannelInfo() {
      return (
        this.inChannelInfo.joinAt &&
          (this.inChannelInfo.duration =
            Date.now() - this.inChannelInfo.joinAt),
        rG({}, this.inChannelInfo)
      );
    }
    async getGatewayVersion() {
      return (await this.signal.request(fG.GATEWAY_INFO)).version;
    }
    reset() {
      if (
        (this.inChannelInfo.joinAt &&
          ((this.inChannelInfo.duration =
            Date.now() - this.inChannelInfo.joinAt),
          (this.inChannelInfo.joinAt = null)),
        this.trafficStatsInterval &&
          (window.clearInterval(this.trafficStatsInterval),
          (this.trafficStatsInterval = void 0)),
        this.joinInfo)
      ) {
        const e = Qj.get(this.joinInfo.cname);
        e && e.delete(this.joinInfo.uid);
      }
      (this.joinInfo = void 0),
        (this.key = void 0),
        this.networkQualityInterval &&
          (window.clearInterval(this.networkQualityInterval),
          (this.networkQualityInterval = void 0));
    }
    updateTurnConfigFromSignal() {
      if (!this.joinInfo) return;
      const e = (function(e) {
        let t;
        return (
          (t = e.startsWith("dc")
            ? e.match(/(dc\:\/\/)?([^:]+):(\d+)/)
            : e.match(/(wss\:\/\/)?([^:]+):(\d+)/)),
          t
            ? {
                username: FM.username,
                password: FM.password,
                turnServerURL: t[2],
                tcpport: parseInt(t[3]) + 30,
                udpport: parseInt(t[3]) + 30,
                forceturn: !1
              }
            : null
        );
      })(
        ("disabled" === this.joinInfo.cloudProxyServer
          ? this.signal.url
          : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) ||
          ""
      );
      (this.joinInfo.turnServer.serversFromGateway = []),
        e &&
          "off" !== this.joinInfo.turnServer.mode &&
          "disabled" === this.joinInfo.cloudProxyServer &&
          this.joinInfo.turnServer.serversFromGateway.push(
            rG(
              rG({}, FM),
              {},
              {
                turnServerURL: e.turnServerURL,
                tcpport: e.tcpport,
                udpport: e.udpport,
                username: this.joinInfo.uid.toString(),
                password: this.joinInfo.token
              }
            )
          );
    }
    async updateTrafficStats() {
      if ("CONNECTED" !== this.state) return;
      const e = await this.signal.request(fG.TRAFFIC_STATS, void 0, !0);
      (e.timestamp = Date.now()),
        null != e.ntp_offset && (this.ntpOffset = e.ntp_offset),
        e.peer_delay.forEach(e => {
          const t =
            this._statsCollector.trafficStats &&
            this._statsCollector.trafficStats.peer_delay.find(
              t => t.peer_uid === e.peer_uid
            );
          t &&
            t.B_st !== e.B_st &&
            Pk(() => {
              this.emit(CG.STREAM_TYPE_CHANGE, e.peer_uid, e.B_st);
            });
        }),
        this._statsCollector.updateTrafficStats(e);
    }
    getJoinMessage(e) {
      if (!this.joinInfo || !this.key)
        throw new AU(
          zP.UNEXPECTED_ERROR,
          "can not generate join message, no join info"
        );
      const t = Object.assign({}, this.joinInfo.apResponse);
      let i = WM("REPORT_APP_SCENARIO");
      if ("string" != typeof i)
        try {
          i = JSON.stringify(i);
        } catch (e) {
          i = void 0;
        }
      var s;
      i && i.length > 128 && (i = void 0),
        (this.store.hasStartJoinChannel = !0),
        this.store.isABTestSuccess || this.emit(CG.UPDATE_GATEWAY_CONFIG),
        (s = this.store.clientId),
        $V.includes(s) || $V.push(s);
      const r =
          !(DP() || NP(87) || Px()) &&
          "boolean" == typeof WM("ENABLE_PRE_SUB") && WM("ENABLE_PRE_SUB"),
        n = !Px() && $j("ENABLE_PREALLOC_PC", "boolean"),
        a = (function() {
          try {
            const e = WM("EXPERIMENTS") || {};
            return "string" == typeof e || Array.isArray(e) ? {} : rG({}, e);
          } catch (e) {
            return EU.debug("handle gateway attributes failed: ", e), {};
          }
        })(),
        o =
          LP(87) ||
          (function() {
            const e = vP();
            if (e.name !== gP.SAFARI || !e.browserVersion) return !1;
            const t = e.browserVersion.split(".");
            return (
              Number(t[0]) > 15 || (15 === Number(t[0]) && Number(t[1]) >= 4)
            );
          })(),
        c = rG(
          {
            license: this.joinInfo.license,
            p2p_id: this.store.p2pId,
            session_id: this.joinInfo.sid,
            app_id: this.joinInfo.appId,
            channel_key: this.key,
            channel_name: this.joinInfo.cname,
            sdk_version: MM,
            browser: navigator.userAgent,
            process_id: WM("PROCESS_ID"),
            mode: this.store.useP2P ? "p2p" : this.spec.mode,
            codec: this.spec.codec,
            role: this.role,
            has_changed_gateway: this.hasChangeBGPAddress,
            ap_response: t,
            extend: WM("JOIN_EXTEND"),
            details: {
              6: this.joinInfo.stringUid,
              cservice_map:
                "proxy3" === this.joinInfo.cloudProxyServer
                  ? "1"
                  : "proxy5" === this.joinInfo.cloudProxyServer
                  ? "2"
                  : void 0
            },
            features: { rejoin: !0 },
            optionalInfo: this.joinInfo.optionalInfo,
            appScenario: i,
            attributes: {
              userAttributes: rG(
                {
                  enableEncodedTransform:
                    (!!WM("ENABLE_AUDIO_METADATA") && o) ||
                    (!!WM("ENABLE_AUDIO_TOPN") && PP(gP.CHROME, 87, 116)) ||
                    void 0,
                  enableAudioMetadata: !!WM("ENABLE_AUDIO_METADATA") && o,
                  enableAudioPts: !!WM("ENABLE_AUDIO_PTS_METADATA") && o,
                  topnSmoothLevel: WM("TOPN_SMOOTH_LEVEL"),
                  topnNewSpeakerDelay: WM("TOPN_NEW_SPEAKER_DELAY"),
                  topnSwitchHoldMs: WM("TOPN_SWITCH_HOLD_MS"),
                  topnAudioGain: WM("TOPN_AUDIO_GAIN"),
                  enablePublishedUserList: WM("ENABLE_PUBLISHED_USER_LIST"),
                  maxSubscription: WM("MAX_SUBSCRIPTION"),
                  subscribeAudioFilterTopN: $j(
                    "SUBSCRIBE_AUDIO_FILTER_TOPN",
                    "number"
                  ),
                  enablePublishAudioFilter: $j(
                    "ENABLE_PUBLISH_AUDIO_FILTER",
                    "boolean"
                  ),
                  enableUserLicenseCheck: $j(
                    "ENABLE_USER_LICENSE_CHECK",
                    "boolean"
                  ),
                  enableRTX:
                    !0 === WM("USE_PUB_RTX") ||
                    !0 === WM("USE_SUB_RTX") ||
                    void 0,
                  disableFEC: WM("DISABLE_FEC"),
                  enableNTPReport: !!WM("ENABLE_NTP_REPORT") || void 0,
                  enableInstantVideo: !!WM("ENABLE_INSTANT_VIDEO") || void 0,
                  enableFulllinkAvSync:
                    !!WM("ENABLE_FULL_LINK_AV_SYNC") || void 0,
                  enableDataStream2: $j("ENABLE_DATASTREAM_2", "boolean"),
                  enableAutFeedback: !!WM("ENABLE_AUT_FEEDBACK") || void 0,
                  rtm2Flag:
                    "number" == typeof this.joinInfo.rtmFlag
                      ? this.joinInfo.rtmFlag
                      : void 0,
                  enableUserAutoRebalanceCheck: !!WM(
                    "ENABLE_USER_AUTO_REBALANCE_CHECK"
                  ),
                  enableXR: $j("USE_XR", "boolean"),
                  enableLossbasedBwe: $j("ENABLE_LOSSBASED_BWE", "boolean"),
                  enableAutCC: !!WM("ENABLE_AUT_CC") || void 0,
                  enableCCFallback: $j("ENABLE_CC_FALLBACK", "boolean"),
                  enablePreallocPC: n,
                  preSubNum: r ? $j("PRE_SUB_NUM", "number") : void 0,
                  enablePubTWCC: $j("PUBLISH_TWCC", "boolean"),
                  enableSubTWCC: $j("SUBSCRIBE_TWCC", "boolean"),
                  enablePubRTX: $j("USE_PUB_RTX", "boolean"),
                  enableSubRTX: $j("USE_SUB_RTX", "boolean"),
                  enableSubSVC: WM("ENABLE_SVC")
                    ? WM("ENABLE_SVC_DEFAULT_CODECS")
                    : Array.isArray(WM("SVC")) && 0 !== WM("SVC").length
                    ? WM("SVC")
                    : void 0,
                  enableSvcExtended:
                    WM("ENABLE_SVC") &&
                    Array.isArray(WM("SVC_EXTENDED")) &&
                    0 !== WM("SVC_EXTENDED").length
                      ? WM("SVC_EXTENDED")
                      : void 0
                },
                a
              )
            },
            join_ts: this.joinGatewayStartTime
          },
          e
        );
      return (
        this.joinInfo.stringUid && (c.string_uid = this.joinInfo.stringUid),
        this.joinInfo.aesmode &&
          this.joinInfo.aespassword &&
          ((c.aes_mode = this.joinInfo.aesmode),
          WM("ENCRYPT_AES")
            ? ((c.aes_secret = this.joinInfo.aespassword), (c.aes_encrypt = !0))
            : (c.aes_secret = this.joinInfo.aespassword),
          this.joinInfo.aessalt && (c.aes_salt = this.joinInfo.aessalt)),
        t.addresses[this.signal.websocket.currentURLIndex] &&
          ((c.ap_response.ticket =
            t.addresses[this.signal.websocket.currentURLIndex].ticket),
          delete t.addresses),
        void 0 !== this.joinInfo.defaultVideoStream &&
          (c.default_video_stream = this.joinInfo.defaultVideoStream),
        c
      );
    }
    getRejoinMessage() {
      if (!this.joinInfo)
        throw new AU(
          zP.UNEXPECTED_ERROR,
          "can not generate rejoin message, no join info"
        );
      return {
        session_id: this.joinInfo.sid,
        channel_name: this.joinInfo.cname,
        cid: this.joinInfo.cid,
        uid: this.joinInfo.uid,
        vid: Number(this.joinInfo.vid)
      };
    }
    handleSignalEvents() {
      this.signal.on(pG.WS_RECONNECT_CREATE_CONNECTION, e => {
        this.joinGatewayStartTime = Date.now();
      }),
        this.signal.on(pG.WS_RECONNECTING, e => {
          this.joinInfo &&
            yU.WebSocketQuit(this.joinInfo.sid, {
              lts: Date.now(),
              succ: -1,
              cname: this.joinInfo.cname,
              uid: this.joinInfo.uid,
              cid: this.joinInfo.cid,
              errorCode: e || yk.NETWORK_ERROR
            }),
            this.joinInfo &&
              ((this.state = "RECONNECTING"),
              yU.sessionInit(this.joinInfo.sid, {
                lts: new Date().getTime(),
                extend: this.isSignalRecover ? { recover: !0 } : { rejoin: !0 },
                cname: this.joinInfo.cname,
                appid: this.joinInfo.appId,
                mode: this.spec.mode,
                stringUid: this.joinInfo.stringUid,
                channelProfile: "live" === this.spec.mode ? 1 : 0,
                channelMode: 0,
                lsid: this.joinInfo.sid,
                clientRole: "audience" === this.role ? 2 : 1,
                buildFormat: 3
              }),
              (this.isSignalRecover = !1),
              (this.joinGatewayStartTime = Date.now()));
        }),
        this.signal.on(pG.WS_CLOSED, e => {
          let t;
          switch (e) {
            case _k.LEAVE:
              t = yk.LEAVE;
              break;
            case _k.UID_BANNED:
            case _k.IP_BANNED:
            case _k.CHANNEL_BANNED:
            case _k.SERVER_ERROR:
              t = yk.SERVER_ERROR;
              break;
            case _k.FALLBACK:
              t = yk.FALLBACK;
              break;
            case _k.LICENSE_MISSING:
            case _k.LICENSE_EXPIRED:
            case _k.LICENSE_MINUTES_EXCEEDED:
            case _k.LICENSE_PERIOD_INVALID:
            case _k.LICENSE_MULTIPLE_SDK_SERVICE:
            case _k.LICENSE_ILLEGAL:
            case _k.TOKEN_EXPIRE:
              t = e;
              break;
            default:
              t = yk.NETWORK_ERROR;
          }
          EU.debug(
            "["
              .concat(
                this.store.clientId,
                "] [signal] websocket closed, reason: "
              )
              .concat(t || "undefined -> " + yk.NETWORK_ERROR)
          ),
            this.joinInfo &&
              yU.WebSocketQuit(this.joinInfo.sid, {
                lts: Date.now(),
                succ: e === _k.LEAVE ? 1 : -1,
                cname: this.joinInfo.cname,
                uid: this.joinInfo.uid,
                cid: this.joinInfo.cid,
                errorCode: t
              }),
            (this._disconnectedReason = e),
            e !== _k.FALLBACK && (this.state = "DISCONNECTED"),
            this.reset();
        }),
        this.signal.on(pG.WS_CONNECTED, () => {
          if (
            (this.updateTurnConfigFromSignal(),
            (this.state = "CONNECTED"),
            this.joinInfo)
          ) {
            if ("audience" === this.role) {
              const e = WM("CLIENT_ROLE_OPTIONS") || this._clientRoleOptions;
              e &&
                (e.level || e.delay) &&
                (EU.debug(
                  "["
                    .concat(
                      this.store.clientId,
                      "] patch to send set client role, role: "
                    )
                    .concat(this.role, ", mode: ")
                    .concat(this.spec.mode, ", level: ")
                    .concat(e.level, ", delay: ")
                    .concat(e.delay)
                ),
                this.setClientRole(this.role, e));
            }
            if (
              (yU.joinGateway(this.joinInfo.sid, {
                lts: this.joinGatewayStartTime,
                succ: !0,
                ec: null,
                vid: this.joinInfo.vid,
                addr: this.signal.url,
                uid: this.joinInfo.uid,
                cid: this.joinInfo.cid,
                firstSuccess: this._isProactiveJoin,
                avoidJoinStartTime: this.store.avoidJoinStart,
                isProxy: !!this.joinInfo.proxyServer,
                signalChannel: "0",
                preload: this.joinInfo.preload,
                isABTestSuccess: this.store.isABTestSuccess
              }),
              (this._isProactiveJoin = !1),
              this.joinInfo.useLocalAccessPoint &&
                1 === this.joinInfo.setLocalAPVersion)
            ) {
              const e =
                this.signal.url &&
                this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
              if (!e)
                return void EU.error(
                  "["
                    .concat(
                      this.store.clientId,
                      "] set local access point after joined failed: "
                    )
                    .concat(e)
                );
              KM("EVENT_REPORT_DOMAIN", e[1]),
                KM("EVENT_REPORT_BACKUP_DOMAIN", e[1]),
                KM("LOG_UPLOAD_SERVER", "".concat(e[1], ":6444"));
            }
          }
        }),
        this.signal.on(mG.ON_UPLINK_STATS, e => {
          this._statsCollector.updateUplinkStats(e);
        }),
        this.signal.on(pG.REQUEST_RECOVER, (e, t, i) => {
          if (!this.joinInfo)
            return i(
              new AU(
                zP.UNEXPECTED_ERROR,
                "gateway: can not recover, no join info"
              )
            );
          e && ((this.joinInfo.multiIP = e), (this.hasChangeBGPAddress = !0)),
            (this.isSignalRecover = !0),
            Ck(this, CG.REQUEST_NEW_GATEWAY_LIST)
              .then(t)
              .catch(i);
        }),
        this.signal.on(pG.REQUEST_JOIN_INFO, async (e, t, i) => {
          var s;
          if ((this.updateTurnConfigFromSignal(), this.store.useP2P))
            return void e(this.getJoinMessage({ ortc: {} }));
          const r = kk(
            null === (s = this.joinInfo) || void 0 === s ? void 0 : s.turnServer
          );
          if (WM("NEW_TURN_MODE") && r) {
            let e = r.servers,
              t = r.serversFromGateway;
            const i = this.signal.currentURLIndex;
            if (e.length > 0) {
              (e = [e[i % e.length]]), (r.servers = e);
            }
            Array.isArray(t) &&
              t.length > 0 &&
              ((t = [t[0]]), (r.serversFromGateway = t)),
              EU.debug(
                "["
                  .concat(
                    this.store.clientId,
                    "] use single turn, use turn server index: "
                  )
                  .concat(i)
              );
          }
          const {
            iceParameters: n,
            dtlsParameters: a,
            rtpCapabilities: o
          } = await Ck(this, CG.REQUEST_P2P_CONNECTION_PARAMS, {
            turnServer: r
          });
          try {
            e(
              this.getJoinMessage({
                ortc: {
                  iceParameters: n,
                  dtlsParameters: a,
                  rtpCapabilities: o,
                  version: "2"
                }
              })
            );
          } catch (e) {
            t(e);
          }
        }),
        this.signal.on(pG.REQUEST_REJOIN_INFO, e => {
          e(this.getRejoinMessage());
        }),
        this.signal.on(pG.REPORT_JOIN_GATEWAY, (e, t) => {
          if (!this.joinInfo) return;
          let i,
            s = "";
          var r;
          e instanceof AU
            ? ((i =
                (null === (r = e.data) || void 0 === r ? void 0 : r.desc) ||
                e.code),
              (s = e.message))
            : (i = e);
          yU.joinGateway(this.joinInfo.sid, {
            lts: this.joinGatewayStartTime,
            succ: !1,
            ec: i,
            errorMsg: s,
            addr: t,
            uid: this.joinInfo.uid,
            cid: this.joinInfo.cid,
            firstSuccess: this._isProactiveJoin,
            avoidJoinStartTime: this.store.avoidJoinStart,
            isProxy: !!this.joinInfo.proxyServer,
            signalChannel: "0",
            preload: this.joinInfo.preload
          });
        }),
        this.signal.on(pG.IS_P2P_DISCONNECTED, e => {
          e(Dk(this, CG.IS_P2P_DISCONNECTED));
        }),
        this.signal.on(pG.DISCONNECT_P2P, () => {
          this.emit(CG.DISCONNECT_P2P);
        }),
        this.signal.on(pG.REQUEST_SUCCESS, () => {
          this._signalTimeout = !1;
        }),
        this.signal.on(pG.REQUEST_TIMEOUT, () => {
          this._signalTimeout = !0;
        }),
        this.signal.on(pG.JOIN_RESPONSE, e => {
          const t = this.getCurrentGatewayAddress();
          this.emit(CG.JOIN_RESPONSE, e, t);
        }),
        this.signal.on(pG.PRE_CONNECT_PC, async () => {
          if (this.joinInfo) {
            this.updateTurnConfigFromSignal();
            const e = this.getCurrentGatewayAddress(),
              t =
                WM("FINGERPRINT") ||
                this.joinInfo.apResponse.addresses[this.signal.currentURLIndex]
                  .fingerprint;
            if (e && t) {
              const i = Nj(e);
              this.emit(CG.PRE_CONNECT_PC, { candidates: i, fingerprint: t });
            }
          }
        }),
        this.signal.on(pG.RECOVER_NOTIFICATION, e => {
          this.joinInfo &&
            "string" == typeof WM("AP_REQUEST_DETAIL") &&
            (this.joinInfo.apRequestDetail = ""
              .concat(WM("AP_REQUEST_DETAIL"), ";")
              .concat(e));
        });
    }
    async tryUnsubBeforeResub(e, t) {
      try {
        await this.signal.request(
          fG.UNSUBSCRIBE,
          { p2p_id: this.store.p2pId, stream_id: e, ortc: [t] },
          !0
        );
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"),
          e
        ),
        e);
      }
    }
    async tryUnsubDataChannelBeforeResub(e, t) {
      try {
        await this.signal.request(fG.UNSUBSCRIBE, { stream_id: t.id }, !0);
      } catch (e) {
        throw (EU.warning("unsubscribe datachannel warning", e), e);
      }
    }
    async tryUnpubBeforeRepub(e, t) {
      try {
        await this.signal.request(fG.UNPUBLISH, { stream_id: e, ortc: t }, !0);
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "),
          e
        ),
        e);
      }
    }
    async tryUnpubDataChannelBeforeRepub(e, t) {
      try {
        await this.signal.request(
          fG.UNPUBLISH_DATASTREAM,
          { channnel_id: t.channelId },
          !0
        );
      } catch (e) {
        throw (EU.warning("unpublish datastream warning: ", e), e);
      }
    }
    async tryMassUnsubBeforeResub(e) {
      const t = {
        users: e.map(e => ({
          stream_id: e.stream_id,
          stream_type: e.stream_type
        }))
      };
      try {
        await this.signal.request(fG.UNSUBSCRIBE_STREAMS, t, !0);
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"),
          e
        ),
        e);
      }
    }
    async muteLocal(e, t) {
      const i = {
        action: e.find(e => e.stream_type === IG.Audio)
          ? "mute_local_audio"
          : "mute_local_video",
        p2p_id: this.store.p2pId,
        ortc: e,
        stream_id: t
      };
      try {
        await this.signal.request(fG.CONTROL, i, !0, !0);
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] gateway muteLocal warning: "),
          e
        ),
        e);
      }
    }
    async unmuteLocal(e, t) {
      const i = {
        action: e.find(e => e.stream_type === IG.Audio)
          ? "unmute_local_audio"
          : "unmute_local_video",
        p2p_id: this.store.p2pId,
        ortc: e,
        stream_id: t
      };
      try {
        await this.signal.request(fG.CONTROL, i, !0, !0);
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] gateway unmuteLocal warning: "),
          e
        ),
        e);
      }
    }
    async muteRemote(e, t) {
      const i = {
        action: e === xG.AUDIO ? "mute_remote_audio" : "mute_remote_video",
        p2p_id: this.store.p2pId,
        stream_id: t
      };
      try {
        await this.signal.request(fG.CONTROL, i, !0, !0);
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] gateway muteRemote warning: "),
          e
        ),
        e);
      }
    }
    async unmuteRemote(e, t) {
      const i = {
        action: e === xG.AUDIO ? "unmute_remote_audio" : "unmute_remote_video",
        p2p_id: this.store.p2pId,
        stream_id: t
      };
      try {
        await this.signal.request(fG.CONTROL, i, !0, !0);
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] gateway unmuteRemote warning: "),
          e
        ),
        e);
      }
    }
    uploadWRTCStats(e) {
      this.signal.uploadWRTCStats(e);
    }
    upload(e, t) {
      this.signal.upload(e, t);
    }
    getSignalRTT() {
      return this.signal.rtt;
    }
    async restartICE(e) {
      const t = {
        p2p_id: this.store.p2pId,
        stream_id: this.store.uid,
        ortc: e
      };
      try {
        return await this.signal.request(fG.RESTART_ICE, t, !0);
      } catch (e) {
        throw (EU.warning(
          "[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "),
          e
        ),
        e);
      }
    }
    reconnect(e, t) {
      "CONNECTED" === this.state &&
        this.signal.reconnect(e || void 0, t || yk.P2P_FAILED);
    }
    getCurrentGatewayAddress() {
      var e, t;
      if (!WM("GATEWAY_WSS_ADDRESS"))
        return WM("USE_CANDIDATE_FROM_AP_DETAIL") &&
          null !== (e = this.joinInfo) &&
          void 0 !== e &&
          e.apGatewayAddress
          ? (EU.debug(
              "["
                .concat(this.store.clientId, "] use candidate from ap detail, ")
                .concat(JSON.stringify(this.joinInfo.apGatewayAddress))
            ),
            this.joinInfo.apGatewayAddress)
          : null !== (t = this.joinInfo) && void 0 !== t && t.gatewayAddrs
          ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex]
          : void 0;
    }
    async setPublishAudioFilterEnabled(e) {
      await this.signal.request(fG.SET_PARAMETER, {
        enablePublishAudioFilter: e
      });
    }
  }
  let eH = 0,
    tH = 0;
  function iH(e, t, i, s) {
    return new Promise((r, n) => {
      (t.timeout = t.timeout || WM("HTTP_CONNECT_TIMEOUT")),
        (t.responseType = t.responseType || "json"),
        t.data && !i
          ? ((t.data = JSON.stringify(t.data)), (eH += jk(t.data)))
          : i &&
            (t.data.size
              ? (eH += t.data.size)
              : t.data instanceof FormData
              ? (eH += Hk(t.data))
              : (eH += jk(JSON.stringify(t.data)))),
        (t.headers = t.headers || {}),
        (t.headers["Content-Type"] =
          t.headers["Content-Type"] || "application/json"),
        (t.method = "POST"),
        (t.url = e),
        lP
          .request(t)
          .then(e => {
            "string" == typeof e.data
              ? (tH += jk(e.data))
              : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array
              ? (tH += e.data.byteLength)
              : (tH += jk(JSON.stringify(e.data))),
              s && r({ data: e.data, headers: e.headers }),
              r(e.data);
          })
          .catch(e => {
            lP.isCancel(e)
              ? n(new AU(zP.OPERATION_ABORTED, "cancel token canceled"))
              : "ECONNABORTED" === e.code
              ? n(new AU(zP.NETWORK_TIMEOUT, e.message))
              : e.response
              ? n(new AU(zP.NETWORK_RESPONSE_ERROR, e.response.status))
              : n(new AU(zP.NETWORK_ERROR, e.message));
          });
    });
  }
  const sH = () => {
      const e = WM("AREAS");
      0 === e.length && e.push(DG.GLOBAL);
      return e.reduce((e, t, i) => {
        const s = rH(t);
        return s ? (0 === i ? s : "".concat(e, ",").concat(s)) : e;
      }, "");
    },
    rH = e =>
      e === DG.OVERSEA
        ? ""
            .concat(LG.ASIA, ",")
            .concat(LG.EUROPE, ",")
            .concat(LG.AFRICA, ",")
            .concat(LG.NORTH_AMERICA, ",")
            .concat(LG.SOUTH_AMERICA, ",")
            .concat(LG.OCEANIA)
        : LG[e],
    nH = e => {
      const t = {
        CODE: "",
        WEBCS_DOMAIN: [],
        WEBCS_DOMAIN_BACKUP_LIST: [],
        PROXY_CS: [],
        CDS_AP: [],
        ACCOUNT_REGISTER: [],
        UAP_AP: [],
        EVENT_REPORT_DOMAIN: [],
        EVENT_REPORT_BACKUP_DOMAIN: [],
        LOG_UPLOAD_SERVER: [],
        PROXY_SERVER_TYPE3: []
      };
      return (
        e.map(e => {
          const i = NG[e],
            s = Object.keys(i);
          s &&
            s.map(e => {
              "CODE" !== e && (t[e] = t[e].concat(i[e]));
            });
        }),
        t
      );
    },
    aH = {
      GLOBAL: {
        ASIA: [DG.CHINA, DG.JAPAN, DG.INDIA, DG.KOREA, DG.HKMC],
        EUROPE: [],
        NORTH_AMERICA: [DG.US],
        SOUTH_AMERICA: [],
        OCEANIA: [],
        AFRICA: []
      }
    },
    oH = Object.keys(aH[DG.GLOBAL]),
    cH = [
      DG.CHINA,
      DG.NORTH_AMERICA,
      DG.EUROPE,
      DG.ASIA,
      DG.JAPAN,
      DG.INDIA,
      DG.OCEANIA,
      DG.SOUTH_AMERICA,
      DG.AFRICA,
      DG.KOREA,
      DG.HKMC,
      DG.US
    ],
    dH = function(e, t) {
      let i = [];
      if (e.includes(DG.GLOBAL)) {
        const n = [DG.GLOBAL, DG.OVERSEA],
          a = Object.keys(NG);
        if (t === DG.GLOBAL)
          throw new AU(
            zP.INVALID_PARAMS,
            "GLOBAL is an invalid excludedArea value"
          );
        if (t === DG.CHINA) i = [DG.OVERSEA];
        else if (((r = t), oH.includes(r))) {
          const e = ((s = t), aH[DG.GLOBAL][s] || []),
            r = [...n, t, ...e];
          i = a.filter(e => !r.includes(e));
        } else if (
          (function(e) {
            let t = !1;
            return (
              oH.forEach(i => {
                aH[DG.GLOBAL][i].includes(e) && (t = !0);
              }),
              t
            );
          })(t)
        ) {
          const e = (function(e) {
              let t;
              return (
                oH.forEach(i => {
                  aH[DG.GLOBAL][i].includes(e) && (t = i);
                }),
                t
              );
            })(t),
            s = [...n, e, t];
          i = a.filter(e => !s.includes(e));
        } else i = e;
        i = (function(e) {
          const t = [];
          return (
            cH.forEach(i => {
              e.includes(i) && t.push(i);
            }),
            t.concat(e.filter(e => !cH.includes(e)))
          );
        })(i);
      } else i = e;
      var s, r;
      return i;
    };
  function lH(e) {
    if (!e && WM("AREAS").includes(DG.EXTENSIONS))
      return EU.debug("update area from ap : reset"), void hH(KV, !0);
    if (!WM("AREAS").includes(DG.GLOBAL) || !e) return;
    let t = NG.EXTENSIONS;
    t &&
      ((t = {
        CODE: rH(DG.EXTENSIONS),
        WEBCS_DOMAIN: ["ap-web-1-".concat(e, ".agora.io")],
        WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e, ".ap.sd-rtn.com")],
        PROXY_CS: ["proxy-ap-web-".concat(e, ".agora.io")],
        CDS_AP: [
          "cds-ap-web-1-".concat(e, ".agora.io"),
          "cds-ap-web-2-".concat(e, ".ap.sd-rtn.com")
        ],
        ACCOUNT_REGISTER: [
          "sua-ap-web-1-".concat(e, ".agora.io"),
          "sua-ap-web-2-".concat(e, ".ap.sd-rtn.com")
        ],
        UAP_AP: [
          "uap-ap-web-1-".concat(e, ".agora.io"),
          "uap-ap-web-2-".concat(e, ".ap.sd-rtn.com")
        ],
        EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e, ".agora.io")],
        EVENT_REPORT_BACKUP_DOMAIN: [
          "statscollector-2-".concat(e, ".agora.io")
        ],
        LOG_UPLOAD_SERVER: ["logservice-".concat(e, ".agora.io")],
        PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e, ".agora.io")]
      }),
      EU.debug("update area from ap success: ".concat(e, ",config is "), t),
      KM("AREAS", [DG.EXTENSIONS], !0),
      Object.keys(t).map(e => {
        if (
          "LOG_UPLOAD_SERVER" === e ||
          "EVENT_REPORT_DOMAIN" === e ||
          "EVENT_REPORT_BACKUP_DOMAIN" === e ||
          "PROXY_SERVER_TYPE3" === e
        ) {
          KM(e, t[e][0]);
        } else KM(e, t[e]);
      }));
  }
  function hH(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const i = yU.reportApiInvoke(null, {
      name: Ek.SET_AREA,
      options: e,
      tag: mk.TRACER
    });
    try {
      let s = [];
      if (
        ("string" == typeof e && (s = [e]),
        Array.isArray(e) &&
          (e.forEach(e => {
            if (!wG.includes(e))
              throw new AU(zP.INVALID_PARAMS, "invalid area code");
          }),
          (s = e)),
        "[object Object]" === Object.prototype.toString.call(e))
      ) {
        const { areaCode: t, excludedArea: i } = e;
        if (!t) throw new AU(zP.INVALID_PARAMS, "area code is needed");
        let r = t;
        "string" == typeof t && (r = [t]), (s = i ? dH(r, i) : r);
      }
      if (!t) {
        if ($M.AREAS) {
          const e = new AU(
            zP.PROHIBITED_OPERATION,
            "setArea is prohibited because of config-distribute"
          );
          return (
            i.onError(e),
            void EU.warning(
              "setArea is prohibited because of config-distribute"
            )
          );
        }
        if (s.includes(DG.GLOBAL) && WM("AREAS") === DG.EXTENSIONS) {
          const e = new AU(
            zP.PROHIBITED_OPERATION,
            "setArea is prohibited because of ap extensions"
          );
          return (
            i.onError(e),
            void EU.warning("setArea is prohibited because of ap extensions")
          );
        }
      }
      KM("AREAS", s, t);
      const r = nH(s);
      Object.keys(r).map(e => {
        if (
          "LOG_UPLOAD_SERVER" === e ||
          "EVENT_REPORT_DOMAIN" === e ||
          "EVENT_REPORT_BACKUP_DOMAIN" === e ||
          "PROXY_SERVER_TYPE3" === e
        ) {
          KM(e, r[e][0]);
        } else KM(e, r[e]);
      }),
        EU.debug("set area success:", s.join(","));
    } catch (e) {
      throw (i.onError(e), e);
    }
    i.onSuccess();
  }
  let uH = 1;
  function pH(e, t, i, s, r) {
    uH += 1;
    const n = {
        sid: i.sid,
        command: "convergeAllocateEdge",
        uid: "666",
        appId: i.appId,
        ts: Math.floor(Date.now() / 1e3),
        seq: uH,
        requestId: uH,
        version: MM,
        cname: i.cname
      },
      a = { service_name: t, json_body: JSON.stringify(n) };
    let o,
      c,
      d = e[0];
    return oM(
      async () => {
        o = Date.now();
        const e = await iH(d, {
          data: a,
          cancelToken: s,
          headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }
        });
        if (((c = Date.now() - o), 0 !== e.code)) {
          const t = new AU(
            zP.UNEXPECTED_RESPONSE,
            "live streaming ap error, code" + e.code,
            { retry: !0, responseTime: c }
          );
          throw (EU.error(t.toString()), t);
        }
        const i = JSON.parse(e.json_body);
        if (200 !== i.code) {
          const e = new AU(
            zP.UNEXPECTED_RESPONSE,
            "live streaming app center error, code: "
              .concat(i.code, ", reason: ")
              .concat(i.reason),
            { code: i.code, responseTime: c }
          );
          throw (EU.error(e.toString()), e);
        }
        if (!i.servers || 0 === i.servers.length) {
          const e = new AU(
            zP.UNEXPECTED_RESPONSE,
            "live streaming app center empty server",
            { code: i.code, responseTime: c }
          );
          throw (EU.error(e.toString()), e);
        }
        const r = (function(e, t) {
          return {
            addressList: e.servers.map(e =>
              "wss://"
                .concat(e.address.replace(/\./g, "-"), ".")
                .concat(WM("WORKER_DOMAIN"), ":")
                .concat(e.wss, "?serviceName=")
                .concat(encodeURIComponent(t))
            ),
            workerToken: e.workerToken,
            vid: e.vid
          };
        })(i, t);
        return (
          WM("LIVE_STREAMING_ADDRESS") &&
            (r.addressList =
              WM("LIVE_STREAMING_ADDRESS") instanceof Array
                ? WM("LIVE_STREAMING_ADDRESS")
                : [WM("LIVE_STREAMING_ADDRESS")]),
          rG(rG({}, r), {}, { responseTime: c })
        );
      },
      (s, r) => (
        yU.apworkerEvent(i.sid, {
          success: !0,
          sc: 200,
          serviceName: t,
          responseDetail: JSON.stringify(s.addressList),
          firstSuccess: 0 === r,
          responseTime: c,
          serverIp: e[r % e.length]
        }),
        !1
      ),
      (s, r) => (
        yU.apworkerEvent(i.sid, {
          success: !1,
          sc: (s.data && s.data.code) || 200,
          serviceName: t,
          responseTime: c,
          serverIp: e[r % e.length]
        }),
        !!(
          (s.code !== zP.OPERATION_ABORTED &&
            s.code !== zP.UNEXPECTED_RESPONSE) ||
          (s.data && s.data.retry)
        ) && ((d = e[(r + 1) % e.length]), !0)
      ),
      r
    );
  }
  function fH(e, t, i, s) {
    let { url: r, areaCode: n } = e;
    const { clientId: a, sid: o } = t,
      c = Date.now();
    let d;
    const l = t.role,
      [h, u] = TH(t, n, [pj.CHOOSE_SERVER]);
    let p = wk.networkState;
    return oM(
      async () => {
        p &&
          wk.networkState === Ak.OFFLINE &&
          wk.onlineWaiter &&
          (await Promise.race([
            wk.onlineWaiter,
            Wk((s && s.maxRetryTimeout) || nM.maxRetryTimeout)
          ])),
          (p = wk.networkState);
        const { data: e, headers: n } = await iH(
          r,
          {
            data: h,
            cancelToken: i,
            headers: { "Content-Type": "multipart/form-data;" }
          },
          !0,
          !0
        );
        (d = "1" === n.http3 ? 1 : -1),
          yU.reportResourceTiming(r, o),
          mH(e, r, t, c, [pj.CHOOSE_SERVER], d);
        const a = Tj(e, pj.CHOOSE_SERVER);
        return gH(a), Ej(a, r);
      },
      e => (
        e &&
          yU.joinChooseServer(o, {
            role: l,
            lts: c,
            succ: !0,
            csAddr: r,
            opid: u,
            serverList: e.gatewayAddrs.map(e => e.address),
            ec: null,
            cid: e.cid.toString(),
            uid: e.uid.toString(),
            csIp: e.csIp,
            unilbsServerIds: [pj.CHOOSE_SERVER].toString(),
            isHttp3: d,
            corssRegionTagReq: t.apRequestDetail,
            corssRegionTagRes: e.res.detail && e.res.detail[38]
          }),
        !1
      ),
      e =>
        e.code !== zP.OPERATION_ABORTED &&
        (e.code === zP.CAN_NOT_GET_GATEWAY_SERVER
          ? e.data.retry
          : (yU.joinChooseServer(o, {
              role: l,
              lts: c,
              succ: !1,
              csAddr: r,
              serverList: null,
              opid: u,
              ec: e.code,
              csIp: e.data && e.data.csIp,
              unilbsServerIds: [pj.CHOOSE_SERVER].toString(),
              extend: JSON.stringify({ networkState: p }),
              isHttp3: d,
              corssRegionTagReq: t.apRequestDetail
            }),
            EU.warning(
              "[".concat(
                a || "sid-".concat(o.slice(0, 6)),
                "] Choose server network error, retry"
              ),
              e
            ),
            !0)),
      s
    );
  }
  function EH(e, t, i, s) {
    let r,
      { url: n, areaCode: a, serviceIds: o } = e;
    const c = Date.now(),
      d = t.role,
      [l, h] = TH(t, a, o);
    let u;
    return oM(
      async () => {
        u &&
          wk.networkState === Ak.OFFLINE &&
          wk.onlineWaiter &&
          (await Promise.race([
            wk.onlineWaiter,
            Wk((s && s.maxRetryTimeout) || nM.maxRetryTimeout)
          ])),
          (u = wk.networkState);
        const { data: e, headers: a } = await iH(
          n,
          {
            data: l,
            cancelToken: i,
            headers: { "Content-Type": "multipart/form-data;" }
          },
          !0,
          !0
        );
        (r = "1" === a.http3 ? 1 : -1),
          yU.reportResourceTiming(n, t.sid),
          mH(e, n, t, c, o, r);
        const d = Tj(e, pj.CHOOSE_SERVER),
          h = Tj(
            e,
            "proxy5" === t.cloudProxyServer
              ? pj.CLOUD_PROXY_5
              : "proxy3" === t.cloudProxyServer ||
                "proxy4" === t.cloudProxyServer
              ? pj.CLOUD_PROXY
              : pj.CLOUD_PROXY_FALLBACK
          );
        return gH(d), { gatewayInfo: Ej(d, n), proxyInfo: h, url: n };
      },
      e => (
        e.gatewayInfo &&
          yU.joinChooseServer(t.sid, {
            role: d,
            lts: c,
            succ: !0,
            csAddr: n,
            serverList: e.gatewayInfo.gatewayAddrs.map(e => e.address),
            ec: null,
            opid: h,
            cid: e.gatewayInfo.cid.toString(),
            uid: e.gatewayInfo.uid.toString(),
            csIp: e.gatewayInfo.csIp,
            unilbsServerIds: o.toString(),
            isHttp3: r,
            corssRegionTagReq: t.apRequestDetail,
            corssRegionTagRes:
              e.gatewayInfo.res.detail && e.gatewayInfo.res.detail[38]
          }),
        e.proxyInfo &&
          yU.joinWebProxyAP(t.sid, {
            lts: c,
            sucess: 1,
            apServerAddr: n,
            turnServerAddrList: e.proxyInfo.addresses.map(e => e.ip).join(","),
            errorCode: null,
            eventType: t.cloudProxyServer,
            unilbsServerIds: o.toString()
          }),
        !1
      ),
      e =>
        e.code !== zP.OPERATION_ABORTED &&
        (e.code === zP.CAN_NOT_GET_GATEWAY_SERVER
          ? e.data.retry
          : (yU.joinWebProxyAP(t.sid, {
              lts: c,
              sucess: 0,
              apServerAddr: n,
              turnServerAddrList: null,
              errorCode: e.code,
              eventType: t.cloudProxyServer,
              unilbsServerIds: o.toString(),
              extend: JSON.stringify({ networkState: u })
            }),
            EU.warning(
              "[".concat(t.clientId, "] multi unilbs network error, retry"),
              e
            ),
            !0)),
      s
    );
  }
  const mH = (e, t, i, s, r, n) => {
      const { sid: a, clientId: o, cloudProxyServer: c } = i,
        d = [],
        l = o => {
          4096 === o.flag
            ? yU.joinChooseServer(a, {
                role: i.role,
                lts: s,
                succ: !1,
                csAddr: t,
                opid: e.opid,
                serverList: null,
                ec: o.error.message,
                csIp: o.error.data && o.error.data.csIp,
                unilbsServerIds: r.toString(),
                isHttp3: n,
                corssRegionTagReq: i.apRequestDetail
              })
            : (1048576 !== o.flag &&
                4194304 !== o.flag &&
                4194310 !== o.flag) ||
              yU.joinWebProxyAP(a, {
                lts: s,
                sucess: 0,
                apServerAddr: t,
                turnServerAddrList: null,
                errorCode: o.error.code,
                eventType: c,
                unilbsServerIds: r.toString()
              });
        };
      if (
        (e.response_body.forEach(t => {
          const i = t.buffer.code;
          if (23 === t.uri && 0 === i && !t.buffer.edges_services)
            if (4194310 === t.buffer.flag)
              EU.warning(
                "no edge services in ap response of proxy fallback, will not set proxy in iceServers"
              ),
                (t.buffer.edges_services = []);
            else {
              const i = {
                error: new AU(
                  zP.CAN_NOT_GET_GATEWAY_SERVER,
                  "no edge services in ap response",
                  { retry: !0, csIp: e.detail[502] }
                ),
                flag: t.buffer.flag
              };
              d.push(i), l(i);
            }
          if (0 !== i) {
            const s = ZG(i),
              r = {
                error: new AU(zP.CAN_NOT_GET_GATEWAY_SERVER, s.desc, {
                  desc: s.desc,
                  retry: s.retry,
                  csIp: e.detail[502]
                }),
                flag: t.buffer.flag
              };
            4194310 === t.buffer.flag
              ? EU.warning(r.error.toString())
              : d.push(r),
              l(r);
          }
        }),
        d.length)
      )
        throw (EU.warning(
          "["
            .concat(o || "sid-".concat(a.slice(0, 6)), "] multi unilbs ")
            .concat(t, " failed, ")
            .concat(
              d
                .map(e =>
                  "flag: "
                    .concat(e.flag, ", message: ")
                    .concat(e.error.message, ", retry: ")
                    .concat(e.error.data.retry)
                )
                .join(" | ")
            )
        ),
        new AU(
          zP.CAN_NOT_GET_GATEWAY_SERVER,
          d
            .map(e =>
              "flag: ".concat(e.flag, ", message: ").concat(e.error.message)
            )
            .join(" | "),
          {
            retry: !!d.find(e => e.error.data.retry),
            csIp: e.detail[502],
            desc: [
              ...new Set(
                d
                  .map(e => {
                    var t;
                    return null == e ||
                      null === (t = e.error) ||
                      void 0 === t ||
                      null === (t = t.data) ||
                      void 0 === t
                      ? void 0
                      : t.desc;
                  })
                  .filter(e => !!e)
              )
            ]
          }
        ));
    },
    gH = e => {
      var t, i, s, r;
      if (e.addresses && 0 === e.addresses.length && 0 === e.code)
        throw new AU(zP.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", {
          retry: !0,
          csIp: e.detail && e.detail[502]
        });
      WM("AP_AREA") &&
        (null !== (s = e.detail) &&
        void 0 !== s &&
        s[23] &&
        "string" ==
          typeof (null === (r = e.detail) || void 0 === r ? void 0 : r[23])
          ? lH(e.detail[23].toLowerCase())
          : lH());
      if (
        null !== (t = e.detail) &&
        void 0 !== t &&
        t[19] &&
        "string" ==
          typeof (null === (i = e.detail) || void 0 === i ? void 0 : i[19])
      ) {
        const t = e.detail[19],
          i = null == t ? void 0 : t.split(";");
        for (let t = 0; t < i.length; t++) {
          const s = i[t].trim();
          e.addresses[t] && i && (e.addresses[t].fingerprint = s);
        }
      }
      if (WM("GATEWAY_ADDRESS") && WM("GATEWAY_ADDRESS").length > 0) {
        EU.debug("assign gateway address to", WM("GATEWAY_ADDRESS"));
        const t = WM("GATEWAY_ADDRESS").map(t => {
          var i, s;
          const r =
            null !==
              (i =
                null ===
                  (s = e.addresses.find(
                    e => e.ip === t.ip && e.port === t.port
                  )) || void 0 === s
                  ? void 0
                  : s.fingerprint) && void 0 !== i
              ? i
              : "";
          return {
            ip: t.ip,
            port: t.port,
            ticket: e.addresses[0] && e.addresses[0].ticket,
            fingerprint: r
          };
        });
        e.addresses = t;
      }
    },
    _H = (e, t) => {
      if (e.response_body && e.response_body.length) {
        const t = e.response_body[0];
        if (0 !== t.buffer.code) {
          const e = ZG(t.buffer.code);
          throw new AU(
            zP.UPDATE_TICKET_FAILED,
            "[".concat(t.buffer.code, "]: ").concat(e.desc),
            { retry: e.retry }
          );
        }
        return t.buffer.ticket;
      }
      throw (EU.debug(
        "update ticket request received ap response without response body:",
        t
      ),
      new AU(
        zP.UPDATE_TICKET_FAILED,
        "cannot find response body from ap response",
        { retry: !1 }
      ));
    },
    TH = (e, t, i) => {
      const s = Math.floor(Math.random() * 10 ** 12),
        r = "host" === e.role ? "1" : "audience" === e.role ? "2" : void 0,
        n = {
          appid: e.appId,
          client_ts: Date.now(),
          opid: s,
          sid: e.sid,
          request_bodies: [
            {
              uri: 22,
              buffer: {
                cname: e.cname,
                detail: rG(
                  rG(
                    rG(
                      {
                        6: e.stringUid,
                        11: t,
                        12: WM("USE_NEW_TOKEN") ? "1" : void 0
                      },
                      r ? { 17: r } : {}
                    ),
                    {},
                    { 22: t },
                    e.apRequestDetail ? { 33: e.apRequestDetail } : {}
                  ),
                  e.apRTM ? { 26: "RTM2" } : {}
                ),
                key: e.token,
                service_ids: i,
                uid: e.uid || 0
              }
            }
          ]
        };
      n.request_bodies.forEach(t => {
        e.multiIP &&
          e.multiIP.gateway_ip &&
          (t.buffer.detail[5] = JSON.stringify({
            vocs_ip: [e.multiIP.uni_lbs_ip],
            vos_ip: [e.multiIP.gateway_ip]
          }));
      });
      const a = new FormData();
      return a.append("request", JSON.stringify(n)), [a, s];
    },
    SH = (e, t) => {
      const i = Math.floor(Math.random() * 10 ** 12),
        s = {
          appid: e.appId,
          client_ts: Date.now(),
          opid: i,
          sid: e.sid,
          request_bodies: [
            {
              uri: 28,
              buffer: {
                cname: e.cname,
                detail: { 1: "", 6: e.stringUid, 12: "1" },
                token: e.token,
                service_ids: t,
                uid: e.uid || 0,
                edges_services: e.apResponse.addresses.map(e => ({
                  ip: e.ip,
                  port: e.port
                }))
              }
            }
          ]
        },
        r = new FormData();
      return r.append("request", JSON.stringify(s)), [r, i];
    };
  function vH(e) {
    return Promise.all(
      e.map(e =>
        e.then(
          e => {
            throw e;
          },
          e => e
        )
      )
    ).then(
      e => {
        throw e;
      },
      e => e
    );
  }
  const RH = async e => {
      let {
          fragementLength: t,
          referenceList: i,
          asyncMapHandler: s,
          allFailedhandler: r,
          promisesCollector: n
        } = e,
        a = 0;
      const o = t;
      let c,
        d = 0;
      const l = async () => {
        const e = (() => {
          const e = a * o,
            t = e + o;
          return i.slice(e, t).map(s);
        })();
        n && n.push(...e);
        try {
          c = await vH(e);
        } catch (e) {
          if (((d += o), a++, !(d >= i.length))) return void (await l());
          r(e);
        }
        e.forEach(e => e.cancel());
      };
      return await l(), c;
    },
    yH = async e => {
      let { referenceList: t, asyncMapHandler: i, closeFn: s } = e;
      const r = t.length;
      let n = 0;
      const a = async () => {
        const e = i(t.shift());
        try {
          return await e;
        } catch (e) {
          if ((n++, n >= r || (null != s && s(e)))) throw e;
          return a();
        }
      };
      return a();
    };
  async function AH(e, t, i, s) {
    const r = (async function(e, t, i, s) {
      let r = null;
      const n = [],
        a = async () => {
          const r = WM("WEBCS_DOMAIN")
              .slice(0, WM("AJAX_REQUEST_CONCURRENT"))
              .map(t => ({
                url: e.proxyServer
                  ? "https://"
                      .concat(e.proxyServer, "/ap/?url=")
                      .concat(t + "/api/v2/transpond/webrtc?v=2")
                  : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"),
                areaCode: sH()
              })),
            a = s.recordJoinChannelService({
              startTs: Date.now(),
              status: "pending",
              service: "chooseServer",
              urls: r.map(e => e.url)
            }),
            o = await RH({
              fragementLength: WM("FRAGEMENT_LENGTH"),
              referenceList: r,
              asyncMapHandler: s => (
                EU.debug(
                  "[".concat(e.clientId, "] Connect to choose_server:"),
                  s.url
                ),
                fH(s, e, t, i)
              ),
              allFailedhandler: e => {
                throw (s.recordJoinChannelService(
                  { endTs: Date.now(), status: "error", errors: e },
                  a
                ),
                e[0]);
              },
              promisesCollector: n
            });
          return (
            s.recordJoinChannelService(
              { endTs: Date.now(), status: "success" },
              a
            ),
            o
          );
        },
        o = async () => {
          if ((await Wk(1e3), null !== r)) return r;
          const a = WM("WEBCS_DOMAIN_BACKUP_LIST").map(t => ({
              url: e.proxyServer
                ? "https://"
                    .concat(e.proxyServer, "/ap/?url=")
                    .concat(t + "/api/v2/transpond/webrtc?v=2")
                : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"),
              areaCode: sH()
            })),
            o = s.recordJoinChannelService({
              endTs: void 0,
              startTs: Date.now(),
              status: "pending",
              service: "chooseServer",
              urls: a.map(e => e.url)
            }),
            c = await RH({
              fragementLength: WM("FRAGEMENT_LENGTH"),
              referenceList: a,
              asyncMapHandler: s => (
                EU.debug(
                  "[".concat(e.clientId, "] Connect to backup choose_server:"),
                  s.url
                ),
                fH(s, e, t, i)
              ),
              allFailedhandler: e => {
                throw (s.recordJoinChannelService(
                  { endTs: Date.now(), status: "error", errors: e },
                  o
                ),
                e[0]);
              },
              promisesCollector: n
            });
          return (
            s.recordJoinChannelService(
              { endTs: Date.now(), status: "success" },
              o
            ),
            c
          );
        };
      try {
        return (
          (r = await vH([a(), o()])),
          n.length &&
            n.forEach(
              e => e.cancel && "function" == typeof e.cancel && e.cancel()
            ),
          r
        );
      } catch (e) {
        throw e[0];
      }
    })(e, t, i, s);
    return { gatewayInfo: await r };
  }
  async function IH(e, t, i, s, r) {
    const n = e.cloudProxyServer;
    if ("disabled" === n) {
      if (!s) return;
      if (e.useLocalAccessPoint) return await AH(e, t, i, r);
      if (WM("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
        const { gatewayInfo: s, proxyInfo: n } = await wH(e, t, i, r);
        if (e.turnServer && "auto" !== e.turnServer.mode)
          return { gatewayInfo: s };
        const o = n.map(e => ({
          turnServerURL: e.address,
          tcpport: e.tcpport || FM.tcpport,
          udpport: e.udpport || FM.udpport,
          username: e.username || FM.username,
          password: e.password || FM.password,
          forceturn: !1,
          security: !0
        }));
        if (r.useP2P) {
          var a;
          const t = null !== (a = e.uid) && void 0 !== a ? a : s.uid,
            i = "glb:".concat(t.toString()),
            r = await hk(i),
            c = n.map(e => ({
              turnServerURL: e.address,
              tcpport: e.tcpport || FM.tcpport,
              udpport: e.udpport || FM.udpport,
              username: i,
              password: r,
              forceturn: !1,
              security: !0
            }));
          o.push(...c);
        }
        return (
          (e.turnServer = { mode: "manual", servers: o }), { gatewayInfo: s }
        );
      }
      return await AH(e, t, i, r);
    }
    const { proxyInfo: o, gatewayInfo: c } = await wH(e, t, i, r),
      d = { gatewayInfo: c },
      l = o.map(e => ({
        turnServerURL: e.address,
        tcpport: "proxy3" === n ? void 0 : e.tcpport ? e.tcpport : FM.tcpport,
        udpport: "proxy4" === n ? void 0 : e.udpport ? e.udpport : FM.udpport,
        username: e.username || FM.username,
        password: e.password || FM.password,
        forceturn: "proxy4" !== n,
        security: "proxy5" === n
      }));
    if (r.useP2P) {
      var h;
      const t = null !== (h = e.uid) && void 0 !== h ? h : c.uid,
        i = "glb:".concat(t.toString()),
        s = await hk(i),
        r = o.map(e => ({
          turnServerURL: e.address,
          tcpport: "proxy3" === n ? void 0 : e.tcpport || FM.tcpport,
          udpport: "proxy4" === n ? void 0 : e.udpport || FM.udpport,
          username: i,
          password: s,
          forceturn: "proxy4" !== n,
          security: "proxy5" === n
        }));
      l.push(...r);
    }
    return (
      (e.turnServer = { mode: "manual", servers: l }),
      EU.debug(
        "["
          .concat(e.clientId, "] set proxy server: ")
          .concat(e.proxyServer, ", mode: ")
          .concat(n)
      ),
      d
    );
  }
  async function CH(e, t, i, s, r) {
    const n = WM("ACCOUNT_REGISTER").slice(0, WM("AJAX_REQUEST_CONCURRENT"));
    let a = [];
    a = t.proxyServer
      ? n.map(e =>
          "https://".concat(t.proxyServer, "/ap/?url=").concat(e + "/api/v1")
        )
      : n.map(e => "https://".concat(e, "/api/v1"));
    const o =
      null == r
        ? void 0
        : r.recordJoinChannelService({
            startTs: Date.now(),
            status: "pending",
            service: "stringUID",
            urls: a
          });
    try {
      const n = await (async function(e, t, i, s, r) {
        const n = Date.now(),
          a = { sid: i.sid, opid: 10, appid: i.appId, string_uid: t };
        let o = e[0];
        const c = await oM(
          () =>
            iH(
              o +
                "".concat(
                  -1 === o.indexOf("?") ? "?" : "&",
                  "action=stringuid"
                ),
              {
                data: a,
                cancelToken: s,
                headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 }
              }
            ),
          (i, s) => {
            if (0 === i.code) {
              if (i.uid <= 0 || i.uid >= Math.pow(2, 32))
                throw (EU.error(
                  "Invalid Uint Uid ".concat(t, " => ").concat(i.uid),
                  i
                ),
                yU.reqUserAccount(a.sid, {
                  lts: n,
                  success: !1,
                  serverAddr: o,
                  stringUid: a.string_uid,
                  uid: i.uid,
                  errorCode: zP.INVALID_UINT_UID_FROM_STRING_UID,
                  extend: a
                }),
                new AU(zP.INVALID_UINT_UID_FROM_STRING_UID));
              return (
                yU.reqUserAccount(a.sid, {
                  lts: n,
                  success: !0,
                  serverAddr: o,
                  stringUid: a.string_uid,
                  uid: i.uid,
                  errorCode: null,
                  extend: a
                }),
                !1
              );
            }
            const r = ZG(i.code);
            return (
              r.retry && (o = e[(s + 1) % e.length]),
              yU.reqUserAccount(a.sid, {
                lts: n,
                success: !1,
                serverAddr: o,
                stringUid: a.string_uid,
                uid: i.uid,
                errorCode: r.desc,
                extend: a
              }),
              r.retry
            );
          },
          (t, i) =>
            t.code !== zP.OPERATION_ABORTED &&
            (yU.reqUserAccount(a.sid, {
              lts: n,
              success: !1,
              serverAddr: o,
              stringUid: a.string_uid,
              uid: null,
              errorCode: t.code,
              extend: a
            }),
            (o = e[(i + 1) % e.length]),
            !0),
          r
        );
        if (0 !== c.code) {
          const e = ZG(c.code);
          throw new AU(zP.UNEXPECTED_RESPONSE, e.desc);
        }
        return c;
      })(a, e, t, i, s);
      return (
        null == r ||
          r.recordJoinChannelService(
            { status: "success", endTs: Date.now() },
            o
          ),
        n.uid
      );
    } catch (e) {
      throw (null == r ||
        r.recordJoinChannelService(
          { status: "error", endTs: Date.now(), errors: [e] },
          o
        ),
      e);
    }
  }
  async function bH(e, t, i) {
    const s = WM("ACCOUNT_REGISTER");
    let r = [];
    r = t.proxyServer
      ? s.map(e =>
          "https://".concat(t.proxyServer, "/ap/?url=").concat(e + "/api/v1")
        )
      : s.map(e => "https://".concat(e, "/api/v1"));
    try {
      const s = await yH({
        referenceList: r,
        asyncMapHandler: s =>
          (async function(e, t, i, s) {
            const r = Date.now(),
              n = { sid: i.sid, opid: 10, appid: i.appId, string_uid: t };
            try {
              const t = await iH(
                e +
                  "".concat(
                    -1 === e.indexOf("?") ? "?" : "&",
                    "action=stringuid"
                  ),
                {
                  data: n,
                  cancelToken: s,
                  headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 }
                }
              );
              if (0 !== t.code) {
                const e = ZG(t.code);
                throw new AU(
                  zP.UNEXPECTED_RESPONSE,
                  "preload sua error:".concat(e.desc),
                  e
                );
              }
              if (t.uid <= 0 || t.uid >= Math.pow(2, 32))
                throw new AU(zP.INVALID_UINT_UID_FROM_STRING_UID);
              return {
                requestTime: r,
                url: e,
                req: n,
                uid: t.uid,
                elapse: Date.now() - r
              };
            } catch (e) {
              throw e;
            }
          })(s, e, t, i),
        closeFn: e =>
          e.code === zP.OPERATION_ABORTED ||
          (e.code === zP.UNEXPECTED_RESPONSE && !e.data.retry)
      });
      return s;
    } catch (e) {
      throw e;
    }
  }
  async function OH(e, t, i) {
    const s = WM("CDS_AP")
        .slice(0, WM("AJAX_REQUEST_CONCURRENT"))
        .map(t =>
          e.proxyServer
            ? "https://"
                .concat(e.proxyServer, "/ap/?url=")
                .concat(t + "/api/v1")
            : "https://".concat(t, "/api/v1?action=config")
        ),
      r = s.map(s =>
        (function(e, t, i, s) {
          const r = vP(),
            n = {
              flag: 64,
              cipher_method: 0,
              features: rG(
                rG(
                  rG(
                    rG(
                      rG(
                        {
                          install_id: kM(),
                          device: r.name,
                          system: r.os,
                          system_general: navigator.userAgent,
                          vendor: t.appId,
                          version: MM,
                          cname: t.cname,
                          session_id: t.sid,
                          proxyServer: t.proxyServer,
                          sdk_type: uj.WEB_RTC,
                          browser_name: r.name,
                          browser_version: r.version,
                          user_agent: navigator.userAgent,
                          channel_name: t.cname
                        },
                        t.stringUid && { string_uid: t.stringUid }
                      ),
                      t.uid && { uid: t.uid + "" }
                    ),
                    r.os && { os_name: r.os }
                  ),
                  r.osVersion && { os_version: r.osVersion }
                ),
                {},
                { detail: "" }
              )
            };
          return oM(
            () =>
              iH(e, {
                data: n,
                timeout: 1e3,
                cancelToken: i,
                headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 }
              }),
            void 0,
            e => e.code !== zP.OPERATION_ABORTED,
            s
          );
        })(s, e, t, i)
      );
    let n = null,
      a = null,
      o = {};
    try {
      n = await vH(r);
    } catch (e) {
      if (e.code === zP.OPERATION_ABORTED) throw e;
      a = e;
    }
    r.forEach(e => e.cancel());
    if (
      (yU
        .reportApiInvoke(e.sid, {
          name: Ek.REQUEST_CONFIG_DISTRIBUTE,
          options: { error: a, res: n }
        })
        .onSuccess(),
      n && n.test_tags)
    )
      try {
        o = (function(e) {
          if (!e.test_tags) return {};
          const t = e.test_tags,
            i = Object.keys(t),
            s = {};
          return (
            i.forEach(e => {
              const i = e.slice(4).trim(),
                r = JSON.parse(t[e]),
                n = r[1];
              s[i] = { tag: r[0] || "", value: n };
            }),
            s
          );
        })(n);
      } catch (e) {}
    return o;
  }
  async function DH(e, t) {
    const i = WM("WEBCS_DOMAIN")
      .concat(WM("WEBCS_DOMAIN_BACKUP_LIST"))
      .map(e => ({
        url: "https://".concat(e, "/api/v2/transpond/webrtc?v=2"),
        areaCode: sH(),
        serviceIds: [pj.CHOOSE_SERVER, pj.CLOUD_PROXY_FALLBACK]
      }));
    try {
      const s = await yH({
        referenceList: i,
        asyncMapHandler: i =>
          (async function(e, t, i) {
            let s,
              { url: r, areaCode: n, serviceIds: a } = e;
            const o = Date.now(),
              [c, d] = TH(t, n, a);
            let l = wk.networkState;
            try {
              l &&
                wk.networkState === Ak.OFFLINE &&
                wk.onlineWaiter &&
                (await Promise.race([wk.onlineWaiter, Wk(nM.maxRetryTimeout)])),
                (l = wk.networkState);
              const { data: e, headers: t } = await iH(
                r,
                {
                  data: c,
                  cancelToken: i,
                  headers: { "Content-Type": "multipart/form-data;" }
                },
                !0,
                !0
              );
              s = "1" === t.http3 ? 1 : -1;
              const n = e => {
                const t = [];
                if (
                  (e.response_body.forEach(i => {
                    const s = i.buffer.code;
                    if (23 === i.uri && 0 === s && !i.buffer.edges_services)
                      if (4194310 === i.buffer.flag)
                        i.buffer.edges_services = [];
                      else {
                        const s = {
                          error: new AU(
                            zP.CAN_NOT_GET_GATEWAY_SERVER,
                            "no edge services in ap response",
                            { retry: !0, csIp: e.detail[502] }
                          ),
                          flag: i.buffer.flag
                        };
                        t.push(s);
                      }
                    if (0 !== s) {
                      const r = ZG(s),
                        n = {
                          error: new AU(zP.CAN_NOT_GET_GATEWAY_SERVER, r.desc, {
                            desc: r.desc,
                            retry: r.retry,
                            csIp: e.detail[502]
                          }),
                          flag: i.buffer.flag
                        };
                      4194310 === i.buffer.flag
                        ? EU.warning(n.error.toString())
                        : t.push(n);
                    }
                  }),
                  t.length)
                )
                  throw new AU(
                    zP.CAN_NOT_GET_GATEWAY_SERVER,
                    t
                      .map(e =>
                        "flag: "
                          .concat(e.flag, ", message: ")
                          .concat(e.error.message)
                      )
                      .join(" | "),
                    {
                      retry: !!t.find(e => e.error.data.retry),
                      csIp: e.detail[502],
                      desc: [
                        ...new Set(
                          t
                            .map(e => {
                              var t;
                              return null == e ||
                                null === (t = e.error) ||
                                void 0 === t ||
                                null === (t = t.data) ||
                                void 0 === t
                                ? void 0
                                : t.desc;
                            })
                            .filter(e => !!e)
                        )
                      ]
                    }
                  );
              };
              n(e);
              const a = Tj(e, pj.CHOOSE_SERVER),
                h = Tj(e, pj.CLOUD_PROXY_FALLBACK);
              return (
                gH(a),
                {
                  gatewayInfo: Ej(a, r),
                  proxyInfo: h,
                  opid: d,
                  requestTime: o,
                  url: r,
                  isHttp3: s,
                  elapse: Date.now() - o
                }
              );
            } catch (e) {
              throw e;
            }
          })(i, e, t),
        closeFn: e =>
          e.code === zP.OPERATION_ABORTED ||
          (e.code === zP.CAN_NOT_GET_GATEWAY_SERVER && !e.data.retry)
      });
      return s;
    } catch (e) {
      throw e;
    }
  }
  async function wH(e, t, i, s) {
    const r = WM("PROXY_SERVER_TYPE3"),
      n = (e, t, i) => {
        let s = i || r;
        return (
          Array.isArray(s) && (s = t % 2 == 0 ? r[1] : r[0]),
          "https://".concat(s, "/ap/?url=").concat(e)
        );
      };
    let a = null;
    const o = [],
      c = async () => {
        const r = WM("WEBCS_DOMAIN")
            .slice(0, WM("AJAX_REQUEST_CONCURRENT"))
            .map((t, i) => {
              let s;
              return (
                (s =
                  "disabled" === e.cloudProxyServer && e.proxyServer
                    ? n(
                        "".concat(t, "/api/v2/transpond/webrtc?v=2"),
                        i,
                        e.proxyServer
                      )
                    : "disabled" === e.cloudProxyServer ||
                      "fallback" === e.cloudProxyServer
                    ? "https://".concat(t, "/api/v2/transpond/webrtc?v=2")
                    : n("".concat(t, "/api/v2/transpond/webrtc?v=2"), i)),
                {
                  url: s,
                  areaCode: sH(),
                  serviceIds: [
                    pj.CHOOSE_SERVER,
                    "proxy5" === e.cloudProxyServer
                      ? pj.CLOUD_PROXY_5
                      : "proxy3" === e.cloudProxyServer ||
                        "proxy4" === e.cloudProxyServer
                      ? pj.CLOUD_PROXY
                      : pj.CLOUD_PROXY_FALLBACK
                  ]
                }
              );
            }),
          a = s.recordJoinChannelService({
            startTs: Date.now(),
            status: "pending",
            service: "chooseServer",
            urls: r.map(e => e.url)
          }),
          c = await RH({
            fragementLength: WM("FRAGEMENT_LENGTH"),
            referenceList: r,
            asyncMapHandler: s => (
              EU.debug(
                "[".concat(e.clientId, "] Connect to choose_server:"),
                s.url
              ),
              EH(s, e, t, i)
            ),
            allFailedhandler: e => {
              throw (s.recordJoinChannelService(
                { endTs: Date.now(), status: "error", errors: e },
                a
              ),
              e[0]);
            },
            promisesCollector: o
          });
        return (
          s.recordJoinChannelService(
            { endTs: Date.now(), status: "success" },
            a
          ),
          c
        );
      },
      d = async () => {
        if ((await Wk(1e3), null !== a)) return a;
        const r = WM("WEBCS_DOMAIN_BACKUP_LIST").map((t, i) => {
            let s;
            return (
              (s =
                "disabled" === e.cloudProxyServer && e.proxyServer
                  ? n(
                      "".concat(t, "/api/v2/transpond/webrtc?v=2"),
                      i,
                      e.proxyServer
                    )
                  : "disabled" === e.cloudProxyServer ||
                    "fallback" === e.cloudProxyServer
                  ? "https://".concat(t, "/api/v2/transpond/webrtc?v=2")
                  : n("".concat(t, "/api/v2/transpond/webrtc?v=2"), i)),
              {
                url: s,
                areaCode: sH(),
                serviceIds: [
                  pj.CHOOSE_SERVER,
                  "proxy5" === e.cloudProxyServer
                    ? pj.CLOUD_PROXY_5
                    : "proxy3" === e.cloudProxyServer ||
                      "proxy4" === e.cloudProxyServer
                    ? pj.CLOUD_PROXY
                    : pj.CLOUD_PROXY_FALLBACK
                ]
              }
            );
          }),
          c = s.recordJoinChannelService({
            startTs: Date.now(),
            status: "pending",
            service: "chooseServer",
            urls: r.map(e => e.url)
          }),
          d = await RH({
            fragementLength: WM("FRAGEMENT_LENGTH"),
            referenceList: r,
            asyncMapHandler: s => (
              EU.debug(
                "[".concat(e.clientId, "] Connect to backup choose_server:"),
                s.url
              ),
              EH(s, e, t, i)
            ),
            allFailedhandler: e => {
              throw (s.recordJoinChannelService(
                { endTs: Date.now(), status: "error", errors: e },
                c
              ),
              e[0]);
            },
            promisesCollector: o
          });
        return (
          s.recordJoinChannelService(
            { endTs: Date.now(), status: "success" },
            c
          ),
          d
        );
      };
    let l, h, u;
    try {
      ({ gatewayInfo: l, proxyInfo: h, url: u } = await vH([c(), d()]));
    } catch (e) {
      throw e[0];
    }
    if (
      (o.length &&
        o.forEach(e => e.cancel && "function" == typeof e.cancel && e.cancel()),
      !l || !h)
    )
      throw new AU(
        zP.UNEXPECTED_ERROR,
        "missing gateway or proxy response"
      ).print();
    if (
      ((e.apUrl = u),
      "disabled" !== e.cloudProxyServer && Array.isArray(r) && u)
    ) {
      const t = /^https?:\/\/(.+?)(\/.*)?$/.exec(u)[1];
      r.includes(t) &&
        ((e.proxyServer = t), EU.setProxyServer(t), yU.setProxyServer(t));
    }
    return (a = { gatewayInfo: l, proxyInfo: await Sj(h, l.uid) }), a;
  }
  async function LH(e, t, i) {
    let s = null;
    const r = [],
      n = async n => {
        const a = WM(n ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map(t =>
          e.proxyServer
            ? "https://"
                .concat(e.proxyServer, "/ap/?url=")
                .concat(t + "/api/v2/transpond/webrtc?v=2")
            : "https://".concat(t, "/api/v2/transpond/webrtc?v=2")
        );
        return n && (await Wk(1e3), null !== s)
          ? s
          : await RH({
              fragementLength: WM("FRAGEMENT_LENGTH"),
              referenceList: a,
              asyncMapHandler: s => (
                EU.debug(
                  "["
                    .concat(e.clientId, "] update ticket, Connect to ")
                    .concat(n ? "backup" : "", " choose_server:"),
                  s
                ),
                (function(e, t, i, s) {
                  const [r] = SH(t, [pj.CHOOSE_SERVER]);
                  let n = wk.networkState;
                  return oM(
                    async () => {
                      n &&
                        wk.networkState === Ak.OFFLINE &&
                        wk.onlineWaiter &&
                        (await Promise.race([
                          wk.onlineWaiter,
                          Wk((s && s.maxRetryTimeout) || nM.maxRetryTimeout)
                        ])),
                        (n = wk.networkState);
                      const t = await iH(
                        e,
                        {
                          data: r,
                          cancelToken: i,
                          headers: { "Content-Type": "multipart/form-data;" }
                        },
                        !0
                      );
                      return _H(t, e);
                    },
                    () => !1,
                    e =>
                      e.code !== zP.OPERATION_ABORTED &&
                      (e.code === zP.UPDATE_TICKET_FAILED
                        ? e.data.retry
                        : (EU.warning(
                            "[".concat(
                              t.clientId,
                              "] update ticket network error, retry"
                            ),
                            e
                          ),
                          !0)),
                    s
                  );
                })(s, e, t, i)
              ),
              allFailedhandler: e => {
                throw e[0];
              },
              promisesCollector: r
            });
      };
    try {
      return (
        (s = await vH([n(!1), n(!0)])),
        r.length &&
          r.forEach(
            e => e.cancel && "function" == typeof e.cancel && e.cancel()
          ),
        s
      );
    } catch (e) {
      throw e[0];
    }
  }
  class NH extends uk {
    get isSuccess() {
      return !!this.configs;
    }
    constructor(e, t) {
      super(),
        (this.configs = void 0),
        (this.store = void 0),
        (this.joinInfo = void 0),
        (this.cancelToken = void 0),
        (this.retryConfig = {
          timeout: 3e3,
          timeoutFactor: 1.5,
          maxRetryCount: 1,
          maxRetryTimeout: 1e4
        }),
        (this.interval = void 0),
        (this.mutex = void 0),
        (this.mutableParamsRead = !1),
        (this.configCache = {}),
        (this.limit_bitrate = void 0),
        (this.mutex = new sM("config-distribute", e)),
        (this.store = t);
    }
    startGetConfigDistribute(e, t) {
      (this.joinInfo = e),
        (this.cancelToken = t),
        this.interval && this.stopGetConfigDistribute(),
        WM("ENABLE_CONFIG_DISTRIBUTE") &&
          (this.updateConfigDistribute(),
          (this.interval = window.setInterval(() => {
            this.updateConfigDistribute();
          }, WM("CONFIG_DISTRIBUTE_INTERVAL"))));
    }
    stopGetConfigDistribute() {
      this.interval && clearInterval(this.interval),
        (this.interval = void 0),
        (this.joinInfo = void 0),
        (this.cancelToken = void 0),
        (this.configs = void 0),
        (this.limit_bitrate = void 0);
    }
    async awaitConfigDistributeComplete() {
      if (!this.mutex.isLocked) return;
      (await this.mutex.lock())();
    }
    async updateConfigDistribute() {
      if (!this.mutableParamsRead) {
        this.mutableParamsRead = !0;
        yU.reportApiInvoke(null, {
          options: void 0,
          name: Ek.LOAD_CONFIG_FROM_LOCALSTORAGE,
          tag: mk.TRACER
        }).onSuccess(JSON.stringify($M));
      }
      if (!this.joinInfo || !this.cancelToken || !this.retryConfig)
        return void EU.debug(
          "[config-distribute] get config distribute interrupted have no joininfo"
        );
      let e;
      const t = await this.mutex.lock();
      try {
        (e = await OH(this.joinInfo, this.cancelToken, this.retryConfig)),
          EU.debug(
            "[config-distribute] get config distribute",
            JSON.stringify(e)
          );
        const i = (function(e) {
          const t = Object.keys(e)
            .filter(e => /^webrtc_ng_global_parameter/.test(e))
            .sort();
          for (let i = 0; i < t.length; i++)
            for (let s = t.length - 1; s > i; s--) {
              const i = t[s],
                r = e[i].value;
              if ("number" == typeof r.__priority) {
                const n = r.__priority,
                  a = t[s - 1],
                  o = e[a].value;
                if ("number" == typeof o.__priority) {
                  if (!(n > o.__priority)) continue;
                  {
                    const e = i;
                    (t[s] = t[s - 1]), (t[s - 1] = e);
                  }
                } else {
                  const e = i;
                  (t[s] = t[s - 1]), (t[s - 1] = e);
                }
              }
            }
          const i = Date.now();
          let s = {};
          return (
            t.forEach(t => {
              const r = e[t].value.__expires;
              (r && r <= i) || (s[t] = e[t]);
            }),
            s
          );
        })(e);
        this.cacheGlobalParameterConfig(i),
          this.store.hasStartJoinChannel || (this.store.isABTestSuccess = !0),
          (this.configs = i);
      } catch (e) {
        const t = new AU(zP.NETWORK_RESPONSE_ERROR, e);
        EU.warning("[config-distribute] ".concat(t.toString()));
      } finally {
        t();
      }
    }
    getBitrateLimit() {
      return this.limit_bitrate || void 0;
    }
    handleBitrateLimit(e) {
      kG(e) &&
        (this.limit_bitrate
          ? this.limit_bitrate &&
            this.limit_bitrate.id !== e.id &&
            this.emit(PG.UPDATE_BITRATE_LIMIT, e)
          : this.emit(PG.UPDATE_BITRATE_LIMIT, e));
    }
    getLowStreamConfigDistribute() {
      return this.limit_bitrate && rG({}, this.limit_bitrate.low_stream_uplink);
    }
    handleABTestConfigDistribute(e) {
      try {
        const t = {},
          i = Object.keys(e),
          s = [];
        i.forEach(i => {
          const r = e[i].value;
          t[i] = r;
          const n = r.__id;
          if (n && this.configCache[i] && this.configCache[i].__id === n)
            return;
          const a = r.__type,
            o = e[i].value,
            c = e[i].tag;
          let d = 0;
          a
            ? a === YM.REALTIME && (d = 1)
            : Object.keys(o).some(e =>
                Object.prototype.hasOwnProperty.call(jM, e) ||
                (!XV() && Object.prototype.hasOwnProperty.call(BM, e))
                  ? ((d = 1), !0)
                  : void 0
              ),
            s.push({
              tag: c,
              isApplied: d,
              feature: i,
              params: JSON.stringify(r)
            });
        }),
          s.forEach(e => {
            let { tag: t, feature: i, params: s, isApplied: r } = e;
            this.store.sessionId &&
              yU.abTest(this.store.sessionId, {
                intSucc: 1,
                isApplied: r,
                tag: t,
                feature: i,
                params: s,
                cid: this.store.cid,
                uid: this.store.intUid
              });
          }),
          (this.configCache = t);
      } catch (e) {
        EU.debug("handleABTestConfigDistribute error", e);
      }
    }
    cacheGlobalParameterConfig(e) {
      const t = (function(e) {
        const t = {};
        return (
          Object.keys(e).forEach(i => {
            const s = e[i].value,
              r = s.__expires,
              n = s.__type;
            Object.keys(s).forEach(e => {
              "__id" === e ||
                "__type" === e ||
                "__priority" === e ||
                "__expires" === e ||
                Object.prototype.hasOwnProperty.call(t, e) ||
                (t[e] = rG(
                  rG({ value: s[e] }, r && { expires: r }),
                  n && { type: n }
                ));
            });
          }),
          t
        );
      })(e);
      try {
        var i;
        const s =
          null === (i = t.LIMIT_BITRATE) || void 0 === i ? void 0 : i.value;
        delete t.LIMIT_BITRATE,
          s && kG(s) && this.handleBitrateLimit(s),
          (this.limit_bitrate = s),
          this.handleGlobalParameterConfig(t),
          this.handleABTestConfigDistribute(e),
          (function(e) {
            try {
              const t = Date.now();
              Object.keys(e).forEach(i => {
                const { value: s, type: r, expires: n } = e[i];
                (n && n <= t) ||
                  ((r === YM.REALTIME ||
                    Object.prototype.hasOwnProperty.call(jM, i)) &&
                    (($M[i] = s),
                    (HM[i] = s),
                    EU.debug(
                      "Update realtime parameters from config distribute",
                      i,
                      s
                    )),
                  r ||
                    XV() ||
                    !Object.prototype.hasOwnProperty.call(BM, i) ||
                    (($M[i] = s),
                    (HM[i] = s),
                    EU.debug(
                      "Update gateway parameters from config distribute",
                      i,
                      s
                    )));
              });
            } catch (t) {
              EU.error(
                "Error update config immediately: ".concat(e),
                t.message
              );
            }
          })(t);
        const r = JSON.stringify(t),
          n = window.btoa(r);
        window.localStorage.setItem("websdk_ng_global_parameter", n),
          EU.debug("Caching global parameters ".concat(r));
      } catch (e) {
        EU.error("Error caching global parameters:", e.message);
      }
    }
    handleGlobalParameterConfig(e) {
      try {
        const t = Date.now();
        Object.keys(e).forEach(i => {
          if ("CLIENT_ROLE_OPTIONS" === i)
            if (Object.prototype.hasOwnProperty.call(HM, i)) {
              const { value: s, expires: r } = e[i];
              if (r && r <= t) return;
              (function(e, t) {
                try {
                  return (
                    "object" == typeof e &&
                    "object" == typeof t &&
                    JSON.stringify(e) === JSON.stringify(t)
                  );
                } catch (e) {
                  return !1;
                }
              })(HM[i], s) ||
                (($M[i] = s),
                (HM[i] = s),
                this.emit(PG.UPDATE_CLIENT_ROLE_OPTIONS, s),
                EU.debug(
                  "Updating client role options: ".concat(JSON.stringify(s))
                ));
            }
        });
      } catch (e) {
        EU.error("Error handling global parameter config:", e.message);
      }
    }
  }
  class PH extends uk {
    constructor() {
      super(...arguments), (this.resultStorage = new Map());
    }
    setLocalAudioStats(e, t, i) {
      this.record(
        "AUDIO_INPUT_LEVEL_TOO_LOW",
        e,
        this.checkAudioInputLevel(i, t)
      ),
        this.record(
          "SEND_AUDIO_BITRATE_TOO_LOW",
          e,
          this.checkSendAudioBitrate(i, t)
        );
    }
    setLocalVideoStats(e, t, i) {
      this.record(
        "SEND_VIDEO_BITRATE_TOO_LOW",
        e,
        this.checkSendVideoBitrate(i, t)
      ),
        this.record(
          "FRAMERATE_INPUT_TOO_LOW",
          e,
          this.checkFramerateInput(i, t)
        ),
        this.record("FRAMERATE_SENT_TOO_LOW", e, this.checkFramerateSent(i));
    }
    setRemoteAudioStats(e, t) {
      const i = e.getUserId();
      this.record(
        "AUDIO_OUTPUT_LEVEL_TOO_LOW",
        i,
        this.checkAudioOutputLevel(t)
      );
    }
    setRemoteVideoStats(e, t) {
      const i = e.getUserId();
      this.record("RECV_VIDEO_DECODE_FAILED", i, this.checkVideoDecode(t));
    }
    record(e, t, i) {
      if (WM("STATS_UPDATE_INTERVAL") > 500) return;
      this.resultStorage.has(e) ||
        this.resultStorage.set(e, { result: [], isPrevNormal: !0 });
      const s = this.resultStorage.get(e);
      if (s && (s.result.push(i), s.result.length >= 5)) {
        const i = s.result.includes(!0);
        s.isPrevNormal && !i && this.emit("exception", kH[e], e, t),
          !s.isPrevNormal &&
            i &&
            this.emit("exception", kH[e] + 2e3, e + "_RECOVER", t),
          (s.isPrevNormal = i),
          (s.result = []);
      }
    }
    checkAudioOutputLevel(e) {
      return !(e.receiveBitrate > 0 && 0 === e.receiveLevel);
    }
    checkAudioInputLevel(e, t) {
      return (
        (t instanceof VB && !t.isActive) || !!t.muted || 0 !== e.sendVolumeLevel
      );
    }
    checkFramerateInput(e, t) {
      let i = null;
      t._encoderConfig &&
        t._encoderConfig.frameRate &&
        (i = mj(t._encoderConfig.frameRate));
      const s = e.captureFrameRate;
      return !i || !s || !((i > 10 && s < 5) || (i < 10 && i >= 5 && s <= 1));
    }
    checkFramerateSent(e) {
      return !(
        e.captureFrameRate &&
        e.sendFrameRate &&
        e.captureFrameRate > 5 &&
        e.sendFrameRate <= 1
      );
    }
    checkSendVideoBitrate(e, t) {
      return !!t.muted || 0 !== e.sendBitrate;
    }
    checkSendAudioBitrate(e, t) {
      return (
        (t instanceof VB && !t.isActive) || !!t.muted || 0 !== e.sendBitrate
      );
    }
    checkVideoDecode(e) {
      return 0 === e.receiveBitrate || 0 !== e.decodeFrameRate;
    }
  }
  const kH = {
    FRAMERATE_INPUT_TOO_LOW: 1001,
    FRAMERATE_SENT_TOO_LOW: 1002,
    SEND_VIDEO_BITRATE_TOO_LOW: 1003,
    RECV_VIDEO_DECODE_FAILED: 1005,
    AUDIO_INPUT_LEVEL_TOO_LOW: 2001,
    AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002,
    SEND_AUDIO_BITRATE_TOO_LOW: 2003
  };
  const MH = new (class {
    markSubscribeStart(e, t) {
      performance.mark("agora-web-sdk/".concat(e, "/subscribe-").concat(t));
    }
    markPublishStart(e, t) {
      performance.mark("agora-web-sdk/".concat(e, "/publish-").concat(t));
    }
    measureFromSubscribeStart(e, t) {
      const i = performance.getEntriesByName(
        "agora-web-sdk/".concat(e, "/subscribe-").concat(t)
      );
      if (i.length > 0) {
        const e = i[i.length - 1];
        return Math.round(performance.now() - e.startTime);
      }
      return 0;
    }
    measureFromPublishStart(e, t) {
      const i = performance.getEntriesByName(
        "agora-web-sdk/".concat(e, "/publish-").concat(t)
      );
      if (i.length > 0) {
        const e = i[i.length - 1];
        return Math.round(performance.now() - e.startTime);
      }
      return 0;
    }
  })();
  class UH {
    constructor(e) {
      (this.store = void 0),
        (this.onStatsException = void 0),
        (this.onUploadPublishDuration = void 0),
        (this.onStatsChanged = void 0),
        (this.localStats = new Map()),
        (this.remoteStats = new Map()),
        (this.updateStatsInterval = void 0),
        (this.trafficStats = void 0),
        (this.trafficStatsPeerList = []),
        (this.uplinkStats = void 0),
        (this.exceptionMonitor = void 0),
        (this.p2pChannel = void 0),
        (this.scalabilityMode = CM.L1T1),
        (this.updateStats = () => {
          this.p2pChannel &&
            (this.updateRemoteStats(this.p2pChannel),
            this.updateLocalStats(this.p2pChannel));
        }),
        (this.store = e),
        (this.exceptionMonitor = new PH()),
        this.exceptionMonitor.on("exception", (e, t, i) => {
          this.onStatsException && this.onStatsException(e, t, i);
        });
    }
    startUpdateStats() {
      this.updateStatsInterval ||
        (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));
    }
    stopUpdateStats() {
      this.updateStatsInterval &&
        (window.clearInterval(this.updateStatsInterval),
        (this.updateStatsInterval = void 0));
    }
    reset() {
      (this.localStats = new Map()),
        (this.remoteStats = new Map()),
        (this.trafficStats = void 0),
        (this.trafficStatsPeerList = []),
        (this.uplinkStats = void 0);
    }
    getLocalAudioTrackStats() {
      return this.localStats.get(GG.LocalAudioTrack) || rG({}, zx);
    }
    getLocalVideoTrackStats() {
      return this.localStats.get(GG.LocalVideoTrack) || rG({}, Jx);
    }
    getRemoteAudioTrackStats(e) {
      const t = (e, t) => {
          if (!this.trafficStats) return t;
          const i = this.trafficStats.peer_delay.find(t => t.peer_uid === e);
          return (
            i &&
              (t.publishDuration =
                i.B_ppad + (Date.now() - this.trafficStats.timestamp)),
            t
          );
        },
        i = {};
      if (e) {
        var s;
        const r =
          null === (s = this.remoteStats.get(e)) || void 0 === s
            ? void 0
            : s.audioStats;
        r && (i[e] = t(e, r));
      } else
        Array.from(this.remoteStats.entries()).forEach(e => {
          let [s, { audioStats: r }] = e;
          r && (i[s] = t(s, r));
        });
      return i;
    }
    getRemoteNetworkQualityStats(e) {
      const t = {};
      if (e) {
        var i;
        const s =
          null === (i = this.remoteStats.get(e)) || void 0 === i
            ? void 0
            : i.networkStats;
        s && (t[e] = s);
      } else
        Array.from(this.remoteStats.entries()).forEach(e => {
          let [i, { networkStats: s }] = e;
          s && (t[i] = s);
        });
      return t;
    }
    getNetworkQuality() {
      let e = 0,
        t = 0;
      return (
        this.trafficStats &&
          ((e = _j(this.trafficStats.B_unq)),
          (t = _j(this.trafficStats.B_dnq))),
        { uplinkNetworkQuality: e, downlinkNetworkQuality: t }
      );
    }
    getRemoteVideoTrackStats(e) {
      const t = (e, t) => {
          if (!this.trafficStats) return t;
          const i = this.trafficStats.peer_delay.find(t => t.peer_uid === e);
          return (
            i &&
              (t.publishDuration =
                i.B_ppvd + (Date.now() - this.trafficStats.timestamp)),
            t
          );
        },
        i = {};
      if (e) {
        var s;
        const r =
          null === (s = this.remoteStats.get(e)) || void 0 === s
            ? void 0
            : s.videoStats;
        r && (i[e] = t(e, r));
      } else
        Array.from(this.remoteStats.entries()).forEach(e => {
          let [s, { videoStats: r }] = e;
          r && (i[s] = t(s, r));
        });
      return i;
    }
    getRTCStats() {
      let e = 0,
        t = 0,
        i = 0,
        s = 0;
      const r = this.localStats.get(GG.LocalAudioTrack);
      r && ((e += r.sendBytes), (t += r.sendBitrate));
      const n = this.localStats.get(GG.LocalVideoTrack);
      n && ((e += n.sendBytes), (t += n.sendBitrate));
      const a = this.localStats.get(GG.LocalVideoLowTrack);
      a && ((e += a.sendBytes), (t += a.sendBitrate)),
        this.remoteStats.forEach(e => {
          let { audioStats: t, videoStats: r } = e;
          t && ((i += t.receiveBytes), (s += t.receiveBitrate)),
            r && ((i += r.receiveBytes), (s += r.receiveBitrate));
        });
      let o = 1;
      return (
        this.trafficStats && (o += this.trafficStats.peer_delay.length),
        {
          Duration: 0,
          UserCount: o,
          SendBitrate: t,
          SendBytes: e,
          RecvBytes: i,
          RecvBitrate: s,
          OutgoingAvailableBandwidth: this.uplinkStats
            ? this.uplinkStats.B_uab / 1e3
            : 0,
          RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0
        }
      );
    }
    addLocalStats(e) {
      this.localStats.set(e, void 0);
    }
    removeLocalStats(e) {
      e ? this.localStats.delete(e) : this.localStats.clear();
    }
    addRemoteStats(e) {
      this.remoteStats.set(e, {});
    }
    removeRemoteStats(e) {
      e ? this.remoteStats.delete(e) : this.remoteStats.clear();
    }
    addP2PChannel(e) {
      this.p2pChannel = e;
    }
    updateTrafficStats(e) {
      e.peer_delay = e.peer_delay.filter(
        e => void 0 !== e.B_ppad || void 0 !== e.B_ppvd
      );
      e.peer_delay
        .filter(e => -1 === this.trafficStatsPeerList.indexOf(e.peer_uid))
        .forEach(e => {
          var t;
          const i =
              null === (t = this.p2pChannel) || void 0 === t
                ? void 0
                : t.getRemoteMedia(e.peer_uid),
            s =
              null != i && i.videoSSRC
                ? MH.measureFromSubscribeStart(this.store.clientId, i.videoSSRC)
                : 0,
            r =
              null != i && i.audioSSRC
                ? MH.measureFromSubscribeStart(this.store.clientId, i.audioSSRC)
                : 0;
          void 0 !== e.B_ppad &&
            void 0 !== e.B_ppvd &&
            (this.onUploadPublishDuration &&
              this.onUploadPublishDuration(
                e.peer_uid,
                e.B_ppad,
                e.B_ppvd,
                s > r ? s : r
              ),
            this.trafficStatsPeerList.push(e.peer_uid));
        }),
        (this.trafficStats = e);
    }
    updateUplinkStats(e) {
      this.uplinkStats &&
        this.uplinkStats.B_fir !== e.B_fir &&
        EU.debug(
          "["
            .concat(this.store.clientId, "]: Period fir changes to ")
            .concat(e.B_fir)
        ),
        (this.uplinkStats = e);
    }
    static isRemoteVideoFreeze(e, t, i) {
      if (!e) return !1;
      const s = !!i && t.framesDecodeFreezeTime > i.framesDecodeFreezeTime,
        r = !i || t.framesDecodeCount > i.framesDecodeCount;
      return s || !r;
    }
    static isRemoteAudioFreeze(e) {
      return !!e && e._isFreeze();
    }
    isLocalVideoFreeze(e) {
      return (
        !(!e.inputFrame || !e.sentFrame) &&
        e.inputFrame.frameRate > 5 && e.sentFrame.frameRate < 3
      );
    }
    updateLocalStats(e) {
      Array.from(this.localStats.entries()).forEach(t => {
        let [i, s] = t;
        switch (i) {
          case GG.LocalVideoTrack:
          case GG.LocalVideoLowTrack: {
            const t = s,
              n = rG({}, Jx),
              a = e.getStats(),
              o = e.getLocalMedia(i);
            if (a) {
              const i = a.videoSend.find(
                e => e.ssrc === (null == o ? void 0 : o.ssrcs[0].ssrcId)
              );
              if (i) {
                const s = e.getLocalVideoSize(),
                  r = e.getEncoderConfig(GG.LocalVideoTrack);
                ("H264" !== i.codec &&
                  "H265" !== i.codec &&
                  "VP8" !== i.codec &&
                  "VP9" !== i.codec &&
                  "AV1X" !== i.codec &&
                  "AV1" !== i.codec) ||
                  (n.codecType = i.codec),
                  (n.sendBytes = i.bytes),
                  (n.sendBitrate = t
                    ? 8 * Math.max(0, n.sendBytes - t.sendBytes)
                    : 0),
                  i.inputFrame
                    ? ((n.captureFrameRate = i.inputFrame.frameRate),
                      (n.captureResolutionHeight = i.inputFrame.height),
                      (n.captureResolutionWidth = i.inputFrame.width))
                    : s &&
                      ((n.captureResolutionWidth = s.width),
                      (n.captureResolutionHeight = s.height)),
                  i.sentFrame
                    ? ((n.sendFrameRate = i.sentFrame.frameRate),
                      (n.sendResolutionHeight = i.sentFrame.height),
                      (n.sendResolutionWidth = i.sentFrame.width))
                    : s &&
                      ((n.sendResolutionWidth = s.width),
                      (n.sendResolutionHeight = s.height)),
                  i.avgEncodeMs && (n.encodeDelay = i.avgEncodeMs),
                  r &&
                    r.bitrateMax &&
                    (n.targetSendBitrate = 1e3 * r.bitrateMax),
                  (n.sendPackets = i.packets),
                  (n.sendPacketsLost = i.packetsLost),
                  (n.sendJitterMs = i.jitterMs),
                  (n.sendRttMs = i.rttMs),
                  (n.totalDuration = t ? t.totalDuration + 1 : 1),
                  (n.totalFreezeTime = t ? t.totalFreezeTime : 0),
                  this.isLocalVideoFreeze(i) && (n.totalFreezeTime += 1),
                  i.scalabilityMode &&
                    this.scalabilityMode !== i.scalabilityMode &&
                    (EU.debug(
                      "["
                        .concat(
                          this.store.clientId,
                          "]: The scalabilityMode of the video sending stream is "
                        )
                        .concat(i.scalabilityMode)
                    ),
                    (this.scalabilityMode = i.scalabilityMode));
              }
              this.trafficStats &&
                (n.currentPacketLossRate =
                  (this.trafficStats.B_pvlr4 || 0) / 100);
            }
            var r;
            if (
              (this.localStats.set(i, n),
              (null == t ? void 0 : t.sendResolutionWidth) !==
                n.sendResolutionWidth ||
                (null == t ? void 0 : t.sendResolutionHeight) !==
                  n.sendResolutionHeight)
            )
              null === (r = this.onStatsChanged) ||
                void 0 === r ||
                r.call(this, "resolution", {
                  width: n.sendResolutionWidth,
                  height: n.sendResolutionHeight
                });
            n &&
              o &&
              this.exceptionMonitor.setLocalVideoStats(
                this.store.uid,
                o.track,
                n
              );
            break;
          }
          case GG.LocalAudioTrack: {
            const t = s,
              r = rG({}, zx),
              n = e.getStats(),
              a = e.getLocalMedia(i);
            if (n) {
              const i = n.audioSend.find(
                e => e.ssrc === (null == a ? void 0 : a.ssrcs[0].ssrcId)
              );
              if (i) {
                if (
                  (("opus" !== i.codec &&
                    "aac" !== i.codec &&
                    "PCMU" !== i.codec &&
                    "PCMA" !== i.codec &&
                    "G722" !== i.codec) ||
                    (r.codecType = i.codec),
                  i.inputLevel)
                )
                  r.sendVolumeLevel = Math.round(32767 * i.inputLevel);
                else {
                  const t = e.getLocalAudioVolume();
                  t && (r.sendVolumeLevel = Math.round(32767 * t));
                }
                (r.sendBytes = i.bytes),
                  (r.sendPackets = i.packets),
                  (r.sendPacketsLost = i.packetsLost),
                  (r.sendJitterMs = i.jitterMs),
                  (r.sendRttMs = i.rttMs),
                  (r.sendBitrate = t
                    ? 8 * Math.max(0, r.sendBytes - t.sendBytes)
                    : 0);
              }
            }
            this.trafficStats &&
              (r.currentPacketLossRate =
                (this.trafficStats.B_palr4 || 0) / 100),
              this.localStats.set(GG.LocalAudioTrack, r),
              r &&
                a &&
                this.exceptionMonitor.setLocalAudioStats(
                  this.store.uid,
                  a.track,
                  r
                );
            break;
          }
        }
      });
    }
    updateRemoteStats(e) {
      Array.from(this.remoteStats.entries()).forEach(t => {
        var i, s;
        let [r, { videoStats: n, audioStats: a, videoPcStats: o }] = t;
        const c = a,
          d = n,
          l = o,
          h = rG({}, Qx),
          u = rG({}, eF),
          p = rG({}, Zx),
          {
            audioTrack: f,
            videoTrack: E,
            audioSSRC: m,
            videoSSRC: g
          } = e.getRemoteMedia(r);
        let _;
        _ = this.store.useP2P ? e.getStats(!0) : e.getStats();
        const T =
            null === (i = _) || void 0 === i
              ? void 0
              : i.audioRecv.find(e => e.ssrc === m),
          S =
            null === (s = _) || void 0 === s
              ? void 0
              : s.videoRecv.find(e => e.ssrc === g),
          v =
            this.trafficStats &&
            this.trafficStats.peer_delay.find(e => e.peer_uid === r);
        if (
          (T &&
            (("opus" !== T.codec &&
              "aac" !== T.codec &&
              "PCMU" !== T.codec &&
              "PCMA" !== T.codec &&
              "G722" !== T.codec) ||
              (h.codecType = T.codec),
            T.outputLevel
              ? (h.receiveLevel = Math.round(32767 * T.outputLevel))
              : f && (h.receiveLevel = Math.round(32767 * f.getVolumeLevel())),
            (h.receiveBytes = T.bytes),
            (h.receivePackets = T.packets),
            (h.receivePacketsLost = T.packetsLost),
            (h.receivePacketsDiscarded = T.packetsDiscarded),
            (h.packetLossRate =
              h.receivePacketsLost / (h.receivePackets + h.receivePacketsLost)),
            (h.receiveBitrate = c
              ? 8 * Math.max(0, h.receiveBytes - c.receiveBytes)
              : 0),
            (h.totalDuration = c ? c.totalDuration + 1 : 1),
            (h.totalFreezeTime = c ? c.totalFreezeTime : 0),
            (h.freezeRate = h.totalFreezeTime / h.totalDuration),
            (h.receiveDelay = T.jitterBufferMs),
            h.totalDuration > 10 &&
              UH.isRemoteAudioFreeze(f) &&
              (h.totalFreezeTime += 1)),
          S)
        ) {
          var R;
          ("H264" !== S.codec &&
            "H265" !== S.codec &&
            "VP8" !== S.codec &&
            "VP9" !== S.codec &&
            "AV1X" !== S.codec &&
            "AV1" !== S.codec) ||
            (u.codecType = S.codec),
            (u.receiveBytes = S.bytes),
            (u.receiveBitrate = d
              ? 8 * Math.max(0, u.receiveBytes - d.receiveBytes)
              : 0),
            (u.decodeFrameRate = S.decodeFrameRate < 0 ? 0 : S.decodeFrameRate),
            (u.renderFrameRate = S.decodeFrameRate < 0 ? 0 : S.decodeFrameRate),
            S.outputFrame && (u.renderFrameRate = S.outputFrame.frameRate),
            S.receivedFrame
              ? ((u.receiveFrameRate = S.receivedFrame.frameRate),
                (u.receiveResolutionHeight = S.receivedFrame.height),
                (u.receiveResolutionWidth = S.receivedFrame.width))
              : E &&
                ((u.receiveResolutionHeight = E._videoHeight || 0),
                (u.receiveResolutionWidth = E._videoWidth || 0)),
            void 0 !== S.framesRateFirefox &&
              (u.receiveFrameRate = Math.round(S.framesRateFirefox)),
            (u.receivePackets = S.packets),
            (u.receivePacketsLost = S.packetsLost),
            (u.packetLossRate =
              u.receivePacketsLost / (u.receivePackets + u.receivePacketsLost));
          const t = d ? d.totalFreezeTime : 0,
            i = d ? d.totalDuration : 0;
          (u.totalDuration = d ? d.totalDuration + 1 : 1),
            (u.totalFreezeTime =
              null !== (R = S.totalFreezesDuration) && void 0 !== R
                ? R
                : t || 0),
            (u.receiveDelay = S.jitterBufferMs || 0);
          const s = !!g && e.getRemoteVideoIsReady(g);
          void 0 === S.totalFreezesDuration &&
            E &&
            s &&
            UH.isRemoteVideoFreeze(E, S, l) &&
            (u.totalFreezeTime += 1),
            (u.freezeRate = Math.max(
              0,
              Math.min((u.totalFreezeTime - t) / (u.totalDuration - i), 1)
            ));
        }
        v &&
          ((h.end2EndDelay = v.B_ad),
          (u.end2EndDelay = v.B_vd),
          (h.transportDelay = v.B_ed),
          (u.transportDelay = v.B_ed),
          (h.currentPacketLossRate = v.B_ealr4 / 100),
          (u.currentPacketLossRate = v.B_evlr4 / 100),
          (p.uplinkNetworkQuality = v.B_punq ? v.B_punq : 0),
          (p.downlinkNetworkQuality = v.B_pdnq ? v.B_pdnq : 0)),
          this.remoteStats.set(r, {
            audioStats: h,
            videoStats: u,
            videoPcStats: S,
            networkStats: p
          }),
          f && this.exceptionMonitor.setRemoteAudioStats(f, h),
          E && this.exceptionMonitor.setRemoteVideoStats(E, u);
      });
    }
  }
  class xH {
    constructor() {
      (this.destChannelMediaInfos = new Map()),
        (this.srcChannelMediaInfo = void 0);
    }
    setSrcChannelInfo(e) {
      yG(e), (this.srcChannelMediaInfo = e);
    }
    addDestChannelInfo(e) {
      yG(e), this.destChannelMediaInfos.set(e.channelName, e);
    }
    removeDestChannelInfo(e) {
      TG(e), this.destChannelMediaInfos.delete(e);
    }
    getSrcChannelMediaInfo() {
      return this.srcChannelMediaInfo;
    }
    getDestChannelMediaInfo() {
      return this.destChannelMediaInfos;
    }
  }
  function FH(e) {
    if (!(e instanceof xH)) {
      return new AU(
        zP.INVALID_PARAMS,
        "Config should be instance of [ChannelMediaRelayConfiguration]"
      ).throw();
    }
    const t = e.getSrcChannelMediaInfo(),
      i = e.getDestChannelMediaInfo();
    if (!t) {
      return new AU(
        zP.INVALID_PARAMS,
        "srcChannelMediaInfo should not be empty"
      ).throw();
    }
    if (0 === i.size) {
      return new AU(
        zP.INVALID_PARAMS,
        "destChannelMediaInfo should not be empty"
      ).throw();
    }
  }
  class BH {
    get hasVideo() {
      return this._video_enabled_ && !this._video_muted_ && this._video_added_;
    }
    get hasAudio() {
      return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
    }
    get audioTrack() {
      if (this.hasAudio || this._audio_pre_subscribed) return this._audioTrack;
    }
    get videoTrack() {
      if (this.hasVideo || this._video_pre_subscribed) return this._videoTrack;
    }
    get dataChannels() {
      return this._dataChannels;
    }
    constructor(e, t) {
      (this.uid = void 0),
        (this._uintid = void 0),
        (this._trust_in_room_ = !0),
        (this._trust_audio_enabled_state_ = !0),
        (this._trust_video_enabled_state_ = !0),
        (this._trust_audio_mute_state_ = !0),
        (this._trust_video_mute_state_ = !0),
        (this._audio_muted_ = !1),
        (this._video_muted_ = !1),
        (this._audio_enabled_ = !0),
        (this._video_enabled_ = !0),
        (this._audio_added_ = !1),
        (this._video_added_ = !1),
        (this._is_pre_created = !1),
        (this._video_pre_subscribed = !1),
        (this._audio_pre_subscribed = !1),
        (this._trust_video_stream_added_state_ = !0),
        (this._trust_audio_stream_added_state_ = !0),
        (this._audioTrack = void 0),
        (this._videoTrack = void 0),
        (this._dataChannels = []),
        (this._audioSSRC = void 0),
        (this._videoSSRC = void 0),
        (this._audioOrtc = void 0),
        (this._videoOrtc = void 0),
        (this._cname = void 0),
        (this._rtxSsrcId = void 0),
        (this._videoMid = void 0),
        (this._audioMid = void 0),
        (this.uid = e),
        (this._uintid = t);
    }
  }
  const VH = "9",
    GH = 4e4;
  class jH {
    get localCapabilities() {
      return kk(this._localCapabilities);
    }
    get rtpCapabilities() {
      return kk(this._rtpCapabilities);
    }
    get candidates() {
      return kk(this._candidates);
    }
    get iceParameters() {
      return kk(this._iceParameters);
    }
    get dtlsParameters() {
      return kk(this._dtlsParameters);
    }
    constructor(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      (this.sessionDesc = void 0),
        (this._localCapabilities = void 0),
        (this._rtpCapabilities = void 0),
        (this._candidates = void 0),
        (this._originCandidates = void 0),
        (this._iceParameters = void 0),
        (this._isUseExtmapAllowMixed = void 0),
        (this._dtlsParameters = void 0),
        (this.setup = void 0),
        (this.currentMidIndex = void 0),
        (this.cname = void 0),
        (this.firefoxSsrcMidMap = new Map()),
        (this._isUseExtmapAllowMixed = t),
        (e = kk(e));
      const {
        iceParameters: i,
        dtlsParameters: s,
        candidates: r,
        rtpCapabilities: n,
        setup: a,
        localCapabilities: o,
        cname: c
      } = e;
      (this._rtpCapabilities = n),
        (this._candidates = r),
        (this._originCandidates = kk(r)),
        (this._iceParameters = i),
        (this._dtlsParameters = s),
        (this._localCapabilities = o),
        (this.setup = a),
        (this.cname = c),
        (this.sessionDesc = this.updateRemoteRTPCapabilities(n)),
        (this.currentMidIndex = this.sessionDesc.mediaDescriptions.length - 1);
    }
    preloadRemoteMedia(e) {
      const t = this.candidates,
        i = this.dtlsParameters,
        s = this.iceParameters,
        r = this.rtpCapabilities.send;
      let n = this.sessionDesc.mediaDescriptions.length - 1;
      for (let a = 1; a < e; a++) {
        const e = 2 * a + 2e4,
          o = 2 * a + GH,
          { ssrcs: c, ssrcGroups: d } = Pj([{ ssrcId: e }], this.cname),
          { ssrcs: l, ssrcGroups: h } = Pj(
            [{ ssrcId: o, rtx: WM("USE_SUB_RTX") ? o + 1 : void 0 }],
            this.cname
          );
        this.sessionDesc.mediaDescriptions.push({
          media: {
            mediaType: "video",
            port: VH,
            protos: ["UDP", "TLS", "RTP", "SAVPF"],
            fmts: r.videoCodecs.map(e => e.payloadType.toString(10))
          },
          connections: [
            { nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }
          ],
          bandwidths: [],
          attributes: {
            iceUfrag: s.iceUfrag,
            icePwd: s.icePwd,
            unrecognized: [],
            candidates: t,
            extmaps: r.videoExtensions,
            fingerprints: i.fingerprints,
            imageattr: [],
            msids: [],
            remoteCandidatesList: [],
            rids: [],
            ssrcs: l,
            ssrcGroups: h,
            rtcpFeedbackWildcards: [],
            payloads: r.videoCodecs,
            rtcp: {
              port: "9",
              netType: "IN",
              addressType: "IP4",
              address: "0.0.0.0"
            },
            setup: this.setup,
            direction: "sendonly",
            rtcpMux: !0,
            rtcpRsize: !0,
            mid: "".concat(++n)
          }
        }),
          this.sessionDesc.mediaDescriptions.push({
            media: {
              mediaType: "audio",
              port: VH,
              protos: ["UDP", "TLS", "RTP", "SAVPF"],
              fmts: r.audioCodecs.map(e => e.payloadType.toString(10))
            },
            connections: [
              { nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }
            ],
            bandwidths: [],
            attributes: {
              iceUfrag: s.iceUfrag,
              icePwd: s.icePwd,
              unrecognized: [],
              candidates: t,
              extmaps: r.audioExtensions,
              fingerprints: i.fingerprints,
              imageattr: [],
              msids: [],
              remoteCandidatesList: [],
              rids: [],
              ssrcs: c,
              ssrcGroups: d,
              rtcpFeedbackWildcards: [],
              payloads: r.audioCodecs,
              rtcp: {
                port: "9",
                netType: "IN",
                addressType: "IP4",
                address: "0.0.0.0"
              },
              setup: this.setup,
              direction: "sendonly",
              rtcpMux: !0,
              rtcpRsize: !0,
              mid: "".concat(++n)
            }
          }),
          (this.currentMidIndex += 2);
      }
      this.updateBundleMids();
    }
    toString() {
      return rU(this.sessionDesc);
    }
    send(e, t, i, s) {
      const { ssrcs: r, ssrcGroups: n } = Pj(
          t,
          this.cname,
          WM("SYNC_GROUP") ? i : void 0
        ),
        a = this.findPreloadMediaDesc(r);
      if (a) {
        if (
          (DP() && this.firefoxSsrcMidMap.set(r[0].ssrcId, a.attributes.mid),
          s && (s.twcc || s.remb))
        ) {
          const e = this.sessionDesc.mediaDescriptions.indexOf(a);
          return (
            (this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(
              a,
              s
            )),
            { mid: a.attributes.mid, needExchangeSDP: !0 }
          );
        }
        return { mid: a.attributes.mid, needExchangeSDP: !1 };
      }
      {
        const t = this.findAvailableMediaIndex(e, r);
        let i;
        return (
          -1 === t ||
          (1 === t &&
            (bP() ||
              (function() {
                const e = vP();
                return (
                  !(e.name !== gP.CHROME || !e.osVersion) &&
                  Number(e.version) <= 90
                );
              })() ||
              (WM("ENABLE_ENCODED_TRANSFORM") && CP()))) ||
          (0 === t && WM("USE_SUB_RTX")) ||
          xP()
            ? ((i = this.createOrRecycleSendMedia(e, r, n, "sendonly", s)),
              this.updateBundleMids())
            : ((i = kk(this.sessionDesc.mediaDescriptions[t])),
              (i.attributes.direction = "sendonly"),
              (i.attributes.ssrcs = r),
              (i.attributes.ssrcGroups = n),
              (this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(
                i,
                s
              ))),
          DP() && this.firefoxSsrcMidMap.set(r[0].ssrcId, i.attributes.mid),
          { mid: i.attributes.mid, needExchangeSDP: !0 }
        );
      }
    }
    sendDataChannel() {
      const {
        mediaDesc: e,
        needExchangeSDP: t
      } = this.createOrRecycleDataChannel();
      return (
        this.updateBundleMids(), { mid: e.attributes.mid, needExchangeSDP: t }
      );
    }
    batchSend(e) {
      const t = e.map(e => {
          let { kind: t, ssrcMsg: i, mslabel: s } = e;
          return this.send(t, i, s);
        }),
        i = [];
      let s = !1;
      return (
        t.forEach(e => {
          let { mid: t, needExchangeSDP: r } = e;
          r && (s = !0), i.push(t);
        }),
        { mids: i, needExchangeSDP: s }
      );
    }
    stopSending(e) {
      const t = this.sessionDesc.mediaDescriptions.filter(
        t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid)
      );
      if (t.length !== e.length)
        throw new Error(
          "mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending."
        );
      t.forEach(e => {
        "0" === e.attributes.mid || DP() || xP()
          ? (e.attributes.ssrcs = [])
          : ((e.attributes.ssrcs = []),
            (e.attributes.direction = "inactive"),
            (e.media.port = "0"));
      }),
        this.updateBundleMids();
    }
    mute(e) {
      const t = this.sessionDesc.mediaDescriptions.find(
        t => t.attributes.mid === e
      );
      if (!t)
        throw new Error(
          "mediaDescription not found with ".concat(
            e,
            " in remote SDP when calling RemoteSDP.mute."
          )
        );
      t.attributes.direction = "inactive";
    }
    unmute(e) {
      const t = this.sessionDesc.mediaDescriptions.find(
        t => t.attributes.mid === e
      );
      if (!t)
        throw new Error(
          "mediaDescription not found with ".concat(
            e,
            " in remote SDP when calling RemoteSDP.unmute."
          )
        );
      t.attributes.direction = "sendonly";
    }
    muteRemote(e) {
      const t = this.sessionDesc.mediaDescriptions.filter(t =>
        e.includes(t.attributes.mid || "")
      );
      if (t.length !== e.length)
        throw new Error(
          "mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote."
        );
      t.forEach(e => {
        e.attributes.direction = "inactive";
      });
    }
    unmuteRemote(e) {
      const t = this.sessionDesc.mediaDescriptions.filter(t =>
        e.includes(t.attributes.mid || "")
      );
      if (t.length !== e.length)
        throw new Error(
          "mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote."
        );
      t.forEach(e => {
        e.attributes.direction = "recvonly";
      });
    }
    receive(e, t, i, s) {
      e.forEach((e, r) => {
        this.createOrRecycleRecvMedia(e, [], "recvonly", t, i, s[r]);
      }),
        this.updateBundleMids();
    }
    stopReceiving(e) {
      const t = this.sessionDesc.mediaDescriptions.filter(
        t => -1 !== e.indexOf(t.attributes.mid)
      );
      if (t.length !== e.length)
        throw new Error(
          "MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive."
        );
      t.forEach(e => {
        (e.media.port = "0"), (e.attributes.direction = "inactive");
      }),
        this.updateBundleMids();
    }
    updateRemoteRTPCapabilities(e) {
      const t =
        this.sessionDesc ||
        sU(
          ((i = this._isUseExtmapAllowMixed),
          "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite".concat(
            i ? "\na=extmap-allow-mixed" : "",
            "\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n"
          ))
        );
      var i;
      this._rtpCapabilities = e;
      const s = this.rtpCapabilities.send,
        r = this.localCapabilities.send;
      for (const e of t.mediaDescriptions) {
        if (
          ((e.attributes.iceUfrag = this._iceParameters.iceUfrag),
          (e.attributes.icePwd = this._iceParameters.icePwd),
          (e.attributes.fingerprints = this._dtlsParameters.fingerprints),
          (e.attributes.candidates = this._candidates),
          (e.attributes.setup = this.setup),
          "application" === e.media.mediaType &&
            (e.attributes.sctpPort = "5000"),
          "video" === e.media.mediaType)
        )
          if (0 === s.videoCodecs.length) {
            const t = r.videoCodecs.filter(e => {
              var t;
              return null === (t = e.rtpMap) || void 0 === t
                ? void 0
                : t.encodingName.toLowerCase().includes("vp8");
            }) || [r.videoCodecs[0]];
            (e.media.fmts = t.map(e => e.payloadType.toString(10))),
              (e.attributes.payloads = t),
              (e.attributes.extmaps = []);
          } else if (
            ((e.media.fmts = s.videoCodecs.map(e =>
              e.payloadType.toString(10)
            )),
            (e.attributes.payloads = s.videoCodecs),
            (e.attributes.extmaps = s.videoExtensions),
            WM("PRELOAD_MEDIA_COUNT") > 0)
          ) {
            const { ssrcs: t, ssrcGroups: i } = Pj(
              [{ ssrcId: GH, rtx: WM("USE_SUB_RTX") ? 40001 : void 0 }],
              this.cname
            );
            (e.attributes.ssrcs = t), (e.attributes.ssrcGroups = i);
          }
        if ("audio" === e.media.mediaType)
          if (0 === s.audioCodecs.length) {
            const t = r.audioCodecs.filter(e => {
              var t;
              return null === (t = e.rtpMap) || void 0 === t
                ? void 0
                : t.encodingName.toLowerCase().includes("opus");
            }) || [r.audioCodecs[0]];
            (e.media.fmts = t.map(e => e.payloadType.toString(10))),
              (e.attributes.payloads = t),
              (e.attributes.extmaps = []);
          } else if (
            ((e.media.fmts = s.audioCodecs.map(e =>
              e.payloadType.toString(10)
            )),
            (e.attributes.payloads = s.audioCodecs),
            (e.attributes.extmaps = s.audioExtensions),
            Bj(e),
            WM("PRELOAD_MEDIA_COUNT") > 0)
          ) {
            const { ssrcs: t, ssrcGroups: i } = Pj(
              [{ ssrcId: 2e4 }],
              this.cname
            );
            (e.attributes.ssrcs = t), (e.attributes.ssrcGroups = i);
          }
      }
      return (
        (this.sessionDesc = t),
        (this.currentMidIndex = t.mediaDescriptions.length - 1),
        this.sessionDesc
      );
    }
    updateCandidates(e) {
      const t = this._originCandidates.filter(e => "udp" === e.transport),
        i = [];
      if (
        (t.forEach(e => {
          i.push(
            rG(
              rG({}, e),
              {},
              {
                foundation: "tcpcandidate",
                priority: Number(e.priority) - 1 + "",
                transport: "tcp",
                port: Number(e.port) + 90 + ""
              }
            )
          );
        }),
        0 !== t.length)
      ) {
        switch (e) {
          case FG.TCP_RELAY:
            this._candidates = i;
            break;
          case FG.UDP_TCP_RELAY:
          case FG.RELAY:
            this._candidates = [...t, ...i];
            break;
          default:
            this._candidates = t;
        }
        for (const e of this.sessionDesc.mediaDescriptions)
          e.attributes.candidates = this.candidates;
      }
    }
    restartICE(e) {
      (e = kk(e)),
        (this._iceParameters = e),
        this.sessionDesc.mediaDescriptions.forEach(t => {
          (t.attributes.iceUfrag = e.iceUfrag),
            (t.attributes.icePwd = e.icePwd);
        });
    }
    predictReceivingMids(e) {
      const t = [];
      for (let i = 0; i < e; i++)
        t.push((this.currentMidIndex + i + 1).toString(10));
      return t;
    }
    findAvailableMediaIndex(e, t) {
      return this.sessionDesc.mediaDescriptions.findIndex(i => {
        const s =
          i.media.mediaType === e &&
          "0" !== i.media.port &&
          ("sendonly" === i.attributes.direction ||
            "sendrecv" === i.attributes.direction) &&
          0 === i.attributes.ssrcs.length;
        if (DP()) {
          if (s) {
            const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);
            return (
              !(e || ("0" !== i.attributes.mid && "1" !== i.attributes.mid)) ||
              !(!e || e !== i.attributes.mid)
            );
          }
          return !1;
        }
        return s;
      });
    }
    createOrRecycleDataChannel() {
      for (const e of this.sessionDesc.mediaDescriptions)
        if ("application" === e.media.mediaType)
          return { mediaDesc: e, needExchangeSDP: !1 };
      this.currentMidIndex += 1;
      const e = "".concat(this.currentMidIndex),
        t = {
          media: {
            mediaType: "application",
            port: VH,
            protos: ["UDP", "DTLS", "SCTP"],
            fmts: ["webrtc-datachannel"]
          },
          connections: [
            { nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }
          ],
          bandwidths: [],
          attributes: {
            iceUfrag: this.iceParameters.iceUfrag,
            icePwd: this.iceParameters.icePwd,
            unrecognized: [],
            candidates: this.candidates,
            extmaps: [],
            fingerprints: this.dtlsParameters.fingerprints,
            imageattr: [],
            msids: [],
            remoteCandidatesList: [],
            rids: [],
            ssrcs: [],
            ssrcGroups: [],
            rtcpFeedbackWildcards: [],
            payloads: [],
            rtcp: {
              port: "9",
              netType: "IN",
              addressType: "IP4",
              address: "0.0.0.0"
            },
            setup: this.setup,
            mid: "".concat(e),
            sctpPort: "5000"
          }
        };
      return (
        this.sessionDesc.mediaDescriptions.push(t),
        { mediaDesc: t, needExchangeSDP: !0 }
      );
    }
    createOrRecycleRecvMedia(e, t, i, s, r, n) {
      const a = e._mediaStreamTrack.kind,
        o = this.rtpCapabilities.recv,
        c = Vj(a, o, this.localCapabilities.send, a === xG.VIDEO ? s : r),
        d = a === xG.VIDEO ? o.videoExtensions : o.audioExtensions;
      this.currentMidIndex += 1;
      const l = "".concat(this.currentMidIndex);
      let h = {
        media: {
          mediaType: a,
          port: VH,
          protos: ["UDP", "TLS", "RTP", "SAVPF"],
          fmts: c.map(e => e.payloadType.toString(10))
        },
        connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }],
        bandwidths: [],
        attributes: {
          iceUfrag: this.iceParameters.iceUfrag,
          icePwd: this.iceParameters.icePwd,
          unrecognized: [],
          candidates: this.candidates,
          extmaps: d,
          fingerprints: this.dtlsParameters.fingerprints,
          imageattr: [],
          msids: [],
          remoteCandidatesList: [],
          rids: [],
          ssrcs: t,
          ssrcGroups: [],
          rtcpFeedbackWildcards: [],
          payloads: c,
          rtcp: {
            port: "9",
            netType: "IN",
            addressType: "IP4",
            address: "0.0.0.0"
          },
          setup: this.setup,
          direction: i,
          rtcpMux: !0,
          rtcpRsize: !0,
          mid: "".concat(l)
        }
      };
      h = this.mungRecvMediaDsec(h, e, n);
      const u = this.findFirstClosedMedia(a);
      if (u) {
        const e = this.sessionDesc.mediaDescriptions.indexOf(u);
        this.sessionDesc.mediaDescriptions[e] = h;
      } else this.sessionDesc.mediaDescriptions.push(h);
      return h;
    }
    updateRemoteCodec(e, t, i) {
      const s = [
          ...new Set(
            this._rtpCapabilities.recv.videoCodecs
              .map(e => (e.rtpMap && e.rtpMap.encodingName.toLowerCase()) || "")
              .filter(e => Object.keys(zM).includes(e))
          )
        ],
        r = new Set(t);
      if (s.every(e => r.has(e)))
        return (
          EU.debug(
            "codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(
              t
            )
          ),
          !1
        );
      const n = this._rtpCapabilities.recv.videoCodecs.filter(e =>
        t.some(t =>
          ((e.rtpMap && e.rtpMap.encodingName.toLowerCase()) || "").includes(t)
        )
      );
      if (0 === n.length)
        return (
          EU.debug(
            "updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: "
              .concat(s, " codecs: ")
              .concat(t)
          ),
          !1
        );
      const a = [
        ...new Set(
          n.map(e => (e.rtpMap && e.rtpMap.encodingName.toLowerCase()) || "")
        )
      ];
      let o;
      if (
        (EU.debug("updateRemoteCodec, from ".concat(s, " to ").concat(a)),
        0 === e.length)
      )
        o = this.sessionDesc.mediaDescriptions.filter(
          e =>
            "video" === e.media.mediaType &&
            "recvonly" === e.attributes.direction
        );
      else if (
        ((o = this.sessionDesc.mediaDescriptions.filter(
          t =>
            t.attributes.mid &&
            e.includes(t.attributes.mid) &&
            "recvonly" === t.attributes.direction
        )),
        o.length !== e.length)
      )
        return (
          EU.debug(
            "updateRemoteCodec failed, because cannot find mids, mids: "
              .concat(e, ", codecs: ")
              .concat(t)
          ),
          !1
        );
      if (WM("USE_PUB_RTX") || WM("USE_SUB_RTX")) {
        const e = Gj(n, this.rtpCapabilities.recv.videoCodecs);
        n.push(...e);
      }
      this._rtpCapabilities.recv.videoCodecs = n;
      const c = this.localCapabilities.send,
        d = this.rtpCapabilities.recv,
        l = Vj(xG.VIDEO, d, c, i);
      return (
        o.forEach(e => {
          const t = l.map(e => e.payloadType.toString(10));
          EU.debug(
            "updateRemoteCodec mid: ".concat(e.attributes.mid, ", from"),
            e.attributes.payloads,
            "to",
            l
          ),
            (e.attributes.payloads = l),
            (e.media.fmts = t);
        }),
        !0
      );
    }
    createOrRecycleSendMedia(e, t, i, s, r) {
      const n = this.rtpCapabilities.send,
        a = e === xG.VIDEO ? n.videoCodecs : n.audioCodecs,
        o = e === xG.VIDEO ? n.videoExtensions : n.audioExtensions;
      this.currentMidIndex += 1;
      const c = "".concat(this.currentMidIndex);
      let d = {
        media: {
          mediaType: e,
          port: VH,
          protos: ["UDP", "TLS", "RTP", "SAVPF"],
          fmts: a.map(e => e.payloadType.toString(10))
        },
        connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }],
        bandwidths: [],
        attributes: {
          iceUfrag: this.iceParameters.iceUfrag,
          icePwd: this.iceParameters.icePwd,
          unrecognized: [],
          candidates: this.candidates,
          extmaps: o,
          fingerprints: this.dtlsParameters.fingerprints,
          imageattr: [],
          msids: [],
          remoteCandidatesList: [],
          rids: [],
          ssrcs: t,
          ssrcGroups: i,
          rtcpFeedbackWildcards: [],
          payloads: a,
          rtcp: {
            port: "9",
            netType: "IN",
            addressType: "IP4",
            address: "0.0.0.0"
          },
          setup: this.setup,
          direction: s,
          rtcpMux: !0,
          rtcpRsize: !0,
          mid: "".concat(c)
        }
      };
      d = this.mungSendMediaDesc(d, r);
      const l = this.findFirstClosedMedia(e);
      if (l) {
        const e = this.sessionDesc.mediaDescriptions.indexOf(l);
        this.sessionDesc.mediaDescriptions[e] = d;
      } else this.sessionDesc.mediaDescriptions.push(d);
      return d;
    }
    updateBundleMids() {
      this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions
        .filter(e => "0" !== e.media.port)
        .map(e => e.attributes.mid);
    }
    mungRecvMediaDsec(e, t, i) {
      const s = kk(e);
      return (
        (function(e) {
          const t = e.attributes.unrecognized.findIndex(
            e => "x-google-flag" === e.attField && "conference" === e.attValue
          );
          -1 !== t && e.attributes.unrecognized.splice(t, 1);
        })(s),
        kj(s, t),
        (function(e, t) {
          if (
            !(
              t instanceof AV &&
              t._encoderConfig &&
              -1 === t._hints.indexOf(Hx.SCREEN_TRACK)
            )
          )
            return;
          const i = t._encoderConfig;
          Lx().supportMinBitrate &&
            i.bitrateMin &&
            e.attributes.payloads.forEach(e => {
              var t;
              ["h264", "h265", "vp8", "vp9", "av1"].includes(
                (null === (t = e.rtpMap) || void 0 === t
                  ? void 0
                  : t.encodingName.toLowerCase()) || ""
              ) &&
                (e.fmtp || (e.fmtp = { parameters: {} }),
                (e.fmtp.parameters["x-google-min-bitrate"] = "".concat(
                  i.bitrateMin
                )));
            }),
            Lx().supportMinBitrate &&
              !t._hints.includes(Hx.LOW_STREAM) &&
              i.bitrateMax &&
              e.attributes.payloads.forEach(e => {
                var t;
                ["h264", "h265", "vp8", "vp9", "av1"].includes(
                  (null === (t = e.rtpMap) || void 0 === t
                    ? void 0
                    : t.encodingName.toLowerCase()) || ""
                ) &&
                  (e.fmtp || (e.fmtp = { parameters: {} }),
                  (e.fmtp.parameters["x-google-start-bitrate"] = "".concat(
                    WM("X_GOOGLE_START_BITRATE") || Math.floor(i.bitrateMax)
                  )));
              });
        })(s, t),
        (function(e) {
          if ("video" !== e.media.mediaType) return;
          const t = vP();
          if (t.name !== gP.SAFARI && t.os !== mP.IOS) return;
          const i = e.attributes.extmaps.findIndex(e =>
            /video-orientation/g.test(e.extensionName)
          );
          -1 !== i && e.attributes.extmaps.splice(i, 1);
        })(s),
        Mj(s, i, this.localCapabilities.send),
        s
      );
    }
    mungSendMediaDesc(e, t) {
      const i = kk(e);
      return Mj(i, t, this.localCapabilities.recv), Bj(i), i;
    }
    updateRecvMedia(e, t) {
      const i = this.sessionDesc.mediaDescriptions.findIndex(
        t => t.attributes.mid === e
      );
      if (-1 !== i) {
        const e = this.mungRecvMediaDsec(
          this.sessionDesc.mediaDescriptions[i],
          t
        );
        this.sessionDesc.mediaDescriptions[i] = e;
      }
    }
    bumpMid(e) {
      this.currentMidIndex += e;
    }
    findFirstClosedMedia(e) {
      return this.sessionDesc.mediaDescriptions.find(t =>
        DP()
          ? "0" === t.media.port && t.media.mediaType === e
          : "0" === t.media.port
      );
    }
    findPreloadMediaDesc(e) {
      return this.sessionDesc.mediaDescriptions.find(t => {
        var i;
        return (
          (null === (i = t.attributes) ||
          void 0 === i ||
          null === (i = i.ssrcs[0]) ||
          void 0 === i
            ? void 0
            : i.ssrcId) === e[0].ssrcId
        );
      });
    }
    getSSRC(e) {
      var t;
      return null ===
        (t = this.sessionDesc.mediaDescriptions.find(
          t => t.attributes.mid === e
        )) || void 0 === t
        ? void 0
        : t.attributes.ssrcs;
    }
  }
  var HH = (function(e) {
    return (e[(e.DOWN = 0)] = "DOWN"), (e[(e.UP = 1)] = "UP"), e;
  })(HH || {});
  const KH = new Map();
  function WH(e, t, i, s) {
    let { scale: r } = e;
    if ((0 === r && s === HH.UP) || (r >= t.length - 1 && s === HH.DOWN))
      return e;
    let n = rG(rG({}, e), {}, { scale: s === HH.DOWN ? ++r : --r });
    switch (i) {
      case "maintain-framerate":
        n = rG(rG({}, n), t[r].motion);
        break;
      case "maintain-resolution":
        n = rG(rG({}, n), t[r].detail);
        break;
      case "balanced":
        n = rG(rG({}, n), t[r].balanced);
    }
    return n;
  }
  function YH(e, t) {
    if (t) {
      const i = { overUse: 0, underUse: 0, adaptationList: $H(t) };
      KH.set(e, i);
    } else KH.delete(e);
  }
  function $H(e) {
    const t = rG({}, e),
      {
        bitrateMax: i,
        frameRate: s,
        scaleResolutionDownBy: r,
        bitrateMin: n
      } = t,
      {
        MIN_FRAME_RATE: a,
        MAX_THRESHOLD_FRAMERATE: o,
        MAX_SCALE: c,
        BITRATE_MIN_THRESHOLD: d,
        BITRATE_MAX_THRESHOLD: l,
        BWE_SCALE_UP_THRESHOLD: h,
        BWE_SCALE_DOWN_THRESHOLD: u,
        PERF_SCALE_DOWN_THRESHOLD: p,
        PERF_SCALE_UP_THRESHOLD: f,
        BALANCE_BITRATE_FACTOR: E,
        BALANCE_FRAMERATE_FACTOR: m,
        BALANCE_RESOLUTION_FACTOR: g,
        MOTION_RESOLUTION_FACTOR: _,
        MOTION_BITRATE_FACTOR: T,
        DETAIL_FRAMERATE_FACTOR: S,
        DETAIL_BITRATE_FACTOR: v
      } = VM,
      R = Math.min(t.frameRate, o),
      y = [
        {
          scale: 0,
          threshold: {
            bwe_down: Math.round(Math.pow(u, 1) * i),
            bwe_up: i,
            fps_down: Math.round(Math.pow(p, 1) * R),
            fps_up: s
          },
          balanced: {
            scaleResolutionDownBy: 1,
            frameRate: s,
            bitrateMax: i,
            bitrateMin: n
          },
          motion: {
            scaleResolutionDownBy: 1,
            frameRate: s,
            bitrateMax: i,
            bitrateMin: n
          },
          detail: {
            scaleResolutionDownBy: 1,
            frameRate: s,
            bitrateMax: i,
            bitrateMin: n
          }
        }
      ];
    for (let e = 1; e <= c; e++) {
      const t = {
          bwe_up: Math.round(Math.pow(h, e) * i),
          bwe_down: Math.round(Math.pow(u, e + 1) * i),
          fps_up: Math.round(Math.pow(f, e) * R),
          fps_down: Math.round(Math.pow(p, e + 1) * R)
        },
        o = {
          scaleResolutionDownBy: r / Math.pow(g, e),
          frameRate: Math.max(Math.round(Math.pow(m, e) * s), a),
          bitrateMax: Math.max(Math.round(Math.pow(E, e) * i), l),
          bitrateMin: Math.max(Math.round(Math.pow(E, e) * n), d)
        },
        c = {
          scaleResolutionDownBy: r / Math.pow(_, e),
          frameRate: s,
          bitrateMax: Math.max(Math.round(Math.pow(T, e) * i), l),
          bitrateMin: Math.max(Math.round(Math.pow(T, e) * n), d)
        },
        A = {
          scaleResolutionDownBy: 1,
          frameRate: Math.max(Math.round(Math.pow(S, e) * s), a),
          bitrateMax: Math.max(Math.round(Math.pow(v, e) * i), l),
          bitrateMin: Math.max(Math.round(Math.pow(v, e) * n), d)
        };
      y.push({ scale: e, threshold: t, balanced: o, motion: c, detail: A });
    }
    return y;
  }
  function qH(e, t, i, s, r, n) {
    const a = KH.get(e) || { overUse: 0, underUse: 0, adaptationList: $H(r) },
      { adaptationList: o } = a;
    KH.set(e, a);
    const { OVERUSE_TIMES_THRESHOLD: c, UNDERUSE_TIMES_THRESHOLD: d } = VM,
      { scale: l } = s;
    let h, u;
    return ("number" == typeof t &&
      t > 0 &&
      (function(e, t, i, s) {
        if (t >= i.length) return !1;
        let {
          threshold: { fps_down: r }
        } = i[t];
        return (
          WM("FORCE_AG_HIGH_FRAMERATE") &&
            "maintain-framerate" === s &&
            (r = i[0].threshold.fps_down),
          e < r
        );
      })(t, l, o, n) &&
      (a.overUse++, (u = IM.CPU), a.overUse > c)) ||
      ("number" == typeof i &&
        i > 0 &&
        (function(e, t, i) {
          if (t >= i.length) return !1;
          const {
            threshold: { bwe_down: s }
          } = i[t];
          return e < s;
        })(i, l, o) &&
        (a.overUse++, (u = IM.BANDWIDTH), a.overUse > c))
      ? ((a.overUse = 0), (a.underUse = 0), (h = WH(s, o, n, HH.DOWN)), [h, u])
      : ("number" == typeof t &&
          t > 0 &&
          "number" == typeof i &&
          i > 0 &&
          (function(e, t, i, s) {
            if (0 === t) return;
            let {
              threshold: { fps_up: r }
            } = i[t];
            return (
              WM("FORCE_AG_HIGH_FRAMERATE") &&
                "maintain-framerate" === s &&
                (r = i[1].threshold.fps_up),
              e > r
            );
          })(t, l, o, n) &&
          (function(e, t, i) {
            if (0 === t) return;
            const {
              threshold: { bwe_up: s }
            } = i[t];
            return e > s;
          })(i, l, o) &&
          (a.underUse++,
          a.underUse > d &&
            ((a.overUse = 0),
            (a.underUse = 0),
            (h = WH(s, o, n, HH.UP)),
            0 === h.scale && (u = IM.NONE))),
        [h, u]);
  }
  function XH(e) {
    return (
      !!WM("ENABLE_AG_ADAPTATION") &&
      !!(e instanceof IV || e._hints.includes(Hx.CUSTOM_TRACK)) &&
        (!!WM("FORCE_SUPPORT_AG_ADAPTATION") ||
          !!(
            ((function(e) {
              const t = vP();
              if (t.os !== mP.IOS || !t.osVersion) return !1;
              const i = t.osVersion.split(".");
              return Number(i[0]) >= e;
            })(14) &&
              MP(17, 4, !0)) ||
            (kP(14) && UP(17, 4, !0))
          ))
    );
  }
  const zH = new Map();
  function JH(e, t) {
    const i = zH.get(e);
    if (i) {
      const { timer: t } = i;
      window.clearTimeout(t), zH.delete(e);
    }
    (t.qualityLimitationReason = IM.NONE), YH(e);
  }
  function QH(e) {
    const t = Lx();
    if (e.some(e => e._bypassWebAudio))
      throw new JP(
        zP.NOT_SUPPORTED,
        "cannot publish multiple tracks which one of them configured with bypassWebAudio"
      );
    if (!t.webAudioMediaStreamDest)
      throw new JP(
        zP.NOT_SUPPORTED,
        "cannot publish multiple tracks because your browser does not support audio mixing"
      );
  }
  function ZH(e, t) {
    QH(e);
    const i = t || new VB();
    return e.forEach(e => i.addAudioTrack(e)), i;
  }
  const eK = !Lx().supportUnifiedPlan || (WM("CHROME_FORCE_PLAN_B") && KP());
  function tK(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var i;
    return eK
      ? ((i = { spec: t, store: e }), Xj("PlanBConnection").create(i))
      : new nK(t, e);
  }
  function iK(e) {
    return (
      e &&
      ("disconnected" === e.iceConnectionState ||
        "checking" === e.iceConnectionState ||
        "failed" === e.iceConnectionState)
    );
  }
  function sK(e) {
    try {
      if (e.iceServers) return !1;
      if (e.turnServer && "off" !== e.turnServer.mode) {
        if (Tk(e.turnServer.servers)) return !1;
        if (
          WM("FORCE_TURN_TCP") ||
          e.turnServer.servers
            .concat(e.turnServer.serversFromGateway || [])
            .some(e => e.forceturn)
        )
          return !0;
      }
      return !1;
    } catch (e) {
      return !1;
    }
  }
  var rK;
  let nK =
    ((rK = class e extends UG {
      get currentLocalDescription() {
        return this.peerConnection.currentLocalDescription;
      }
      get currentRemoteDescription() {
        return this.peerConnection.currentRemoteDescription;
      }
      get peerConnectionState() {
        return this.peerConnection.connectionState;
      }
      get iceConnectionState() {
        return this.peerConnection.iceConnectionState;
      }
      get dtlsTransportState() {
        var e, t;
        return null !==
          (e =
            null === (t = this.peerConnection.getReceivers()[0]) ||
            void 0 === t ||
            null === (t = t.transport) ||
            void 0 === t
              ? void 0
              : t.state) && void 0 !== e
          ? e
          : null;
      }
      get localCodecs() {
        return [
          ...new Set(
            this.localCapabilities &&
              this.localCapabilities.send.videoCodecs
                .map(
                  e => (e.rtpMap && e.rtpMap.encodingName.toLowerCase()) || ""
                )
                .filter(e => Object.keys(zM).includes(e))
          )
        ];
      }
      constructor(t, i) {
        super(t, i),
          (this.id = Yk(5, "connection-")),
          (this.store = void 0),
          (this.peerConnection = void 0),
          (this.forceTurn = !1),
          (this.remoteSDP = void 0),
          (this.initialOffer = void 0),
          (this.transportEventReceiver = void 0),
          (this.statsFilter = void 0),
          (this.extension = { useXR: WM("USE_XR") }),
          (this.localCapabilities = void 0),
          (this.remoteCodecs = void 0),
          (this.localCandidateCount = 0),
          (this.allCandidatesReceived = !1),
          (this.isPreallocation = !1),
          (this.preSSRCMap = new Map()),
          (this.dataStreamChannelMap = new Map()),
          (this.establishPromise = void 0),
          (this.recoveredDataChannelIds = []),
          (this.currentDataChannelId = 1),
          (this.supportAV1RtpSpec = !1),
          (this.mutex = void 0),
          (this.qualityLimitationReason = IM.NONE),
          (this.isFirstConnected = !1),
          (this.store = i),
          (this.forceTurn = sK(t)),
          (this.mutex = new sM("P2PConnection-mutex", i.clientId)),
          (this.peerConnection = new RTCPeerConnection(
            e.resolvePCConfiguration(t),
            { optional: [{ googDscp: !0 }] }
          )),
          (this.isFirstConnected = !1),
          (this.statsFilter = (function(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 250,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 8,
              s =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 500,
              r =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 1e4;
            const n = (function() {
              const e = navigator.userAgent
                .toLocaleLowerCase()
                .match(/chrome\/[\d]*/i);
              return e && e[0] ? Number(e[0].split("/")[1]) : null;
            })();
            return n
              ? n < 76
                ? new AM(e, {
                    updateInterval: t,
                    lossRateInterval: i,
                    freezeRateLimit: s,
                    firstVideoDecodedTimeout: r
                  })
                : new LM(e, {
                    updateInterval: t,
                    lossRateInterval: i,
                    freezeRateLimit: s,
                    firstVideoDecodedTimeout: r
                  })
              : (function(e) {
                  if (!window.RTCStatsReport) return !1;
                  const t = e.getStats();
                  return !!(
                    t instanceof Promise ||
                    (function(e) {
                      return (
                        !!e &&
                        ("object" == typeof e || "function" == typeof e) &&
                        "function" == typeof e.then
                      );
                    })(t)
                  );
                })(e)
              ? new LM(e, {
                  updateInterval: t,
                  lossRateInterval: i,
                  freezeRateLimit: s,
                  firstVideoDecodedTimeout: r
                })
              : new NM(e, {
                  updateInterval: t,
                  lossRateInterval: i,
                  freezeRateLimit: s,
                  firstVideoDecodedTimeout: r
                });
          })(
            this.peerConnection,
            WM("STATS_UPDATE_INTERVAL"),
            void 0,
            DP() ? 1200 : void 0
          )),
          this.bindPCEvents(),
          this.bindStatsEvents(),
          (this.store.p2pId = this.store.p2pId + 1),
          (this.establishPromise = this.establish());
      }
      getPreMedia(e) {
        const t = this.preSSRCMap.get(e);
        if (void 0 !== t) {
          const e = this.peerConnection
            .getTransceivers()
            .find(e => e.mid === t);
          if (e) return { transceiver: e, track: e.receiver.track, id: t };
        }
      }
      async updateRemoteRTPCapabilities(e, t) {
        if (((this.remoteCodecs = t), !this.remoteSDP))
          return void EU.debug(
            "[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: "
              .concat(this.localCodecs, ", codecs: ")
              .concat(t)
          );
        if (this.remoteSDP.updateRemoteCodec(e, t, this.store.codec)) {
          const e = await this.peerConnection.createOffer(),
            t = this.logSDPExchange(e.sdp || "", "offer", "local", "muteLocal");
          await this.peerConnection.setLocalDescription(e);
          const i = this.remoteSDP.toString();
          null == t || t(i),
            await this.peerConnection.setRemoteDescription({
              type: "answer",
              sdp: i
            });
        } else
          EU.debug(
            "[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP."
          );
      }
      async establish() {
        try {
          this.peerConnection.addTransceiver("video", {
            direction: "recvonly"
          }),
            this.peerConnection.addTransceiver("audio", {
              direction: "recvonly"
            });
          const i = await this.peerConnection.createOffer();
          if (!i.sdp)
            throw new Error(
              "Cannot get initialOffer.sdp when trying to establish PeerConnection."
            );
          const s = wj(i.sdp),
            r = await Uj(
              {
                filterRTX: !WM("USE_PUB_RTX") && !WM("USE_SUB_RTX"),
                filterVideoFec: WM("FILTER_VIDEO_FEC"),
                filterAudioFec: WM("FILTER_AUDIO_FEC"),
                filterVideoCodec: WM("FILTER_VIDEO_CODEC")
              },
              this.extension
            );
          if (
            ((this.localCapabilities = Fj(r)),
            (this.initialOffer = i),
            WM("ENABLE_SVC") && "av1" == this.store.codec)
          ) {
            const t = await (async function() {
              try {
                const e = new RTCPeerConnection();
                e.addTransceiver("video", {
                  direction: "sendonly",
                  sendEncodings: [{ scalabilityMode: CM.L1T3 }]
                });
                const t = await e.createOffer();
                if (!t.sdp) return void e.close();
                const i = sU(t.sdp).mediaDescriptions[0];
                if (!i) return;
                const s = i.attributes.extmaps.find(
                  e =>
                    "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension" ===
                    e.extensionName
                );
                return e.close(), s;
              } catch (e) {
                return;
              }
            })();
            var e;
            if (t)
              (this.supportAV1RtpSpec = !0),
                null === (e = r.send) ||
                  void 0 === e ||
                  e.videoExtensions.push(t);
          }
          let n;
          return (
            i.sdp &&
              Wj(i.sdp) &&
              ((n = kk(r)),
              (t = n).send &&
                (Cj(xG.VIDEO, t.send.videoExtensions),
                Cj(xG.AUDIO, t.send.audioExtensions)),
              t.recv &&
                (Cj(xG.VIDEO, t.recv.videoExtensions),
                Cj(xG.AUDIO, t.recv.audioExtensions)),
              t.sendrecv &&
                (Cj(xG.VIDEO, t.sendrecv.videoExtensions),
                Cj(xG.AUDIO, t.sendrecv.audioExtensions))),
            rG(rG({}, s), {}, { rtpCapabilities: n || r, offerSDP: i.sdp })
          );
        } catch (e) {
          throw new JP(zP.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());
        }
        var t;
      }
      async connect(e) {
        try {
          if (!this.initialOffer)
            throw new Error(
              "Cannot establish P2PConnection without initial offer."
            );
          this.initialOffer.sdp &&
            Wj(this.initialOffer.sdp) &&
            ((t = e.rtpCapabilities),
            (i = this.localCapabilities),
            t.send &&
              (Ij(xG.VIDEO, t.send.videoExtensions, i.send.videoExtensions),
              Ij(xG.AUDIO, t.send.audioExtensions, i.send.audioExtensions)),
            t.recv &&
              (Ij(xG.VIDEO, t.recv.videoExtensions, i.recv.videoExtensions),
              Ij(xG.AUDIO, t.recv.audioExtensions, i.recv.audioExtensions))),
            (this.remoteSDP = new jH(
              rG(rG({}, e), {}, { localCapabilities: this.localCapabilities }),
              this.supportAV1RtpSpec
            )),
            e.preallocation && (this.isPreallocation = !0),
            Array.isArray(this.remoteCodecs) &&
              this.remoteCodecs.length > 0 &&
              this.remoteSDP.updateRemoteCodec(
                [],
                this.remoteCodecs,
                this.store.codec
              );
          const s = this.remoteSDP.toString(),
            r = Hj(this.initialOffer.sdp, this.extension),
            n = this.logSDPExchange(r || "", "offer", "local", "connect");
          this.store.descriptionStart(),
            await this.peerConnection.setLocalDescription({
              type: "offer",
              sdp: r
            }),
            null == n || n(s),
            await this.peerConnection.setRemoteDescription({
              type: "answer",
              sdp: s
            });
          const a = this.peerConnection.getTransceivers()[0];
          if (
            (null != a && a.receiver && this.tryBindTransportEvents(a.receiver),
            WM("PRELOAD_MEDIA_COUNT") > 0)
          ) {
            this.remoteSDP.preloadRemoteMedia(WM("PRELOAD_MEDIA_COUNT"));
            const e = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({
              type: "offer",
              sdp: e
            });
            const t = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(t);
          }
          const { preSSRCs: o } = e;
          if (Array.isArray(o) && o.length > 0) {
            const { mids: e } = this.remoteSDP.batchSend(
              o.map(e => ({
                kind: e.kind,
                ssrcMsg: [{ ssrcId: e.ssrcId, rtx: e.rtx }],
                mslabel: e.mslabel
              }))
            );
            e.forEach((e, t) => {
              this.preSSRCMap.set(o[t].ssrcId, e);
            }),
              await jj(this.peerConnection, this.remoteSDP, this.extension),
              EU.debug(
                "[".concat(
                  this.store.clientId,
                  "] [P2PConnection] pre-batchReceive exchange SDP."
                )
              );
          }
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.connect failed; ".concat(e.toString())
          );
        }
        var t, i;
      }
      async updateRemoteConnect(e) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.updateRemoteConnect before remote SDP created"
            );
          const { rtpCapabilities: t } = e;
          this.remoteSDP.updateRemoteRTPCapabilities(t),
            Array.isArray(this.remoteCodecs) &&
              this.remoteCodecs.length > 0 &&
              this.remoteSDP.updateRemoteCodec(
                [],
                this.remoteCodecs,
                this.store.codec
              );
          const { preSSRCs: i } = e;
          if (Array.isArray(i) && i.length > 0) {
            const { mids: e } = this.remoteSDP.batchSend(
              i.map(e =>
                Object.assign(
                  {},
                  {
                    kind: e.kind,
                    ssrcMsg: [{ ssrcId: e.ssrcId, rtx: e.rtx }],
                    mslabel: e.mslabel
                  }
                )
              )
            );
            e.forEach((e, t) => {
              this.preSSRCMap.set(i[t].ssrcId, e);
            });
          }
          await jj(this.peerConnection, this.remoteSDP, this.extension),
            EU.debug(
              "[P2PConnection] updateRemoteRTPCapabilities by exchanging SDP."
            );
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.updateRemoteConnect failed; ".concat(e.toString())
          );
        }
      }
      send(e, t, i) {
        var s = this;
        return nG(function*() {
          const r = yield tG(s.mutex.lock("From P2PConnection.send"));
          try {
            if (!s.remoteSDP)
              throw new Error(
                "Cannot call P2PConnection.send before remote SDP created"
              );
            const n = [],
              a = yj();
            e.forEach(e => {
              const t = s.peerConnection.addTransceiver(
                e._mediaStreamTrack,
                rG(
                  { direction: "sendonly" },
                  "video" === e.trackMediaType && s.supportAV1RtpSpec && a
                    ? { sendEncodings: [{ scalabilityMode: a }] }
                    : {}
                )
              );
              n.push(t), e._updateRtpTransceiver(t);
            }),
              DP() &&
                !0 === WM("SIMULCAST") &&
                (yield tG(s.applySimulcastForFirefox(n, e)));
            const o = yield tG(s.peerConnection.createOffer()),
              c = s.remoteSDP.predictReceivingMids(e.length),
              d = s.mungSendOfferSDP(o.sdp, e, c),
              l = sU(d),
              h = c.map(e => {
                const t = l.mediaDescriptions.find(t => t.attributes.mid === e);
                if (!t)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return (function(e, t) {
                  const i = [],
                    s = e.attributes.ssrcGroups.filter(
                      e => "FID" === e.semantic
                    ),
                    r = e.attributes.ssrcGroups.find(e => "SIM" === e.semantic),
                    n = e.attributes.ssrcs;
                  if (r)
                    r.ssrcIds.forEach(e => {
                      var r;
                      const n =
                        null === (r = s.find(t => t.ssrcIds[0] === e)) ||
                        void 0 === r
                          ? void 0
                          : r.ssrcIds[1];
                      i.push({ ssrcId: e, rtx: t ? n : void 0 });
                    });
                  else if (s.length > 0) {
                    const e = s[0].ssrcIds[0],
                      r = s[0].ssrcIds[1];
                    i.push({ ssrcId: e, rtx: t ? r : void 0 });
                  } else {
                    if (0 === n.length)
                      throw new Error(
                        "No ssrcs found on local media description."
                      );
                    i.push({ ssrcId: n[0].ssrcId });
                  }
                  return i;
                })(t, WM("USE_PUB_RTX"));
              });
            let u;
            try {
              u = yield h;
            } catch (r) {
              (u = []), s.remoteSDP.receive(e, t, i, u);
              const n = s.remoteSDP.toString();
              throw (yield tG(
                s.peerConnection.setLocalDescription({ type: "offer", sdp: d })
              ),
              yield tG(
                s.peerConnection.setRemoteDescription({
                  type: "answer",
                  sdp: n
                })
              ),
              yield tG(s.stopSending(c, !0)),
              r);
            }
            s.remoteSDP.receive(e, t, i, u);
            const p = s.remoteSDP.toString(),
              f = s.logSDPExchange(d, "offer", "local", "send");
            return (
              yield tG(
                s.peerConnection.setLocalDescription({ type: "offer", sdp: d })
              ),
              yield tG(s.applySimulcastEncodings(n, e)),
              yield tG(s.applySendEncodings(n, e)),
              null == f || f(p),
              yield tG(
                s.peerConnection.setRemoteDescription({
                  type: "answer",
                  sdp: p
                })
              ),
              n.map((e, t) => {
                const i = c[t];
                return { localSSRC: h[t], id: i, transceiver: e };
              })
            );
          } catch (e) {
            throw e instanceof JP
              ? e
              : new JP(
                  zP.EXCHANGE_SDP_FAILED,
                  "P2PConnection.send failed; ".concat(e.toString())
                );
          } finally {
            r();
          }
        })();
      }
      async createDataChannels(e, t) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.createDataChannels before remote SDP created"
            );
          let i = this.dataStreamChannelMap.get(e);
          if (i && "open" === i.readyState)
            EU.debug(
              "[P2PConnection] Channels are already available and can be reused directly."
            );
          else {
            const t =
              this.currentDataChannelId < 1023
                ? this.currentDataChannelId++
                : this.recoveredDataChannelIds.shift();
            if ("number" != typeof t)
              throw new Error(
                "create DataChannel error, because cannot get dc id"
              );
            (i = this.peerConnection.createDataChannel("datastream-channel", {
              id: t,
              negotiated: !0,
              ordered: !1,
              maxRetransmits: WM("DATASTREAM_MAX_RETRANSMITS")
            })),
              (i.binaryType = "arraybuffer"),
              this.dataStreamChannelMap.set(e, i);
          }
          t.forEach(e => {
            e._updateOriginDataChannel(i);
          });
          const { needExchangeSDP: s } = this.remoteSDP.sendDataChannel();
          if (s) {
            const e = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({
              type: "offer",
              sdp: e
            });
            const t = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(t),
              EU.debug("[P2PConnection] createDataChannels by exchanging SDP.");
          } else
            EU.debug(
              "[P2PConnection] createDataChannels no need to exchange SDP."
            );
          return;
        } catch (e) {
          throw e instanceof JP
            ? e
            : new JP(
                zP.EXCHANGE_SDP_FAILED,
                "P2PConnection.createDataChannels failed; ".concat(e.toString())
              );
        }
      }
      async stopDataChannels(e) {
        try {
          const t = this.dataStreamChannelMap.get(e);
          return (
            t && (t.id && this.recoveredDataChannelIds.push(t.id), t.close()),
            void this.dataStreamChannelMap.delete(e)
          );
        } catch (e) {
          throw e instanceof JP
            ? e
            : new JP(
                zP.DATACHANNEL_FAILED,
                "P2PConnection.stopDataChannels failed; ".concat(e.toString())
              );
        }
      }
      async stopSending(e, t) {
        const i = t
          ? void 0
          : await this.mutex.lock("From P2PConnection.stopSending");
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.stopSending before remote SDP created"
            );
          const t = this.peerConnection
            .getTransceivers()
            .filter(t => -1 !== e.indexOf(t.mid));
          if (t.length !== e.length)
            throw new Error(
              "Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending."
            );
          t.map(e => {
            var t;
            JH(this.id + e.mid, this),
              (e.direction = "inactive"),
              null === (t = e.stop) || void 0 === t || t.call(e);
          });
          const s = await this.peerConnection.createOffer(),
            r = this.logSDPExchange(
              s.sdp || "",
              "offer",
              "local",
              "stopSending"
            );
          await this.peerConnection.setLocalDescription(s),
            this.remoteSDP.stopReceiving(e);
          const n = this.remoteSDP.toString();
          null == r || r(n),
            await this.peerConnection.setRemoteDescription({
              type: "answer",
              sdp: n
            });
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.stopSending failed; ".concat(e.toString())
          );
        } finally {
          i && i();
        }
      }
      async receive(e, t, i, s) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.receive ".concat(
                e,
                " before remoteSDP created."
              )
            );
          const { mid: r, needExchangeSDP: n } = this.remoteSDP.send(
            e,
            t,
            i,
            s
          );
          n &&
            (await jj(this.peerConnection, this.remoteSDP, this.extension),
            EU.debug(
              "["
                .concat(this.store.clientId, "] [P2PConnection] receive ")
                .concat(e, " by exchanging SDP.")
            ));
          const a = this.peerConnection
            .getTransceivers()
            .find(e => e.mid === r);
          if (!a)
            throw new Error(
              "Cannot get transceiver after setLocalDescription."
            );
          return { track: a.receiver.track, id: r, transceiver: a };
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.receive failed; ".concat(e.toString())
          );
        }
      }
      async batchReceive(e) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.batchReceive before remoteSDP created."
            );
          const { mids: t, needExchangeSDP: i } = this.remoteSDP.batchSend(e);
          return (
            i &&
              (await jj(this.peerConnection, this.remoteSDP, this.extension),
              EU.debug(
                "[".concat(
                  this.store.clientId,
                  "] [P2PConnection] batchReceive by exchanging SDP."
                )
              )),
            t.map(e => {
              const t = this.peerConnection
                .getTransceivers()
                .find(t => t.mid === e);
              if (!t)
                throw new Error(
                  "Cannot get transceiver after setLocalDescription."
                );
              return { track: t.receiver.track, id: e, transceiver: t };
            })
          );
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.receive failed; ".concat(e.toString())
          );
        }
      }
      async stopReceiving(e) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.stopReceiving before remote SDP created."
            );
          e.forEach(e => {
            Array.from(this.preSSRCMap.entries()).some(t => {
              let [i, s] = t;
              if (s === e) return this.preSSRCMap.delete(i), !0;
            });
          }),
            this.remoteSDP.stopSending(e);
          const t = this.remoteSDP.toString(),
            i = this.logSDPExchange(t, "offer", "remote", "stopReceiving");
          await this.peerConnection.setRemoteDescription({
            type: "offer",
            sdp: t
          });
          const s = await this.peerConnection.createAnswer();
          null == i || i(s.sdp || ""),
            await this.peerConnection.setLocalDescription(s);
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection stopReceiving failed; ".concat(e.toString())
          );
        }
      }
      async muteRemote(e) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.muteRemote mid=".concat(
                e,
                " before remote SDP created."
              )
            );
          this.remoteSDP.mute(e);
          const t = this.remoteSDP.toString(),
            i = this.logSDPExchange(t, "offer", "remote", "muteRemote");
          await this.peerConnection.setRemoteDescription({
            type: "offer",
            sdp: t
          });
          const s = await this.peerConnection.createAnswer();
          null == i || i(s.sdp || ""),
            await this.peerConnection.setLocalDescription(s);
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.muteRemote failed; ".concat(e.toString())
          );
        }
      }
      async unmuteRemote(e) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.unmuteRemote mid=".concat(
                e,
                " before remote SDP created."
              )
            );
          this.remoteSDP.unmute(e);
          const t = this.remoteSDP.toString(),
            i = this.logSDPExchange(t, "offer", "remote", "unmuteRemote");
          await this.peerConnection.setRemoteDescription({
            type: "offer",
            sdp: t
          });
          const s = await this.peerConnection.createAnswer();
          null == i || i(s.sdp || ""),
            await this.peerConnection.setLocalDescription(s);
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.unmuteRemote failed; ".concat(e.toString())
          );
        }
      }
      async muteLocal(e) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.muteLocal before remote SDP created."
            );
          const t = this.peerConnection
            .getTransceivers()
            .filter(t => t.mid && -1 !== e.indexOf(t.mid));
          if (t.length !== e.length)
            throw new Error("Transceivers' length doesn't match mids' length.");
          t.map(e => {
            e.direction = "inactive";
          });
          const i = await this.peerConnection.createOffer(),
            s = this.logSDPExchange(i.sdp || "", "offer", "local", "muteLocal");
          await this.peerConnection.setLocalDescription(i),
            this.remoteSDP.muteRemote(e);
          const r = this.remoteSDP.toString();
          null == s || s(r),
            await this.peerConnection.setRemoteDescription({
              type: "answer",
              sdp: r
            });
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.muteLocal failed; ".concat(e.toString())
          );
        }
      }
      async unmuteLocal(e) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.unmuteLocal before remote SDP created."
            );
          const t = this.peerConnection
            .getTransceivers()
            .filter(t => t.mid && -1 !== e.indexOf(t.mid));
          if (t.length !== e.length)
            throw new Error("Transceivers' length doesn't match mids' length.");
          t.map(async (e, t) => {
            e.direction = "sendonly";
          });
          const i = await this.peerConnection.createOffer(),
            s = this.logSDPExchange(
              i.sdp || "",
              "offer",
              "local",
              "unmuteLocal"
            );
          await this.peerConnection.setLocalDescription(i),
            this.remoteSDP.unmuteRemote(e),
            Array.isArray(this.remoteCodecs) &&
              this.remoteCodecs.length > 0 &&
              this.remoteSDP.updateRemoteCodec(
                e,
                this.remoteCodecs,
                this.store.codec
              );
          const r = this.remoteSDP.toString();
          null == s || s(r),
            await this.peerConnection.setRemoteDescription({
              type: "answer",
              sdp: r
            });
        } catch (e) {
          throw new JP(
            zP.EXCHANGE_SDP_FAILED,
            "P2PConnection.unmuteLocal failed; ".concat(e.toString())
          );
        }
      }
      restartICE(e) {
        var t = this;
        return nG(function*() {
          const i = yield tG(t.mutex.lock("From P2PConnection.restartICE"));
          try {
            if (!t.remoteSDP)
              throw new Error("Cannot restartICE before remoteSDP created.");
            const s = Lx().supportPCSetConfiguration,
              r = WM("FORCE_TURN_TCP") || t.forceTurn;
            if (e === FG.RELAY && !s) return;
            if (s && !r) {
              const i = e === FG.RELAY ? "relay" : "all",
                s = t.peerConnection.getConfiguration();
              s.iceTransportPolicy !== i &&
                (EU.debug(
                  "["
                    .concat(
                      t.store.clientId,
                      "] restartICE change iceTransportPolicy from ["
                    )
                    .concat(s.iceTransportPolicy, "] to [")
                    .concat(i, "]")
                ),
                (s.iceTransportPolicy = i),
                t.peerConnection.setConfiguration(s));
            }
            t.remoteSDP.updateCandidates(e);
            const n = yield tG(
              t.peerConnection.createOffer({ iceRestart: !0 })
            );
            if (!n.sdp)
              throw new Error(
                "Cannot restartICE because restart offer SDP does not exist."
              );
            const a = wj(n.sdp),
              { remoteIceParameters: o } = yield a.iceParameters;
            t.remoteSDP.restartICE(o);
            const c = t.remoteSDP.toString(),
              d = t.logSDPExchange(n.sdp || "", "offer", "local", "restartICE");
            t.store.descriptionStart(),
              yield tG(t.peerConnection.setLocalDescription(n)),
              null == d || d(c),
              yield tG(
                t.peerConnection.setRemoteDescription({
                  type: "answer",
                  sdp: c
                })
              );
          } catch (e) {
            EU.warning(
              "[".concat(
                t.store.clientId,
                "] restart ICE failed, abort operation"
              ),
              e
            );
          } finally {
            i();
          }
        })();
      }
      async extendCandidate() {
        if (!this.remoteSDP || this.isFirstConnected) return;
        const e = await this.mutex.lock("From P2PConnection.extendCandidate");
        try {
          this.remoteSDP.updateCandidates(FG.TCP_RELAY),
            await jj(this.peerConnection, this.remoteSDP, this.extension);
        } catch (e) {
          EU.warning(
            "[".concat(
              this.store.clientId,
              "] extend candidate failed, abort operation"
            ),
            e
          );
        } finally {
          e();
        }
      }
      close() {
        var e;
        this.peerConnection.getTransceivers().forEach(e => {
          JH(this.id + e.mid, this);
        }),
          this.preSSRCMap.clear(),
          this.peerConnection.close(),
          null === (e = this.onConnectionStateChange) ||
            void 0 === e ||
            e.call(this, "closed"),
          this.tryUnbindTransportEvents(),
          this.unbindPCEvents(),
          this.unbindStatsEvents(),
          this.removeAllListeners(),
          (this.transportEventReceiver = void 0),
          this.statsFilter.destroy(),
          this.dataStreamChannelMap.clear(),
          (this.recoveredDataChannelIds = []),
          (this.currentDataChannelId = 1);
      }
      getStats() {
        return rG(
          rG({}, this.statsFilter.getStats()),
          {},
          { qualityLimitationReason: this.qualityLimitationReason }
        );
      }
      getRemoteVideoIsReady(e) {
        return this.statsFilter.getVideoIsReady(e);
      }
      async updateEncoderConfig(e, t) {
        try {
          if (!this.remoteSDP)
            throw new Error(
              "Cannot call P2PConnection.updateEncoderConfig before remote SDP created."
            );
          const i = await this.peerConnection.createOffer(),
            s = this.mungSendOfferSDP(i.sdp, [t], [e]);
          this.remoteSDP.updateRecvMedia(e, t);
          const r = this.remoteSDP.toString(),
            n = this.logSDPExchange(s, "offer", "local", "updateEncoderConfig");
          await this.peerConnection.setLocalDescription({
            type: "offer",
            sdp: s
          }),
            null == n || n(r),
            await this.peerConnection.setRemoteDescription({
              type: "answer",
              sdp: r
            });
        } catch (e) {
          throw new JP(zP.EXCHANGE_SDP_FAILED, e.toString());
        }
      }
      async updateSendParameters(e, t) {
        const i = this.peerConnection
          .getTransceivers()
          .filter(t => t.mid === e);
        1 === i.length &&
          (this.isVP8Simulcast(t)
            ? DP() || (await this.applySimulcastEncodings(i, [t]))
            : await this.applySendEncodings(i, [t]));
      }
      setStatsRemoteVideoIsReady(e, t) {
        this.statsFilter.setVideoIsReady2(e, t);
      }
      async replaceTrack(e, t) {
        const i = this.peerConnection.getTransceivers().find(e => e.mid === t);
        i && (await i.sender.replaceTrack(e._mediaStreamTrack));
      }
      async getSelectedCandidatePair() {
        const e = this.peerConnection.getReceivers();
        if (
          e.length > 0 &&
          e[0].transport &&
          e[0].transport.iceTransport &&
          e[0].transport.iceTransport.getSelectedCandidatePair &&
          e[0].transport.iceTransport.getSelectedCandidatePair()
        ) {
          const t = e[0].transport.iceTransport,
            { local: i, remote: s } = t.getSelectedCandidatePair();
          return {
            local: rG(
              rG({}, gM),
              {},
              {
                candidateType: i.type,
                protocol: i.protocol,
                address: i.address,
                port: i.port
              }
            ),
            remote: rG(
              rG({}, gM),
              {},
              {
                candidateType: s.type,
                protocol: s.protocol,
                address: s.address,
                port: s.port
              }
            )
          };
        }
        return this.statsFilter.getSelectedCandidatePair();
      }
      bindPCEvents() {
        (this.peerConnection.oniceconnectionstatechange = () => {
          var e;
          null === (e = this.onICEConnectionStateChange) ||
            void 0 === e ||
            e.call(this, this.peerConnection.iceConnectionState);
        }),
          (this.peerConnection.onconnectionstatechange = () => {
            var e;
            "connected" === this.peerConnection.connectionState &&
              (this.isFirstConnected = !0),
              null === (e = this.onConnectionStateChange) ||
                void 0 === e ||
                e.call(this, this.peerConnection.connectionState);
          }),
          (this.peerConnection.onicecandidateerror = e => {
            if (e && (e.errorCode || e.errorText)) {
              var t;
              const i = "code: "
                  .concat(e.errorCode, ", message: ")
                  .concat(e.errorText),
                s = e.port ? "local: ".concat(e.port) : "";
              EU.debug(
                "["
                  .concat(this.store.clientId, "] [p2pId: ")
                  .concat(
                    this.store.p2pId,
                    "]: P2PConnection.onICECandidateError("
                  )
                  .concat(i, "), url: ")
                  .concat(e.url || "", ", host_candidate:")
                  .concat(s)
              ),
                null === (t = this.onICECandidateError) ||
                  void 0 === t ||
                  t.call(this, i);
            }
          }),
          (this.peerConnection.onicegatheringstatechange = e => {
            e &&
              e.target &&
              "iceGatheringState" in e.target &&
              EU.debug(
                "["
                  .concat(this.store.clientId, "] [pc-")
                  .concat(
                    this.store.p2pId,
                    "] RTCPeerConnection.onicegatheringstatechange("
                  )
                  .concat(e.target.iceGatheringState, ")")
              );
          }),
          (this.peerConnection.onicecandidate = e => {
            e.candidate
              ? (this.localCandidateCount += 1)
              : ((this.peerConnection.onicecandidate = null),
                (this.allCandidatesReceived = !0),
                EU.debug(
                  "["
                    .concat(this.store.clientId, "] [pc-")
                    .concat(this.store.p2pId, "] local candidate count"),
                  this.localCandidateCount
                ));
          }),
          setTimeout(() => {
            this.allCandidatesReceived ||
              ((this.allCandidatesReceived = !0),
              EU.debug(
                "["
                  .concat(this.store.clientId, "] [pc-")
                  .concat(
                    this.store.p2pId,
                    "] onicecandidate timeout, local candidate count"
                  ),
                this.localCandidateCount
              ));
          }, WM("CANDIDATE_TIMEOUT"));
      }
      unbindPCEvents() {
        (this.peerConnection.oniceconnectionstatechange = null),
          (this.peerConnection.onconnectionstatechange = null),
          (this.peerConnection.onsignalingstatechange = null),
          (this.peerConnection.onicecandidateerror = null),
          (this.peerConnection.onicecandidate = null),
          (this.peerConnection.ontrack = null);
      }
      static resolvePCConfiguration(t) {
        const i = { iceServers: [] };
        return (
          t.iceServers
            ? (i.iceServers = t.iceServers)
            : t.turnServer &&
              (Tk(t.turnServer.servers)
                ? (i.iceServers = t.turnServer.servers)
                : WM("NEW_TURN_MODE") && i.iceServers
                ? (WM("USE_TURN_SERVER_OF_GATEWAY")
                    ? t.turnServer.serversFromGateway &&
                      i.iceServers.push(
                        ...e.newTurnServerConfigToIceServers(
                          t.turnServer.serversFromGateway
                        )
                      )
                    : i.iceServers.push(
                        ...e.newTurnServerConfigToIceServers(
                          t.turnServer.servers
                        )
                      ),
                  WM("NEW_FORCE_TURN") && (i.iceTransportPolicy = "relay"))
                : "off" !== t.turnServer.mode &&
                  (i.iceServers &&
                    i.iceServers.push(
                      ...e.turnServerConfigToIceServers(t.turnServer.servers)
                    ),
                  WM("USE_TURN_SERVER_OF_GATEWAY") &&
                    i.iceServers &&
                    t.turnServer.serversFromGateway &&
                    i.iceServers.push(
                      ...e.turnServerConfigToIceServers(
                        t.turnServer.serversFromGateway
                      )
                    ),
                  WM("FORCE_TURN_TCP")
                    ? (i.iceTransportPolicy = "relay")
                    : t.turnServer.servers
                        .concat(t.turnServer.serversFromGateway || [])
                        .forEach(e => {
                          e.forceturn && (i.iceTransportPolicy = "relay");
                        }))),
          WM("ENABLE_ENCODED_TRANSFORM") &&
            Lx().supportWebRTCEncodedTransform &&
            (i.encodedInsertableStreams = !0),
          i
        );
      }
      static turnServerConfigToIceServers(e) {
        const t = [];
        return (
          e.forEach(e => {
            e.security
              ? e.tcpport &&
                t.push({
                  username: e.username,
                  credential: e.password,
                  credentialType: "password",
                  urls: "turns:"
                    .concat(fj(e.turnServerURL), ":")
                    .concat(e.tcpport, "?transport=tcp")
                })
              : (e.udpport &&
                  !WM("FORCE_TURN_TCP") &&
                  t.push({
                    username: e.username,
                    credential: e.password,
                    credentialType: "password",
                    urls: "turn:"
                      .concat(e.turnServerURL, ":")
                      .concat(e.udpport, "?transport=udp")
                  }),
                e.tcpport &&
                  t.push({
                    username: e.username,
                    credential: e.password,
                    credentialType: "password",
                    urls: "turn:"
                      .concat(e.turnServerURL, ":")
                      .concat(e.tcpport, "?transport=tcp")
                  }));
          }),
          t
        );
      }
      static newTurnServerConfigToIceServers(e) {
        const t = [];
        return (
          e.forEach(e => {
            const i = WM("NEW_TURN_MODE");
            1 === i
              ? t.push({
                  username: e.username,
                  credential: e.password,
                  credentialType: "password",
                  urls: "turn:".concat(e.turnServerURL, ":3478?transport=udp")
                })
              : 2 === i
              ? t.push({
                  username: e.username,
                  credential: e.password,
                  credentialType: "password",
                  urls: "turn:".concat(e.turnServerURL, ":3478?transport=tcp")
                })
              : 3 === i
              ? t.push({
                  username: e.username,
                  credential: e.password,
                  credentialType: "password",
                  urls: "turns:".concat(
                    fj(e.turnServerURL),
                    ":443?transport=tcp"
                  )
                })
              : 4 === i &&
                (t.push({
                  username: e.username,
                  credential: e.password,
                  credentialType: "password",
                  urls: "turn:".concat(e.turnServerURL, ":3478?transport=udp")
                }),
                t.push({
                  username: e.username,
                  credential: e.password,
                  credentialType: "password",
                  urls: "turn:".concat(e.turnServerURL, ":3478?transport=tcp")
                }),
                t.push({
                  username: e.username,
                  credential: e.password,
                  credentialType: "password",
                  urls: "turns:".concat(
                    fj(e.turnServerURL),
                    ":443?transport=tcp"
                  )
                }));
          }),
          t
        );
      }
      tryBindTransportEvents(e) {
        const t = e.transport;
        if (t) {
          (this.transportEventReceiver = e),
            (t.onstatechange = () => {
              var e;
              null != t &&
                t.state &&
                (null === (e = this.onDTLSTransportStateChange) ||
                  void 0 === e ||
                  e.call(this, t.state));
            }),
            (t.onerror = e => {
              var t;
              null === (t = this.onDTLSTransportError) ||
                void 0 === t ||
                t.call(this, "error" in e ? e.error : e);
            });
          const i = t.iceTransport;
          i &&
            ((i.onstatechange = () => {
              const e = null == t ? void 0 : t.iceTransport.state;
              var i;
              e &&
                (null === (i = this.onICETransportStateChange) ||
                  void 0 === i ||
                  i.call(this, e));
            }),
            i.getSelectedCandidatePair &&
              (i.onselectedcandidatepairchange = () => {
                if (i.getSelectedCandidatePair()) {
                  const { local: e, remote: t } = i.getSelectedCandidatePair();
                  EU.info(
                    "["
                      .concat(this.store.clientId, "] [pc-")
                      .concat(
                        this.store.p2pId,
                        "] selectedcandidatepairchange: local "
                      )
                      .concat(
                        JSON.stringify({
                          candidateType: e.type,
                          protocol: e.protocol
                        }),
                        ", remote "
                      )
                      .concat(
                        JSON.stringify({
                          candidateType: t.type,
                          protocol: t.protocol,
                          address: t.address,
                          port: t.port
                        }),
                        " )"
                      )
                  );
                }
              }));
        }
      }
      tryUnbindTransportEvents() {
        this.transportEventReceiver &&
          this.transportEventReceiver.transport &&
          ((this.transportEventReceiver.transport.onstatechange = null),
          (this.transportEventReceiver.transport.onerror = null),
          this.transportEventReceiver.transport.iceTransport &&
            (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
      }
      async updateRtpSenderEncodings(e, t) {
        var i;
        if (!t) {
          const i = this.peerConnection.getSenders();
          t = i.find(t => t.track === e._mediaStreamTrack);
        }
        if (!t)
          return EU.warn("[".concat(e.getTrackId(), "] no rtpSender found}"));
        if (this.isVP8Simulcast(e))
          return EU.warn(
            "[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings"
          );
        if (!Lx().supportSetRtpSenderParameters)
          return EU.warn(
            "[updateRtpSenderEncodings] Browser not support set rtp-sender parameters"
          );
        const s = {},
          r = {};
        switch (e._optimizationMode) {
          case "motion":
            s.degradationPreference = "maintain-framerate";
            break;
          case "detail":
            s.degradationPreference = "maintain-resolution";
            break;
          case "balanced":
            s.degradationPreference = "balanced";
        }
        const n = (function(e, t) {
            return e
              .getTransceivers()
              .find(e => e.sender.track === t || e.receiver.track === t);
          })(this.peerConnection, e._mediaStreamTrack),
          a = XF(e);
        if (
          XH(e) &&
          n &&
          t &&
          a &&
          this.getLocalVideoStats &&
          ["vp8", "vp9"].includes(this.store.codec)
        ) {
          const i =
            s.degradationPreference ||
            (e._hints.includes(Hx.CUSTOM_TRACK)
              ? WM("CUSTOM_ADAPTATION_DEFAULT_MODE")
              : "maintain-framerate");
          !(function(e, t, i, s, r, n) {
            if (
              (JH(e, i),
              r(t),
              "balanced" !== s &&
                "maintain-framerate" !== s &&
                "maintain-resolution" !== s)
            )
              return;
            let a = -1;
            YH(e, t);
            const o = window.setInterval(() => {
                const o = zH.get(e);
                if (!WM("ENABLE_AG_ADAPTATION") || !o)
                  return JH(e, i), void r(t);
                const c = n();
                if (c.sendPackets > 0 && c.OutgoingAvailableBandwidth > 0) {
                  if (-1 === a) return void (a = Date.now());
                  if (Date.now() - a < 1e3) return;
                  const n = c.sendFrameRate,
                    d = c.OutgoingAvailableBandwidth,
                    [l, h] = qH(e, n, d, o.adaptationConfig, t, s);
                  h && (i.qualityLimitationReason = h),
                    l &&
                      o.adaptationConfig.scale !== l.scale &&
                      (EU.debug(
                        "["
                          .concat(e, "] applyAdaptation: ")
                          .concat(
                            i.qualityLimitationReason,
                            "\n           sendFps "
                          )
                          .concat(n, ", bwe ")
                          .concat(d, ", switch from ")
                          .concat(o.adaptationConfig.scale, " to ")
                          .concat(l.scale, " ")
                      ),
                      (o.adaptationConfig = rG(rG({}, o.adaptationConfig), l)),
                      r(l));
                }
              }, WM("CHECK_LOCAL_STATS_INTERVAL")),
              c = rG({}, t);
            zH.set(e, {
              timer: o,
              adaptationConfig: c,
              originConfig: t,
              adaptationFunc: r
            }),
              EU.debug(
                "["
                  .concat(e, "] start adaptation, originConfig: ")
                  .concat(JSON.stringify(t), ", degradationPreference: ")
                  .concat(s)
              );
          })(
            this.id + n.mid,
            a,
            this,
            i,
            e => {
              t && this.updateAdaptation(t, e);
            },
            this.getLocalVideoStats.bind(this)
          );
        }
        if (e._encoderConfig) {
          const {
            bitrateMax: t,
            frameRate: i,
            scaleResolutionDownBy: s
          } = e._encoderConfig;
          t && (r.maxBitrate = 1e3 * t),
            (e._hints.includes(Hx.LOW_STREAM) ||
              e.isUseScaleResolutionDownBy) &&
              (i && (r.maxFramerate = mj(i)),
              s && s >= 1 && (r.scaleResolutionDownBy = s));
        }
        const { maxFramerate: o } = WM("ENCODER_CONFIG_LIMIT");
        if (
          (o &&
            "number" == typeof o &&
            (r.maxFramerate = r.maxFramerate ? Math.min(r.maxFramerate, o) : o),
          WM("DSCP_TYPE") && KP())
        ) {
          const e = WM("DSCP_TYPE");
          ["very-low", "low", "medium", "high"].includes(e) &&
            (r.networkPriority = e);
        }
        const c = t.getParameters(),
          d = null === (i = c.encodings) || void 0 === i ? void 0 : i[0];
        DP() && !d && (s.encodings = [r]),
          d && Object.assign(d, r),
          Object.assign(c, s),
          EU.debug(
            "["
              .concat(e.getTrackId(), "] updateRtpSenderEncodings: ")
              .concat(JSON.stringify(c.encodings))
          ),
          await t.setParameters(c),
          await (async function(e, t, i) {
            try {
              var s;
              if (!Lx().supportSetRtpSenderParameters) return;
              if (
                !(function(e) {
                  return "vp9" === e || "av1" === e;
                })(e) ||
                !WM("ENABLE_SVC")
              )
                return;
              const r = {},
                n = {},
                a = t.getParameters(),
                o = null === (s = a.encodings) || void 0 === s ? void 0 : s[0];
              (n.scalabilityMode = yj(i)),
                o && Object.assign(o, n),
                Object.assign(a, r),
                await t.setParameters(a),
                EU.debug(
                  "[updateAdaptation] updateRtpSenderEncodings scalabilityMode success: ".concat(
                    JSON.stringify(a.encodings)
                  )
                );
            } catch (e) {
              EU.debug(
                "[updateAdaptation] updateRtpSenderEncodings scalabilityMode failed",
                e
              );
            }
          })(this.store.codec, t, WM("SVC_MODE"));
      }
      async updateAdaptation(e, t) {
        var i;
        if (!e) return EU.debug("[updateAdaptation] no rtpSender found");
        if (!Lx().supportSetRtpSenderParameters)
          return EU.debug(
            "[updateAdaptation] Browser not support set rtp-sender parameters"
          );
        const s = {},
          { bitrateMax: r, frameRate: n, scaleResolutionDownBy: a } = t;
        r && (s.maxBitrate = 1e3 * r),
          n && (s.maxFramerate = mj(n)),
          a &&
            a >= 1 &&
            ["vp8", "vp9"].includes(this.store.codec) &&
            (s.scaleResolutionDownBy = a);
        const o = e.getParameters(),
          c = null === (i = o.encodings) || void 0 === i ? void 0 : i[0];
        c && Object.assign(c, s), Object.assign(o, {});
        try {
          await e.setParameters(o),
            EU.debug(
              "[updateAdaptation] updateRtpSenderEncodings: ".concat(
                JSON.stringify(o.encodings)
              )
            );
        } catch (t) {
          !("transport" in e) ||
          (e.transport && "connected" === e.transport.state)
            ? "connected" !== this.peerConnectionState
              ? EU.debug("[updateAdaptation] peerConnection not connected}")
              : EU.debug(
                  "[updateAdaptation] updateRtpSenderEncodings failed",
                  t
                )
            : EU.debug("[updateAdaptation] rtpSender transport not connected}");
        }
      }
      async applySendEncodings(e, t) {
        try {
          if (!Lx().supportSetRtpSenderParameters) return;
          if (e.length !== t.length) return;
          for (let i = 0; i < e.length; i++) {
            const s = e[i],
              r = t[i];
            r instanceof AV &&
              !this.isVP8Simulcast(r) &&
              (await this.updateRtpSenderEncodings(r, s.sender));
          }
        } catch (e) {
          EU.debug(
            "[".concat(this.store.clientId, "] Apply RTPSendEncodings failed.")
          );
        }
      }
      mungSendOfferSDP(e, t, i) {
        const s = sU(e);
        return (
          t.forEach((e, t) => {
            const r = i[t],
              n = s.mediaDescriptions.find(e => e.attributes.mid === r);
            n &&
              (kj(n, e),
              (function(e, t, i) {
                if (DP()) return;
                if ("video" !== e.media.mediaType) return;
                if (!(t instanceof AV)) return;
                if ("vp9" !== i && "vp8" !== i) return;
                if ("vp8" === i && !WM("SIMULCAST")) return;
                if ("vp9" === i && WM("ENABLE_SVC")) return;
                if (
                  void 0 === t._scalabilityMode ||
                  t._scalabilityMode.numSpatialLayers <= 1
                )
                  return;
                const s = "vp8" === i ? 2 : t._scalabilityMode.numSpatialLayers,
                  r = e.attributes.ssrcs[0],
                  n = e.attributes.ssrcGroups.find(
                    e => "FID" === e.semantic && e.ssrcIds[0] === r.ssrcId
                  ),
                  a = { semantic: "SIM", ssrcIds: [r.ssrcId] };
                for (let t = 1; t < s; t++)
                  e.attributes.ssrcs.push({
                    ssrcId: r.ssrcId + t,
                    attributes: kk(r.attributes)
                  }),
                    a.ssrcIds.push(r.ssrcId + t),
                    n &&
                      (e.attributes.ssrcs.push({
                        ssrcId: n.ssrcIds[1] + t,
                        attributes: kk(r.attributes)
                      }),
                      e.attributes.ssrcGroups.push({
                        semantic: "FID",
                        ssrcIds: [r.ssrcId + t, n.ssrcIds[1] + t]
                      }));
                e.attributes.ssrcGroups.unshift(a);
              })(n, e, this.store.codec));
          }),
          rU(s)
        );
      }
      bindStatsEvents() {
        (this.statsFilter.onFirstAudioReceived = e => {
          var t;
          null === (t = this.onFirstAudioReceived) ||
            void 0 === t ||
            t.call(this, e);
        }),
          (this.statsFilter.onFirstVideoReceived = e => {
            var t;
            null === (t = this.onFirstVideoReceived) ||
              void 0 === t ||
              t.call(this, e);
          }),
          (this.statsFilter.onFirstAudioDecoded = e => {
            var t;
            null === (t = this.onFirstAudioDecoded) ||
              void 0 === t ||
              t.call(this, e);
          }),
          (this.statsFilter.onFirstVideoDecoded = (e, t, i) => {
            var s;
            null === (s = this.onFirstVideoDecoded) ||
              void 0 === s ||
              s.call(this, e, t, i);
          }),
          (this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {
            var i;
            null === (i = this.onSelectedLocalCandidateChanged) ||
              void 0 === i ||
              i.call(this, e, t);
          }),
          (this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {
            var i;
            null === (i = this.onSelectedRemoteCandidateChanged) ||
              void 0 === i ||
              i.call(this, e, t);
          }),
          (this.statsFilter.onFirstVideoDecodedTimeout = e => {
            var t;
            null === (t = this.onFirstVideoDecodedTimeout) ||
              void 0 === t ||
              t.call(this, e);
          });
      }
      unbindStatsEvents() {
        (this.statsFilter.onFirstAudioReceived = void 0),
          (this.statsFilter.onFirstVideoReceived = void 0),
          (this.statsFilter.onFirstAudioDecoded = void 0),
          (this.statsFilter.onFirstVideoDecoded = void 0),
          (this.statsFilter.onSelectedLocalCandidateChanged = void 0),
          (this.statsFilter.onSelectedRemoteCandidateChanged = void 0),
          (this.statsFilter.onFirstVideoDecodedTimeout = void 0);
      }
      async applySimulcastForFirefox(e, t) {
        if (e.length === t.length)
          for (let a = 0; a < e.length; a++) {
            var i, s, r, n;
            const o = e[a],
              c = t[a];
            if (
              c instanceof AV &&
              !c._hints.includes(Hx.LOW_STREAM) &&
              null !== (i = c._encoderConfig) &&
              void 0 !== i &&
              i.bitrateMax &&
              (null === (s = c._encoderConfig) || void 0 === s
                ? void 0
                : s.bitrateMax) > 200 &&
              null !== (r = c._scalabilityMode) &&
              void 0 !== r &&
              r.numSpatialLayers &&
              (null === (n = c._scalabilityMode) || void 0 === n
                ? void 0
                : n.numSpatialLayers) > 1 &&
              "vp8" === this.store.codec
            ) {
              const e = {},
                t = {
                  high: 1e3 * (c._encoderConfig.bitrateMax - 50),
                  medium: 5e4
                };
              e.encodings = [
                {
                  rid: "m",
                  active: !0,
                  maxBitrate: t.medium,
                  scaleResolutionDownBy: 4
                },
                { rid: "h", active: !0, maxBitrate: t.high }
              ];
              const i = o.sender.getParameters();
              await o.sender.setParameters(Object.assign(i, e));
            }
          }
      }
      async applySimulcastEncodings(e, t) {
        if (!DP() && e.length === t.length)
          for (let i = 0; i < e.length; i++) {
            const s = t[i];
            if (s instanceof AV && this.isVP8Simulcast(s)) {
              const t = e[i],
                r = {},
                n = {
                  high: 1e3 * (s._encoderConfig.bitrateMax - 50),
                  medium: 5e4
                };
              r.encodings = [
                {
                  active: !0,
                  adaptivePtime: !1,
                  networkPriority: "high",
                  priority: "high",
                  maxBitrate: n.high
                },
                {
                  active: !0,
                  adaptivePtime: !1,
                  networkPriority: "low",
                  priority: "low",
                  maxBitrate: n.medium,
                  scaleResolutionDownBy: 4
                }
              ];
              const a = t.sender.getParameters();
              await t.sender.setParameters(Object.assign(a, r));
            }
          }
      }
      isVP8Simulcast(e) {
        var t, i, s, r;
        return !!(
          e instanceof AV &&
          WM("SIMULCAST") &&
          "vp8" === this.store.codec &&
          !e._hints.includes(Hx.LOW_STREAM) &&
          null !== (t = e._encoderConfig) &&
          void 0 !== t &&
          t.bitrateMax &&
          (null === (i = e._encoderConfig) || void 0 === i
            ? void 0
            : i.bitrateMax) > 200 &&
          null !== (s = e._scalabilityMode) &&
          void 0 !== s &&
          s.numSpatialLayers &&
          (null === (r = e._scalabilityMode) || void 0 === r
            ? void 0
            : r.numSpatialLayers) > 1
        );
      }
      logSDPExchange(e, t, i, s) {
        if (WM("SDP_LOGGING"))
          return (
            EU.upload(
              "["
                .concat(this.store.clientId, "] exchanging ")
                .concat(i, " ")
                .concat(t, " SDP during P2PConnection.")
                .concat(s, "\n"),
              e
            ),
            "offer" === t
              ? e => {
                  this.logSDPExchange(
                    e,
                    "answer",
                    "local" === i ? "remote" : "local",
                    s
                  );
                }
              : void 0
          );
      }
      async getRemoteSSRC(e) {
        if (!this.remoteSDP) return;
        const t = this.remoteSDP.getSSRC(e);
        return t && 0 !== t.length ? t[0].ssrcId : void 0;
      }
      setConfiguration(t) {
        if (Lx().supportPCSetConfiguration) {
          const i = e.resolvePCConfiguration(t);
          this.peerConnection.setConfiguration(i);
        }
      }
    }),
    JV(
      rK.prototype,
      "updateRemoteRTPCapabilities",
      [aK],
      Object.getOwnPropertyDescriptor(
        rK.prototype,
        "updateRemoteRTPCapabilities"
      ),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "connect",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "connect"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "updateRemoteConnect",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "updateRemoteConnect"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "createDataChannels",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "createDataChannels"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "receive",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "receive"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "batchReceive",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "batchReceive"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "stopReceiving",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "stopReceiving"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "muteRemote",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "muteRemote"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "unmuteRemote",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "unmuteRemote"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "muteLocal",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "muteLocal"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "unmuteLocal",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "unmuteLocal"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "close",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "close"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "updateEncoderConfig",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "updateEncoderConfig"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "updateSendParameters",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "updateSendParameters"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "replaceTrack",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "replaceTrack"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "updateAdaptation",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "updateAdaptation"),
      rK.prototype
    ),
    JV(
      rK.prototype,
      "getRemoteSSRC",
      [aK],
      Object.getOwnPropertyDescriptor(rK.prototype, "getRemoteSSRC"),
      rK.prototype
    ),
    rK);
  function aK(e, t, i) {
    const s = e[t];
    if ("function" != typeof s)
      throw new Error("Cannot use mutex on object property.");
    return (
      (i.value = async function() {
        const e = this.mutex,
          i = await e.lock("From P2PConnection.".concat(t));
        try {
          for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
            n[a] = arguments[a];
          return await s.apply(this, n);
        } finally {
          i();
        }
      }),
      i
    );
  }
  function oK(e, t) {
    let i = document.createElement("video"),
      s = document.createElement("canvas");
    i.setAttribute("style", "display:none"),
      s.setAttribute("style", "display:none"),
      i.setAttribute("muted", ""),
      (i.muted = !0),
      i.setAttribute("autoplay", ""),
      (i.autoplay = !0),
      i.setAttribute("playsinline", ""),
      (s.width = mj(t.width)),
      (s.height = mj(t.height));
    const r = mj(t.framerate || 15);
    document.body.append(i), document.body.append(s);
    let n = e._mediaStreamTrack;
    (i.srcObject = new MediaStream([n])), i.play();
    const a = s.getContext("2d");
    if (!a) throw new AU(zP.UNEXPECTED_ERROR, "can not get canvas context");
    const o = Lx(),
      c = s.captureStream(o.supportRequestFrame ? 0 : r).getVideoTracks()[0];
    c.canvas || (c.canvas = s),
      (s.startCapture = () => {
        if (!i) return s.stopCapture && s.stopCapture();
        if ((i.paused && i.play(), i.videoHeight > 2 && i.videoWidth > 2)) {
          const e = i.videoWidth,
            t = i.videoHeight / e,
            r = s.width * t;
          Math.abs(r - s.height) >= 2 &&
            (EU.debug(
              "adjust low stream resolution",
              ""
                .concat(s.width, "x")
                .concat(s.height, " -> ")
                .concat(s.width, "x")
                .concat(r)
            ),
            (s.height = r));
        }
        a.drawImage(i, 0, 0, s.width, s.height),
          c.requestFrame && c.requestFrame(),
          n !== e._mediaStreamTrack &&
            ((n = e._mediaStreamTrack), (i.srcObject = new MediaStream([n])));
      }),
      (s.stopCapture = SF(() => s.startCapture && s.startCapture(), r));
    const d = c.stop;
    return (
      (c.stop = () => {
        d.call(c),
          i && (i.remove(), (i.srcObject = null), (i = null)),
          s &&
            ((s.width = 0),
            s.remove(),
            s.stopCapture && s.stopCapture(),
            (s.startCapture = void 0),
            (s.stopCapture = void 0),
            (s = null)),
          EU.debug("clean low stream renderer");
      }),
      c
    );
  }
  var cK = (function(e) {
      return (
        (e[(e.HEIGHT = 2033)] = "HEIGHT"),
        (e[(e.FRAME_RATE = 2034)] = "FRAME_RATE"),
        (e[(e.WIDTH = 2035)] = "WIDTH"),
        e
      );
    })(cK || {}),
    dK = (function(e) {
      return (
        (e[(e.FRAME_RATE = 2002)] = "FRAME_RATE"),
        (e[(e.WIDTH = 2003)] = "WIDTH"),
        (e[(e.HEIGHT = 2004)] = "HEIGHT"),
        (e[(e.PACKAGE_LOST = 2005)] = "PACKAGE_LOST"),
        (e[(e.AVG_ENCODE = 2007)] = "AVG_ENCODE"),
        (e[(e.NACKS = 2009)] = "NACKS"),
        (e[(e.PLIS = 2010)] = "PLIS"),
        (e[(e.FIRS = 2011)] = "FIRS"),
        (e[(e.BITRATE = 2012)] = "BITRATE"),
        (e[(e.PACKAGE_RATE = 2031)] = "PACKAGE_RATE"),
        (e[(e.ADAPTATION = 2032)] = "ADAPTATION"),
        (e[(e.ACTUAL_ENCODED = 2060)] = "ACTUAL_ENCODED"),
        (e[(e.BANDWIDTH = 2061)] = "BANDWIDTH"),
        (e[(e.RETRANSMIT = 2062)] = "RETRANSMIT"),
        (e[(e.TARGET_ENCODED = 2064)] = "TARGET_ENCODED"),
        (e[(e.TRANSMIT = 2066)] = "TRANSMIT"),
        (e[(e.FREEZE = 2082)] = "FREEZE"),
        (e[(e.DISABLED = 2095)] = "DISABLED"),
        (e[(e.PLAYER_STATUS = 2128)] = "PLAYER_STATUS"),
        (e[(e.QP_SUM = 2143)] = "QP_SUM"),
        (e[(e.BYTES_RETRANSMIT = 2173)] = "BYTES_RETRANSMIT"),
        (e[(e.PACKAGES_RETRANSMIT = 2172)] = "PACKAGES_RETRANSMIT"),
        (e[(e.HUGE_FRAME_SENT = 2174)] = "HUGE_FRAME_SENT"),
        (e[(e.KEY_FRAMES_ENCODED = 2207)] = "KEY_FRAMES_ENCODED"),
        e
      );
    })(dK || {}),
    lK = (function(e) {
      return (
        (e[(e.BITRATE = 2069)] = "BITRATE"),
        (e[(e.PACKAGE_LOST = 2070)] = "PACKAGE_LOST"),
        (e[(e.PACKAGE_RATE = 2071)] = "PACKAGE_RATE"),
        (e[(e.HEIGHT = 2073)] = "HEIGHT"),
        (e[(e.FRAME_RATE = 2075)] = "FRAME_RATE"),
        (e[(e.WIDTH = 2077)] = "WIDTH"),
        e
      );
    })(lK || {}),
    hK = (function(e) {
      return (
        (e[(e.JITTER = -1)] = "JITTER"),
        (e[(e.PACKAGE_LOST = 2014)] = "PACKAGE_LOST"),
        (e[(e.WIDTH = 2018)] = "WIDTH"),
        (e[(e.HEIGHT = 2019)] = "HEIGHT"),
        (e[(e.FRAME_RATE = 2020)] = "FRAME_RATE"),
        (e[(e.JITTER_BUFFER = 2023)] = "JITTER_BUFFER"),
        (e[(e.CURRENT_DELAY = 2024)] = "CURRENT_DELAY"),
        (e[(e.NACKS = 2026)] = "NACKS"),
        (e[(e.PLIS = 2027)] = "PLIS"),
        (e[(e.FIRS = 2028)] = "FIRS"),
        (e[(e.BITRATE = 2029)] = "BITRATE"),
        (e[(e.PACKAGE_RATE = 2078)] = "PACKAGE_RATE"),
        (e[(e.FREEZE = 2084)] = "FREEZE"),
        (e[(e.DISABLED = 2101)] = "DISABLED"),
        (e[(e.PLAYER_STATUS = 2129)] = "PLAYER_STATUS"),
        (e[(e.QP_SUM = 2144)] = "QP_SUM"),
        (e[(e.I_FRAME_DELAY = 2149)] = "I_FRAME_DELAY"),
        (e[(e.FRAMES_DROPPED = 2181)] = "FRAMES_DROPPED"),
        (e[(e.BYTES_RETRANSMIT = 2175)] = "BYTES_RETRANSMIT"),
        (e[(e.PACKAGES_RETRANSMIT = 2176)] = "PACKAGES_RETRANSMIT"),
        (e[(e.PACKAGES_DISCARDED = 2198)] = "PACKAGES_DISCARDED"),
        (e[(e.AVG_DECODE = 2200)] = "AVG_DECODE"),
        (e[(e.AVG_PROCESSING_DELAY = 2202)] = "AVG_PROCESSING_DELAY"),
        (e[(e.AVG_ASSEMBLY_TIME = 2203)] = "AVG_ASSEMBLY_TIME"),
        (e[(e.AVG_INTER_FRAME_DELAY = 2204)] = "AVG_INTER_FRAME_DELAY"),
        (e[(e.KEY_FRAMES_DECODED = 2206)] = "KEY_FRAMES_DECODED"),
        e
      );
    })(hK || {}),
    uK = (function(e) {
      return (
        (e[(e.FRAME_RATE_DECODE = 2021)] = "FRAME_RATE_DECODE"),
        (e[(e.FRAME_RATE_RENDER = 2022)] = "FRAME_RATE_RENDER"),
        (e[(e.FRAME_RATE_OUTPUT = 2155)] = "FRAME_RATE_OUTPUT"),
        (e[(e.FREEZE_TIME = 2109)] = "FREEZE_TIME"),
        (e[(e.FREEZE_TIME_RENDER = 2147)] = "FREEZE_TIME_RENDER"),
        (e[(e.FREEZE_DURATION = 2156)] = "FREEZE_DURATION"),
        e
      );
    })(uK || {}),
    pK = (function(e) {
      return (e[(e.PCM_LEVEL = 2104)] = "PCM_LEVEL"), e;
    })(pK || {}),
    fK = (function(e) {
      return (
        (e[(e.PACKAGE_LOST = -1)] = "PACKAGE_LOST"),
        (e[(e.LEVEL = 2038)] = "LEVEL"),
        (e[(e.BITRATE = 2039)] = "BITRATE"),
        (e[(e.PACKAGE_RATE = 2040)] = "PACKAGE_RATE"),
        (e[(e.AEC_RETURN_LOSS = 2041)] = "AEC_RETURN_LOSS"),
        (e[(e.AEC_RETURN_LOSS_ENH = 2042)] = "AEC_RETURN_LOSS_ENH"),
        (e[(e.FREEZE = 2081)] = "FREEZE"),
        (e[(e.DISABLED = 2096)] = "DISABLED"),
        (e[(e.BYTES_RETRANSMIT = 2179)] = "BYTES_RETRANSMIT"),
        (e[(e.PACKAGES_RETRANSMIT = 2180)] = "PACKAGES_RETRANSMIT"),
        e
      );
    })(fK || {}),
    EK = (function(e) {
      return (
        (e[(e.BITRATE = 2044)] = "BITRATE"),
        (e[(e.PACKAGE_LOST = 2045)] = "PACKAGE_LOST"),
        (e[(e.PACKAGE_RATE = 2046)] = "PACKAGE_RATE"),
        (e[(e.CURRENT_DELAY = 2047)] = "CURRENT_DELAY"),
        (e[(e.JITTER_BUFFER = 2054)] = "JITTER_BUFFER"),
        (e[(e.JITTER = 2055)] = "JITTER"),
        (e[(e.FREEZE = 2083)] = "FREEZE"),
        (e[(e.DISABLED = 2102)] = "DISABLED"),
        (e[(e.PCM_LEVEL = 2105)] = "PCM_LEVEL"),
        (e[(e.PLAYER_STATUS = 2130)] = "PLAYER_STATUS"),
        (e[(e.CONCEALED_SAMPLES = 2148)] = "CONCEALED_SAMPLES"),
        (e[(e.BYTES_RETRANSMIT = 2178)] = "BYTES_RETRANSMIT"),
        (e[(e.PACKAGES_RETRANSMIT = 2177)] = "PACKAGES_RETRANSMIT"),
        (e[(e.PACKAGES_DISCARDED = 2199)] = "PACKAGES_DISCARDED"),
        (e[(e.AVG_PROCESSING_DELAY = 2201)] = "AVG_PROCESSING_DELAY"),
        (e[(e.TOTAL_SAMPLES_RECEIVED = 2224)] = "TOTAL_SAMPLES_RECEIVED"),
        e
      );
    })(EK || {}),
    mK = (function(e) {
      return (
        (e[(e.FREEZE_TIME = -1)] = "FREEZE_TIME"),
        (e[(e.LEVEL = 2043)] = "LEVEL"),
        e
      );
    })(mK || {}),
    gK = (function(e) {
      return (
        (e[(e.RTT = 2006)] = "RTT"),
        (e[(e.CONN_TYPE = 801)] = "CONN_TYPE"),
        (e[(e.STATS_UPDATE_INTERVAL = 2205)] = "STATS_UPDATE_INTERVAL"),
        e
      );
    })(gK || {}),
    _K = (function(e) {
      return (
        (e[(e.RTC_PEER_CONNECTION_STATE = 2219)] = "RTC_PEER_CONNECTION_STATE"),
        e
      );
    })(_K || {});
  const TK = 1e3,
    SK = 6,
    vK = 3,
    RK = Math.max(SK, vK);
  function yK(e, t, i) {
    null != i && Number.isFinite(i) && (e[t] = Math.round(Math.max(0, i)));
  }
  function AK(e) {
    const t = {
      [gK.CONN_TYPE]: 0,
      [gK.RTT]: e.rtt,
      [gK.STATS_UPDATE_INTERVAL]: e.updateInterval
        ? Math.round(Math.max(0, e.updateInterval))
        : void 0
    };
    switch (e.selectedCandidatePair.localCandidate.candidateType) {
      case "relay": {
        const i = e.selectedCandidatePair.localCandidate.relayProtocol;
        "udp" === i && (t[gK.CONN_TYPE] = 1),
          "tcp" === i && (t[gK.CONN_TYPE] = 3),
          "tls" === i && (t[gK.CONN_TYPE] = 4);
        break;
      }
      case "srflx":
        t[gK.CONN_TYPE] = 2;
        break;
      case "unknown":
        t[gK.CONN_TYPE] = 5;
        break;
      default:
        t[gK.CONN_TYPE] = 0;
    }
    return t;
  }
  function IK(e) {
    let t = 0;
    switch (e) {
      case "none":
        t = 0;
        break;
      case "cpu":
        t = 1;
        break;
      case "bandwidth":
        t = 2;
        break;
      case "other":
        t = 3;
    }
    return t;
  }
  class CK extends uk {
    constructor(e) {
      super(),
        (this.store = void 0),
        (this.uploadWRTCStatsTimer = void 0),
        (this.uploadOutboundDenoiserStatsTimer = void 0),
        (this.uploadExtStatsTimer = void 0),
        (this.uploadExtUsageStatsTimer = void 0),
        (this.uploadInboundExtStatsTimer = void 0),
        (this.requestStats = void 0),
        (this.requestTransportStats = void 0),
        (this.requestLocalMedia = void 0),
        (this.requestRemoteMedia = void 0),
        (this.requestAllTracks = void 0),
        (this.requestVideoIsReady = void 0),
        (this.requestUploadStats = void 0),
        (this.requestUpload = void 0),
        (this.uploadOutboundStarted = !1),
        (this.uploadInboundStarted = !1),
        (this.uploadTransportStarted = !1),
        (this.uploadBaseStatsStarted = !1),
        (this.uploadExtensionUsageStarted = !1),
        (this.lastRecvStats = void 0),
        (this.lastSendStats = void 0),
        (this.lastRefRecvStats = void 0),
        (this.lastRefSendStats = void 0),
        (this.lastFullRecvStats = void 0),
        (this.lastFullSendStats = void 0),
        (this.needUploadRenderFreezeTime = !0),
        (this.store = e);
    }
    uploadWRTCStats(e) {
      if (!this.requestStats || !this.requestUploadStats) return;
      const t = e % vK == 0,
        i = e % SK == 0;
      let s, r;
      if (
        (this.uploadTransportStarted &&
          ((s = this.requestStats()),
          this.store.useP2P && (r = this.requestStats(!0))),
        !s && this.uploadOutboundStarted && (s = this.requestStats()),
        !r && this.uploadInboundStarted && (r = this.requestStats(!0)),
        s || r)
      ) {
        var n;
        const e = {};
        if (this.uploadTransportStarted && s) {
          const i = this.getTransportStats(s, r, t);
          i && (e.misc = [i]);
        }
        if (this.uploadOutboundStarted && s) {
          const r = this.getOutboundStats(
            s,
            i
              ? this.lastFullSendStats
              : t
              ? this.lastRefSendStats
              : this.lastSendStats,
            t,
            i
          );
          r && (e.outbound = [r]);
        }
        if (this.uploadInboundStarted && r) {
          const s = this.getInboundStats(
            r,
            i
              ? this.lastFullRecvStats
              : t
              ? this.lastRefRecvStats
              : this.lastRecvStats,
            t,
            i
          );
          s && (e.inbound = s);
        }
        const a =
          null === (n = this.requestTransportStats) || void 0 === n
            ? void 0
            : n.call(this).connectState;
        a &&
          (Array.isArray(e.misc)
            ? e.misc[0] &&
              e.misc[0].addition &&
              (e.misc[0].addition[_K.RTC_PEER_CONNECTION_STATE] = bM[a])
            : (e.misc = [
                { addition: { [_K.RTC_PEER_CONNECTION_STATE]: bM[a] } }
              ])),
          this.requestUploadStats(e);
      }
      (this.lastRecvStats = r),
        (this.lastSendStats = s),
        i && ((this.lastFullRecvStats = r), (this.lastFullSendStats = s)),
        t && ((this.lastRefRecvStats = r), (this.lastRefSendStats = s));
    }
    startUploadWRTCStats() {
      if (this.uploadWRTCStatsTimer) return;
      this.uploadBaseStatsStarted = !0;
      let e = 1;
      this.uploadWRTCStatsTimer = window.setInterval(() => {
        if (
          !this.uploadTransportStarted &&
          !this.uploadInboundStarted &&
          !this.uploadOutboundStarted
        ) {
          if (this.uploadBaseStatsStarted) {
            var t, i;
            const e =
              null === (t = this.requestTransportStats) || void 0 === t
                ? void 0
                : t.call(this);
            return void (
              e &&
              (null === (i = this.requestUploadStats) ||
                void 0 === i ||
                i.call(this, {
                  misc: [
                    {
                      addition: {
                        [_K.RTC_PEER_CONNECTION_STATE]: bM[e.connectState]
                      }
                    }
                  ]
                }))
            );
          }
          return this.stopUploadWRTCStats();
        }
        this.uploadWRTCStats(e), ++e === RK + 1 && (e = 1);
      }, TK);
    }
    stopUploadWRTCStats() {
      window.clearInterval(this.uploadWRTCStatsTimer),
        (this.uploadWRTCStatsTimer = void 0),
        this.lastSendStats &&
          ((this.lastSendStats.videoSend = []),
          (this.lastSendStats.audioSend = []),
          (this.lastSendStats = void 0)),
        this.lastRecvStats &&
          ((this.lastRecvStats.videoRecv = []),
          (this.lastRecvStats.audioRecv = []),
          (this.lastRecvStats = void 0));
    }
    getTransportStats(e, t, i) {
      if (!this.requestStats) return;
      if (!i)
        return null == e.rtt
          ? void 0
          : {
              addition: {
                [gK.RTT]: e.rtt,
                [gK.CONN_TYPE]: void 0,
                [gK.STATS_UPDATE_INTERVAL]: e.updateInterval || void 0
              }
            };
      const s = AK(e);
      if (this.store.useP2P) {
        if (t) {
          const e = AK(t);
          s[gK.CONN_TYPE] += e[gK.CONN_TYPE] << 3;
        }
        s[gK.CONN_TYPE] += 110;
      } else s[gK.CONN_TYPE] += 100;
      return { addition: s };
    }
    getOutboundStats(e, t, i, s) {
      if (!this.requestUploadStats || !this.requestLocalMedia) return;
      const r = this.requestLocalMedia();
      if (!r || 0 === r.length) return;
      let n, a, o;
      return (
        r.forEach(r => {
          let [c, { track: d, ssrcs: l }] = r;
          switch (c) {
            case GG.LocalVideoLowTrack:
            case GG.LocalVideoTrack:
              if (c === GG.LocalVideoTrack) {
                const r = (function(e, t, i, s, r, n) {
                    const a = t.videoSend.find(t => t.ssrc === e);
                    if (!a) return;
                    const o = {},
                      { sentFrame: c, inputFrame: d } = a;
                    if (n && (yK(o, dK.QP_SUM, a.qpSumPerFrame), d && c)) {
                      const e = d.frameRate,
                        t = c.frameRate;
                      o[dK.FREEZE] = (function(e, t) {
                        let i = !0;
                        return (
                          (i =
                            !(e <= 5) &&
                            (e <= 10 ? t < 3 : e <= 20 ? t < 4 : t < 5)),
                          i
                        );
                      })(e, t)
                        ? 1
                        : 0;
                    }
                    if (r) {
                      switch (
                        (c &&
                          (yK(o, dK.HEIGHT, c.height),
                          yK(o, dK.WIDTH, c.width),
                          yK(o, dK.FRAME_RATE, c.frameRate)),
                        (o[dK.DISABLED] =
                          (s._originMediaStreamTrack &&
                            !s._originMediaStreamTrack.enabled) ||
                          (s._mediaStreamTrack && !s._mediaStreamTrack.enabled)
                            ? 1
                            : 0),
                        a.adaptionChangeReason)
                      ) {
                        case "none":
                          o[dK.ADAPTATION] = 0;
                          break;
                        case "cpu":
                          o[dK.ADAPTATION] = 1;
                          break;
                        case "bandwidth":
                          o[dK.ADAPTATION] = 2;
                          break;
                        case "other":
                          o[dK.ADAPTATION] = 3;
                      }
                      let n = 0;
                      a.adaptionChangeReason &&
                        (n += IK(a.adaptionChangeReason)),
                        t.qualityLimitationReason &&
                          (n += IK(t.qualityLimitationReason) << 3),
                        (o[dK.ADAPTATION] = n),
                        (o[dK.PLAYER_STATUS] =
                          oF[
                            s._player ? s._player.videoElementStatus : "uninit"
                          ]),
                        yK(o, dK.NACKS, a.nacksCount),
                        yK(o, dK.PLIS, a.plisCount),
                        yK(o, dK.FIRS, a.firsCount),
                        yK(o, dK.AVG_ENCODE, a.avgEncodeMs),
                        yK(o, dK.HUGE_FRAME_SENT, a.hugeFramesSent),
                        yK(o, dK.BYTES_RETRANSMIT, a.retransmittedBytesSent),
                        yK(
                          o,
                          dK.PACKAGES_RETRANSMIT,
                          a.retransmittedPacketsSent
                        ),
                        yK(o, dK.KEY_FRAMES_ENCODED, a.keyFramesEncoded);
                      const d = i && i.videoSend.find(t => t.ssrc === e);
                      if (d) {
                        let e = r ? TK : TK * SK;
                        d.timestamp &&
                          a.timestamp &&
                          (e = a.timestamp - d.timestamp),
                          null != d.packets &&
                            null != a.packets &&
                            yK(
                              o,
                              dK.PACKAGE_RATE,
                              (1e3 * (a.packets - d.packets)) / e
                            ),
                          null != a.packetsLost &&
                            null != d.packetsLost &&
                            yK(
                              o,
                              dK.PACKAGE_LOST,
                              a.packetsLost - d.packetsLost
                            ),
                          null != d.bytes &&
                            null != a.bytes &&
                            yK(o, dK.BITRATE, (8 * (a.bytes - d.bytes)) / e);
                      }
                    }
                    return o;
                  })(l[0].ssrcId, e, t, d, i, s),
                  n =
                    d &&
                    (function(e, t, i, s) {
                      const r = t.videoSend.find(t => t.ssrc === e);
                      if (!r) return null;
                      const n = {};
                      if (s) {
                        const e = r.inputFrame,
                          t = (e && e.height) || i.videoHeight || 0,
                          s = (e && e.width) || i.videoWidth || 0,
                          a = (e && e.frameRate) || 0;
                        yK(n, cK.HEIGHT, t),
                          yK(n, cK.WIDTH, s),
                          yK(n, cK.FRAME_RATE, a);
                      }
                      return n;
                    })(l[0].ssrcId, e, d, i),
                  o = (function(e, t) {
                    const i = {};
                    return (
                      t &&
                        (yK(i, dK.RETRANSMIT, e.bitrate.retransmit),
                        yK(i, dK.TARGET_ENCODED, e.bitrate.targetEncoded),
                        yK(i, dK.ACTUAL_ENCODED, e.bitrate.actualEncoded),
                        yK(i, dK.TRANSMIT, e.bitrate.transmit),
                        yK(i, dK.BANDWIDTH, e.sendBandwidth)),
                      i
                    );
                  })(e, i);
                a = Object.assign({}, r, n, o);
              } else
                o = (function(e, t, i, s) {
                  const r = t.videoSend.find(t => t.ssrc === e);
                  if (!r) return;
                  const n = {};
                  if (s) {
                    const t = r.sentFrame;
                    if (
                      (t &&
                        (yK(n, lK.HEIGHT, t.height),
                        yK(n, lK.WIDTH, t.width),
                        yK(n, lK.FRAME_RATE, t.frameRate)),
                      i)
                    ) {
                      const t = i.videoSend.find(t => t.ssrc === e);
                      if (t) {
                        let e = TK * SK;
                        t.timestamp &&
                          r.timestamp &&
                          (e = r.timestamp - t.timestamp),
                          null != t.packets &&
                            null != r.packets &&
                            yK(
                              n,
                              lK.PACKAGE_RATE,
                              (1e3 * (r.packets - t.packets)) / e
                            ),
                          null != r.packetsLost &&
                            null != t.packetsLost &&
                            yK(
                              n,
                              lK.PACKAGE_LOST,
                              r.packetsLost - t.packetsLost
                            ),
                          null != t.bytes &&
                            null != r.bytes &&
                            yK(n, lK.BITRATE, (8 * (r.bytes - t.bytes)) / e);
                      }
                    }
                  }
                  return n;
                })(l[0].ssrcId, e, t, i);
              break;
            case GG.LocalAudioTrack:
              n =
                d &&
                (function(e, t, i, s, r) {
                  const n = t.audioSend.find(t => t.ssrc === e);
                  if (!n) return;
                  const a = {};
                  if (r) {
                    a[fK.DISABLED] =
                      (s._originMediaStreamTrack &&
                        !s._originMediaStreamTrack.enabled) ||
                      (s._mediaStreamTrack && !s._mediaStreamTrack.enabled)
                        ? 1
                        : 0;
                    const t = 100 * s._source.getAccurateVolumeLevel(),
                      r = n.inputLevel;
                    if (null != r) {
                      const e = Math.ceil(50 * Math.log10(100 * r + 1));
                      yK(a, fK.LEVEL, e);
                    }
                    yK(a, pK.PCM_LEVEL, t),
                      yK(a, fK.AEC_RETURN_LOSS, n.aecReturnLoss),
                      yK(a, fK.AEC_RETURN_LOSS_ENH, n.aecReturnLossEnhancement),
                      yK(a, fK.BYTES_RETRANSMIT, n.retransmittedBytesSent),
                      yK(a, fK.PACKAGES_RETRANSMIT, n.retransmittedPacketsSent),
                      (a[fK.FREEZE] = 0);
                    const o = i && i.audioSend.find(t => t.ssrc === e);
                    if (o) {
                      let e = TK * SK;
                      o.timestamp &&
                        n.timestamp &&
                        (e = n.timestamp - o.timestamp),
                        null != o.bytes &&
                          null != n.bytes &&
                          yK(a, fK.BITRATE, (8 * (n.bytes - o.bytes)) / e),
                        null != o.packets &&
                          null != n.packets &&
                          yK(
                            a,
                            fK.PACKAGE_RATE,
                            (1e3 * (n.packets - o.packets)) / e
                          );
                    }
                  }
                  return a;
                })(l[0].ssrcId, e, t, d, i);
          }
        }),
        { high: a, low: o, audio: n }
      );
    }
    getInboundStats(e, t, i, s) {
      if (!this.requestRemoteMedia) return;
      const r = this.requestRemoteMedia() || [],
        n = [];
      return (
        r.forEach(r => {
          let [a, o] = r;
          const c = { peer: a.uid };
          if (o.has(xG.VIDEO) && a.videoTrack) {
            const r =
                (a._videoSSRC &&
                  this.requestVideoIsReady &&
                  this.requestVideoIsReady(a._videoSSRC)) ||
                !1,
              n = a.videoTrack
                ? (function(e, t, i, s, r, n, a, o) {
                    const c = t.videoRecv.find(t => t.ssrc === e);
                    if (!c) return;
                    const d = {},
                      {
                        receivedFrame: l,
                        outputFrame: h,
                        decodeFrameRate: u
                      } = c,
                      p = i && i.videoRecv.find(t => t.ssrc === e);
                    if (
                      (yK(d, uK.FRAME_RATE_DECODE, u),
                      c.framesRateFirefox &&
                        yK(d, hK.FRAME_RATE, c.framesRateFirefox),
                      l && yK(d, hK.FRAME_RATE, l.frameRate),
                      yK(d, hK.FRAMES_DROPPED, c.framesDroppedCount),
                      yK(d, hK.BYTES_RETRANSMIT, c.retransmittedBytesReceived),
                      yK(
                        d,
                        hK.PACKAGES_RETRANSMIT,
                        c.retransmittedPacketsReceived
                      ),
                      yK(d, hK.PACKAGES_DISCARDED, c.packetsDiscarded),
                      yK(d, hK.AVG_DECODE, c.avgDecodeMs),
                      yK(d, hK.AVG_PROCESSING_DELAY, c.avgProcessingDelayMs),
                      yK(
                        d,
                        hK.AVG_ASSEMBLY_TIME,
                        c.avgFramesAssembledFromMultiplePacketsMs
                      ),
                      yK(d, hK.AVG_INTER_FRAME_DELAY, c.avgInterFrameDelayMs),
                      yK(d, hK.KEY_FRAMES_DECODED, c.keyFramesDecoded),
                      p)
                    ) {
                      const e =
                        t.timestamp - i.timestamp || TK * (o ? SK : a ? vK : 1);
                      null != c.packetsLost &&
                        null != p.packetsLost &&
                        yK(d, hK.PACKAGE_LOST, c.packetsLost - p.packetsLost),
                        null != p.bytes &&
                          null != c.bytes &&
                          yK(d, hK.BITRATE, (8 * (c.bytes - p.bytes)) / e),
                        null != p.packets &&
                          null != c.packets &&
                          yK(
                            d,
                            hK.PACKAGE_RATE,
                            (1e3 * (c.packets - p.packets)) / e
                          );
                    }
                    if (
                      (o &&
                        (yK(d, hK.QP_SUM, c.qpSumPerFrame),
                        (d[hK.FREEZE] =
                          r && UH.isRemoteVideoFreeze(s, c, p) ? 1 : 0)),
                      a)
                    ) {
                      var f;
                      l
                        ? (yK(d, hK.HEIGHT, l.height), yK(d, hK.WIDTH, l.width))
                        : s &&
                          (yK(d, hK.HEIGHT, s._videoHeight || 0),
                          yK(d, hK.WIDTH, s._videoWidth || 0)),
                        h && yK(d, uK.FRAME_RATE_OUTPUT, h.frameRate);
                      const e =
                        null === (f = s._player) || void 0 === f
                          ? void 0
                          : f.rendFrameRate.toFixed(0);
                      if (
                        (e && yK(d, uK.FRAME_RATE_RENDER, +e),
                        yK(d, hK.JITTER_BUFFER, c.jitterBufferMs),
                        yK(d, hK.CURRENT_DELAY, c.currentDelayMs),
                        yK(d, hK.FIRS, c.firsCount),
                        yK(d, hK.NACKS, c.nacksCount),
                        yK(d, hK.PLIS, c.plisCount),
                        s)
                      ) {
                        d[hK.DISABLED] =
                          s._originMediaStreamTrack.enabled &&
                          s._mediaStreamTrack.enabled
                            ? 0
                            : 1;
                        const e = s._player;
                        if (e) {
                          const {
                            freezeTimeCounterList: t,
                            renderFreezeAccTime: i,
                            videoElementStatus: s
                          } = e;
                          if (
                            (t &&
                              t.length > 0 &&
                              yK(d, uK.FREEZE_TIME, t.splice(0, 1)[0]),
                            n &&
                              "visible" === GV.visibility &&
                              s === nF.PLAYING &&
                              Lx().supportRequestVideoFrameCallback)
                          ) {
                            const t = Math.min(6e3, i);
                            (e.renderFreezeAccTime = Math.max(0, i - t)),
                              yK(d, uK.FREEZE_TIME_RENDER, t);
                          }
                          if ("number" == typeof c.totalFreezesDuration) {
                            const e =
                              p && p.totalFreezesDuration
                                ? c.totalFreezesDuration -
                                  p.totalFreezesDuration
                                : c.totalFreezesDuration;
                            yK(d, uK.FREEZE_DURATION, 1e3 * e);
                          }
                        }
                      }
                      if (
                        ((d[hK.PLAYER_STATUS] =
                          oF[
                            s._player ? s._player.videoElementStatus : "uninit"
                          ]),
                        p &&
                          void 0 !== c.totalInterFrameDelay &&
                          void 0 !== c.totalSquaredInterFrameDelay &&
                          void 0 !== p.totalInterFrameDelay &&
                          void 0 !== p.totalSquaredInterFrameDelay)
                      ) {
                        const e =
                            c.totalInterFrameDelay - p.totalInterFrameDelay,
                          t =
                            c.totalSquaredInterFrameDelay -
                            p.totalSquaredInterFrameDelay,
                          i = c.framesDecodeCount - p.framesDecodeCount,
                          s = (e / i) * 1e3,
                          r = Math.round(
                            1e3 * Math.sqrt((t - Math.pow(e, 2) / i) / i)
                          );
                        !isNaN(r) &&
                          s + r > Math.max(3 * s, s + 150) &&
                          (d[hK.I_FRAME_DELAY] = r);
                      }
                    }
                    return d;
                  })(
                    a._videoSSRC,
                    e,
                    t,
                    a.videoTrack,
                    !0 === r,
                    this.needUploadRenderFreezeTime,
                    i,
                    s
                  )
                : void 0;
            n && (c.video = n);
          }
          if (o.has(xG.AUDIO) && a.audioTrack) {
            const r = a.audioTrack
              ? (function(e, t, i, s, r, n) {
                  const a = t.audioRecv.find(t => t.ssrc === e);
                  if (!a) return;
                  const o = {},
                    c = i && i.audioRecv.find(t => t.ssrc === e);
                  if (
                    (yK(o, EK.JITTER, a.jitterMs),
                    yK(o, EK.BYTES_RETRANSMIT, a.retransmittedBytesReceived),
                    yK(
                      o,
                      EK.PACKAGES_RETRANSMIT,
                      a.retransmittedPacketsReceived
                    ),
                    yK(o, EK.PACKAGES_DISCARDED, a.packetsDiscarded),
                    yK(o, EK.AVG_PROCESSING_DELAY, a.avgProcessingDelayMs),
                    c)
                  ) {
                    const e =
                      t.timestamp - i.timestamp || TK * (n ? SK : r ? vK : 1);
                    null != a.packets &&
                      null != c.packets &&
                      yK(
                        o,
                        EK.PACKAGE_RATE,
                        (1e3 * (a.packets - c.packets)) / e
                      ),
                      r &&
                        null != c.bytes &&
                        null != a.bytes &&
                        yK(o, EK.BITRATE, (8 * (a.bytes - c.bytes)) / e),
                      null != a.packetsLost &&
                        null != c.packetsLost &&
                        yK(o, EK.PACKAGE_LOST, a.packetsLost - c.packetsLost);
                  }
                  if (n) {
                    const { receivedFrames: e, droppedFrames: t } = a;
                    null != e &&
                      null != t &&
                      (o[EK.FREEZE] =
                        0 === (d = e) || (100 * t) / d > 20 ? 1 : 0);
                  }
                  var d;
                  if (r) {
                    const e = 100 * s._source.getAccurateVolumeLevel(),
                      t = a.outputLevel;
                    if (null != t) {
                      const e = Math.ceil(50 * Math.log10(100 * t + 1));
                      yK(o, mK.LEVEL, e);
                    }
                    if (
                      (yK(o, EK.PCM_LEVEL, e),
                      s &&
                        (o[EK.DISABLED] =
                          s._originMediaStreamTrack.enabled &&
                          s._mediaStreamTrack.enabled
                            ? 0
                            : 1),
                      yK(o, EK.JITTER_BUFFER, a.jitterBufferMs),
                      yK(o, EK.CURRENT_DELAY, a.jitterBufferMs),
                      (o[EK.PLAYER_STATUS] =
                        oF[BF.getPlayerState(s.getTrackId())]),
                      c)
                    ) {
                      const e = a.concealedSamples - c.concealedSamples;
                      e > 0 && yK(o, EK.CONCEALED_SAMPLES, e);
                      const t = a.totalSamplesReceived - c.totalSamplesReceived;
                      t > 0 && yK(o, EK.TOTAL_SAMPLES_RECEIVED, t);
                    }
                  }
                  return o;
                })(a._audioSSRC, e, t, a.audioTrack, i, s)
              : void 0;
            r && (c.audio = r);
          }
          (c.video || c.audio) && n.push(c);
        }),
        (this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime),
        n
      );
    }
    startUploadTransportStats() {
      (this.uploadTransportStarted = !0),
        this.uploadWRTCStatsTimer || this.startUploadWRTCStats();
    }
    stopUploadTransportStats() {
      this.uploadTransportStarted = !1;
    }
    startUploadOutboundStats() {
      this.uploadOutboundStarted ||
        ((this.uploadOutboundStarted = !0),
        this.uploadWRTCStatsTimer || this.startUploadWRTCStats(),
        this.uploadOutboundDenoiserStatsTimer &&
          window.clearInterval(this.uploadOutboundDenoiserStatsTimer),
        (this.uploadOutboundDenoiserStatsTimer = window.setInterval(() => {
          if (!this.requestAllTracks || !this.requestUpload) return;
          const e = (this.requestAllTracks() || []).find(e => e instanceof BB);
          if (e && e._external.getDenoiserStats) {
            const t = e._external.getDenoiserStats();
            t && this.requestUpload(EG.DENOISER_STATS, t);
          }
        }, 2e3)),
        this.uploadExtStatsTimer &&
          window.clearInterval(this.uploadExtStatsTimer),
        (this.uploadExtStatsTimer = window.setInterval(() => {
          if (!this.requestAllTracks || !this.requestUpload) return;
          this.requestAllTracks().forEach(e => {
            e.getProcessorStats().forEach(e => {
              this.requestUpload && this.requestUpload(e.type, e.stats);
            });
          });
        }, 2e3)));
    }
    stopUploadOutboundStats() {
      this.uploadOutboundStarted &&
        ((this.uploadOutboundStarted = !1),
        this.lastSendStats &&
          ((this.lastSendStats.videoSend = []),
          (this.lastSendStats.audioSend = []),
          (this.lastSendStats = void 0)),
        this.uploadOutboundDenoiserStatsTimer &&
          window.clearInterval(this.uploadOutboundDenoiserStatsTimer),
        (this.uploadOutboundDenoiserStatsTimer = void 0));
    }
    startUploadInboundStats() {
      this.uploadInboundStarted ||
        ((this.uploadInboundStarted = !0),
        this.uploadWRTCStatsTimer || this.startUploadWRTCStats(),
        this.uploadInboundExtStatsTimer &&
          window.clearInterval(this.uploadInboundExtStatsTimer),
        (this.uploadInboundExtStatsTimer = window.setInterval(() => {
          if (!this.requestUpload || !this.requestRemoteMedia) return;
          (this.requestRemoteMedia() || []).forEach(e => {
            let [t, i] = e;
            if (i.has(xG.VIDEO) && t.videoTrack) {
              t.videoTrack.getProcessorStats().forEach(e => {
                this.requestUpload && this.requestUpload(e.type, e.stats);
              });
            }
            if (i.has(xG.AUDIO) && t.audioTrack) {
              t.audioTrack.getProcessorStats().forEach(e => {
                this.requestUpload && this.requestUpload(e.type, e.stats);
              });
            }
          });
        }, 2e3)));
    }
    stopUploadInboundStats() {
      this.uploadInboundStarted &&
        ((this.uploadInboundStarted = !1),
        this.lastRecvStats &&
          ((this.lastRecvStats.videoRecv = []),
          (this.lastRecvStats.audioRecv = []),
          (this.lastRecvStats = void 0)));
    }
    startUploadExtensionUsageStats() {
      if (this.uploadExtensionUsageStarted) return;
      (this.uploadExtensionUsageStarted = !0),
        this.uploadExtUsageStatsTimer &&
          window.clearInterval(this.uploadExtUsageStatsTimer);
      const e = new Map();
      this.uploadExtUsageStatsTimer = window.setInterval(async () => {
        const t = Date.now(),
          i = {
            connectionInterval: WM("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3,
            details: [],
            lts: t
          };
        let s = [];
        const r = (this.requestAllTracks && this.requestAllTracks()) || [];
        for (const e of r)
          !e.muted && e.enabled && (s = s.concat(await e.getProcessorUsage()));
        const n = (this.requestRemoteMedia && this.requestRemoteMedia()) || [];
        for (const [e, t] of n)
          t.has(xG.VIDEO) &&
            e.videoTrack &&
            (s = s.concat(await e.videoTrack.getProcessorUsage())),
            t.has(xG.AUDIO) &&
              e.audioTrack &&
              (s = s.concat(await e.audioTrack.getProcessorUsage()));
        if (0 === s.length) return;
        i.details = (function(e, t) {
          const i = {};
          for (const { id: a, value: o, level: c, direction: d } of e) {
            var s;
            const e = null !== (s = t.get(a)) && void 0 !== s ? s : 0,
              l = 2 === o ? e + WM("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e;
            var r, n;
            t.set(a, l),
              i[a]
                ? (2 === o && (i[a].value = o),
                  c > i[a].level && (i[a].level = c),
                  "remote" === d && (i[a].remoteUidCount += 1),
                  (i[a].totalTs =
                    null !== (r = t.get(a)) && void 0 !== r ? r : 0))
                : (i[a] = {
                    value: o,
                    level: c,
                    remoteUidCount: "local" === d ? 0 : 1,
                    totalTs: null !== (n = t.get(a)) && void 0 !== n ? n : 0
                  });
          }
          return Object.keys(i).map(e => {
            const { level: t, value: s, totalTs: r } = i[e];
            return { id: e, level: t, value: s, totalTs: r };
          });
        })(s, e);
        const a = Date.now(),
          o = a > t ? a : t + 1;
        this.requestUpload &&
          this.requestUpload(EG.EXTENSION_USAGE_STATS, {
            usageStats: i,
            sendTs: o
          });
      }, WM("EXTENSION_USAGE_UPLOAD_INTERVAL"));
    }
    stopUploadExtensionUsageStats() {
      this.uploadExtensionUsageStarted &&
        ((this.uploadExtensionUsageStarted = !1),
        this.uploadExtUsageStatsTimer &&
          window.clearInterval(this.uploadExtUsageStatsTimer),
        (this.uploadExtUsageStatsTimer = void 0));
    }
    stopUploadBaseStats() {
      this.uploadBaseStatsStarted = !1;
    }
  }
  const bK = WM("ICE_RESTART_INTERVAL");
  let OK = new Map(),
    DK = new Map(),
    wK = [FG.UDP_TCP_RELAY, FG.TCP_RELAY, FG.RELAY],
    LK =
      WM("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") &&
      Lx().supportPCSetConfiguration;
  function NK(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const i = OK.get(e.id);
    i && (window.clearTimeout(i), OK.delete(e.id));
    const s = DK.get(e.id);
    t &&
      s &&
      s.index === wK.length - 1 &&
      (EU.debug("[".concat(e.id, "] reset ICE restart policy")),
      DK.delete(e.id));
  }
  function PK(e, t, i) {
    if (
      (0 === OK.size &&
        0 === DK.size &&
        (Array.isArray(WM("RESTART_SEQUENCE")) &&
          WM("RESTART_SEQUENCE").length > 0 &&
          !(function(e, t) {
            if (e.length !== t.length) return !1;
            for (let i = 0; i < e.length; i += 1) {
              const s = e[i];
              if (
                e.filter(e => e === s).length !== t.filter(e => e === s).length
              )
                return !1;
            }
            return !0;
          })(wK, WM("RESTART_SEQUENCE")) &&
          ((wK = WM("RESTART_SEQUENCE").filter(e => {
            if (Object.values(FG).includes(e)) return !0;
          })),
          EU.debug(
            "use reconnection policy from config distribution, queues: ".concat(
              wK.join(" => ")
            )
          )),
        (LK =
          WM("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") &&
          Lx().supportPCSetConfiguration)),
      0 === wK.length)
    )
      return void i();
    let s,
      { index: r = 0, type: n } = DK.get(e.id) || {};
    if (LK && n === FG.RELAY) return void i();
    let a = n && r >= wK.length - 1;
    if (LK) n = FG.RELAY;
    else {
      if (a) return void i();
      n ? (r++, (n = wK[r])) : ((n = wK[0]), (r = 0));
    }
    EU.debug(
      "["
        .concat(e.id, "] choose ICE restart policy: ")
        .concat(n, ", index: ")
        .concat(r)
    ),
      t(n),
      DK.set(e.id, { index: r, type: n }),
      (s = window.setTimeout(() => PK(e, t, i), bK)),
      OK.set(e.id, s);
  }
  var kK;
  let MK =
    ((kK = class extends uk {
      get state() {
        return this._state;
      }
      set state(e) {
        const t = this._state;
        (this._state = e), this.emit(HG.StateChange, t, this._state);
      }
      constructor(e, t) {
        super(),
          (this.isPlanB = void 0),
          (this.store = void 0),
          (this.statsUploader = void 0),
          (this.connection = void 0),
          (this.localTrackMap = new Map()),
          (this.remoteUserMap = new Map()),
          (this.localDataChannels = []),
          (this.remoteDataChannelMap = new Map()),
          (this.pendingLocalTracks = []),
          (this.pendingRemoteTracks = []),
          (this.pendingLocalDataChannels = []),
          (this.pendingRemoteDataChannels = []),
          (this.statsCollector = void 0),
          (this.shouldForwardP2PCreation = void 0),
          (this.iceFailedCount = 0),
          (this.dtlsFailedCount = 0),
          (this.mutex = void 0),
          (this._state = jG.Disconnected),
          (this._pcStatsUploadType = WM("NEW_ICE_RESTART")
            ? BG.FIRST_CONNECTION
            : BG.OLD_FIRST_CONNECTION),
          (this._isStartRestartIce = !1),
          (this._restartTimer = void 0),
          (this._isTryConnecting = !1),
          (this._iceError = null),
          (this._forceTurn = !1),
          (this._isWaitPcToRePub = !1),
          (this.handleMuteLocalTrack = async (e, t, i) => {
            const s = await this.mutex.lock(
              "Locking from P2PChannel.handleMuteLocalTrack"
            );
            try {
              if (!this.connection || this.state !== jG.Connected)
                return void i(
                  new JP(
                    zP.INVALID_OPERATION,
                    "Cannot call P2PChannel.handleMuteLocalTrack before connection established."
                  )
                );
              const r = this.filterTobeMutedTracks(e);
              if (0 === r.length) return void t();
              const n = r.find(e => "videoLowTrack" === e[0]);
              if (n) {
                n[1].track._originMediaStreamTrack.stop();
              }
              await this.connection.muteLocal(
                r.map(e => {
                  let [, { id: t }] = e;
                  return t;
                })
              );
              const a = this.createMuteMessage(r);
              await bk(this, HG.RequestMuteLocal, a), t();
            } catch (e) {
              i(e);
            } finally {
              s();
            }
          }),
          (this.handleUnmuteLocalTrack = async (e, t, i) => {
            const s = await this.mutex.lock(
              "Locking from P2PChannel.handleUnmuteLocalTrack"
            );
            try {
              if (!this.connection || this.state !== jG.Connected)
                return void i(
                  new JP(
                    zP.INVALID_OPERATION,
                    "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."
                  )
                );
              const r = this.filterTobeUnmutedTracks(e);
              if (0 === r.length) return void t();
              const n = r.find(e => "videoLowTrack" === e[0]);
              if (n) {
                const t = n[1];
                if (
                  (t.track._originMediaStreamTrack.stop(),
                  !WM("DISABLE_DUAL_STREAM_USE_ENCODING") &&
                    Lx().supportDualStreamEncoding)
                ) {
                  const i = e._mediaStreamTrack.clone();
                  (t.track._mediaStreamTrack = i),
                    (t.track._originMediaStreamTrack = i);
                } else {
                  const i = oK(e, Dk(this, HG.RequestLowStreamParameter));
                  (t.track._mediaStreamTrack = i),
                    (t.track._originMediaStreamTrack = i);
                }
                await new Promise((e, i) => {
                  this.handleReplaceTrack(t.track, e, i, !0);
                });
              }
              await this.connection.unmuteLocal(
                r.map(e => {
                  let [, { id: t }] = e;
                  return t;
                })
              );
              const a = this.createUnmuteMessage(r);
              await bk(this, HG.RequestUnmuteLocal, a), t();
            } catch (e) {
              i(e);
            } finally {
              s();
            }
          }),
          (this.handleUpdateVideoEncoder = async (e, t, i, s) => {
            let r;
            s ||
              (r = await this.mutex.lock(
                "Locking from P2PChannel.handleUpdateVideoEncoder"
              ));
            try {
              const i = this.localTrackMap.get(GG.LocalVideoTrack);
              if (
                !this.connection ||
                !i ||
                i.track !== e ||
                this.state !== jG.Connected
              )
                return void t();
              const { id: s, track: a } = i;
              await this.connection.updateSendParameters(s, a),
                await this.connection.updateEncoderConfig(s, a),
                this.emit(HG.UpdateVideoEncoder, a),
                t();
            } catch (e) {
              i(e);
            } finally {
              var n;
              null === (n = r) || void 0 === n || n();
            }
          }),
          (this.handleUpdateVideoSendParameters = async (e, t, i) => {
            const s = await this.mutex.lock(
              "Locking from P2PChannel.handleUpdateVideoSendParameters"
            );
            try {
              const i = this.localTrackMap.get(GG.LocalVideoTrack);
              if (
                !this.connection ||
                !i ||
                i.track !== e ||
                this.state !== jG.Connected
              )
                return void t();
              const { id: r, track: n } = i;
              await this.connection.updateSendParameters(r, n), t();
            } catch (e) {
              i(e);
            } finally {
              s();
            }
          }),
          (this.handleReplaceMixingTrack = async (e, t, i, s) => {
            if (!this.connection || this.state !== jG.Connected)
              return void t();
            const r = ZH([e]);
            let n;
            EU.debug(
              "["
                .concat(this.store.clientId, "] [p2pId: ")
                .concat(
                  this.store.p2pId,
                  "]: P2PConnection will replace audioTrack ["
                )
                .concat(r.getTrackId(), "]")
            ),
              ("boolean" == typeof s && s) ||
                (n = await this.mutex.lock(
                  "From P2PChannel.handleReplaceMixingTrack"
                ));
            try {
              await this.replaceTrack(e, r), t();
            } catch (e) {
              i(e);
            } finally {
              var a;
              null === (a = n) || void 0 === a || a();
            }
          }),
          (this.handleReplaceTrack = async (e, t, i, s) => {
            let r;
            EU.debug(
              "["
                .concat(
                  this.store.clientId,
                  "] P2PChannel handleReplaceTrack for [track-id-"
                )
                .concat(e.getTrackId(), "]")
            ),
              ("boolean" == typeof s && s) ||
                (r = await this.mutex.lock(
                  "From P2PChannel.handleReplaceTrack"
                ));
            try {
              var n;
              const i = Array.from(this.localTrackMap.entries()).find(t => {
                let [, { track: i }] = t;
                return e === i;
              });
              if (!this.connection || !i || this.state !== jG.Connected)
                return void t();
              if (
                (await (null === (n = this.connection) || void 0 === n
                  ? void 0
                  : n.replaceTrack(e, i[1].id)),
                this.isPlanB)
              ) {
                const t = i[1];
                (t.id = e._mediaStreamTrack.id),
                  this.localTrackMap.set(i[0], t);
              }
              if (
                i[0] === GG.LocalVideoTrack &&
                !WM("DISABLE_DUAL_STREAM_USE_ENCODING") &&
                Lx().supportDualStreamEncoding
              ) {
                const t = this.localTrackMap.get(GG.LocalVideoLowTrack);
                if (t) {
                  const i = e._mediaStreamTrack.clone();
                  t.track._originMediaStreamTrack.stop(),
                    (t.track._mediaStreamTrack = i),
                    (t.track._originMediaStreamTrack = i),
                    await new Promise((e, i) => {
                      this.handleReplaceTrack(t.track, e, i, !0);
                    });
                }
              }
              t();
            } catch (e) {
              i(e);
            } finally {
              var a;
              null === (a = r) || void 0 === a || a();
            }
          }),
          (this.handleGetRTCStats = e => {
            e(this.statsCollector.getRTCStats());
          }),
          (this.handleGetLocalVideoStats = e => {
            e(this.statsCollector.getLocalVideoTrackStats());
          }),
          (this.handleGetLocalAudioStats = e => {
            e(this.statsCollector.getLocalAudioTrackStats());
          }),
          (this.handleGetRemoteVideoStats = e =>
            this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid]),
          (this.handleGetRemoteAudioStats = e =>
            this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid]),
          (this.store = e),
          (this.statsCollector = t),
          this.statsCollector.addP2PChannel(this),
          (this.statsUploader = new CK(this.store)),
          this.bindStatsUploaderEvents(),
          (this.mutex = new sM("P2PChannel-mutex", this.store.clientId)),
          (this.isPlanB =
            !Lx().supportUnifiedPlan || (WM("CHROME_FORCE_PLAN_B") && KP())),
          (this.shouldForwardP2PCreation =
            WM("FORWARD_P2P_CREATION") &&
            Lx().supportPCSetConfiguration &&
            HP()),
          this.shouldForwardP2PCreation &&
            ((this.connection = tK(this.store)),
            this.emit(
              HG.PeerConnectionStateChange,
              this.connection.peerConnectionState
            ),
            this.bindConnectionEvents(this.connection));
      }
      async startP2PConnection(e) {
        var t;
        (this.state = jG.New),
          (this._forceTurn = sK(e)),
          EU.debug(
            "["
              .concat(this.store.clientId, "] [")
              .concat(this.store.p2pId, "] forceTurn: ")
              .concat(this._forceTurn)
          );
        const i =
          this.shouldForwardP2PCreation &&
          "closed" ===
            (null === (t = this.connection) || void 0 === t
              ? void 0
              : t.peerConnectionState);
        if (
          ((this.shouldForwardP2PCreation && !i) ||
            (i &&
              this.connection &&
              (EU.warning(
                "[".concat(
                  this.store.clientId,
                  "] P2PChannel.startP2PConnection ForwardP2P closed."
                )
              ),
              this.resetConnection(this.connection)),
            (this.connection = tK(this.store, e)),
            this.emit(
              HG.PeerConnectionStateChange,
              this.connection.peerConnectionState
            ),
            this.bindConnectionEvents(this.connection)),
          !this.connection)
        )
          throw new JP(
            zP.UNEXPECTED_ERROR,
            "Cannot P2PChannel.startConnection before P2PConnection initialization ."
          );
        return (
          (this._pcStatsUploadType = WM("NEW_ICE_RESTART")
            ? BG.FIRST_CONNECTION
            : BG.OLD_FIRST_CONNECTION),
          (this._isTryConnecting = !0),
          (this._isStartRestartIce = !1),
          (this._iceError = null),
          this.connection.setConfiguration(e),
          this.connection.establishPromise
        );
      }
      async connect(e) {
        if (!this.connection)
          throw new JP(
            zP.UNEXPECTED_ERROR,
            "Cannot P2PChannel.connect before P2PChannel.startP2PConnection ."
          );
        WM("ENABLE_PREALLOC_PC") && this.state === jG.Connected
          ? await this.connection.updateRemoteConnect(e)
          : (this.store.peerConnectionStart(),
            await this.connection.connect(e),
            this.statsUploader.startUploadTransportStats(),
            this.statsUploader.startUploadExtensionUsageStats(),
            (this.state = jG.Connected));
      }
      updateRemoteRTPCapabilities(e) {
        const t = Array.from(this.localTrackMap.entries()).filter(e => {
            let [t] = e;
            return [GG.LocalVideoLowTrack, GG.LocalVideoTrack].includes(t);
          }),
          i = t.map(e => {
            let [, { id: t }] = e;
            return t;
          }),
          s = t.map(e => {
            let [t] = e;
            return t;
          });
        if (this.connection instanceof nK) {
          if (
            (yU.updateRemoteRTPCapabilities(this.store.sessionId, {
              trackTypes: JSON.stringify(s),
              localCodecs: JSON.stringify(this.connection.localCodecs),
              remoteCodecs: JSON.stringify(e)
            }),
            !e.includes(this.store.codec))
          ) {
            const t = ["vp9", "vp8", "h264"].find(t => e.includes(t));
            t &&
              ((this.store.codec = t),
              EU.debug(
                "["
                  .concat(this.store.clientId, "] [")
                  .concat(
                    this.store.p2pId,
                    " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to "
                  )
                  .concat(t, ".")
              ));
          }
          this.connection.updateRemoteRTPCapabilities(i, e);
        }
      }
      async getEstablishParams() {
        if (
          this.connection instanceof nK &&
          "closed" !== this.connection.peerConnectionState &&
          [jG.New, jG.Connected].includes(this.state)
        )
          return this.connection.establishPromise;
      }
      async publishDataChannel(e) {
        if (!this.connection || this.state !== jG.Connected) {
          if (this.state === jG.Disconnected)
            throw new JP(
              zP.UNEXPECTED_ERROR,
              "PeerConnection already disconnected."
            );
          return (
            e.forEach(e => {
              this.pendingLocalDataChannels.includes(e) ||
                this.pendingLocalDataChannels.push(e);
            }),
            []
          );
        }
        const t = this.filterTobePublishedDataChannels(e);
        return 0 === t.length
          ? []
          : (t.forEach(e => {
              const t = Date.now();
              this.store.publish(e.id.toString(), "datachannel", t);
            }),
            await this.connection.createDataChannels(this.store.uid, t),
            t.forEach(e => {
              this.localDataChannels.push(e);
              const t = Date.now();
              this.store.publish(e.id + "", "datachannel", void 0, t);
            }),
            e.map(e => ({
              streamId: e.id,
              ordered: e.ordered,
              maxRetransmits: e.maxRetransmits,
              metadata: e.metadata,
              channelId: e._originDataChannelId
            })));
      }
      publish(e, t, i) {
        var s = this;
        return nG(function*() {
          const r = yield tG(s.mutex.lock("From P2PChannel.publish"));
          try {
            const n =
              s.connection &&
              ["disconnected", "failed"].includes(
                s.connection.peerConnectionState
              );
            if (!s.connection || s.state !== jG.Connected || n) {
              if (s.state === jG.Disconnected)
                throw new JP(
                  zP.UNEXPECTED_ERROR,
                  "PeerConnection already disconnected."
                );
              s.throwIfTrackTypeNotMatch(e);
              const t = e.filter(e => -1 === s.pendingLocalTracks.indexOf(e));
              return (
                (s.pendingLocalTracks = s.pendingLocalTracks.concat(t)),
                void (n && (s._isWaitPcToRePub = !0))
              );
            }
            (s.store.pubId = s.store.pubId + 1),
              MH.markPublishStart(s.store.clientId, s.store.pubId);
            const a = s.filterTobePublishedTracks(e, t, i);
            if (0 === a.length) return void (yield tG(s.tryToUnmuteAudio(e)));
            yield* QV(ZV(s.doPublish(s.connection, a)));
          } finally {
            r();
          }
        })();
      }
      doPublish(e, t) {
        var i = this;
        return nG(function*() {
          t.forEach(e => {
            let { track: t, type: s } = e;
            const r = Date.now();
            i.store.publish(
              t.getTrackId(),
              s === GG.LocalAudioTrack ? "audio" : "video",
              r
            );
          }),
            i.bindLocalTrackEvents(t);
          const s = t.map(e => {
              let { track: t } = e;
              return t;
            }),
            r = yield tG(e.send(s, i.store.codec, i.store.audioCodec)),
            n = (yield tG(r.next())).value,
            a = i.createGatewayPublishMessage(t, n);
          let o;
          try {
            o = yield a;
          } catch (e) {
            throw (r.throw(e),
            (null == e ? void 0 : e.code) === zP.WS_ABORT &&
              t.forEach(e => {
                let { track: t } = e;
                -1 === i.pendingLocalTracks.indexOf(t) &&
                  i.pendingLocalTracks.push(t);
              }),
            i.unbindLocalTrackEvents(t),
            e);
          }
          const c = i.mapPubResToRemoteConfig(a, o, s),
            d = (yield tG(r.next(c))).value;
          if (i.state === jG.Disconnected)
            throw new JP(
              zP.UNEXPECTED_ERROR,
              "PeerConnection already disconnected."
            );
          WM("ENABLE_VIDEO_SEI");
          const l = WM("ENABLE_ENCODED_TRANSFORM"),
            h = WM("ENABLE_AUDIO_METADATA");
          s.forEach(async e => {
            const t = e.getRTCRtpTransceiver();
            if (!t || !l) return;
            const {
              interceptLocalVideoFrame: i,
              interceptLocalAudioFrame: s
            } = Jj();
            e.trackMediaType === xG.VIDEO
              ? await i(t.sender, e)
              : e.trackMediaType === xG.AUDIO &&
                (await s(t.sender, {
                  metadata: h
                    ? () => {
                        const t = e.metadata.shift();
                        return t && t.value;
                      }
                    : void 0
                }));
          }),
            t.forEach(e => {
              let { type: t } = e;
              i.statsCollector.addLocalStats(t);
            }),
            i.assignLocalTracks(t, d),
            i.statsUploader.startUploadOutboundStats(),
            t.forEach(e => {
              let { track: t, type: s } = e;
              const r = Date.now();
              i.store.publish(
                t.getTrackId(),
                s === GG.LocalAudioTrack ? "audio" : "video",
                void 0,
                r
              );
            });
        })();
      }
      async updateVideoStreamParameter(e, t) {
        const i = this.localTrackMap.get(t);
        if (!i || !this.connection) return;
        if (!(i.track instanceof AV))
          return EU.warn(
            "[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack"
          );
        const { track: s } = i,
          r = (function(e, t) {
            const i = {};
            return (
              e.height && e.width && (i.scaleResolutionDownBy = vj(e, t)),
              (i.maxFramerate = e.framerate ? mj(e.framerate) : void 0),
              (i.maxBitrate = e.bitrate ? 1e3 * e.bitrate : void 0),
              i
            );
          })(e, s);
        if (
          (s._encoderConfig || (s._encoderConfig = {}),
          t !== GG.LocalVideoLowTrack ||
            (!WM("DISABLE_DUAL_STREAM_USE_ENCODING") &&
              Lx().supportDualStreamEncoding))
        )
          null != r.scaleResolutionDownBy &&
            (s._encoderConfig.scaleResolutionDownBy = r.scaleResolutionDownBy);
        else {
          const t = s._originMediaStreamTrack;
          if (!t.canvas)
            return EU.warn("[".concat(s.getTrackId(), "] no canvas on track"));
          !(function(e, t) {
            const i = e.canvas;
            t.width && (i.width = mj(t.width)),
              t.height && (i.height = mj(t.height)),
              t.framerate &&
                (i.stopCapture && i.stopCapture(),
                (i.stopCapture = SF(() => {
                  !i.startCapture && i.stopCapture && i.stopCapture(),
                    i.startCapture && i.startCapture();
                }, mj(t.framerate))));
          })(t, e);
        }
        null != r.maxBitrate &&
          (s._encoderConfig.bitrateMax = r.maxBitrate / 1e3),
          null != r.maxFramerate &&
            (s._encoderConfig.frameRate &&
            "object" == typeof s._encoderConfig.frameRate
              ? (s._encoderConfig.frameRate.max = r.maxFramerate)
              : (s._encoderConfig.frameRate = { max: r.maxFramerate })),
          EU.debug(
            "["
              .concat(s.getTrackId(), "] LowStreamEncoderConfig: , ")
              .concat(JSON.stringify(s._encoderConfig))
          ),
          await this.connection.updateRtpSenderEncodings(s);
      }
      publishLowStream(e) {
        var t = this;
        return nG(function*() {
          if (!t.connection || t.state !== jG.Connected) return;
          const i = yield tG(
            t.mutex.lock("Locking from P2PChannel.publishLowStream")
          );
          try {
            const r = t.localTrackMap.get(GG.LocalVideoTrack);
            if (!r)
              throw new JP(zP.UNEXPECTED_ERROR, "Could not find high stream");
            if (t.localTrackMap.has(GG.LocalVideoLowTrack))
              throw new JP(
                zP.UNEXPECTED_ERROR,
                "[".concat(
                  t.store.clientId,
                  "] Can't publish low stream when stream already publish"
                )
              );
            const n = [
              {
                track: t.getLowVideoTrack(r.track, e),
                type: GG.LocalVideoLowTrack
              }
            ];
            if (
              (yield* QV(ZV(t.doPublish(t.connection, n))),
              r.track.muted || !r.track.enabled)
            ) {
              var s;
              const e =
                null === (s = t.localTrackMap.get(GG.LocalVideoLowTrack)) ||
                void 0 === s
                  ? void 0
                  : s.id;
              void 0 !== e && (yield tG(t.connection.muteLocal([e])));
            }
          } finally {
            i();
          }
        })();
      }
      async republish() {
        this.pendingLocalTracks.length > 0 &&
          (EU.debug(
            "[".concat(
              this.store.clientId,
              "] Emit P2PChannelEvents.RequestRePublish to republish tracks."
            )
          ),
          await Ck(this, HG.RequestRePublish, this.pendingLocalTracks),
          this.emit(HG.MediaReconnectEnd, this.store.uid),
          (this.pendingLocalTracks = [])),
          this.pendingLocalDataChannels.length > 0 &&
            (EU.debug(
              "Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."
            ),
            await Ck(
              this,
              HG.RequestRePublishDataChannel,
              this.pendingLocalDataChannels
            ),
            (this.pendingLocalDataChannels = [])),
          (this._isWaitPcToRePub = !1);
      }
      async reSubscribe(e) {
        for (let e = this.pendingRemoteTracks.length - 1; e >= 0; e--) {
          const { user: t, kind: i } = this.pendingRemoteTracks[e];
          ((i !== xG.AUDIO || (t._audio_added_ && t._audioSSRC)) &&
            (i !== xG.VIDEO || (t._video_added_ && t._videoSSRC))) ||
            this.pendingRemoteTracks.splice(e, 1);
        }
        if (e) await Ck(this, HG.RequestReSubscribe, this.pendingRemoteTracks);
        else
          for (const { user: e, kind: t } of this.pendingRemoteTracks)
            await this.subscribe(
              e,
              t,
              t === xG.VIDEO ? e._videoSSRC : e._audioSSRC
            );
        this.pendingRemoteTracks.forEach(e => {
          let { user: t } = e;
          this.emit(HG.MediaReconnectEnd, t.uid);
        }),
          (this.pendingRemoteTracks = []);
      }
      async unpublish(e) {
        if (!this.connection || this.state !== jG.Connected)
          return void e.forEach(e => {
            const t = this.pendingLocalTracks.indexOf(e);
            -1 !== t && this.pendingLocalTracks.splice(t, 1);
          });
        const t = this.filterTobeUnpublishedTracks(e);
        if (0 === t.length) return;
        const i = t.find(e => "videoLowTrack" === e[0]);
        if (i) {
          i[1].track.close();
        }
        return this.doUnpublish(this.connection, t);
      }
      async unpublishDataChannel(e) {
        if (!this.connection || this.state !== jG.Connected)
          return void e.forEach(e => {
            const t = this.pendingLocalDataChannels.indexOf(e);
            -1 !== t && this.pendingLocalDataChannels.splice(t, 1);
          });
        const t = this.filterTobeUnpublishedDataChannels(e);
        return 0 !== t.length
          ? (t.forEach(e => {
              const t = this.localDataChannels.indexOf(e);
              -1 !== t && this.localDataChannels.splice(t, 1);
            }),
            0 === this.localDataChannels.length &&
              (await this.connection.stopDataChannels(this.store.uid)),
            t.map(e => e.id))
          : void 0;
      }
      async unpublishLowStream() {
        if (!this.connection || this.state !== jG.Connected) return;
        const e = this.localTrackMap.get(GG.LocalVideoLowTrack);
        if (!e) return;
        e.track.close();
        const t = [[GG.LocalVideoLowTrack, e]];
        return this.doUnpublish(this.connection, t);
      }
      async doUnpublish(e, t) {
        const i = this.createGatewayUnpublishMessage(t);
        return (
          await e.stopSending(
            t.map(e => {
              let [, { id: t }] = e;
              return t;
            })
          ),
          this.withdrawLocalTracks(t),
          this.unbindLocalTrackEvents(
            t.map(e => {
              let [t, { track: i }] = e;
              return { type: t, track: i };
            })
          ),
          t.forEach(e => {
            let [t] = e;
            this.statsCollector.removeLocalStats(t);
          }),
          0 === this.localTrackMap.size &&
            this.statsUploader.stopUploadOutboundStats(),
          i
        );
      }
      async subscribeDataChannel(e, t) {
        if (!this.connection || this.state !== jG.Connected)
          throw new JP(
            zP.INVALID_OPERATION,
            "Cannot subscribe remote user when peerConnection disconnected."
          );
        const i = t.filter(t => {
          var i;
          return !(
            null !== (i = this.remoteDataChannelMap.get(e)) &&
            void 0 !== i &&
            i.get(t.id)
          );
        });
        if (0 !== i.length)
          return (
            await this.connection.createDataChannels(e.uid, i),
            i.forEach(t => {
              var i;
              this.remoteDataChannelMap.has(e)
                ? null === (i = this.remoteDataChannelMap.get(e)) ||
                  void 0 === i ||
                  i.set(t.id, t)
                : this.remoteDataChannelMap.set(e, new Map([[t.id, t]]));
              const s = this.pendingRemoteDataChannels.findIndex(i => {
                let { user: s, id: r } = i;
                return s.uid === e.uid && r === t.id;
              });
              -1 !== s && this.pendingRemoteDataChannels.splice(s, 1);
            }),
            i.map(e => e.id)
          );
      }
      async subscribe(e, t, i, s, r) {
        var n;
        if (!this.connection || this.state !== jG.Connected)
          throw new JP(
            zP.INVALID_OPERATION,
            "Cannot subscribe remote user when peerConnection disconnected."
          );
        if (
          null !== (n = this.remoteUserMap.get(e)) &&
          void 0 !== n &&
          n.has(t)
        )
          return;
        let a, o, c;
        const d = this.connection.getPreMedia(i);
        if (d)
          EU.debug(
            "["
              .concat(this.store.clientId, "] [")
              .concat(this.store.p2pId, "] preSSRCMap has ssrcId: ")
              .concat(i, ", no need to send sub to gateway.")
          ),
            (c = d.transceiver),
            (a = d.track),
            (o = d.id);
        else if (r) {
          const i = r.find(e => {
            let { stream_type: i } = e;
            return i === t;
          });
          if (!i)
            throw new JP(
              zP.UNEXPECTED_ERROR,
              "Cannot subscribe to remote "
                .concat(t, " for user: ")
                .concat(
                  e.uid,
                  " because subscribe answer from gateway does not contain stream_type: "
                )
                .concat(t, ".")
            );
          const s = await this.connection.receive(
            t,
            i.ssrcs,
            String(e._uintid),
            i.attributes
          );
          this.connection instanceof nK && (c = s.transceiver),
            (a = s.track),
            (o = s.id);
        } else {
          const r = await this.connection.receive(
            t,
            [{ ssrcId: i, rtx: s }],
            String(e._uintid),
            void 0
          );
          this.connection instanceof nK && (c = r.transceiver),
            (a = r.track),
            (o = r.id);
        }
        if (
          (t === xG.AUDIO
            ? (e._audioTrack
                ? e._audioTrack._updateOriginMediaStreamTrack(a)
                : ((e._audioTrack = new VV(a, e.uid, e._uintid, this.store)),
                  EU.info(
                    "["
                      .concat(this.store.clientId, "] [")
                      .concat(this.store.p2pId, "] create remote audio track: ")
                      .concat(e._audioTrack.getTrackId())
                  )),
              c && e._audioTrack._updateRtpTransceiver(c),
              this.bindRemoteTrackEvents(e, e._audioTrack))
            : (e._videoTrack
                ? e._videoTrack._updateOriginMediaStreamTrack(a)
                : ((e._videoTrack = new BV(a, e.uid, e._uintid, this.store)),
                  EU.info(
                    "["
                      .concat(this.store.clientId, "] [")
                      .concat(this.store.p2pId, "] create remote video track: ")
                      .concat(e._videoTrack.getTrackId())
                  )),
              c && e._videoTrack._updateRtpTransceiver(c),
              this.bindRemoteTrackEvents(e, e._videoTrack)),
          c && WM("ENABLE_ENCODED_TRANSFORM"))
        ) {
          const {
            interceptRemoteVideoFrame: i,
            interceptRemoteAudioFrame: s
          } = Jj();
          t == xG.VIDEO
            ? await i(c.receiver, {
                onSei:
                  WM("ENABLE_VIDEO_SEI") &&
                  (t => {
                    var i;
                    return null === (i = e._videoTrack) || void 0 === i
                      ? void 0
                      : i._onSei(t);
                  })
              })
            : t == xG.AUDIO &&
              (await s(c.receiver, {
                enableTopn: !!WM("ENABLE_AUDIO_TOPN"),
                enableMetadata: !!WM("ENABLE_AUDIO_METADATA"),
                onMetadata: e => {
                  this.safeEmit(HG.AudioMetadata, e);
                }
              }));
        }
        const l = this.remoteUserMap.get(e);
        l ? l.set(t, o) : this.remoteUserMap.set(e, new Map([[t, o]])),
          this.statsCollector.addRemoteStats(e.uid),
          this.statsUploader.startUploadInboundStats();
        const h = this.pendingRemoteTracks.findIndex(i => {
          let { user: s, kind: r } = i;
          return s.uid === e.uid && t === r;
        });
        -1 !== h &&
          (this.pendingRemoteTracks.splice(h, 1),
          this.emit(HG.MediaReconnectEnd, e.uid));
      }
      async massSubscribe(e) {
        return this.massSubscribeNoLock(e);
      }
      async massSubscribeNoLock(e) {
        if (!this.connection || this.state !== jG.Connected)
          throw new JP(
            zP.INVALID_OPERATION,
            "Cannot subscribeAll remote users when peerConnection disconnected."
          );
        e = e.filter(e => {
          var t;
          let { user: i, mediaType: s } = e;
          return !(
            null !== (t = this.remoteUserMap.get(i)) &&
            void 0 !== t &&
            t.has(s)
          );
        });
        const t = [],
          i = new Map();
        e.forEach(e => {
          if (!this.connection) return;
          const s = this.connection.getPreMedia(e.ssrcId);
          s ? i.set(e.ssrcId, s) : t.push(e);
        });
        const s = await this.connection.batchReceive(
          t.map(e => {
            let { user: t, mediaType: i, ssrcId: s, rtxSsrcId: r } = e;
            return {
              kind: i,
              ssrcMsg: [{ ssrcId: s, rtx: r }],
              mslabel: String(t._uintid)
            };
          })
        );
        t.forEach((e, t) => {
          i.set(e.ssrcId, s[t]);
        });
        for (const { user: t, mediaType: s, ssrcId: r } of e) {
          const e = i.get(r);
          if (!e)
            return void EU.debug(
              "["
                .concat(this.store.clientId, "] [")
                .concat(this.store.p2pId, "] cannot find ")
                .concat(t.uid, " subscribe data,")
                .concat(s, ", ")
                .concat(r)
            );
          const { track: n, id: a, transceiver: o } = e;
          if (o && WM("ENABLE_ENCODED_TRANSFORM")) {
            const {
              interceptRemoteVideoFrame: e,
              interceptRemoteAudioFrame: i
            } = Jj();
            s == xG.VIDEO
              ? await e(o.receiver, {
                  onSei:
                    WM("ENABLE_VIDEO_SEI") &&
                    (e => {
                      var i;
                      return null === (i = t._videoTrack) || void 0 === i
                        ? void 0
                        : i._onSei(e);
                    })
                })
              : s == xG.AUDIO &&
                (await i(o.receiver, {
                  enableTopn: !!WM("ENABLE_AUDIO_TOPN"),
                  enableMetadata: !!WM("ENABLE_AUDIO_METADATA"),
                  onMetadata: e => {
                    this.safeEmit(HG.AudioMetadata, e);
                  }
                }));
          }
          if (
            (s === xG.AUDIO
              ? (t._audioTrack
                  ? t._audioTrack._updateOriginMediaStreamTrack(n)
                  : ((t._audioTrack = new VV(n, t.uid, t._uintid, this.store)),
                    EU.info(
                      "["
                        .concat(this.store.clientId, "] [")
                        .concat(
                          this.store.p2pId,
                          "] create remote audio track: "
                        )
                        .concat(t._audioTrack.getTrackId())
                    )),
                o && t._audioTrack._updateRtpTransceiver(o),
                this.bindRemoteTrackEvents(t, t._audioTrack))
              : (t._videoTrack
                  ? t._videoTrack._updateOriginMediaStreamTrack(n)
                  : ((t._videoTrack = new BV(n, t.uid, t._uintid, this.store)),
                    EU.info(
                      "["
                        .concat(this.store.clientId, "] [")
                        .concat(
                          this.store.p2pId,
                          "] create remote video track: "
                        )
                        .concat(t._videoTrack.getTrackId())
                    )),
                o && t._videoTrack._updateRtpTransceiver(o),
                this.bindRemoteTrackEvents(t, t._videoTrack)),
            WM("ENABLE_VIDEO_SEI") && o)
          ) {
            const {
              interceptRemoteVideoFrame: e,
              interceptRemoteAudioFrame: i
            } = Jj();
            s == xG.VIDEO
              ? await e(o.receiver, {
                  onSei: e => {
                    var i;
                    null === (i = t._videoTrack) || void 0 === i || i._onSei(e);
                  }
                })
              : s == xG.AUDIO && (await i(o.receiver));
          }
          const c = this.remoteUserMap.get(t);
          c ? c.set(s, a) : this.remoteUserMap.set(t, new Map([[s, a]])),
            this.statsCollector.addRemoteStats(t.uid),
            this.statsUploader.startUploadInboundStats();
          const d = this.pendingRemoteTracks.findIndex(e => {
            let { user: i, kind: r } = e;
            return i.uid === t.uid && s === r;
          });
          -1 !== d &&
            (this.pendingRemoteTracks.splice(d, 1),
            this.emit(HG.MediaReconnectEnd, t.uid));
        }
      }
      async unsubscribe(e, t, i) {
        const s = this.pendingRemoteTracks.filter(i => {
          let { user: s, kind: r } = i;
          return void 0 !== t ? s.uid === e.uid && t === r : s.uid === e.uid;
        });
        if (
          (s.forEach(e => {
            const t = this.pendingRemoteTracks.indexOf(e);
            this.pendingRemoteTracks.splice(t, 1);
          }),
          (this.connection && this.state === jG.Connected) ||
            i ||
            s.forEach(t => {
              let { kind: i } = t;
              var s;
              if (i === xG.AUDIO)
                null === (s = e._audioTrack) || void 0 === s || s._destroy(),
                  (e._audioTrack = void 0);
              else if (i === xG.VIDEO) {
                var r;
                null === (r = e._videoTrack) || void 0 === r || r._destroy(),
                  (e._videoTrack = void 0);
              }
            }),
          !this.connection || this.state !== jG.Connected)
        )
          return;
        const r = this.filterTobeUnSubscribedTracks(e, t);
        if (0 === r.length) return;
        await this.connection.stopReceiving(
          r.map(e => {
            let [, { id: t }] = e;
            return t;
          })
        );
        const n = this.createUnsubscribeMessage(r);
        return (
          this.withdrawRemoteTracks(r),
          0 === this.remoteUserMap.size &&
            this.statsUploader.stopUploadInboundStats(),
          r.forEach(e => {
            let [t, { kind: s }] = e;
            var r, n;
            s === xG.VIDEO &&
              t._videoSSRC &&
              (null === (r = this.connection) ||
                void 0 === r ||
                r.setStatsRemoteVideoIsReady(t._videoSSRC, !1));
            if (s === xG.VIDEO)
              this.unbindRemoteTrackEvents(t._videoTrack),
                i ||
                  (null === (n = t._videoTrack) || void 0 === n || n._destroy(),
                  (t._videoTrack = void 0));
            else if (s === xG.AUDIO) {
              var a;
              if ((this.unbindRemoteTrackEvents(t._audioTrack), !i))
                null === (a = t._audioTrack) || void 0 === a || a._destroy(),
                  (t._audioTrack = void 0);
            }
          }),
          n
        );
      }
      async unsubscribeDataChannel(e, t) {
        if (
          (t.forEach(e => {
            const t = this.pendingRemoteDataChannels.findIndex(
              t => t.id === e.id
            );
            -1 !== t && this.pendingRemoteDataChannels.splice(t, 1);
          }),
          !this.connection)
        )
          return;
        const i = this.filterTobeUnSubscribedDataChannels(e, t);
        if (0 === i.length) return;
        t.forEach(e => {
          e._close();
        });
        const s = this.remoteDataChannelMap.get(e);
        return (
          i.forEach(e => {
            s && s.delete(e.id);
          }),
          s &&
            0 === s.size &&
            (this.remoteDataChannelMap.delete(e),
            await this.connection.stopDataChannels(e.uid)),
          i.map(e => e.id)
        );
      }
      async massUnsubscribe(e) {
        return this.massUnsubscribeNoLock(e);
      }
      async massUnsubscribeNoLock(e) {
        let t = [];
        for (const { user: i, mediaType: s } of e) {
          const e = this.pendingRemoteTracks.filter(e => {
            let { user: t, kind: r } = e;
            return void 0 !== s ? t.uid === i.uid && s === r : t.uid === i.uid;
          });
          e.forEach(e => {
            const t = this.pendingRemoteTracks.indexOf(e);
            this.pendingRemoteTracks.splice(t, 1);
          }),
            (t = t.concat(e));
        }
        if (!this.connection || this.state !== jG.Connected)
          return void t.forEach(e => {
            let { user: t, kind: i } = e;
            var s;
            if (i === xG.AUDIO)
              null === (s = t._audioTrack) || void 0 === s || s._destroy(),
                (t._audioTrack = void 0);
            else if (i === xG.VIDEO) {
              var r;
              null === (r = t._videoTrack) || void 0 === r || r._destroy(),
                (t._videoTrack = void 0);
            }
          });
        const i = e.reduce((e, t) => {
          let { user: i, mediaType: s } = t;
          const r = this.filterTobeUnSubscribedTracks(i, s);
          return e.concat(r);
        }, []);
        if (0 === i.length) return;
        await this.connection.stopReceiving(
          i.map(e => {
            let [, { id: t }] = e;
            return t;
          })
        );
        const s = this.createUnsubscribeAllMessage(i);
        return (
          this.withdrawRemoteTracks(i),
          0 === this.remoteUserMap.size &&
            this.statsUploader.stopUploadInboundStats(),
          i.forEach(e => {
            let [t, { kind: i }] = e;
            var s, r;
            i === xG.VIDEO &&
              t._videoSSRC &&
              (null === (s = this.connection) ||
                void 0 === s ||
                s.setStatsRemoteVideoIsReady(t._videoSSRC, !1));
            if (i === xG.VIDEO)
              this.unbindRemoteTrackEvents(t._videoTrack),
                null === (r = t._videoTrack) || void 0 === r || r._destroy(),
                (t._videoTrack = void 0);
            else if (i === xG.AUDIO) {
              var n;
              this.unbindRemoteTrackEvents(t._audioTrack),
                null === (n = t._audioTrack) || void 0 === n || n._destroy(),
                (t._audioTrack = void 0);
            }
          }),
          s
        );
      }
      isPreSubScribe(e) {
        if (!this.connection || this.state !== jG.Connected) return !1;
        return !!this.connection.getPreMedia(e);
      }
      async muteRemote(e, t) {
        if (!this.connection) return;
        const i = this.remoteUserMap.get(e);
        if (!i)
          return void EU.warning(
            "["
              .concat(
                this.store.clientId,
                "] P2PChannel.muteRemote has no remote user "
              )
              .concat(e.uid, ".")
          );
        if (!i.get(t))
          return void EU.warning(
            "["
              .concat(
                this.store.clientId,
                "] P2PChannel.muteRemote has no remote user "
              )
              .concat(e.uid, " media type ")
              .concat(t, ".")
          );
        const s = t === xG.VIDEO ? e._videoSSRC : e._audioSSRC;
        void 0 !== s && this.connection.setStatsRemoteVideoIsReady(s, !1);
      }
      async unmuteRemote(e, t) {
        return this.unmuteRemoteNoLock(e, t);
      }
      async unmuteRemoteNoLock(e, t) {
        if (!this.connection) return;
        const i = this.remoteUserMap.get(e);
        if (!i)
          return void EU.warning(
            "["
              .concat(
                this.store.clientId,
                "] P2PChannel.unmuteRemote has no remote user "
              )
              .concat(e.uid, ".")
          );
        i.get(t) ||
          EU.warning(
            "["
              .concat(
                this.store.clientId,
                "] P2PChannel.unmuteRemote has no remote user "
              )
              .concat(e.uid, " media type ")
              .concat(t, ".")
          );
      }
      addAudioMetadata(e) {
        const t = this.localTrackMap.get(GG.LocalAudioTrack),
          i = t && t.track;
        i && i.metadata.push(e);
      }
      getAllTracks(e) {
        const t = this.localTrackMap.get(GG.LocalAudioTrack);
        if ((null == t ? void 0 : t.track) instanceof VB) {
          const i = t.track;
          return Array.from(this.localTrackMap.entries())
            .filter(e => {
              let [t] = e;
              return t !== GG.LocalAudioTrack;
            })
            .filter(t => {
              let [i] = t;
              return !(e && i === GG.LocalVideoLowTrack);
            })
            .map(e => {
              let [, { track: t }] = e;
              return t;
            })
            .concat(i.trackList);
        }
        return Array.from(this.localTrackMap.entries())
          .filter(t => {
            let [i] = t;
            return !(e && i === GG.LocalVideoLowTrack);
          })
          .map(e => {
            let [, { track: t }] = e;
            return t;
          });
      }
      getAllDataChannels() {
        return this.localDataChannels;
      }
      reportPublishEvent(e, t, i, s, r) {
        if (e) {
          const i = this.localTrackMap.get(GG.LocalAudioTrack),
            n = s
              ? this.localTrackMap.get(GG.LocalVideoLowTrack)
              : this.localTrackMap.get(GG.LocalVideoTrack);
          yU.publish(this.store.sessionId, {
            eventElapse: MH.measureFromPublishStart(
              this.store.clientId,
              this.store.pubId
            ),
            succ: e,
            ec: t,
            audioName: null == i ? void 0 : i.track.getTrackLabel(),
            videoName: null == n ? void 0 : n.track.getTrackLabel(),
            screenshare:
              -1 !==
              (null == n ? void 0 : n.track._hints.indexOf(Hx.SCREEN_TRACK)),
            audio: !!i,
            video: !!n,
            p2pid: this.store.p2pId,
            publishRequestid: this.store.pubId,
            extend: r
          });
        } else {
          var n;
          i || (i = []);
          const a = i.find(e => e instanceof FB),
            o = s
              ? null === (n = this.localTrackMap.get(GG.LocalVideoTrack)) ||
                void 0 === n
                ? void 0
                : n.track
              : i.find(e => e instanceof AV);
          yU.publish(this.store.sessionId, {
            eventElapse: MH.measureFromPublishStart(
              this.store.clientId,
              this.store.pubId
            ),
            succ: e,
            ec: t,
            audioName: null == a ? void 0 : a.getTrackLabel(),
            videoName: null == o ? void 0 : o.getTrackLabel(),
            screenshare:
              -1 !== (null == o ? void 0 : o._hints.indexOf(Hx.SCREEN_TRACK)),
            audio: !!a,
            video: !!o,
            p2pid: this.store.p2pId,
            publishRequestid: this.store.pubId,
            extend: r
          });
        }
      }
      reportSubscribeEvent(e, t, i, s) {
        const r = s === xG.VIDEO ? i._videoSSRC : i._audioSSRC;
        r &&
          yU.subscribe(this.store.sessionId, {
            succ: e,
            ec: t,
            video: s === xG.VIDEO,
            audio: s === xG.AUDIO,
            peerid: i.uid,
            subscribeRequestid: r,
            p2pid: this.store.p2pId,
            eventElapse: MH.measureFromSubscribeStart(this.store.clientId, r),
            preSsrc: this.isPreSubScribe(r)
          });
      }
      reset() {
        EU.debug("[".concat(this.store.clientId, "] P2PChannel.reset")),
          (this.mutex = new sM("P2PChannel-mutex", this.store.clientId)),
          this.connection &&
            (this.resetConnection(this.connection), (this.connection = void 0)),
          this.shouldForwardP2PCreation &&
            ((this.connection = tK(this.store)),
            this.emit(
              HG.PeerConnectionStateChange,
              this.connection.peerConnectionState
            ),
            this.bindConnectionEvents(this.connection)),
          this.statsUploader.stopUploadOutboundStats(),
          this.statsUploader.stopUploadInboundStats(),
          this.statsUploader.stopUploadTransportStats(),
          this.statsUploader.stopUploadExtensionUsageStats(),
          this.statsUploader.stopUploadBaseStats(),
          this.unbindLocalTrackEvents(),
          this.unbindAllRemoteTrackEvents(),
          this.unbindRtpTransceiver();
        const e = this.localTrackMap.get(GG.LocalAudioTrack);
        if ((null == e ? void 0 : e.track) instanceof VB) {
          if (e.track.trackList.length > 0) {
            const t = e.track;
            e.track.trackList.forEach(e => {
              t.removeAudioTrack(e);
            });
          }
          e.track.close();
        }
        this.localTrackMap.clear(),
          this.remoteUserMap.clear(),
          this.statsCollector.removeRemoteStats(),
          this.statsCollector.removeLocalStats(),
          (this.iceFailedCount = 0),
          (this.dtlsFailedCount = 0),
          (this.pendingLocalTracks = []),
          (this.pendingRemoteTracks = []),
          (this.localDataChannels = []),
          this.remoteDataChannelMap.clear(),
          (this.pendingLocalDataChannels = []),
          (this.pendingRemoteDataChannels = []),
          (this.state = jG.Disconnected);
      }
      getStats() {
        var e;
        return null === (e = this.connection) || void 0 === e
          ? void 0
          : e.getStats();
      }
      getRemoteVideoIsReady(e) {
        var t;
        return (
          (null === (t = this.connection) || void 0 === t
            ? void 0
            : t.getRemoteVideoIsReady(e)) || !1
        );
      }
      getLocalAudioVolume() {
        const e = this.localTrackMap.get(GG.LocalAudioTrack);
        if (e) return e.track.getVolumeLevel();
      }
      getLocalVideoSize() {
        const e = this.localTrackMap.get(GG.LocalVideoTrack);
        if (e)
          return {
            width: e.track.videoWidth || 0,
            height: e.track.videoHeight || 0
          };
      }
      getEncoderConfig(e) {
        const t = this.localTrackMap.get(e);
        return (t && t.track instanceof AV) || (t && t.track instanceof FB)
          ? t.track._encoderConfig
          : void 0;
      }
      getLocalMedia(e) {
        return this.localTrackMap.get(e);
      }
      hasLocalMedia() {
        return this.localTrackMap.size > 0;
      }
      hasRemoteMedia(e, t) {
        if (!e) return this.remoteUserMap.size > 0;
        const i = this.remoteUserMap.get(e);
        return !!i && (!t || i.has(t));
      }
      async hasRemoteMediaWithLock(e, t) {
        if (!e) return this.remoteUserMap.size > 0;
        const i = this.remoteUserMap.get(e);
        return !!i && (!t || i.has(t));
      }
      getRemoteMedia(e) {
        const t = Array.from(this.remoteUserMap.keys()).find(t => t.uid === e);
        return t
          ? {
              audioTrack: t.audioTrack,
              audioSSRC: t._audioSSRC,
              videoTrack: t.videoTrack,
              videoSSRC: t._videoSSRC
            }
          : {};
      }
      getAudioLevels() {
        let e = Array.from(this.remoteUserMap.entries()).map(e => {
          let [t] = e;
          return {
            uid: t.uid,
            level: t.audioTrack
              ? 100 * t.audioTrack._source.getAccurateVolumeLevel()
              : 0
          };
        });
        const t = this.localTrackMap.get(GG.LocalAudioTrack);
        return (
          t &&
            e.push({
              level: 100 * t.track._source.getAccurateVolumeLevel(),
              uid: this.store.uid
            }),
          (e = e.sort((e, t) => e.level - t.level)),
          e
        );
      }
      async disconnectForReconnect() {
        this.connection &&
          (EU.debug(
            "[".concat(
              this.store.clientId,
              "] P2PChannel.disconnectForReconnect closing P2PConnection"
            )
          ),
          (this.state = jG.Reconnecting),
          WM("KEEP_LAST_FRAME") &&
            0 !== this.remoteUserMap.size &&
            Array.from(this.remoteUserMap.entries()).forEach(e => {
              let [t] = e;
              var i;
              t._videoTrack &&
                t._videoTrack._player &&
                (null === (i = t._videoTrack._player.getVideoElement()) ||
                  void 0 === i ||
                  i.pause(),
                (t._videoTrack._player.isKeepLastFrame = !0),
                t._videoTrack._originMediaStreamTrack.stop());
            }),
          this.resetConnection(this.connection),
          (this.connection = void 0),
          this.shouldForwardP2PCreation &&
            ((this.connection = tK(this.store)),
            this.emit(
              HG.PeerConnectionStateChange,
              this.connection.peerConnectionState
            ),
            this.bindConnectionEvents(this.connection)),
          0 !== this.localTrackMap.size &&
            (Array.from(this.localTrackMap.entries()).forEach(e => {
              let [t, { track: i }] = e;
              switch (t) {
                case GG.LocalVideoTrack:
                  i._hints.includes(Hx.LOW_STREAM)
                    ? i.close()
                    : this.pendingLocalTracks.push(i);
                  break;
                case GG.LocalAudioTrack:
                  i instanceof VB
                    ? (this.pendingLocalTracks = this.pendingLocalTracks.concat(
                        i.trackList
                      ))
                    : this.pendingLocalTracks.push(i);
                case GG.LocalVideoLowTrack:
              }
            }),
            this.emit(HG.MediaReconnectStart, this.store.uid)),
          this.unbindLocalTrackEvents(),
          this.localTrackMap.clear(),
          0 !== this.remoteUserMap.size &&
            Array.from(this.remoteUserMap.entries()).forEach(e => {
              let [t, i] = e;
              Array.from(i.keys()).forEach(e => {
                this.setPendingRemoteMedia(t, e);
              }),
                this.emit(HG.MediaReconnectStart, t.uid);
            }),
          this.unbindAllRemoteTrackEvents(),
          this.remoteUserMap.clear(),
          0 !== this.localDataChannels.length &&
            (this.localDataChannels.forEach(e => {
              this.pendingLocalDataChannels.push(e);
            }),
            (this.localDataChannels.length = 0)),
          0 !== this.remoteDataChannelMap.size &&
            (Array.from(this.remoteDataChannelMap.entries()).forEach(e => {
              let [t, i] = e;
              Array.from(i.keys()).forEach(e => {
                this.setPendingRemoteDataChannel(t, e);
              });
            }),
            this.remoteDataChannelMap.clear()),
          this.statsUploader.stopUploadOutboundStats(),
          this.statsUploader.stopUploadInboundStats(),
          this.statsUploader.stopUploadTransportStats(),
          EU.debug(
            "[".concat(
              this.store.clientId,
              "] P2PChannel disconnected, waiting to reconnect."
            )
          ));
      }
      hasPendingRemoteDataChannel(e, t) {
        for (const i of this.pendingRemoteDataChannels) {
          const { user: s, id: r } = i;
          if ((e instanceof BH ? e.uid : e) === s.uid && r === t) return !0;
        }
        return !1;
      }
      setPendingRemoteDataChannel(e, t) {
        this.hasPendingRemoteDataChannel(e, t) ||
          this.pendingRemoteDataChannels.push({ user: e, id: t });
      }
      hasPendingRemoteMedia(e, t) {
        for (const i of this.pendingRemoteTracks) {
          const { user: s, kind: r } = i;
          if ((e instanceof BH ? e.uid : e) === s.uid && t === r) return !0;
        }
        return !1;
      }
      setPendingRemoteMedia(e, t) {
        this.hasPendingRemoteMedia(e, t) ||
          this.pendingRemoteTracks.push({ user: e, kind: t });
      }
      restartICE(e) {
        var t = this;
        return nG(function*() {
          if (!t.connection || t.state !== jG.Connected) return;
          const i = yield tG(t.mutex.lock("From P2PChannel.restartICE"));
          let s;
          try {
            s = yield tG(t.connection.restartICE(e));
            const r = yield tG(s.next());
            if (r.done) return;
            const n = r.value,
              a = yield n;
            switch (
              (iK(t.connection) &&
                t.reportPCStats(Date.now(), !1, t._pcStatsUploadType),
              e)
            ) {
              case FG.UDP_TCP_RELAY:
                t._pcStatsUploadType = BG.UDP_TCP_RESTART;
                break;
              case FG.TCP_RELAY:
                t._pcStatsUploadType = BG.TCP_RESTART;
                break;
              case FG.RELAY:
                t._pcStatsUploadType = BG.RELAY_RESTART;
                break;
              default:
                t._pcStatsUploadType = BG.OLD_RESTART;
            }
            (t._isTryConnecting = !0), s.next(a);
          } catch (e) {
            var r;
            null === (r = s) || void 0 === r || r.throw(e);
          } finally {
            i();
          }
        })();
      }
      getUplinkNetworkQuality() {
        if (!this.connection) return 0;
        const e = this.connection.getStats(),
          t = this.localTrackMap.get(GG.LocalVideoTrack),
          i = this.localTrackMap.get(GG.LocalAudioTrack),
          s = e.videoSend.find(
            e => e.ssrc === (null == t ? void 0 : t.ssrcs[0].ssrcId)
          ),
          r = e.audioSend.find(
            e => e.ssrc === (null == i ? void 0 : i.ssrcs[0].ssrcId)
          );
        if (!s || !r) return 1;
        const n = Ok(this, HG.NeedSignalRTT),
          a = s ? s.rttMs : void 0,
          o = r ? r.rttMs : void 0,
          c = a && o ? (a + o) / 2 : a || o,
          d = (c && n ? (c + n) / 2 : c || n) || 0,
          l = (100 * e.sendPacketLossRate * 0.7) / 50 + (0.3 * d) / 1500,
          h = l < 0.17 ? 1 : l < 0.36 ? 2 : l < 0.59 ? 3 : l < 0.1 ? 4 : 5,
          u = null == t ? void 0 : t.track;
        if (u && u._encoderConfig && -1 === u._hints.indexOf(Hx.SCREEN_TRACK)) {
          const t = u._encoderConfig.bitrateMax,
            i = e.bitrate.actualEncoded;
          if (t && i) {
            const e = (1e3 * t - i) / (1e3 * t);
            return WV[
              e < 0.15 ? 0 : e < 0.3 ? 1 : e < 0.45 ? 2 : e < 0.6 ? 3 : 4
            ][h];
          }
        }
        return h;
      }
      getDownlinkNetworkQuality() {
        if (!this.connection) return 0;
        const e = this.connection.getStats();
        let t = 0;
        return (
          Array.from(this.remoteUserMap.entries()).forEach(i => {
            let [s] = i;
            const r = s._audioSSRC,
              n = s._videoSSRC,
              a = e.audioRecv.find(e => e.ssrc === r),
              o = e.videoRecv.find(e => e.ssrc === n);
            if (!a && !o) return void (t += 1);
            const c = Ok(this, HG.NeedSignalRTT),
              d = e.rtt,
              l = (d && c ? (d + c) / 2 : d || c) || 0,
              h = a ? a.jitterMs : void 0,
              u = e.recvPacketLossRate;
            let p = (0.7 * u * 100) / 50 + (0.3 * l) / 1500;
            h &&
              (p = (0.6 * u * 100) / 50 + (0.2 * l) / 1500 + (0.2 * h) / 400);
            t += p < 0.1 ? 1 : p < 0.17 ? 2 : p < 0.36 ? 3 : p < 0.59 ? 4 : 5;
          }),
          this.remoteUserMap.size > 0
            ? Math.round(t / this.remoteUserMap.size)
            : t
        );
      }
      async muteLocalTrack(e) {
        return new Promise((t, i) => {
          this.handleMuteLocalTrack(e, t, i);
        });
      }
      async replaceTrack(e, t) {
        var i;
        if (
          (EU.debug(
            "["
              .concat(this.store.clientId, "] P2PChannel replaceTrack from [")
              .concat(e.getTrackId(), "] to [")
              .concat(t.getTrackId(), "]")
          ),
          !this.connection || this.state !== jG.Connected)
        )
          return;
        const s = Array.from(this.localTrackMap.entries()).find(t => {
          let [, { track: i }] = t;
          return e === i;
        });
        if (!s) return;
        const r = s[0];
        if (
          (e !== t &&
            (this.unbindLocalTrackEvents([{ track: e, type: r }]),
            this.bindLocalTrackEvents([{ track: t, type: r }]),
            (s[1].track = t)),
          await (null === (i = this.connection) || void 0 === i
            ? void 0
            : i.replaceTrack(t, s[1].id)),
          this.isPlanB)
        ) {
          const e = s[1];
          (e.id = t._mediaStreamTrack.id), this.localTrackMap.set(r, e);
        }
        if (
          r === GG.LocalVideoTrack &&
          !WM("DISABLE_DUAL_STREAM_USE_ENCODING") &&
          Lx().supportDualStreamEncoding
        ) {
          const t = this.localTrackMap.get(GG.LocalVideoLowTrack);
          if (t) {
            const i = e._mediaStreamTrack.clone();
            t.track._originMediaStreamTrack.stop(),
              (t.track._mediaStreamTrack = i),
              (t.track._originMediaStreamTrack = i),
              await new Promise((e, i) => {
                this.handleReplaceTrack(t.track, e, i, !0);
              });
          }
        }
      }
      filterTobePublishedTracks(e, t, i) {
        const s = [],
          r = this.getAllTracks();
        e = Nk((e = e.filter(e => -1 === r.indexOf(e))));
        let n,
          a = !1;
        const o = this.localTrackMap.get(GG.LocalAudioTrack);
        for (const r of e) {
          if (
            r instanceof AV &&
            (this.localTrackMap.has(GG.LocalVideoTrack) || a
              ? new JP(zP.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw()
              : (s.push({ track: r, type: GG.LocalVideoTrack }), (a = !0)),
            t)
          ) {
            const e = this.getLowVideoTrack(r, i);
            s.push({ track: e, type: GG.LocalVideoLowTrack });
          }
          if (r instanceof FB)
            if (o) {
              const e = o.track;
              if (e instanceof VB)
                QH([r]),
                  e.addAudioTrack(r),
                  this.bindLocalAudioTrackEvents(r, !0);
              else {
                const t = ZH([e, r]);
                EU.debug(
                  "["
                    .concat(this.store.clientId, "] [p2pId: ")
                    .concat(
                      this.store.p2pId,
                      "]: P2PConnection will replace audioTrack ["
                    )
                    .concat(t.getTrackId(), "]")
                ),
                  this.replaceTrack(e, t);
              }
            } else if (n instanceof VB) QH([r]), n.addAudioTrack(r);
            else if (
              n ||
              (!r._useAudioElement &&
                Lx().webAudioMediaStreamDest &&
                !r._bypassWebAudio)
            ) {
              n = ZH(n ? [r, n] : [r]);
            } else n = r;
        }
        return (
          n &&
            (EU.debug(
              "["
                .concat(this.store.clientId, "] [p2pId: ")
                .concat(
                  this.store.p2pId,
                  "]: P2PConnection will send audioTrack ["
                )
                .concat(n.getTrackId(), "]")
            ),
            s.push({ track: n, type: GG.LocalAudioTrack })),
          s
        );
      }
      filterTobeUnpublishedTracks(e) {
        const t = [],
          i = this.getAllTracks();
        e = Nk((e = e.filter(e => -1 !== i.indexOf(e))));
        for (const i of e) {
          if (i instanceof FB) {
            const e = this.localTrackMap.get(GG.LocalAudioTrack);
            if (!e) continue;
            e.track instanceof VB
              ? (e.track.removeAudioTrack(i),
                this.unbindLocalAudioTrackEvents(i),
                0 === e.track.trackList.length &&
                  (t.push([GG.LocalAudioTrack, e]), e.track.close()))
              : t.push([GG.LocalAudioTrack, e]);
          }
          if (i instanceof AV) {
            const e = this.localTrackMap.get(GG.LocalVideoTrack);
            if (!e) continue;
            t.push([GG.LocalVideoTrack, e]);
            const i = this.localTrackMap.get(GG.LocalVideoLowTrack);
            i && t.push([GG.LocalVideoLowTrack, i]);
          }
        }
        return t;
      }
      filterTobePublishedDataChannels(e) {
        return (e = (e = Nk(e)).filter(
          e => -1 === this.localDataChannels.findIndex(t => t.id === e.id)
        ));
      }
      filterTobeUnpublishedDataChannels(e) {
        return (e = (e = (e = Nk(e)).filter(
          e => -1 !== this.localDataChannels.indexOf(e)
        )).filter(e => e._originDataChannel));
      }
      bindLocalTrackEvents(e) {
        e.forEach(e => {
          let { track: t, type: i } = e;
          switch (i) {
            case GG.LocalVideoTrack:
              t.addListener(jx.GET_STATS, this.handleGetLocalVideoStats),
                t.addListener(jx.GET_RTC_STATS, this.handleGetRTCStats),
                t.addListener(jx.NEED_DISABLE_TRACK, this.handleMuteLocalTrack),
                t.addListener(
                  jx.NEED_ENABLE_TRACK,
                  this.handleUnmuteLocalTrack
                ),
                t.addListener(
                  jx.NEED_UPDATE_VIDEO_ENCODER,
                  this.handleUpdateVideoEncoder
                ),
                t.addListener(
                  jx.NEED_UPDATE_VIDEO_SEND_PARAMETERS,
                  this.handleUpdateVideoSendParameters
                ),
                t.addListener(jx.NEED_REPLACE_TRACK, this.handleReplaceTrack),
                t.addListener(jx.NEED_MUTE_TRACK, this.handleMuteLocalTrack),
                t.addListener(
                  jx.NEED_UNMUTE_TRACK,
                  this.handleUnmuteLocalTrack
                );
              break;
            case GG.LocalAudioTrack:
              this.bindLocalAudioTrackEvents(t);
            case GG.LocalVideoLowTrack:
          }
        });
      }
      bindLocalAudioTrackEvents(e, t) {
        e instanceof VB
          ? e.trackList.forEach(e => {
              e.addListener(jx.NEED_DISABLE_TRACK, this.handleMuteLocalTrack),
                e.addListener(
                  jx.NEED_ENABLE_TRACK,
                  this.handleUnmuteLocalTrack
                ),
                e.addListener(jx.GET_STATS, this.handleGetLocalAudioStats),
                e.addListener(jx.NEED_MUTE_TRACK, this.handleMuteLocalTrack),
                e.addListener(
                  jx.NEED_UNMUTE_TRACK,
                  this.handleUnmuteLocalTrack
                );
            })
          : (e.addListener(jx.GET_STATS, this.handleGetLocalAudioStats),
            e.addListener(jx.NEED_DISABLE_TRACK, this.handleMuteLocalTrack),
            e.addListener(jx.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack),
            e.addListener(jx.NEED_MUTE_TRACK, this.handleMuteLocalTrack),
            e.addListener(jx.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack),
            t ||
              (e.addListener(jx.NEED_REPLACE_TRACK, this.handleReplaceTrack),
              e.addListener(
                jx.NEED_REPLACE_MIXING_TRACK,
                this.handleReplaceMixingTrack
              )));
      }
      unbindLocalTrackEvents(e) {
        e ||
          (e = Array.from(this.localTrackMap.entries()).map(e => {
            let [t, { track: i }] = e;
            return { track: i, type: t };
          })),
          e.forEach(e => {
            let { track: t, type: i } = e;
            switch (i) {
              case GG.LocalVideoTrack:
                t.off(jx.GET_STATS, this.handleGetLocalVideoStats),
                  t.off(jx.GET_RTC_STATS, this.handleGetRTCStats),
                  t.off(jx.NEED_DISABLE_TRACK, this.handleMuteLocalTrack),
                  t.off(jx.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack),
                  t.off(
                    jx.NEED_UPDATE_VIDEO_ENCODER,
                    this.handleUpdateVideoEncoder
                  ),
                  t.off(
                    jx.NEED_UPDATE_VIDEO_SEND_PARAMETERS,
                    this.handleUpdateVideoSendParameters
                  ),
                  t.off(jx.NEED_REPLACE_TRACK, this.handleReplaceTrack),
                  t.off(jx.NEED_MUTE_TRACK, this.handleMuteLocalTrack),
                  t.off(jx.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case GG.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t);
              case GG.LocalVideoLowTrack:
            }
          });
      }
      unbindLocalAudioTrackEvents(e) {
        e instanceof VB
          ? e.trackList.forEach(e => {
              e.off(jx.NEED_DISABLE_TRACK, this.handleMuteLocalTrack),
                e.off(jx.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack),
                e.off(jx.GET_STATS, this.handleGetLocalAudioStats),
                e.off(jx.NEED_MUTE_TRACK, this.handleMuteLocalTrack),
                e.off(jx.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
            })
          : (e.off(jx.GET_STATS, this.handleGetLocalAudioStats),
            e.off(jx.NEED_DISABLE_TRACK, this.handleMuteLocalTrack),
            e.off(jx.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack),
            e.off(jx.NEED_REPLACE_TRACK, this.handleReplaceTrack),
            e.off(jx.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack),
            e.off(jx.NEED_MUTE_TRACK, this.handleMuteLocalTrack),
            e.off(jx.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
      }
      bindRemoteTrackEvents(e, t) {
        t instanceof BV &&
          t.addListener(jx.GET_STATS, t => {
            t(this.handleGetRemoteVideoStats(e));
          }),
          t instanceof VV &&
            t.addListener(jx.GET_STATS, t => {
              t(this.handleGetRemoteAudioStats(e));
            });
      }
      unbindRemoteTrackEvents(e) {
        e && e.removeAllListeners(jx.GET_STATS);
      }
      unbindAllRemoteTrackEvents() {
        Array.from(this.remoteUserMap.entries()).forEach(e => {
          let [t, i] = e;
          i.has(xG.AUDIO) && this.unbindRemoteTrackEvents(t._audioTrack),
            i.has(xG.VIDEO) && this.unbindRemoteTrackEvents(t._videoTrack);
        });
      }
      createGatewayPublishMessage(e, t) {
        return e.map((e, i) => {
          let s,
            r,
            { track: n, type: a } = e;
          switch (a) {
            case GG.LocalAudioTrack:
              (s = IG.Audio),
                (r = {
                  dtx: n instanceof BB && n._config.DTX,
                  hq: !1,
                  lq: !1,
                  stereo: !1,
                  speech: !1
                });
              break;
            case GG.LocalVideoTrack:
              (s = n._hints.includes(Hx.SCREEN_TRACK) ? IG.Screen : IG.High),
                (r = rG(
                  rG({}, gj(n)),
                  {},
                  { codec: this.store.codec, svc_mode: yj() }
                ));
              break;
            case GG.LocalVideoLowTrack:
              (s = IG.Low),
                (r = rG(
                  rG({}, gj(n)),
                  {},
                  { codec: this.store.codec, svc_mode: yj() }
                ));
          }
          return { stream_type: s, attributes: r, ssrcs: t[i] };
        });
      }
      createGatewayUnpublishMessage(e) {
        return e.map(e => {
          let t,
            [i, { track: s, ssrcs: r, id: n }] = e;
          switch (i) {
            case GG.LocalVideoTrack:
              t = s._hints.includes(Hx.SCREEN_TRACK) ? IG.Screen : IG.High;
              break;
            case GG.LocalAudioTrack:
              t = IG.Audio;
              break;
            case GG.LocalVideoLowTrack:
              t = IG.Low;
          }
          return { stream_type: t, ssrcs: r, mid: n };
        });
      }
      assignLocalTracks(e, t) {
        e.forEach((e, i) => {
          let { track: s, type: r } = e;
          this.localTrackMap.set(r, {
            track: s,
            id: t[i].id,
            ssrcs: t[i].localSSRC
          });
        });
      }
      withdrawLocalTracks(e) {
        e.forEach(e => {
          let [t] = e;
          this.localTrackMap.delete(t);
        });
      }
      bindConnectionEvents(e) {
        (e.onConnectionStateChange = async t => {
          if (
            (EU.info(
              "["
                .concat(this.store.clientId, "] [p2pId: ")
                .concat(
                  this.store.p2pId,
                  "]: P2PConnection.onConnectionStateChange("
                )
                .concat(t, ")")
            ),
            this.emit(HG.PeerConnectionStateChange, t),
            "connecting" === t &&
              e instanceof nK &&
              !DP() &&
              WM("FIRST_TCP_CANDIDATE") &&
              window.setTimeout(() => {
                "connecting" === t && e.extendCandidate();
              }, WM("FIRST_TCP_CANDIDATE_INTERVAL")),
            "connected" !== t ||
              this.store.keyMetrics.peerConnectionEnd ||
              this.store.peerConnectionEnd(),
            "connected" === t)
          ) {
            this._restartTimer &&
              (window.clearTimeout(this._restartTimer),
              (this._restartTimer = void 0)),
              e instanceof nK && NK(e, !0),
              this._isTryConnecting &&
                this.reportPCStats(Date.now(), !0, this._pcStatsUploadType),
              (this._isTryConnecting = !1),
              (this._isStartRestartIce = !1),
              (this._pcStatsUploadType = BG.DISCONNECTED_OR_FAILED);
            if (
              "CONNECTED" === Ok(this, HG.QueryClientConnectionState) &&
              this._isWaitPcToRePub
            ) {
              const e = this.pendingLocalTracks.map(e => e.getTrackId()),
                t = this.pendingLocalDataChannels.map(e => "dc_".concat(e.id));
              yU
                .reportApiInvoke(this.store.sessionId, {
                  name: Ek.REPUB_AFTER_PC_CONNECTED,
                  options: e.concat(t),
                  tag: mk.TRACER
                })
                .onSuccess(),
                this.republish();
            }
          }
          if (
            WM("NEW_ICE_RESTART") &&
            e instanceof nK &&
            !DP() &&
            !this._forceTurn
          ) {
            if (VG.includes(t)) {
              if (this._isStartRestartIce) return;
              this._isStartRestartIce = !0;
              const t = t => {
                  if (iK(e)) {
                    EU.debug(
                      "["
                        .concat(
                          this.store.clientId,
                          "] [P2PChannel] try to restartICE, type is "
                        )
                        .concat(t)
                    );
                    "CONNECTED" === Ok(this, HG.QueryClientConnectionState) &&
                      this.emit(HG.RequestRestartICE, t);
                  }
                },
                i = () => {
                  iK(e) &&
                    (this.reportPCStats(
                      Date.now(),
                      !1,
                      this._pcStatsUploadType
                    ),
                    EU.debug(
                      "[".concat(
                        this.store.clientId,
                        "] P2PConnection disconnected timeout, force reconnect"
                      )
                    ),
                    setTimeout(() => this.emit(HG.P2PLost), 0),
                    (this.iceFailedCount += 1),
                    this.requestReconnect());
                };
              return void (this._restartTimer = window.setTimeout(() => {
                PK(e, t, i);
              }, 800));
            }
          } else {
            if ("disconnected" === t && "disconnected" === e.iceConnectionState)
              return (
                setTimeout(() => {
                  if (
                    "disconnected" === e.iceConnectionState &&
                    WM("ICE_RESTART")
                  ) {
                    "CONNECTED" === Ok(this, HG.QueryClientConnectionState) &&
                      this.emit(HG.RequestRestartICE);
                  }
                }, 800),
                void setTimeout(() => {
                  "disconnected" === e.peerConnectionState &&
                    (EU.debug(
                      "["
                        .concat(this.store.clientId, "] [p2pId: ")
                        .concat(
                          this.store.p2pId,
                          "]: P2PConnection disconnected timeout 4000ms, force reconnect"
                        )
                    ),
                    this.reportPCStats(Date.now(), !1, this._pcStatsUploadType),
                    (this._isTryConnecting = !1),
                    setTimeout(() => this.emit(HG.P2PLost), 0),
                    (this.iceFailedCount += 1),
                    this.requestReconnect());
                }, 4e3)
              );
            "failed" === t &&
              (EU.debug(
                "["
                  .concat(this.store.clientId, "] [p2pId: ")
                  .concat(
                    this.store.p2pId,
                    "]: P2PConnection state failed, force reconnect"
                  )
              ),
              this.reportPCStats(Date.now(), !1, this._pcStatsUploadType),
              setTimeout(() => this.emit(HG.P2PLost), 0),
              (this.iceFailedCount += 1),
              await this.requestReconnect());
          }
        }),
          (e.onICEConnectionStateChange = e => {
            "connected" !== e ||
              this.store.keyMetrics.iceConnectionEnd ||
              this.store.iceConnectionEnd(),
              EU.info(
                "["
                  .concat(this.store.clientId, "] [p2pId: ")
                  .concat(
                    this.store.p2pId,
                    "]: P2PConnection.onICEConnectionStateChange("
                  )
                  .concat(e, ")")
              ),
              yU
                .reportApiInvoke(this.store.sessionId, {
                  name: "ICEConnectionStateChange",
                  options: e,
                  tag: mk.TRACER
                })
                .onSuccess(),
              this.emit(HG.IceConnectionStateChange, e);
          }),
          (e.onICETransportStateChange = e => {
            EU.info(
              "["
                .concat(this.store.clientId, "] [p2pId: ")
                .concat(
                  this.store.p2pId,
                  "]: P2PConnection.onICETransportStateChange("
                )
                .concat(e, ")")
            );
          }),
          (e.onDTLSTransportStateChange = e => {
            EU.info(
              "["
                .concat(this.store.clientId, "] [p2pId: ")
                .concat(
                  this.store.p2pId,
                  "]: P2PConnection.onDTLSTransportStateChange("
                )
                .concat(e, ")")
            );
          }),
          (e.onDTLSTransportError = e => {
            EU.info(
              "["
                .concat(this.store.clientId, "] [p2pId: ")
                .concat(
                  this.store.p2pId,
                  "]: P2PConnection.onDTLSTransportError("
                )
                .concat(e, ")")
            );
          }),
          (e.onFirstAudioDecoded = e => {
            const t = Array.from(this.remoteUserMap.keys()).find(
              t => t._audioSSRC === e
            );
            var i;
            t &&
              (this.store.subscribe(
                t.uid,
                "audio",
                void 0,
                void 0,
                void 0,
                Date.now()
              ),
              null === (i = t.audioTrack) ||
                void 0 === i ||
                i.emit($x.FIRST_FRAME_DECODED),
              yU.firstRemoteFrame(
                this.store.sessionId,
                TU.FIRST_AUDIO_DECODE,
                SU.FIRST_AUDIO_DECODE,
                {
                  peer: t._uintid,
                  subscribeElapse: MH.measureFromSubscribeStart(
                    this.store.clientId,
                    e
                  ),
                  subscribeRequestid: e,
                  p2pid: this.store.p2pId
                }
              ));
          }),
          (e.onFirstAudioReceived = e => {
            const t = Array.from(this.remoteUserMap.keys()).find(
              t => t._audioSSRC === e
            );
            t &&
              yU.firstRemoteFrame(
                this.store.sessionId,
                TU.FIRST_AUDIO_RECEIVED,
                SU.FIRST_AUDIO_RECEIVED,
                {
                  peer: t._uintid,
                  subscribeElapse: MH.measureFromSubscribeStart(
                    this.store.clientId,
                    e
                  ),
                  subscribeRequestid: e,
                  p2pid: this.store.p2pId
                }
              );
          }),
          (e.onFirstVideoDecoded = (e, t, i) => {
            this.reportVideoFirstFrameDecoded(e, t, i);
          }),
          (e.onFirstVideoReceived = e => {
            const t = Array.from(this.remoteUserMap.keys()).find(
              t => t._videoSSRC === e
            );
            t &&
              yU.firstRemoteFrame(
                this.store.sessionId,
                TU.FIRST_VIDEO_RECEIVED,
                SU.FIRST_VIDEO_RECEIVED,
                {
                  peer: t._uintid,
                  subscribeElapse: MH.measureFromSubscribeStart(
                    this.store.clientId,
                    e
                  ),
                  subscribeRequestid: e,
                  p2pid: this.store.p2pId
                }
              );
          }),
          (e.onSelectedLocalCandidateChanged = (e, t) => {
            const i = "relay" === e.candidateType,
              s = "relay" === t.candidateType;
            ("unknown" !== t.candidateType && i === s) ||
              this.emit(HG.ConnectionTypeChange, i),
              EU.info(
                "["
                  .concat(this.store.clientId, "] [p2pId: ")
                  .concat(
                    this.store.p2pId,
                    "]: P2PConnection.SelectedLocalCandidateChanged("
                  )
                  .concat(JSON.stringify(Rj(t)), " -> ")
                  .concat(JSON.stringify(Rj(e)), ")")
              );
          }),
          (e.onSelectedRemoteCandidateChanged = (e, t) => {
            EU.info(
              "["
                .concat(this.store.clientId, "] [p2pId: ")
                .concat(
                  this.store.p2pId,
                  "]: P2PConnection.SelectedRemoteCandidateChanged("
                )
                .concat(JSON.stringify(Rj(t)), " -> ")
                .concat(JSON.stringify(Rj(e)), ")")
            );
          }),
          (e.onFirstVideoDecodedTimeout = e => {
            this.reportVideoFirstFrameDecoded(e, void 0, void 0, !0);
          }),
          (e.getLocalVideoStats = () => {
            const e = this.statsCollector.getLocalVideoTrackStats(),
              t = this.statsCollector.getRTCStats();
            return rG(rG({}, e), t);
          }),
          (e.onICECandidateError = e => {
            this._iceError = e;
          });
      }
      resetConnection(e) {
        e instanceof nK &&
          (function(e) {
            DK.delete(e.id), NK(e);
          })(e),
          e.close(),
          this.emit(HG.PeerConnectionStateChange, "closed"),
          (function(e) {
            (e.onConnectionStateChange = void 0),
              (e.onICEConnectionStateChange = void 0),
              (e.onICETransportStateChange = void 0),
              (e.onDTLSTransportStateChange = void 0),
              (e.onDTLSTransportError = void 0),
              (e.onFirstAudioDecoded = void 0),
              (e.onFirstAudioReceived = void 0),
              (e.onFirstVideoDecoded = void 0),
              (e.onFirstVideoReceived = void 0),
              (e.onSelectedLocalCandidateChanged = void 0),
              (e.onSelectedRemoteCandidateChanged = void 0),
              (e.onFirstVideoDecodedTimeout = void 0),
              (e.getLocalVideoStats = void 0);
          })(e),
          (this._isWaitPcToRePub = !1);
      }
      filterTobeMutedTracks(e) {
        const t = [];
        if (-1 === this.getAllTracks().indexOf(e)) return t;
        const i = this.localTrackMap.get(GG.LocalAudioTrack);
        if (e instanceof FB && (null == i ? void 0 : i.track) instanceof VB)
          return i.track.isActive || t.push([GG.LocalAudioTrack, i]), t;
        const s = Array.from(this.localTrackMap.entries()).find(t => {
          let [, { track: i }] = t;
          return e === i;
        });
        if (s && (t.push(s), s[0] === GG.LocalVideoTrack)) {
          const e = this.localTrackMap.get(GG.LocalVideoLowTrack);
          e && t.push([GG.LocalVideoLowTrack, e]);
        }
        return t;
      }
      filterTobeUnmutedTracks(e) {
        const t = [],
          i = this.localTrackMap.get(GG.LocalAudioTrack);
        if (e instanceof FB && (null == i ? void 0 : i.track) instanceof VB)
          return i.track.isActive && t.push([GG.LocalAudioTrack, i]), t;
        const s = Array.from(this.localTrackMap.entries()).find(t => {
          let [, { track: i }] = t;
          return e === i;
        });
        if (s)
          if (s[0] === GG.LocalVideoTrack) {
            t.push(s);
            const e = this.localTrackMap.get(GG.LocalVideoLowTrack);
            e && t.push([GG.LocalVideoLowTrack, e]);
          } else t.push(s);
        return t;
      }
      createMuteMessage(e) {
        return e.map(e => {
          let t,
            [i, { track: s, ssrcs: r, id: n }] = e;
          switch (i) {
            case GG.LocalAudioTrack:
              t = IG.Audio;
              break;
            case GG.LocalVideoTrack:
              t = s._hints.includes(Hx.SCREEN_TRACK) ? IG.Screen : IG.High;
              break;
            case GG.LocalVideoLowTrack:
              t = IG.Low;
          }
          return { stream_type: t, ssrcs: r, mid: n };
        });
      }
      createUnmuteMessage(e) {
        return e.map(e => {
          let t,
            [i, { track: s, ssrcs: r, id: n }] = e;
          switch (i) {
            case GG.LocalAudioTrack:
              t = IG.Audio;
              break;
            case GG.LocalVideoTrack:
              t = s._hints.includes(Hx.SCREEN_TRACK) ? IG.Screen : IG.High;
              break;
            case GG.LocalVideoLowTrack:
              t = IG.Low;
          }
          return { stream_type: t, ssrcs: r, mid: n };
        });
      }
      filterTobeUnSubscribedTracks(e, t) {
        const i = [],
          s = this.remoteUserMap.get(e);
        if (!s) return i;
        if (t) {
          const r = s.get(t);
          if (!r) return i;
          i.push([e, { kind: t, id: r }]);
        } else
          Array.from(s.entries()).forEach(t => {
            let [s, r] = t;
            i.push([e, { kind: s, id: r }]);
          });
        return i;
      }
      filterTobeUnSubscribedDataChannels(e, t) {
        const i = [];
        return (
          t.forEach(t => {
            var s;
            null !== (s = this.remoteDataChannelMap.get(e)) &&
              void 0 !== s &&
              s.has(t.id) &&
              i.push(t);
          }),
          i
        );
      }
      createUnsubscribeMessage(e) {
        const t = [];
        return (
          e.forEach(e => {
            let [i, { kind: s, id: r }] = e;
            switch (s) {
              case xG.VIDEO:
                return void (
                  i._videoSSRC &&
                  t.push({ stream_type: xG.VIDEO, ssrcId: i._videoSSRC })
                );
              case xG.AUDIO:
                return void (
                  i._audioSSRC &&
                  t.push({ stream_type: xG.AUDIO, ssrcId: i._audioSSRC })
                );
            }
          }),
          t
        );
      }
      createUnsubscribeAllMessage(e) {
        const t = new Map();
        return (
          e.forEach(e => {
            let [i, { kind: s }] = e;
            if (t.has(i)) {
              let e = t.get(i);
              s === xG.VIDEO ? (e |= OG.Video) : (e |= OG.Audio), t.set(i, e);
            } else s === xG.VIDEO ? t.set(i, OG.Video) : t.set(i, OG.Audio);
          }),
          {
            users: Array.from(t.entries()).map(e => {
              let [t, i] = e;
              return { stream_id: t.uid, stream_type: i };
            })
          }
        );
      }
      withdrawRemoteTracks(e) {
        e.forEach(e => {
          let [t, { kind: i }] = e;
          const s = this.remoteUserMap.get(t);
          s &&
            (s.delete(i),
            0 === Array.from(s.entries()).length &&
              this.remoteUserMap.delete(t));
        });
      }
      async updateBitrateLimit(e) {
        const t = this.localTrackMap.get(GG.LocalVideoTrack),
          i = this.localTrackMap.get(GG.LocalVideoLowTrack);
        t &&
          (await t.track.setBitrateLimit(e.uplink),
          await new Promise((e, i) => {
            this.handleUpdateVideoEncoder(t.track, e, i, !0);
          })),
          i &&
            e.low_stream_uplink &&
            (await i.track.setBitrateLimit({
              max_bitrate: e.low_stream_uplink.bitrate,
              min_bitrate: e.low_stream_uplink.bitrate || 0
            }),
            await new Promise((e, t) => {
              this.handleUpdateVideoEncoder(i.track, e, t, !0);
            }));
      }
      isP2PDisconnected() {
        if (this.connection) {
          return "connected" !== this.connection.peerConnectionState;
        }
        return !0;
      }
      mapPubResToRemoteConfig(e, t, i) {
        return e.map((e, s) => {
          var r;
          let { stream_type: n } = e;
          const a =
            null ===
              (r = t.find(e => {
                let { stream_type: t } = e;
                return n === t;
              })) || void 0 === r
              ? void 0
              : r.attributes;
          if (a && WM("DISABLE_SCREEN_SHARE_REMB")) {
            const e = i[s]._hints;
            (e.includes(Hx.SCREEN_TRACK) || e.includes(Hx.SCREEN_LOW_TRACK)) &&
              ((a.remb = !1),
              EU.debug("disable remb for screen share, hints:", e));
          }
          return a;
        });
      }
      async tryToUnmuteAudio(e) {
        for (let i = 0; i < e.length; i++)
          if (e[i] instanceof FB) {
            var t;
            const s = this.filterTobeUnmutedTracks(e[i]);
            if (0 === s.length) continue;
            await (null === (t = this.connection) || void 0 === t
              ? void 0
              : t.unmuteLocal(
                  s.map(e => {
                    let [, { id: t }] = e;
                    return t;
                  })
                ));
            const r = this.createUnmuteMessage(s);
            return void (await bk(this, HG.RequestUnmuteLocal, r));
          }
      }
      bindStatsUploaderEvents() {
        (this.statsUploader.requestStats = () => this.getStats()),
          (this.statsUploader.requestLocalMedia = () =>
            Array.from(this.localTrackMap.entries())),
          (this.statsUploader.requestRemoteMedia = () =>
            Array.from(this.remoteUserMap.entries())),
          (this.statsUploader.requestVideoIsReady = e => {
            var t;
            return !(
              null === (t = this.connection) ||
              void 0 === t ||
              !t.getRemoteVideoIsReady(e)
            );
          }),
          (this.statsUploader.requestUpload = (e, t) =>
            this.emit(HG.RequestUpload, e, t)),
          (this.statsUploader.requestUploadStats = e =>
            this.emit(HG.RequestUploadStats, e)),
          (this.statsUploader.requestAllTracks = () => this.getAllTracks()),
          (this.statsUploader.requestTransportStats = () => {
            var e;
            return {
              connectState:
                (null === (e = this.connection) || void 0 === e
                  ? void 0
                  : e.peerConnectionState) || "closed"
            };
          });
      }
      unbindStatsUploaderEvents() {
        (this.statsUploader.requestStats = void 0),
          (this.statsUploader.requestLocalMedia = void 0),
          (this.statsUploader.requestRemoteMedia = void 0),
          (this.statsUploader.requestVideoIsReady = void 0);
      }
      async requestReconnect() {
        (this.dtlsFailedCount += 1),
          await Wk(aM(this.dtlsFailedCount, nM)),
          this.emit(HG.RequestReconnect);
      }
      async reconnectP2P() {
        const e = Array.from(this.localTrackMap.entries()),
          t = this.createGatewayUnpublishMessage(e);
        Array.from(this.remoteUserMap.entries()),
          t.length > 0 &&
            (await Ck(this, HG.RequestUnpublishForReconnectPC, t)),
          this.disconnectForReconnect(),
          this.emit(HG.RequestReconnectPC);
      }
      canPublishLowStream() {
        return (
          this.localTrackMap.has(GG.LocalVideoTrack) ||
          this.pendingLocalTracks.some(e => e instanceof AV)
        );
      }
      throwIfTrackTypeNotMatch(e) {
        if (e.filter(e => e instanceof AV).length > 1)
          throw new JP(zP.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
        if (
          e.filter(e => e instanceof FB).length > 1 &&
          (e.some(e => e instanceof FB && e._bypassWebAudio) ||
            !Lx().webAudioMediaStreamDest)
        )
          throw new JP(
            zP.NOT_SUPPORTED,
            "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode"
          );
        for (const t of e) {
          if (
            t instanceof AV &&
            this.pendingLocalTracks.some(e => e instanceof AV)
          )
            throw new JP(zP.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (
            t instanceof FB &&
            this.pendingLocalTracks.some(e => e instanceof FB) &&
            (!Lx().webAudioMediaStreamDest ||
              t._bypassWebAudio ||
              this.pendingLocalTracks.some(
                e => e instanceof FB && e._bypassWebAudio
              ))
          )
            throw new JP(
              zP.NOT_SUPPORTED,
              "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode"
            );
        }
      }
      getLowVideoTrack(e, t) {
        const i =
            !WM("DISABLE_DUAL_STREAM_USE_ENCODING") &&
            Lx().supportDualStreamEncoding,
          s = rG(
            rG({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }),
            t
          );
        let r;
        r = i ? e._mediaStreamTrack.clone() : oK(e, s);
        const n = Yk(8, "track-low-"),
          a = new AV(
            r,
            rG(
              rG({}, i && { scaleResolutionDownBy: vj(s, e) }),
              {},
              {
                frameRate: s.framerate,
                bitrateMax: s.bitrate,
                bitrateMin: s.bitrate
              }
            ),
            void 0,
            void 0,
            n
          );
        return (
          a.on(Wx.TRANSCEIVER_UPDATED, t => {
            e._updateRtpTransceiver(t, Kx.LOW_STREAM);
          }),
          a._hints.push(Hx.LOW_STREAM),
          e._hints.includes(Hx.SCREEN_TRACK) &&
            a._hints.push(Hx.SCREEN_LOW_TRACK),
          e.on("sei-to-send", e => {
            a.emit("sei-to-send", e);
          }),
          e.addListener(jx.NEED_CLOSE, () => {
            a.close();
          }),
          a
        );
      }
      async globalLock() {
        return this.mutex.lock("From P2PChannel.globalLock");
      }
      async reportPCStats(e, t, i) {
        let s =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
        if (this.connection && this.connection instanceof nK) {
          var r, n, a, o;
          const c = this.store.keyMetrics.descriptionStart || 0,
            {
              iceConnectionState: d,
              dtlsTransportState: l,
              peerConnectionState: h
            } = this.connection,
            {
              local: u,
              remote: p
            } = await this.connection.getSelectedCandidatePair();
          yU.pcStats(this.store.sessionId, {
            startTime: c,
            eventElapse: e - c || 0,
            iceconnectionsate: d,
            dtlsstate: l,
            connectionstate: h,
            intSucc: t ? 1 : 2,
            error: this._iceError || s || "",
            selectedLocalCandidateProtocol:
              null !== (r = null == u ? void 0 : u.protocol) && void 0 !== r
                ? r
                : "",
            selectedLocalCandidateType:
              null !== (n = u.candidateType) && void 0 !== n ? n : "",
            selectedLocalCandidateAddress: ""
              .concat(u.address, ":")
              .concat(u.port),
            selectedRemoteCandidateProtocol:
              null !== (a = p.protocol) && void 0 !== a ? a : "",
            selectedRemoteCandidateType:
              null !== (o = p.candidateType) && void 0 !== o ? o : "",
            selectedRemoteCandidateAddress: ""
              .concat(p.address, ":")
              .concat(p.port),
            restartCnt: i,
            preallocation: this.connection.isPreallocation
          }),
            (this._iceError = null);
        }
      }
      reportVideoFirstFrameDecoded(e, t, i, s) {
        const r = Array.from(this.remoteUserMap.keys()).find(
          t => t._videoSSRC === e
        );
        if (r) {
          s ||
            this.store.subscribe(
              r.uid,
              "video",
              void 0,
              void 0,
              void 0,
              void 0,
              Date.now()
            );
          const n = this.store.keyMetrics,
            a = n.subscribe.find(e => e.userId === r.uid && "video" === e.type);
          yU.firstRemoteVideoDecode(
            this.store.sessionId,
            TU.FIRST_VIDEO_DECODE,
            SU.FIRST_VIDEO_DECODE,
            {
              peer: r._uintid,
              videowidth: t,
              videoheight: i,
              subscribeElapse: MH.measureFromSubscribeStart(
                this.store.clientId,
                e
              ),
              subscribeRequestid: e,
              p2pid: this.store.p2pId,
              apEnd: n.requestAPEnd || 0,
              apStart: n.requestAPStart || 0,
              joinGwEnd: n.joinGatewayEnd || 0,
              joinGwStart: n.joinGatewayStart || 0,
              pcEnd: n.peerConnectionEnd || 0,
              pcStart: n.peerConnectionStart || 0,
              subscriberEnd: (null == a ? void 0 : a.subscribeEnd) || 0,
              subscriberStart: (null == a ? void 0 : a.subscribeStart) || 0,
              videoAddNotify: (null == a ? void 0 : a.streamAdded) || 0,
              state: s ? 1 : 0,
              firstFrame: (null == a ? void 0 : a.firstFrame) || 0
            }
          );
        }
      }
      async remoteMediaSsrcChanged(e, t, i) {
        if (!this.connection) return !1;
        const s = this.remoteUserMap.get(e);
        if (!s) return !1;
        const r = s.get(t);
        if (!r) return !1;
        const n = await this.connection.getRemoteSSRC(r);
        return void 0 !== n && n !== i;
      }
      unbindRtpTransceiver() {
        0 !== this.localTrackMap.size &&
          Array.from(this.localTrackMap.entries()).forEach(e => {
            let [t, { track: i }] = e;
            t === GG.LocalVideoLowTrack
              ? i._updateRtpTransceiver(void 0, Kx.LOW_STREAM)
              : i._updateRtpTransceiver(void 0);
          });
      }
    }),
    JV(
      kK.prototype,
      "startP2PConnection",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "startP2PConnection"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "connect",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "connect"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "updateRemoteRTPCapabilities",
      [UK],
      Object.getOwnPropertyDescriptor(
        kK.prototype,
        "updateRemoteRTPCapabilities"
      ),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "publishDataChannel",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "publishDataChannel"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "unpublish",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "unpublish"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "unpublishDataChannel",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "unpublishDataChannel"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "unpublishLowStream",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "unpublishLowStream"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "subscribeDataChannel",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "subscribeDataChannel"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "subscribe",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "subscribe"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "massSubscribe",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "massSubscribe"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "unsubscribe",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "unsubscribe"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "unsubscribeDataChannel",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "unsubscribeDataChannel"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "massUnsubscribe",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "massUnsubscribe"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "muteRemote",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "muteRemote"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "unmuteRemote",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "unmuteRemote"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "hasRemoteMediaWithLock",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "hasRemoteMediaWithLock"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "disconnectForReconnect",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "disconnectForReconnect"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "updateBitrateLimit",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "updateBitrateLimit"),
      kK.prototype
    ),
    JV(
      kK.prototype,
      "remoteMediaSsrcChanged",
      [UK],
      Object.getOwnPropertyDescriptor(kK.prototype, "remoteMediaSsrcChanged"),
      kK.prototype
    ),
    kK);
  function UK(e, t, i) {
    const s = e[t];
    if ("function" != typeof s)
      throw new Error("Cannot use mutex on object property.");
    return (
      (i.value = async function() {
        const e = this.mutex,
          i = await e.lock("From P2PChannel.".concat(t));
        try {
          for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
            n[a] = arguments[a];
          return await s.apply(this, n);
        } finally {
          i();
        }
      }),
      i
    );
  }
  const xK = Date.now(),
    FK = 20,
    BK = new Map(),
    VK = new Map();
  async function GK(e) {
    const t = BK.get(e),
      i = Array.isArray(t) && t[t.length - 1],
      s = VK.get(e);
    if (!i) return void (s.isSyncing = !1);
    const r = { uid: i.uid, payload: i.payload };
    0 === s.firstRecvTs &&
      ((s.firstRecvTs = i.recvTs), (s.firstSendTs = i.sendTs));
    const n = i.sendTs - s.firstSendTs,
      a = n - (Date.now() - s.firstRecvTs);
    a > 0 && (s.firstRecvTs = Date.now() - n);
    let o = i.mediaDelay + a;
    o <= 0 ? (t.pop(), jK(i.context, r), (o = 0)) : (o = Math.min(o, FK)),
      setTimeout(() => t.length && GK(e), o);
  }
  function jK(e, t) {
    e.safeEmit(Rk.STREAM_MESSAGE, t.uid, t.payload),
      e.onStreamMessage && e.onStreamMessage(t);
  }
  function HK(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      i = arguments.length > 2 ? arguments[2] : void 0;
    if (!e.syncWithAudio) return jK(i, { uid: e.uid, payload: e.payload });
    const s = "".concat(i.id, "-").concat(e.uid),
      r = BK.get(s) || [],
      n = r.findIndex(t => e.sendTs >= t.sendTs),
      a = rG(rG({}, e), {}, { context: i, mediaDelay: t, recvTs: Date.now() });
    -1 === n ? r.push(a) : r.splice(n, 0, a), BK.set(s, r);
    let o = !1;
    var c;
    VK.has(s)
      ? (o = !(null === (c = VK.get(s)) || void 0 === c || !c.isSyncing))
      : VK.set(s, { isSyncing: o, firstRecvTs: 0, firstSendTs: 0 });
    o || GK(s);
  }
  vP().name;
  const KK = "websdk_ng_cache_parameter",
    WK = WM("MAX_PRELOAD_ASYNC_LENGTH"),
    YK = 1e4,
    $K = new Map(),
    qK = [];
  let XK = null,
    zK = 0,
    JK = 0;
  const QK = new Map(),
    ZK = (function(e, t) {
      const i = [];
      let s = 0;
      const r = async () => {
        const e = i.shift();
        e && (await e()), i.length > 0 && s < t ? r() : s--;
      };
      return async function() {
        for (var n = arguments.length, a = new Array(n), o = 0; o < n; o++)
          a[o] = arguments[o];
        return new Promise(async (n, o) => {
          i.push(async () => {
            try {
              const t = await e(...a);
              n(t);
            } catch (e) {
              o(e);
            }
          }),
            s < t && (s++, r());
        });
      };
    })(async function(e, t, i, s, r, n) {
      try {
        if (!WM("ENABLE_PRELOAD")) return;
        if (!Lx().supportWebCrypto)
          return void xk(() => {
            EU.warn(
              "Your browser does not support preloading, this feature  be run in a secure environment"
            );
          }, "preload_webcrypto_not_supported");
        if (!i && null !== i)
          throw new JP(
            zP.INVALID_PARAMS,
            "Invalid token: ".concat(
              i,
              ". If you don not use token, set it to null"
            )
          );
        i && ik(i, "token", 1, 2047),
          ik(e, "appid", 1, 2047),
          TG(t),
          s && SG(s);
        const a = $k();
        EU.debug("preload channel ".concat(t, ", uid is ").concat(s));
        const o = {
          appId: e,
          cname: t,
          token: i || e,
          uid: "string" != typeof s ? s : null,
          sid: a,
          proxyServer: r
        };
        let c, d;
        "string" == typeof s
          ? ((o.stringUid = s),
            ([d, c] = await Promise.all([
              bH(s, { sid: a, appId: e }, eW.token),
              DH(rG(rG({}, o), {}, { token: i || e, uid: 0 }), eW.token)
            ])),
            (o.uid = d.uid),
            (c.gatewayInfo.uid = o.uid),
            (c.gatewayInfo.res.uid = o.uid))
          : (n && (o.stringUid = n), (c = await DH(o, eW.token)));
        const l = {
          sid: a,
          appId: e,
          cname: t,
          token: i || e,
          uid: o.stringUid || s,
          intUid: o.uid || c.gatewayInfo.uid,
          stringUid: o.stringUid,
          ts: Date.now(),
          sua: d,
          ap: c
        };
        await (async function(e) {
          let t;
          try {
            e.uid &&
              iW({
                appId: e.appId,
                cname: e.cname,
                token: e.token,
                uid: e.uid,
                stringUid: e.stringUid
              });
            const i = cW(e),
              s = await (async function(e, t) {
                try {
                  const i = await window.crypto.subtle.importKey(
                      "raw",
                      Vk(t),
                      "AES-GCM",
                      !1,
                      ["encrypt"]
                    ),
                    s = await window.crypto.subtle.encrypt(
                      { name: "AES-GCM", iv: new Uint8Array(1) },
                      i,
                      Fk(window.btoa(JSON.stringify(e)))
                    );
                  return Bk(new Uint8Array(s));
                } catch (e) {
                  return;
                }
              })(e, e.token || e.appId);
            if (!s) return;
            t = aW(KK);
            const r = t ? JSON.parse(t) : [];
            r.push({ [i]: s }),
              r.length > WM("AP_CACHE_NUM") && r.shift(),
              oW(KK, JSON.stringify(r));
          } catch (e) {
            EU.warn("Error caching server parameters:", e.message), oW(KK, "");
          }
        })(l),
          zK++;
      } catch (e) {
        throw (JK++,
        (function(e) {
          XK ||
            (XK = window.setTimeout(() => {
              let t = "";
              QK.forEach((e, i) => {
                t += "".concat(i, ": ").concat(e, " ;");
              }),
                yU
                  .reportApiInvoke(null, {
                    name: Ek.PRELOAD,
                    options: { success: zK, failed: JK, err: t }
                  })
                  .onError(e),
                (zK = 0),
                (JK = 0),
                QK.clear(),
                (XK = null);
            }, YK));
          const t = QK.get(e.code) || 0;
          QK.set(e.code, t + 1);
        })(e),
        e);
      }
    }, WK),
    eW = lP.CancelToken.source();
  async function tW(e) {
    try {
      if (WM("AP_REQUEST_DETAIL") || WM("ENABLE_ROLE_SELECT_EDGE")) return;
      const t = iW(e);
      if (!t || "disabled" !== e.cloudProxyServer) return;
      const i = await (async function(e, t) {
        try {
          const i = await window.crypto.subtle.importKey(
              "raw",
              Vk(t),
              "AES-GCM",
              !1,
              ["decrypt"]
            ),
            s = await window.crypto.subtle.decrypt(
              { name: "AES-GCM", iv: new Uint8Array(1) },
              i,
              Fk(e)
            );
          return JSON.parse(window.atob(Bk(new Uint8Array(s))));
        } catch (e) {
          return;
        }
      })(t, e.token || e.appId);
      if (!i) return;
      if (
        !(function(e, t) {
          const i =
            e.cname === t.cname && e.appId === t.appId && e.token === t.token;
          if (!i) return !1;
          return t.stringUid
            ? e.stringUid === t.stringUid
            : "number" == typeof t.uid
            ? e.uid === t.uid
            : e.uid == t.uid;
        })(i, e)
      )
        return;
      if (i && Date.now() - i.ts < WM("AP_CACHE_LIFETIME")) return i;
    } catch (e) {
      EU.warn("Error get preloadInfo", e.message);
    }
  }
  function iW(e) {
    let t;
    try {
      if (((t = aW(KK)), !t)) return;
      const i = JSON.parse(t),
        s = cW(e),
        r = (function(e, t) {
          for (let i = e.length - 1; i >= 0; i--) if (t(e[i])) return i;
          return -1;
        })(i, e => s in e);
      if (-1 === r) return;
      const n = i.splice(r, 1)[0];
      return oW(KK, JSON.stringify(i)), n[s];
    } catch (e) {
      EU.warn("Error delete preload info: ".concat(t), e.message), oW(KK, "");
    }
  }
  function sW(e) {
    if (e) {
      let t = $K.get(e);
      t && (window.clearTimeout(t), (t = null), $K.delete(e)),
        qK.includes(e) || "disabled" !== e.cloudProxyServer || qK.push(e);
    }
    if ($K.size < WM("AP_CACHE_NUM") && qK.length > 0) {
      const e = qK.shift();
      $K.set(
        e,
        window.setTimeout(async () => {
          const {
            appId: t,
            cname: i,
            token: s,
            stringUid: r,
            uid: n,
            proxyServer: a
          } = e;
          try {
            await ZK(t, i, s, n, a, r), $K.has(e) && sW(e);
          } catch (t) {
            EU.warn("update preload failed", t.message), rW(e);
          }
        }, WM("AP_UPDATE_INTERVAL"))
      );
    }
  }
  function rW(e) {
    const t = qK.indexOf(e);
    -1 !== t && qK.splice(t, 1);
    let i = $K.get(e);
    i && (window.clearTimeout(i), (i = null), $K.delete(e), sW());
  }
  function nW(e, t) {
    const i = e.sua,
      s = e.ap;
    t &&
      i &&
      yU.reqUserAccount(e.sid, {
        lts: i.requestTime,
        elapse: i.elapse,
        success: !0,
        serverAddr: i.url,
        stringUid: t,
        uid: e.intUid,
        errorCode: null,
        extend: i.req
      }),
      yU.reportResourceTiming(e.ap.url, e.sid),
      yU.joinWebProxyAP(e.sid, {
        lts: s.requestTime,
        elapse: s.elapse,
        sucess: 1,
        apServerAddr: s.url,
        turnServerAddrList: s.proxyInfo.addresses.map(e => e.ip).join(","),
        eventType: "disabled",
        unilbsServerIds: [pj.CHOOSE_SERVER, pj.CLOUD_PROXY_FALLBACK].toString()
      }),
      yU.joinChooseServer(e.sid, {
        lts: s.requestTime,
        elapse: s.elapse,
        succ: !0,
        csAddr: s.url,
        opid: s.opid,
        serverList: s.gatewayInfo.gatewayAddrs.map(e => e.address),
        ec: null,
        cid: s.gatewayInfo.cid.toString(),
        uid: s.gatewayInfo.uid.toString(),
        csIp: s.gatewayInfo.csIp,
        unilbsServerIds: [pj.CHOOSE_SERVER].toString(),
        isHttp3: s.isHttp3
      });
  }
  function aW(e) {
    return window.atob(window.localStorage.getItem(e) || "");
  }
  function oW(e, t) {
    window.localStorage.setItem(e, window.btoa(t));
  }
  function cW(e) {
    let t = "".concat(e.appId, "_").concat(e.cname);
    return (
      "string" == typeof e.uid && (t += "_s_".concat(e.uid)),
      "number" == typeof e.uid && (t += "_".concat(e.uid)),
      e.token && (t += "_".concat(e.token)),
      (function(e) {
        const t = "0123456789abcdef";
        function i(e) {
          let i,
            s = "";
          for (i = 0; i <= 3; i++)
            s +=
              t.charAt((e >> (8 * i + 4)) & 15) + t.charAt((e >> (8 * i)) & 15);
          return s;
        }
        function s(e, t) {
          const i = (65535 & e) + (65535 & t);
          return (((e >> 16) + (t >> 16) + (i >> 16)) << 16) | (65535 & i);
        }
        function r(e, t, i, r, n, a) {
          return s(
            (function(e, t) {
              return (e << t) | (e >>> (32 - t));
            })(s(s(t, e), s(r, a)), n),
            i
          );
        }
        function n(e, t, i, s, n, a, o) {
          return r((t & i) | (~t & s), e, t, n, a, o);
        }
        function a(e, t, i, s, n, a, o) {
          return r((t & s) | (i & ~s), e, t, n, a, o);
        }
        function o(e, t, i, s, n, a, o) {
          return r(t ^ i ^ s, e, t, n, a, o);
        }
        function c(e, t, i, s, n, a, o) {
          return r(i ^ (t | ~s), e, t, n, a, o);
        }
        const d = (function(e) {
          let t;
          const i = 1 + ((e.length + 8) >> 6),
            s = new Array(16 * i);
          for (t = 0; t < 16 * i; t++) s[t] = 0;
          for (t = 0; t < e.length; t++)
            s[t >> 2] |= e.charCodeAt(t) << ((t % 4) * 8);
          return (
            (s[t >> 2] |= 128 << ((t % 4) * 8)),
            (s[16 * i - 2] = 8 * e.length),
            s
          );
        })(e);
        let l,
          h,
          u,
          p,
          f,
          E = 1732584193,
          m = -271733879,
          g = -1732584194,
          _ = 271733878;
        for (l = 0; l < d.length; l += 16)
          (h = E),
            (u = m),
            (p = g),
            (f = _),
            (E = n(E, m, g, _, d[l + 0], 7, -680876936)),
            (_ = n(_, E, m, g, d[l + 1], 12, -389564586)),
            (g = n(g, _, E, m, d[l + 2], 17, 606105819)),
            (m = n(m, g, _, E, d[l + 3], 22, -1044525330)),
            (E = n(E, m, g, _, d[l + 4], 7, -176418897)),
            (_ = n(_, E, m, g, d[l + 5], 12, 1200080426)),
            (g = n(g, _, E, m, d[l + 6], 17, -1473231341)),
            (m = n(m, g, _, E, d[l + 7], 22, -45705983)),
            (E = n(E, m, g, _, d[l + 8], 7, 1770035416)),
            (_ = n(_, E, m, g, d[l + 9], 12, -1958414417)),
            (g = n(g, _, E, m, d[l + 10], 17, -42063)),
            (m = n(m, g, _, E, d[l + 11], 22, -1990404162)),
            (E = n(E, m, g, _, d[l + 12], 7, 1804603682)),
            (_ = n(_, E, m, g, d[l + 13], 12, -40341101)),
            (g = n(g, _, E, m, d[l + 14], 17, -1502002290)),
            (m = n(m, g, _, E, d[l + 15], 22, 1236535329)),
            (E = a(E, m, g, _, d[l + 1], 5, -165796510)),
            (_ = a(_, E, m, g, d[l + 6], 9, -1069501632)),
            (g = a(g, _, E, m, d[l + 11], 14, 643717713)),
            (m = a(m, g, _, E, d[l + 0], 20, -373897302)),
            (E = a(E, m, g, _, d[l + 5], 5, -701558691)),
            (_ = a(_, E, m, g, d[l + 10], 9, 38016083)),
            (g = a(g, _, E, m, d[l + 15], 14, -660478335)),
            (m = a(m, g, _, E, d[l + 4], 20, -405537848)),
            (E = a(E, m, g, _, d[l + 9], 5, 568446438)),
            (_ = a(_, E, m, g, d[l + 14], 9, -1019803690)),
            (g = a(g, _, E, m, d[l + 3], 14, -187363961)),
            (m = a(m, g, _, E, d[l + 8], 20, 1163531501)),
            (E = a(E, m, g, _, d[l + 13], 5, -1444681467)),
            (_ = a(_, E, m, g, d[l + 2], 9, -51403784)),
            (g = a(g, _, E, m, d[l + 7], 14, 1735328473)),
            (m = a(m, g, _, E, d[l + 12], 20, -1926607734)),
            (E = o(E, m, g, _, d[l + 5], 4, -378558)),
            (_ = o(_, E, m, g, d[l + 8], 11, -2022574463)),
            (g = o(g, _, E, m, d[l + 11], 16, 1839030562)),
            (m = o(m, g, _, E, d[l + 14], 23, -35309556)),
            (E = o(E, m, g, _, d[l + 1], 4, -1530992060)),
            (_ = o(_, E, m, g, d[l + 4], 11, 1272893353)),
            (g = o(g, _, E, m, d[l + 7], 16, -155497632)),
            (m = o(m, g, _, E, d[l + 10], 23, -1094730640)),
            (E = o(E, m, g, _, d[l + 13], 4, 681279174)),
            (_ = o(_, E, m, g, d[l + 0], 11, -358537222)),
            (g = o(g, _, E, m, d[l + 3], 16, -722521979)),
            (m = o(m, g, _, E, d[l + 6], 23, 76029189)),
            (E = o(E, m, g, _, d[l + 9], 4, -640364487)),
            (_ = o(_, E, m, g, d[l + 12], 11, -421815835)),
            (g = o(g, _, E, m, d[l + 15], 16, 530742520)),
            (m = o(m, g, _, E, d[l + 2], 23, -995338651)),
            (E = c(E, m, g, _, d[l + 0], 6, -198630844)),
            (_ = c(_, E, m, g, d[l + 7], 10, 1126891415)),
            (g = c(g, _, E, m, d[l + 14], 15, -1416354905)),
            (m = c(m, g, _, E, d[l + 5], 21, -57434055)),
            (E = c(E, m, g, _, d[l + 12], 6, 1700485571)),
            (_ = c(_, E, m, g, d[l + 3], 10, -1894986606)),
            (g = c(g, _, E, m, d[l + 10], 15, -1051523)),
            (m = c(m, g, _, E, d[l + 1], 21, -2054922799)),
            (E = c(E, m, g, _, d[l + 8], 6, 1873313359)),
            (_ = c(_, E, m, g, d[l + 15], 10, -30611744)),
            (g = c(g, _, E, m, d[l + 6], 15, -1560198380)),
            (m = c(m, g, _, E, d[l + 13], 21, 1309151649)),
            (E = c(E, m, g, _, d[l + 4], 6, -145523070)),
            (_ = c(_, E, m, g, d[l + 11], 10, -1120210379)),
            (g = c(g, _, E, m, d[l + 2], 15, 718787259)),
            (m = c(m, g, _, E, d[l + 9], 21, -343485551)),
            (E = s(E, h)),
            (m = s(m, u)),
            (g = s(g, p)),
            (_ = s(_, f));
        return i(E) + i(m) + i(g) + i(_);
      })(t)
    );
  }
  const dW = {},
    lW = {};
  function hW(e, t) {
    let i, s, r;
    return t
      ? (r = 0 <= (e >>>= 0) && e < 256) && ((s = lW[e]), s)
        ? s
        : ((i = uW(e, 0, !0)), r && (lW[e] = i), i)
      : (r = -128 <= (e |= 0) && e < 128) && ((s = dW[e]), s)
      ? s
      : ((i = uW(e, e < 0 ? -1 : 0, !1)), r && (dW[e] = i), i);
  }
  function uW(e, t, i) {
    return { low: 0 | e, high: 0 | t, unsigned: !!i };
  }
  var pW,
    fW,
    EW,
    mW,
    gW,
    _W,
    TW,
    SW,
    vW,
    RW,
    yW,
    AW,
    IW,
    CW,
    bW,
    OW,
    DW,
    wW,
    LW,
    NW,
    PW,
    kW,
    MW,
    UW,
    xW,
    FW,
    BW,
    VW,
    GW,
    jW,
    HW,
    KW,
    WW,
    YW,
    $W,
    qW,
    XW,
    zW,
    JW,
    QW,
    ZW,
    eY;
  hW(0, !0), hW(0), sM.setLogger(EU);
  let tY =
    ((pW = RU()),
    (fW = RU({
      argsMap: (e, t) => {
        if (!Array.isArray(t)) {
          if (!(t instanceof pF)) return [t];
          t = [t];
        }
        return t.map(e => (e ? Object(e).toString() : "null"));
      }
    })),
    (EW = RU({
      argsMap: (e, t) => (
        t || (t = []),
        Array.isArray(t) || t.trackMediaType !== qx.DATA
          ? (Array.isArray(t) || (t = [t]), t.map(e => e.getTrackId()))
          : [t.getChannelId()]
      )
    })),
    (mW = RU({
      argsMap: (e, t, i, s) => ["object" == typeof t ? t.uid : t, i, s]
    })),
    (gW = RU({ argsMap: (e, t, i) => [t, i] })),
    (_W = RU({
      argsMap: (e, t) =>
        t.map(e => {
          let { user: t, mediaType: i } = e;
          return [null == t ? void 0 : t.uid, i];
        })
    })),
    (TW = RU({
      argsMap: (e, t, i, s) => ["object" == typeof t ? t.uid : t, i, s]
    })),
    (SW = RU({
      argsMap: (e, t) =>
        t.map(e => {
          let { user: t, mediaType: i } = e;
          return { uid: null == t ? void 0 : t.uid, mediaType: i };
        })
    })),
    (vW = RU()),
    (RW = RU()),
    (yW = RU()),
    (AW = RU()),
    (IW = RU()),
    (CW = RU()),
    (bW = RU()),
    (OW = RU()),
    (DW = RU()),
    (wW = RU()),
    (LW = RU()),
    (NW = RU()),
    (PW = RU()),
    (kW = RU()),
    (MW = RU()),
    (UW = RU({ argsMap: (e, t) => [t] })),
    (xW = RU()),
    (FW = RU()),
    (BW = RU()),
    (VW = RU()),
    (GW = RU()),
    (jW = RU()),
    (HW = RU()),
    (KW = RU()),
    (WW = RU({
      argsMap: (e, t) => (Array.isArray(t) || (t = [t]), [JSON.stringify(t)])
    })),
    (YW = RU()),
    ($W = RU()),
    (qW = RU()),
    (XW = RU()),
    (zW = RU()),
    (JW = RU()),
    (QW = RU({ reportResult: !0 })),
    (ZW = RU()),
    (eY = class extends uk {
      get connectionState() {
        return this._gateway.state;
      }
      get remoteUsers() {
        return this._users;
      }
      get localTracks() {
        return this._p2pChannel.getAllTracks(!0);
      }
      get uid() {
        return this._uid;
      }
      get channelName() {
        return this._channelName;
      }
      get localDataChannels() {
        return this._p2pChannel.getAllDataChannels();
      }
      get mode() {
        return this._config.mode;
      }
      get role() {
        var e;
        return (
          (null === (e = this._config) || void 0 === e ? void 0 : e.role) ||
          "audience"
        );
      }
      get codec() {
        return this._config.codec;
      }
      get audioCodec() {
        return this._config.audioCodec || "opus";
      }
      get isStringUID() {
        return !!this._joinInfo && !!this._joinInfo.stringUid;
      }
      get __className__() {
        return "Client";
      }
      constructor(e, t) {
        let i;
        if (
          (super(),
          (this.store = void 0),
          (this._uid = void 0),
          (this._channelName = void 0),
          (this._uintUid = void 0),
          (this._users = []),
          (this._config = void 0),
          (this._clientId = void 0),
          (this._appId = void 0),
          (this._sessionId = null),
          (this._key = void 0),
          (this._rtmConfig = {}),
          (this._joinInfo = void 0),
          (this._gateway = void 0),
          (this._statsCollector = void 0),
          (this._configDistribute = void 0),
          (this._leaveMutex = void 0),
          (this._publishMutex = void 0),
          (this._renewTokenMutex = void 0),
          (this._subscribeMutex = void 0),
          (this._encryptionMode = "none"),
          (this._encryptionSecret = null),
          (this._encryptionSalt = null),
          (this._encryptDataStream = !1),
          (this._encryptDataStreamKey = null),
          (this._encryptDataStreamIv = null),
          (this._proxyServer = void 0),
          (this._turnServer = { servers: [], mode: "auto" }),
          (this._cloudProxyServerMode = "disabled"),
          (this._isDualStreamEnabled = !1),
          (this._defaultStreamFallbackType = void 0),
          (this._lowStreamParameter = void 0),
          (this._streamFallbackTypeCacheMap = new Map()),
          (this._remoteStreamTypeCacheMap = new Map()),
          (this._axiosCancelSource = lP.CancelToken.source()),
          (this._audioVolumeIndicationInterval = void 0),
          (this._networkQualityInterval = void 0),
          (this._userOfflineTimeout = void 0),
          (this._streamRemovedTimeout = void 0),
          (this._liveTranscodeStreamingClient = void 0),
          (this._liveRawStreamingClient = void 0),
          (this._channelMediaRelayClient = void 0),
          (this._networkQualitySensitivity = "normal"),
          (this._p2pChannel = void 0),
          (this._useLocalAccessPoint = !1),
          (this._setLocalAPVersion = void 0),
          (this._joinAndNotLeaveYet = !1),
          (this._numberOfJoinCount = 0),
          (this._remoteDefaultVideoStreamType = void 0),
          (this._inspect = void 0),
          (this._moderation = void 0),
          (this._license = void 0),
          (this._pendingPublishedUsers = []),
          (this.ntpAlignErrorCount = 0),
          (this.remoteInboundOffset = 0),
          (this._peerConnectionState = void 0),
          (this._handleLocalTrackEnable = (e, t, i) => {
            this.publish(e, !1)
              .then(t)
              .catch(i);
          }),
          (this._handleLocalTrackDisable = (e, t, i) => {
            this.unpublish(e)
              .then(t)
              .catch(i);
          }),
          (this._handleUserOnline = e => {
            if (WM("BLOCK_LOCAL_CLIENT") && qV(e.uid, this.channelName))
              return void EU.debug(
                "[".concat(e.uid, "] will be ignored in local")
              );
            this.isStringUID &&
              "string" != typeof e.uid &&
              EU.error(
                "[".concat(this._clientId, "] StringUID is Mixed with UintUID")
              );
            const t = this._users.find(t => t.uid === e.uid);
            if (t)
              (t._trust_in_room_ = !0),
                t._is_pre_created &&
                  ((t._is_pre_created = !1), this.safeEmit(Rk.USER_JOINED, t));
            else {
              const t = new BH(e.uid, e.uint_id || e.uid);
              this._users.push(t),
                EU.debug("[".concat(this._clientId, "] user online"), e.uid),
                this.safeEmit(Rk.USER_JOINED, t);
            }
          }),
          (this._handleUserOffline = e => {
            if (WM("BLOCK_LOCAL_CLIENT") && qV(e.uid, this.channelName)) return;
            const t = this._users.find(t => t.uid === e.uid);
            t &&
              (this._handleRemoveStream(e),
              this._handleRemoveDataChannels(e),
              t._audio_pre_subscribed || t._video_pre_subscribed
                ? (t._is_pre_created = !0)
                : Lk(this._users, t),
              this._remoteStreamTypeCacheMap.delete(t.uid),
              this._streamFallbackTypeCacheMap.delete(t.uid),
              EU.debug(
                "[".concat(this._clientId, "] user offline"),
                e.uid,
                "reason:",
                e.reason
              ),
              this.safeEmit(Rk.USER_LEAVED, t, e.reason));
          }),
          (this._handleAddAudioOrVideoStream = (e, t, i, s, r, n, a) => {
            if (WM("BLOCK_LOCAL_CLIENT") && qV(t, this.channelName)) return;
            const o = this._users.find(e => e.uid === t);
            if (!o)
              return void EU.error(
                "[".concat(
                  this._clientId,
                  "] can not find target user!(on_add_stream)"
                )
              );
            EU.debug(
              "["
                .concat(this._clientId, "] stream added with uid ")
                .concat(t, ", type ")
                .concat(e)
            ),
              this.store.subscribe(
                o.uid,
                e,
                void 0,
                void 0,
                void 0,
                Date.now()
              );
            const c = "audio" === e ? o.hasAudio : o.hasVideo;
            o._uintid || (o._uintid = r || t),
              "audio" === e
                ? (o._trust_audio_stream_added_state_ = !0)
                : (o._trust_video_stream_added_state_ = !0),
              "audio" === e
                ? ((o._audio_added_ = !0),
                  void 0 !== i && (o._audioSSRC = i),
                  void 0 !== s && (o._cname = s),
                  n && (o._audioOrtc = n))
                : ((o._video_added_ = !0),
                  void 0 !== i && (o._videoSSRC = i),
                  void 0 !== s && (o._cname = s),
                  void 0 !== a && (o._rtxSsrcId = a),
                  n && (o._videoOrtc = n)),
              ("audio" === e ? o.hasAudio : o.hasVideo) &&
                !c &&
                (EU.info(
                  "["
                    .concat(this._clientId, "] remote user ")
                    .concat(o.uid, " published ")
                    .concat(e)
                ),
                this.safeEmit(Rk.USER_PUBLISHED, o, e)),
              "video" === e
                ? yU.onGatewayStream(
                    this._sessionId,
                    TU.ON_ADD_VIDEO_STREAM,
                    SU.ON_ADD_VIDEO_STREAM,
                    { peer: r || t, ssrc: o._videoSSRC }
                  )
                : yU.onGatewayStream(
                    this._sessionId,
                    TU.ON_ADD_AUDIO_STREAM,
                    SU.ON_ADD_AUDIO_STREAM,
                    { peer: r || t, ssrc: o._audioSSRC }
                  ),
              this._p2pChannel.remoteMediaSsrcChanged(o, e, i).then(t => {
                if (
                  t &&
                  (EU.debug(
                    "["
                      .concat(this._clientId, "] resubscribe ")
                      .concat(e, " for user ")
                      .concat(o.uid, " after rejoin because SSRC id changed.")
                  ),
                  this._p2pChannel instanceof MK)
                )
                  return this._p2pChannel.unsubscribe(o, e, !0).then(() =>
                    this._subscribe(o, e, !0).catch(e => {
                      EU.error(
                        "[".concat(this._clientId, "] resubscribe error"),
                        e.toString()
                      );
                    })
                  );
              }),
              this._p2pChannel.hasPendingRemoteMedia(o, e) &&
                (EU.debug(
                  "["
                    .concat(this._clientId, "] resubscribe ")
                    .concat(e, " for user ")
                    .concat(o.uid, " after reconnect.")
                ),
                this._subscribe(o, e, !0).catch(e => {
                  EU.error(
                    "[".concat(this._clientId, "] resubscribe error"),
                    e.toString()
                  );
                }));
          }),
          (this._handleRemoveStream = e => {
            if (WM("BLOCK_LOCAL_CLIENT") && qV(e.uid, this.channelName)) return;
            const t = this._users.find(t => t.uid === e.uid);
            if (!t)
              return void EU.warning(
                "[".concat(
                  this._clientId,
                  "] can not find target user!(on_remove_stream)"
                )
              );
            EU.debug(
              "["
                .concat(this._clientId, "] stream removed with uid ")
                .concat(e.uid)
            );
            let i = () => {};
            t.hasAudio && t.hasVideo
              ? (i = () => {
                  EU.info(
                    "["
                      .concat(this._clientId, "] remote user ")
                      .concat(t.uid, " unpublished audio track")
                  ),
                    this.safeEmit(Rk.USER_UNPUBLISHED, t, "audio"),
                    EU.info(
                      "["
                        .concat(this._clientId, "] remote user ")
                        .concat(t.uid, " unpublished video track")
                    ),
                    this.safeEmit(Rk.USER_UNPUBLISHED, t, "video");
                })
              : t.hasVideo
              ? (i = () => {
                  EU.info(
                    "["
                      .concat(this._clientId, "] remote user ")
                      .concat(t.uid, " unpublished video track")
                  ),
                    this.safeEmit(Rk.USER_UNPUBLISHED, t, "video");
                })
              : t.hasAudio &&
                (i = () => {
                  EU.info(
                    "["
                      .concat(this._clientId, "] remote user ")
                      .concat(t.uid, " unpublished audio track")
                  ),
                    this.safeEmit(Rk.USER_UNPUBLISHED, t, "audio");
                }),
              t._video_pre_subscribed ||
                t._audio_pre_subscribed ||
                ((t._trust_audio_stream_added_state_ = !0),
                (t._trust_video_stream_added_state_ = !0),
                (t._audio_added_ = !1),
                (t._video_added_ = !1),
                this._p2pChannel instanceof MK &&
                  this._p2pChannel.unsubscribe(t).then(e => {
                    if (e) return this._gateway.unsubscribe(e, t.uid);
                  }),
                (t._audioSSRC = void 0),
                (t._videoSSRC = void 0),
                (t._audioOrtc = void 0),
                (t._videoOrtc = void 0),
                (t._rtxSsrcId = void 0)),
              yU.onGatewayStream(
                this._sessionId,
                TU.ON_REMOVE_STREAM,
                SU.ON_REMOVE_STREAM,
                { peer: e.uint_id || e.uid }
              ),
              i();
          }),
          (this._handleSetStreamLocalEnable = (e, t, i) => {
            if (WM("BLOCK_LOCAL_CLIENT") && qV(t, this.channelName)) return;
            const s = this._users.find(e => e.uid === t);
            if (!s)
              return void EU.error(
                "[".concat(
                  this._clientId,
                  "] can not find target user!(disable_local)"
                )
              );
            EU.debug(
              "["
                .concat(this._clientId, "] local ")
                .concat(e, " ")
                .concat(i ? "enabled" : "disabled", " with uid ")
                .concat(t)
            );
            const r = "audio" === e ? s.hasAudio : s.hasVideo;
            if ("audio" === e) {
              s._trust_audio_enabled_state_ = !0;
              const e = s._audio_enabled_;
              if (((s._audio_enabled_ = i), s._audio_enabled_ === e)) return;
              {
                const e = s._audio_enabled_
                  ? "enable-local-audio"
                  : "disable-local-audio";
                EU.debug(
                  "["
                    .concat(this._clientId, "] user-info-updated, uid: ")
                    .concat(t, ", msg: ")
                    .concat(e)
                ),
                  this.safeEmit(Rk.USER_INFO_UPDATED, t, e);
              }
            } else {
              s._trust_video_enabled_state_ = !0;
              const e = s._video_enabled_;
              if (((s._video_enabled_ = i), s._video_enabled_ === e)) return;
              {
                const e = s._video_enabled_
                  ? "enable-local-video"
                  : "disable-local-video";
                EU.debug(
                  "["
                    .concat(this._clientId, "] user-info-update, uid: ")
                    .concat(t, ", msg: ")
                    .concat(e)
                ),
                  this.safeEmit(Rk.USER_INFO_UPDATED, t, e);
              }
            }
            const n = "audio" === e ? s.hasAudio : s.hasVideo;
            return r !== n
              ? !r && n
                ? (EU.info(
                    "["
                      .concat(this._clientId, "] remote user ")
                      .concat(t, " published ")
                      .concat(e)
                  ),
                  void this.safeEmit(Rk.USER_PUBLISHED, s, e))
                : ("video" === e && s._videoTrack && s._videoTrack._destroy(),
                  "audio" === e && s._audioTrack,
                  this._p2pChannel.muteRemote(s, e),
                  EU.info(
                    "["
                      .concat(this._clientId, "] remote user ")
                      .concat(t, " unpublished ")
                      .concat(e)
                  ),
                  void this.safeEmit(Rk.USER_UNPUBLISHED, s, e))
              : void 0;
          }),
          (this._handleMuteStream = (e, t, i) => {
            if (WM("BLOCK_LOCAL_CLIENT") && qV(e, this.channelName)) return;
            EU.debug(
              "[".concat(this._clientId, "] receive mute message"),
              e,
              t,
              i
            );
            const s = this._users.find(t => t.uid === e);
            if (!s)
              return void EU.warning(
                "["
                  .concat(
                    this._clientId,
                    "] can not find remote user, ignore mute event, uid: "
                  )
                  .concat(e)
              );
            const r = "audio" === t ? s.hasAudio : s.hasVideo;
            if ("audio" === t) {
              s._trust_audio_mute_state_ = !0;
              const t = s._audio_muted_;
              if (((s._audio_muted_ = i), s._audio_muted_ === t)) return;
              {
                const t = s._audio_muted_ ? "mute-audio" : "unmute-audio";
                EU.debug(
                  "["
                    .concat(this._clientId, "] user-info-update, uid: ")
                    .concat(e, ", msg: ")
                    .concat(t)
                ),
                  this.safeEmit(Rk.USER_INFO_UPDATED, e, t);
              }
            } else {
              s._trust_video_mute_state_ = !0;
              const t = s._video_muted_;
              if (((s._video_muted_ = i), s._video_muted_ === t)) return;
              {
                const t = s._video_muted_ ? "mute-video" : "unmute-video";
                EU.debug(
                  "["
                    .concat(this._clientId, "] user-info-update, uid: ")
                    .concat(e, ", msg: ")
                    .concat(t)
                ),
                  this.safeEmit(Rk.USER_INFO_UPDATED, e, t);
              }
            }
            const n = "audio" === t ? s.hasAudio : s.hasVideo;
            if (r !== n) {
              if (!r && n) {
                return ("audio" === t
                ? s._audioSSRC
                : s._videoSSRC)
                  ? (EU.info(
                      "["
                        .concat(this._clientId, "] remote user ")
                        .concat(e, " published ")
                        .concat(t)
                    ),
                    void this.safeEmit(Rk.USER_PUBLISHED, s, t))
                  : void EU.warning(
                      "["
                        .concat(this._clientId, "] remote user ")
                        .concat(e, " receive ")
                        .concat(
                          t,
                          " unmute message  before add stream message, "
                        )
                        .concat(t, " SSRC doesn't exist yet.")
                    );
              }
              "video" === t &&
                s._videoTrack &&
                !s._video_pre_subscribed &&
                s._videoTrack._destroy(),
                "audio" === t && s._audioTrack,
                this._p2pChannel.muteRemote(s, t),
                EU.info(
                  "["
                    .concat(this._clientId, "] remote user ")
                    .concat(e, " unpublished ")
                    .concat(t)
                ),
                this.safeEmit(Rk.USER_UNPUBLISHED, s, t);
            }
          }),
          (this._handleP2PLost = async e => {
            EU.debug("[".concat(this._clientId, "] receive p2p lost"), e),
              parseInt(e.p2pid, 10) === this.store.p2pId
                ? await this._p2pChannel.requestReconnect()
                : EU.warning(
                    "[".concat(this._clientId, "] P2PLost stream not found"),
                    e
                  );
          }),
          (this._handleTokenWillExpire = () => {
            EU.debug(
              "[".concat(
                this._clientId,
                "] received message onTokenPrivilegeWillExpire"
              )
            ),
              this.safeEmit(Rk.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          }),
          (this._handleBeforeUnload = e => {
            ("beforeunload" === e.type &&
              void 0 !== e.returnValue &&
              "" !== e.returnValue) ||
              (this.leave(),
              EU.info(
                "[".concat(
                  this._clientId,
                  "] auto leave onbeforeunload or pagehide"
                )
              ));
          }),
          (this._handleUpdateNetworkQuality = () => {
            if ("normal" === this._networkQualitySensitivity) return;
            if (navigator && void 0 !== navigator.onLine && !navigator.onLine)
              return void this.safeEmit(Rk.NETWORK_QUALITY, {
                downlinkNetworkQuality: 6,
                uplinkNetworkQuality: 6
              });
            const e = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            (e.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality()),
              (e.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality()),
              this.safeEmit(Rk.NETWORK_QUALITY, e);
          }),
          (this._handleP2PAddAudioOrVideoStream = (e, t, i, s) => {
            const r = this._users.find(e => e.uid === t);
            if (!r)
              return void EU.error(
                "[".concat(
                  this._clientId,
                  "] can not find target user!(on_add_stream)"
                )
              );
            EU.debug(
              "["
                .concat(this._clientId, "] stream added with uid ")
                .concat(t, ", type ")
                .concat(e)
            ),
              this.store.subscribe(
                r.uid,
                e,
                void 0,
                void 0,
                void 0,
                Date.now()
              );
            const n = "audio" === e ? r.hasAudio : r.hasVideo;
            "audio" === e
              ? (r._trust_audio_stream_added_state_ = !0)
              : (r._trust_video_stream_added_state_ = !0),
              "audio" === e
                ? ((r._audio_added_ = !0),
                  void 0 !== i && (r._audioSSRC = i),
                  void 0 !== s && (r._audioMid = s))
                : ((r._video_added_ = !0),
                  void 0 !== i && (r._videoSSRC = i),
                  void 0 !== s && (r._videoMid = s)),
              ("audio" === e ? r.hasAudio : r.hasVideo) &&
                !n &&
                (EU.info(
                  "["
                    .concat(this._clientId, "] remote user ")
                    .concat(r.uid, " published ")
                    .concat(e)
                ),
                this.safeEmit(Rk.USER_PUBLISHED, r, e)),
              this._p2pChannel.hasPendingRemoteMedia(r, e) &&
                (EU.debug(
                  "["
                    .concat(this._clientId, "] resubscribe ")
                    .concat(e, " for user ")
                    .concat(r.uid, " after reconnect.")
                ),
                this._subscribe(r, e, !0).catch(e => {
                  EU.error(
                    "[".concat(this._clientId, "] resubscribe error"),
                    e.toString()
                  );
                }));
          }),
          (this._config = e),
          (this._clientId = t || Yk(5, "client-")),
          (this.store = new XM(e.codec, e.audioCodec, e.mode, this._clientId)),
          (this._leaveMutex = new sM("client-leave", this._clientId)),
          (this._publishMutex = new sM("client-publish", this._clientId)),
          (this._renewTokenMutex = new sM("client-renewtoken", this._clientId)),
          (this._subscribeMutex = new sM("client-subscribe", this._clientId)),
          this.store.clientCreated(),
          e.proxyServer && this.setProxyServer(e.proxyServer, !0),
          e.turnServer && this.setTurnServer(e.turnServer, !0),
          EU.info(
            "["
              .concat(this._clientId, "] Initializing AgoraRTC client v")
              .concat(MM, " build: ")
              .concat(GM, ", mode: ")
              .concat(this.mode, ", codec: ")
              .concat(this.codec)
          ),
          e.clientRoleOptions)
        )
          try {
            vk(e.clientRoleOptions),
              (i = Object.assign({}, e.clientRoleOptions));
          } catch (e) {
            EU.warning("[".concat(this._clientId, "] ").concat(e.toString()));
          }
        var s;
        (this._statsCollector = new UH(this.store)),
          (this._statsCollector.onStatsException = (e, t, i) => {
            EU.warn(
              "["
                .concat(this._clientId, "] receive exception msg, code: ")
                .concat(e, ", msg: ")
                .concat(t, ", uid: ")
                .concat(i)
            ),
              this.safeEmit(Rk.EXCEPTION, { code: e, msg: t, uid: i });
          }),
          (this._statsCollector.onUploadPublishDuration = (e, t, i, s) => {
            const r = this._users.find(t => t.uid === e);
            r &&
              yU.peerPublishStatus(this._sessionId, {
                subscribeElapse: s,
                audioPublishDuration: t,
                videoPublishDuration: i,
                peer: r._uintid
              });
          }),
          (this.store.useP2P = "p2p" === e.mode),
          (this._gateway = new Zj(this.store, {
            clientId: this._clientId,
            mode: this.mode,
            codec: this.codec,
            websocketRetryConfig: e.websocketRetryConfig || nM,
            httpRetryConfig: e.httpRetryConfig || nM,
            forceWaitGatewayResponse:
              void 0 === e.forceWaitGatewayResponse ||
              e.forceWaitGatewayResponse,
            statsCollector: this._statsCollector,
            role: e.role,
            clientRoleOptions: i
          })),
          (this._configDistribute = new NH(this._clientId, this.store)),
          this.store.useP2P
            ? ((this._p2pChannel =
                ((s = {
                  store: this.store,
                  statsCollector: this._statsCollector
                }),
                Xj("P2PChannel").create(s))),
              this._handleP2PEvents())
            : (this._p2pChannel = new MK(this.store, this._statsCollector)),
          this._handleP2PChannelEvents(),
          this._handleGatewayEvents(),
          this._handleGatewaySignalEvents();
      }
      async joinMeta(e, t, i, s, r) {
        let n =
            !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5],
          a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
        KM("JOIN_GATEWAY_USE_443PORT_ONLY", n),
          KM("JOIN_GATEWAY_USE_DUAL_DOMAIN", a);
        const o = this._gateway.signal.websocket;
        return (
          o instanceof lj && ((o.use443PortOnly = n), (o.tryDoubleDomain = a)),
          (async function(e, t, i) {
            pP.get(e) || pP.set(e, []),
              fP.get(e) || fP.set(e, t),
              EP.get(e) || EP.set(e, 0);
            const s = pP.get(e),
              r = fP.get(e);
            if (!s || !r)
              throw new Error(
                "concurrent: deferQueue or maxConcurrency is null"
              );
            if (EP.get(e) === r) {
              const e = uP();
              s.push(e), await e.promise;
            }
            EP.set(e, EP.get(e) + 1);
            for (
              var n = arguments.length, a = new Array(n > 3 ? n - 3 : 0), o = 3;
              o < n;
              o++
            )
              a[o - 3] = arguments[o];
            const c = await i(...a);
            return (
              EP.set(e, EP.get(e) - 1),
              EP.get(e) === r - 1 &&
                s.length > 0 &&
                (s[0].resolve(), s.shift()),
              0 === EP.get(e) && (pP.set(e, []), fP.set(e, 0), EP.set(e, 0)),
              c
            );
          })(
            "client.join",
            WM("JOIN_MAX_CONCURRENCY"),
            this.join.bind(this),
            e,
            t,
            i,
            s,
            r
          )
        );
      }
      async join(e, t, i, s, r) {
        const n = ++this._numberOfJoinCount;
        this.store.joinStart(), s && (this.store.uid = s);
        const a =
            "HTTPS" ===
            (cM ||
              cM ||
              ((cM = (
                window.location.protocol.split(":")[0] || ""
              ).toUpperCase()),
              cM)),
          o = pM() ? window.isSecureContext : "Browser Not Support";
        if ((!pM() && !a) || !window.isSecureContext) {
          const e =
            "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
          EU.warning(e);
        }
        "DISCONNECTED" === this.connectionState &&
          ((this.store.avoidJoinStart = Math.round(Date.now())),
          EU.debug(
            "["
              .concat(this._clientId, "] set avoidJoinStart to ")
              .concat(this.store.avoidJoinStart)
          )),
          yU.setAppId(e);
        try {
          if (!i && null !== i)
            throw new AU(
              zP.INVALID_PARAMS,
              "Invalid token: ".concat(
                i,
                ". If you don not use token, set it to null"
              )
            );
          i && ik(i, "token", 1, 2047),
            ik(e, "appid", 1, 2047),
            TG(t),
            s && SG(s),
            r && ik(r, "optionalInfo", 1, 2047);
        } catch (r) {
          throw (yU
            .reportApiInvoke($k(), {
              name: Ek.JOIN,
              options: [e, t, i, s],
              states: { isHttps: a, isSecureContext: o },
              tag: mk.TRACER
            })
            .onError(r),
          r);
        }
        if (this._leaveMutex.isLocked) {
          EU.debug(
            "[".concat(this._clientId, "] join: waiting leave operation")
          );
          (await this._leaveMutex.lock())(),
            EU.debug("[".concat(this._clientId, "] join: continue"));
        }
        if (
          ((this._joinAndNotLeaveYet = !0),
          "DISCONNECTED" !== this.connectionState)
        ) {
          const r = new AU(
            zP.INVALID_OPERATION,
            "[".concat(
              this._clientId,
              "] Client already in connecting/connected state"
            )
          );
          throw (yU
            .reportApiInvoke($k(), {
              name: Ek.JOIN,
              options: [e, t, i, s],
              states: { isHttps: a, isSecureContext: o },
              tag: mk.TRACER
            })
            .onError(r),
          r);
        }
        this._gateway.state = "CONNECTING";
        const c = await tW({
          appId: e,
          cname: t,
          uid: s,
          stringUid: "string" == typeof s ? s : void 0,
          token: i || e,
          cloudProxyServer: this._cloudProxyServerMode
        });
        if (!this._joinAndNotLeaveYet)
          throw new AU(
            zP.INVALID_OPERATION,
            "[".concat(this._clientId, "] Client already left")
          );
        const d = (null == c ? void 0 : c.sid) || $k();
        EU.info(
          "["
            .concat(this._clientId, "] start join channel ")
            .concat(t, ", join number: ")
            .concat(n)
        ),
          this._sessionId ||
            ((this._sessionId = d), (this.store.sessionId = this._sessionId));
        const l = yU.reportApiInvoke(d, {
            id: this._clientId,
            name: Ek.JOIN,
            options: [e, t, i, s],
            states: { isHttps: a, isSecureContext: o },
            tag: mk.TRACER
          }),
          h = rG(
            rG(
              rG({}, this._rtmConfig),
              {},
              {
                role: this.role,
                clientId: this._clientId,
                appId: e,
                sid: this._sessionId,
                cname: t,
                uid: "string" != typeof s ? s : null,
                turnServer: this._turnServer,
                proxyServer: this._proxyServer,
                token: i || e,
                cloudProxyServer: this._cloudProxyServerMode,
                optionalInfo: r,
                license: this._license,
                useLocalAccessPoint: this._useLocalAccessPoint,
                preload: !!c
              },
              void 0 !== this._remoteDefaultVideoStreamType && {
                defaultVideoStream: this._remoteDefaultVideoStreamType
              }
            ),
            {},
            { apRequestDetail: WM("AP_REQUEST_DETAIL") || void 0 }
          );
        if (
          (this._useLocalAccessPoint &&
            (h.setLocalAPVersion = this._setLocalAPVersion),
          "string" == typeof s &&
            ((h.stringUid = s),
            this._uintUid
              ? ((h.uid = this._uintUid), (this._uintUid = void 0))
              : (h.uid = 0)),
          "none" !== this._encryptionMode && this._encryptionSecret)
        ) {
          if (
            ((h.aesmode = this._encryptionMode),
            (h.aespassword = await (async e => {
              const t = (function(e) {
                  const t = window.atob(
                      "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"
                    ),
                    i = new Uint8Array(new ArrayBuffer(t.length));
                  for (let e = 0; e < t.length; e += 1) i[e] = t.charCodeAt(e);
                  return i;
                })(),
                i = await window.crypto.subtle.importKey(
                  "spki",
                  t,
                  { name: "RSA-OAEP", hash: "SHA-256" },
                  !0,
                  ["encrypt"]
                ),
                s = dk(e),
                r = await window.crypto.subtle.encrypt(
                  { name: "RSA-OAEP" },
                  i,
                  s
                );
              return (function(e) {
                let t = "";
                for (let i = 0; i < e.length; i += 1)
                  t += String.fromCharCode(e[i]);
                return window.btoa(t);
              })(new Uint8Array(r));
            })(this._encryptionSecret)),
            !this._joinAndNotLeaveYet)
          )
            throw new AU(
              zP.INVALID_OPERATION,
              "[".concat(this._clientId, "] Client already left")
            );
          this._encryptionSalt && (h.aessalt = this._encryptionSalt);
        }
        if (
          this._encryptDataStream &&
          ("aes-128-gcm2" === this._encryptionMode ||
            "aes-256-gcm2" === this._encryptionMode)
        )
          if (this._encryptionSalt && this._encryptionSecret)
            if (window.crypto.subtle) {
              const e = new TextEncoder(),
                t = WM("USE_PURE_ENCRYPTION_MASTER_KEY")
                  ? e.encode(
                      h.appId + this._encryptionSecret + this._encryptionSecret
                    )
                  : e.encode(h.appId + h.cname + this._encryptionSecret);
              (this._encryptDataStreamIv = await (async function(e, t, i) {
                const s = await window.crypto.subtle.importKey(
                    "raw",
                    t,
                    "PBKDF2",
                    !1,
                    ["deriveBits", "deriveKey"]
                  ),
                  r = "aes-128-gcm2" === e ? 128 : 256,
                  n = await window.crypto.subtle.deriveBits(
                    {
                      name: "PBKDF2",
                      iterations: ZM,
                      hash: "SHA-256",
                      salt: i
                    },
                    s,
                    r + QM
                  );
                return new Uint8Array(n).subarray(r / 8);
              })(this._encryptionMode, t, Fk(this._encryptionSalt))),
                (this._encryptDataStreamKey = await (async function(e, t, i) {
                  const s = await window.crypto.subtle.importKey(
                      "raw",
                      t,
                      "PBKDF2",
                      !1,
                      ["deriveBits", "deriveKey"]
                    ),
                    r = "aes-128-gcm2" === e ? 128 : 256;
                  return await window.crypto.subtle.deriveKey(
                    {
                      name: "PBKDF2",
                      iterations: ZM,
                      hash: "SHA-256",
                      salt: i
                    },
                    s,
                    { name: "AES-GCM", length: r },
                    !0,
                    ["encrypt", "decrypt"]
                  );
                })(this._encryptionMode, t, Fk(this._encryptionSalt)));
            } else
              o
                ? EU.warning(
                    "[".concat(
                      this._clientId,
                      "] encrypt datastream must be running in a secure context, fallback to plain data stream"
                    )
                  )
                : EU.warning(
                    "[".concat(
                      this._clientId,
                      "] current browser do not support WebCrypto ,fallback to plain data stream"
                    )
                  ),
                (this._encryptDataStream = !1);
          else
            (this._encryptDataStream = !1),
              EU.debug(
                "[".concat(
                  this._clientId,
                  "] no salt / secret, cannot support encrypt data stream, fallback to plain data stream"
                )
              );
        this._startSession(this._sessionId, {
          channel: t,
          appId: e,
          stringUid: h.stringUid
        });
        const u = this._sessionId;
        setTimeout(() => {
          "CONNECTING" === this.connectionState &&
            u === this._sessionId &&
            yU.joinChannelTimeout(this._sessionId, 5);
        }, 5e3);
        try {
          let s;
          const r = h.cloudProxyServer;
          if (["proxy3", "proxy4", "proxy5"].includes(r)) {
            const e = WM("PROXY_SERVER_TYPE3");
            Array.isArray(e) ? (h.proxyServer = e[0]) : (h.proxyServer = e);
          }
          if (
            (yU.setProxyServer(h.proxyServer),
            EU.setProxyServer(h.proxyServer),
            this.store.requestAPStart(),
            c)
          ) {
            if (
              (EU.debug(
                "["
                  .concat(
                    this._clientId,
                    "] get serverInfo Success from Preload Cache "
                  )
                  .concat(
                    h.stringUid
                      ? ", ".concat(h.stringUid, " => ").concat(c.intUid)
                      : "",
                    " "
                  )
              ),
              h.stringUid && !h.uid && (h.uid = c.intUid),
              (s = { gatewayInfo: c.ap.gatewayInfo }),
              WM("JOIN_WITH_FALLBACK_MEDIA_PROXY") &&
                "auto" === h.turnServer.mode)
            )
              if (0 === c.ap.proxyInfo.addresses.length)
                EU.warning(
                  "no edge services in ap response of proxy fallback, will not set proxy in iceServers"
                );
              else {
                const e = (
                  await Sj(c.ap.proxyInfo, c.ap.gatewayInfo.uid)
                ).map(e => ({
                  turnServerURL: e.address,
                  tcpport: e.tcpport || FM.tcpport,
                  udpport: e.udpport || FM.udpport,
                  username: e.username || FM.username,
                  password: e.password || FM.password,
                  forceturn: !1,
                  security: !0
                }));
                h.turnServer = { mode: "manual", servers: e };
              }
            nW(c, h.stringUid);
          } else {
            if (h.stringUid && !h.uid) {
              let e;
              ([e, s] = await Promise.all([
                CH(
                  h.stringUid,
                  h,
                  this._axiosCancelSource.token,
                  this._config.httpRetryConfig || nM,
                  this.store
                ),
                IH(
                  h,
                  this._axiosCancelSource.token,
                  this._config.httpRetryConfig || nM,
                  !0,
                  this.store
                )
              ])),
                EU.debug(
                  "["
                    .concat(this._clientId, "] getUserAccount Success ")
                    .concat(h.stringUid, " => ")
                    .concat(e)
                ),
                (h.uid = e),
                (s.gatewayInfo.uid = e),
                (s.gatewayInfo.res.uid = e);
            } else
              s = await IH(
                h,
                this._axiosCancelSource.token,
                this._config.httpRetryConfig || nM,
                !0,
                this.store
              );
            if (!this._joinAndNotLeaveYet)
              throw new AU(
                zP.INVALID_OPERATION,
                "[".concat(this._clientId, "] Client already left")
              );
          }
          this.store.requestAPEnd(),
            setTimeout(() => {
              this._configDistribute.startGetConfigDistribute(
                h,
                this._axiosCancelSource.token
              ),
                this._configDistribute.on(PG.UPDATE_BITRATE_LIMIT, e => {
                  this._p2pChannel.updateBitrateLimit(e);
                }),
                this._configDistribute.on(PG.UPDATE_CLIENT_ROLE_OPTIONS, e => {
                  this._setClientRoleOptions(e);
                });
            }, 0),
            (this._key = i || e);
          const n = s.gatewayInfo,
            a = h.uid ? h.uid : n.uid;
          (this._joinInfo = rG(
            rG({}, h),
            {},
            {
              cid: n.cid,
              uid: a,
              vid: n.vid,
              apResponse: n.res,
              apGatewayAddress: n.apGatewayAddress,
              uni_lbs_ip: n.uni_lbs_ip,
              gatewayAddrs: n.gatewayAddrs
            }
          )),
            (this.store.intUid = a),
            (this.store.cid = n.cid);
          const o = await this._joinGateway();
          if (!this._joinAndNotLeaveYet)
            throw new AU(
              zP.INVALID_OPERATION,
              "[".concat(this._clientId, "] Client already left")
            );
          l.onSuccess(o),
            (this._appId = e),
            (this._channelName = h.cname),
            (this._uid = o),
            (this.store.uid = o),
            setTimeout(() => {
              this._networkQualityInterval &&
                window.clearInterval(this._networkQualityInterval),
                (this._networkQualityInterval = window.setInterval(
                  this._handleUpdateNetworkQuality,
                  2e3
                )),
                window.addEventListener(
                  bP() ? "beforeunload" : "pagehide",
                  this._handleBeforeUnload
                ),
                this._statsCollector.startUpdateStats();
            }, 0);
          const d = h.stringUid
            ? "string uid: ".concat(h.stringUid, ",uid: ").concat(h.uid)
            : "uid: ".concat(this._uid);
          return (
            EU.info(
              "["
                .concat(this._clientId, "] Joining channel success: channel: ")
                .concat(t, ",")
                .concat(d)
            ),
            setTimeout(() => {
              EU.startUpload();
            }, 5e3),
            this.store.joinEnd(),
            (p = this),
            YV.includes(p) || YV.push(p),
            "disabled" === this._cloudProxyServerMode &&
              Lx().supportWebCrypto &&
              WM("ENABLE_PRELOAD") &&
              sW(this._joinInfo),
            o
          );
        } catch (e) {
          const t = Array.isArray(e) ? e[0] : e;
          throw (t && t.code === zP.OPERATION_ABORTED
            ? EU.warning(
                "["
                  .concat(this._clientId, "] join number: ")
                  .concat(n, ", Joining channel failed, rollback"),
                t
              )
            : EU.error(
                "["
                  .concat(this._clientId, "] join number: ")
                  .concat(n, ", Joining channel failed, rollback"),
                t
              ),
          t.code !== zP.OPERATION_ABORTED &&
            this._numberOfJoinCount === n &&
            ((this._gateway.state = "DISCONNECTED"), this._reset()),
          l.onError(t),
          t);
        }
        var p;
      }
      _joinGateway() {
        if (!this._joinInfo || !this._key) throw new AU(zP.INVALID_OPERATION);
        return this._gateway.join(
          this._joinInfo,
          this._key,
          !(
            "disabled" !== this._joinInfo.cloudProxyServer ||
            this._joinInfo.proxyServer ||
            !WM("JOIN_WITH_FALLBACK_SIGNAL_PROXY")
          )
        );
      }
      async leave() {
        EU.info("[".concat(this._clientId, "] Leaving channel")),
          window.removeEventListener(
            bP() ? "beforeunload" : "pagehide",
            this._handleBeforeUnload
          ),
          this._reset(),
          (function(e) {
            const t = YV.indexOf(e);
            -1 !== t && YV.splice(t, 1);
          })(this),
          this._statsCollector.stopUpdateStats();
        const e = await this._leaveMutex.lock();
        if ("DISCONNECTED" === this.connectionState)
          return (
            EU.info(
              "[".concat(this._clientId, "] Leaving channel repeated, success")
            ),
            void e()
          );
        await this._gateway.leave(
          "CONNECTED" !== this.connectionState,
          _k.LEAVE
        ),
          EU.info("[".concat(this._clientId, "] Leaving channel success")),
          (this._joinAndNotLeaveYet = !1),
          this.store.resetJoinChannelServiceRecords(),
          e();
      }
      async publish(e) {
        let t =
          !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (!Array.isArray(e)) {
          if (!(e instanceof pF)) return this._publishDataChannel(e);
          e = [e];
        }
        if (0 === e.length)
          throw new AU(zP.INVALID_PARAMS, "param list is empty");
        const i = e;
        if ("audience" === this._gateway.role)
          throw new AU(zP.INVALID_OPERATION, "audience can not publish stream");
        for (const e of i) {
          if (!(e instanceof pF))
            throw new AU(zP.INVALID_PARAMS, "parameter is not local track");
          if (!e._enabled && t)
            throw new AU(
              zP.TRACK_IS_DISABLED,
              "can not publish a disabled track: ".concat(e.getTrackId())
            );
        }
        EU.info(
          "["
            .concat(this._clientId, "] Publishing tracks, id ")
            .concat(i.map(e => "".concat(e.getTrackId(), " ")))
        );
        const s = await this._publishMutex.lock();
        await this._configDistribute.awaitConfigDistributeComplete(),
          t &&
            i.forEach(e => {
              const t = this._configDistribute.getBitrateLimit();
              e instanceof AV && t && e.setBitrateLimit(t.uplink);
            });
        try {
          await this._publishHighStream(i),
            EU.info(
              "["
                .concat(this._clientId, "] Publish success, id ")
                .concat(i.map(e => "".concat(e.getTrackId(), " ")))
            );
        } catch (e) {
          throw (EU.error(
            "[".concat(this._clientId, "] publish error"),
            e.toString()
          ),
          e);
        } finally {
          s();
        }
      }
      async _publishDataChannel(e) {
        ek(e.id, "id", 0, 65535, !0),
          QP(e.ordered, "ordered"),
          ik(e.metadata, "metadata", 0, 512),
          EU.info(
            "["
              .concat(this._clientId, "] Publishing datachannels, id ")
              .concat(e.id)
          );
        const t = await this._publishMutex.lock();
        try {
          if (
            -1 !==
            this._p2pChannel.getAllDataChannels().findIndex(t => t.id === e.id)
          )
            throw new AU(
              zP.INVALID_PARAMS,
              "Invalid id: ".concat(
                e.id,
                ". If you want to republish the datachannel, unpublish first"
              )
            );
          if (!this._joinInfo || void 0 === this._uid)
            throw new AU(
              zP.INVALID_OPERATION,
              "Can't publish datachannel, haven't joined yet!"
            );
          if (
            "CONNECTED" !== this.connectionState &&
            "RECONNECTING" !== this.connectionState
          )
            throw new AU(
              zP.INVALID_OPERATION,
              "can not publish datachannel in ".concat(
                this.connectionState,
                " state"
              )
            );
          if (
            "auto" === this._turnServer.mode &&
            WM("FORCE_TURN") &&
            !WM("TURN_ENABLE_TCP") &&
            !WM("TURN_ENABLE_UDP")
          )
            throw new AU(
              zP.UNEXPECTED_ERROR,
              "force TURN With No TURN Configuration"
            );
          const i = (function(e) {
              return zj(e, !1);
            })(e),
            s = await this._p2pChannel.publishDataChannel([i]);
          if (s.length > 0) {
            if ("number" != typeof i._originDataChannelId)
              throw (EU.error(
                "[".concat(
                  this._clientId,
                  "] can not publish with mediaType datachannel, cannot get RTCDatachannel id"
                )
              ),
              new AU(zP.CREATE_DATACHANNEL_ERROR));
            try {
              await Promise.all(
                s.map(
                  e =>
                    this._uid &&
                    this._gateway.publishDataChannel(this._uid, e, !0)
                )
              ),
                await i._waitTillOpen();
            } catch (e) {
              if (e.code !== zP.DISCONNECT_P2P) throw e;
            }
          }
          return (
            EU.info(
              "["
                .concat(this._clientId, "] Publish dataChannels success, id ")
                .concat(i.id)
            ),
            i
          );
        } catch (e) {
          throw (EU.error(
            "[".concat(this._clientId, "] publish datachannels error"),
            e.toString()
          ),
          e);
        } finally {
          t();
        }
      }
      async unpublish(e) {
        if (!this._joinInfo || void 0 === this._uid)
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't unpublish stream, haven't joined yet!"
          );
        let t = [];
        if (e)
          if (Array.isArray(e)) t = e;
          else {
            if (!(e instanceof pF)) return this._unpublishDataChannel([e]);
            t = [e];
          }
        else
          this.store.useP2P || (await this._unpublishDataChannel()),
            (t = this._p2pChannel.getAllTracks(!0));
        EU.info(
          "[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(
            t.map(e => "".concat(e.getTrackId(), " ")),
            " "
          )
        );
        const i = await this._publishMutex.lock();
        try {
          if (this.store.useP2P) {
            const e = await this._p2pChannel.unpublish(t);
            e &&
              (await this._gateway.sendExtensionMessage(
                zG.UNPUBLISH,
                { unpubMsg: e },
                !0
              ));
          } else {
            const e = await this._p2pChannel.unpublish(t);
            e && (await this._gateway.unpublish(e, this._uid)),
              EU.info(
                "["
                  .concat(this._clientId, "] Unpublish success,tracks ")
                  .concat(t.map(e => "".concat(e.getTrackId())))
              );
          }
        } catch (e) {
          throw (EU.error(
            "[".concat(this._clientId, "] unpublish error"),
            e.toString()
          ),
          e);
        } finally {
          i && i();
        }
      }
      async _unpublishDataChannel(e) {
        (void 0 !== e && 0 !== e.length) ||
          (e = this._p2pChannel.getAllDataChannels()),
          EU.info(
            "["
              .concat(this._clientId, "] Unpublish datachannels, datachannels ")
              .concat(
                e.map(e => "".concat(e.id, " ")),
                " "
              )
          );
        const t = await this._publishMutex.lock();
        try {
          const i = await this._p2pChannel.unpublishDataChannel(e);
          i && (await this._gateway.unpublishDataChannel(i)),
            EU.info(
              "["
                .concat(
                  this._clientId,
                  "] Unpublish dataChannel success,dataChannel "
                )
                .concat(e.map(e => "".concat(e.id)))
            );
        } catch (e) {
          throw (EU.error(
            "[".concat(this._clientId, "] unpublish dataChannel error"),
            e.toString()
          ),
          e);
        } finally {
          t && t();
        }
      }
      async subscribe(e, t, i) {
        if (!(e instanceof BH)) {
          const t = this.remoteUsers.find(t => t.uid === e);
          if (!t)
            throw new AU(zP.INVALID_REMOTE_USER, "user is not in the channel");
          e = t;
        }
        return "datachannel" === t
          ? this._subscribeDataChannel(e, i)
          : this._subscribe(e, t);
      }
      async presubscribe(e, t) {
        if ((ZP(t, "mediaType", ["audio", "video"]), this.store.useP2P))
          throw new AU(zP.INVALID_OPERATION, "can't presub at p2p mode");
        if (!this._joinInfo)
          throw new AU(zP.INVALID_OPERATION, "can't presub when not join");
        if (
          "CONNECTED" !== this.connectionState &&
          "RECONNECTING" !== this.connectionState
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "can't presub in ".concat(this.connectionState, " state")
          );
        const i = t === xG.AUDIO,
          s = t === xG.VIDEO,
          r = await this._subscribeMutex.lock();
        try {
          const {
            ssrcId: n,
            ortc: a,
            rtxSsrcId: o,
            cname: c,
            uint_id: d
          } = await this._gateway.presubscribe(e, t, !0);
          if (null == n) throw new AU(zP.UNEXPECTED_RESPONSE, "no ssrc id");
          let l = this._users.find(t => t.uid === e);
          l ||
            ((l = new BH(e, d || e)),
            (l._is_pre_created = !0),
            this._users.push(l)),
            c && (l._cname = c),
            l._uintid || (l._uintid = d || e),
            i &&
              ((l._audioSSRC = n),
              (l._audio_pre_subscribed = !0),
              a && (l._audioOrtc = a)),
            s &&
              ((l._videoSSRC = n),
              (l._video_pre_subscribed = !0),
              a && (l._videoOrtc = a),
              null != o && (l._rtxSsrcId = o)),
            EU.info(
              "[".concat(this._clientId, "] presub succeed ssrc: ").concat(n)
            ),
            await this._p2pChannel.subscribe(l, t, n, o, a);
          const h = i ? l._audioTrack : l._videoTrack;
          if (!h)
            throw new AU(
              zP.UNEXPECTED_ERROR,
              "can not find remote track in user"
            );
          return (
            i &&
              ((l._trust_audio_stream_added_state_ = !0),
              (l._audio_added_ = !0)),
            s &&
              ((l._trust_video_stream_added_state_ = !0),
              (l._video_added_ = !0)),
            h
          );
        } catch (t) {
          throw (EU.error(
            "[".concat(this._clientId, "] presub user ").concat(e, " error"),
            t
          ),
          t);
        } finally {
          r();
        }
      }
      async _subscribeDataChannel(e, t) {
        var i;
        if ((ek(t, "channelId", 0, 65535, !0), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe datachannel, not joined"
          );
        if (
          "CONNECTED" !== this.connectionState &&
          "RECONNECTING" !== this.connectionState
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe datachannel in ".concat(
              this.connectionState,
              " state"
            )
          );
        const s = this._users.find(t => t === e);
        if (!s)
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, ", this user is not in the channel")
          ),
          new AU(zP.INVALID_REMOTE_USER, "user is not in the channel"));
        if (!e.hasAudio && !e.hasVideo && 0 === e._dataChannels.length)
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, ", user is not published")
          ),
          new AU(zP.INVALID_REMOTE_USER, "user is not published"));
        const r =
          null === (i = e._dataChannels) || void 0 === i
            ? void 0
            : i.find(e => e.id === t);
        if (!r)
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(
                e.uid,
                " with mediaType datachannel, remote datachannel is not published"
              )
          ),
          new AU(zP.REMOTE_USER_IS_NOT_PUBLISHED));
        const n = await this._subscribeMutex.lock();
        EU.info(
          "["
            .concat(this._clientId, "] subscribe user ")
            .concat(e.uid, ", mediaType: datachannel")
        );
        try {
          const t = await this._p2pChannel.subscribeDataChannel(e, [r]);
          if (t && t.includes(r.id))
            try {
              var a;
              if ("number" != typeof r._originDataChannelId)
                throw (EU.error(
                  "["
                    .concat(this._clientId, "] can not subscribe ")
                    .concat(
                      e.uid,
                      " with mediaType datachannel, cannot get RTCDatachannel"
                    )
                ),
                new AU(zP.CREATE_DATACHANNEL_ERROR));
              const t = {
                id: r.id,
                datachannelId: r._originDataChannelId,
                ordered: r.ordered,
                maxRetransmits: r.maxRetransmits,
                metadata: null !== (a = r.metadata) && void 0 !== a ? a : ""
              };
              await this._gateway.subscribeDataChannel(e.uid, t, !0),
                await r._waitTillOpen();
            } catch (t) {
              if ((null == t ? void 0 : t.code) !== zP.WS_ABORT)
                throw (await this._p2pChannel.unsubscribeDataChannel(e, [r]),
                t);
              await this._p2pChannel.unsubscribeDataChannel(e, [r]),
                this._p2pChannel.setPendingRemoteDataChannel(e, r.id);
            }
          return (
            EU.info(
              "["
                .concat(this._clientId, "] subscribe success user ")
                .concat(e.uid, ", mediaType: datachannel")
            ),
            r
          );
        } finally {
          n();
        }
      }
      async _p2pSubscribe(e, t, i) {
        if ((ZP(t, "mediaType", ["audio", "video"]), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe stream, not joined"
          );
        if (
          "CONNECTED" !== this.connectionState &&
          "RECONNECTING" !== this.connectionState
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe stream in ".concat(this.connectionState, " state")
          );
        const s = this._users.find(t => t === e);
        if (!s) {
          const t = new AU(
            zP.INVALID_REMOTE_USER,
            "user is not in the channel"
          );
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, ", this user is not in the channel")
          ),
          t);
        }
        if (!e.hasAudio && !e.hasVideo) {
          const t = new AU(zP.INVALID_REMOTE_USER, "user is not published");
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, ", user is not published")
          ),
          t);
        }
        if (
          !i &&
          (("audio" === t && !e.hasAudio) || ("video" === t && !e.hasVideo))
        ) {
          const i = new AU(zP.REMOTE_USER_IS_NOT_PUBLISHED);
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, " with mediaType ")
              .concat(t, ", remote track is not published")
          ),
          i);
        }
        const r = await this._subscribeMutex.lock();
        EU.info(
          "["
            .concat(this._clientId, "] subscribe user ")
            .concat(e.uid, ", mediaType: ")
            .concat(t)
        );
        try {
          if (await this._p2pChannel.hasRemoteMediaWithLock(e, t))
            await this._p2pChannel.unmuteRemote(e, t);
          else
            try {
              const i = "audio" === t ? e._audioSSRC : e._videoSSRC,
                s = "audio" === t ? e._audioMid : e._videoMid;
              this.store.subscribe(e.uid, t, Date.now()),
                this.store.useP2P &&
                  (await this._p2pChannel.subscribe(e, t, i, s));
            } catch (e) {
              throw e;
            }
          EU.info(
            "["
              .concat(this._clientId, "] subscribe success user ")
              .concat(e.uid, ", mediaType: ")
              .concat(t)
          ),
            this._defaultStreamFallbackType &&
              this.setStreamFallbackOption(
                e.uid,
                this._defaultStreamFallbackType
              ).catch(e => {
                EU.warning(
                  "[".concat(this._clientId, "] auto set fallback failed"),
                  e
                );
              });
          const i = "audio" === t ? e._audioTrack : e._videoTrack;
          if (!i)
            throw new AU(
              zP.UNEXPECTED_ERROR,
              "can not find remote track in user object"
            );
          return i;
        } catch (t) {
          throw (EU.error(
            "["
              .concat(this._clientId, "] subscribe user ")
              .concat(e.uid, " error"),
            t
          ),
          t);
        } finally {
          r();
        }
      }
      async _subscribe(e, t, i) {
        if (this.store.useP2P) return this._p2pSubscribe(e, t);
        if ((ZP(t, "mediaType", ["audio", "video"]), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe stream, not joined"
          );
        if (
          "CONNECTED" !== this.connectionState &&
          "RECONNECTING" !== this.connectionState
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe stream in ".concat(this.connectionState, " state")
          );
        const s = this._users.find(t => t === e);
        if (!s) {
          const t = new AU(
            zP.INVALID_REMOTE_USER,
            "user is not in the channel"
          );
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, ", this user is not in the channel")
          ),
          t);
        }
        if (!e.hasAudio && !e.hasVideo) {
          const t = new AU(zP.INVALID_REMOTE_USER, "user is not published");
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, ", user is not published")
          ),
          t);
        }
        if (
          !(
            i ||
            (("audio" !== t || (e.hasAudio && void 0 !== e._audioSSRC)) &&
              ("video" !== t || (e.hasVideo && void 0 !== e._videoSSRC)))
          )
        ) {
          const i = new AU(zP.REMOTE_USER_IS_NOT_PUBLISHED);
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not subscribe ")
              .concat(e.uid, " with mediaType ")
              .concat(t, ", remote track is not published")
          ),
          i);
        }
        let r = "audio" === t ? e._audioSSRC : e._videoSSRC,
          n = "audio" === t ? e._audioOrtc : e._videoOrtc,
          a = "video" === t ? e._rtxSsrcId : void 0,
          o = { stream_type: "audio" === t ? xG.AUDIO : xG.VIDEO, ssrcId: r };
        const c = await this._subscribeMutex.lock();
        EU.info(
          "["
            .concat(this._clientId, "] subscribe user ")
            .concat(e.uid, ", mediaType: ")
            .concat(t)
        );
        try {
          if (await this._p2pChannel.hasRemoteMediaWithLock(e, t))
            await this._p2pChannel.unmuteRemote(e, t);
          else
            try {
              const i = "audio" === t ? e._audioSSRC : e._videoSSRC;
              void 0 !== i &&
                i !== r &&
                ((r = i),
                (n = "audio" === t ? e._audioOrtc : e._videoOrtc),
                (a = "video" === t ? e._rtxSsrcId : void 0),
                (o = {
                  stream_type: "audio" === t ? xG.AUDIO : xG.VIDEO,
                  ssrcId: r
                })),
                MH.markSubscribeStart(this.store.clientId, r),
                this.store.subscribe(e.uid, t, Date.now()),
                await this._p2pChannel.subscribe(e, t, r, a, n);
              try {
                this._p2pChannel.isPreSubScribe(r) ||
                  (await this._gateway.subscribe(e.uid, o, !0));
              } catch (i) {
                if ((null == i ? void 0 : i.code) !== zP.WS_ABORT)
                  throw (await this._p2pChannel.unsubscribe(e, t), i);
                await this._p2pChannel.unsubscribe(e, t, !0),
                  this._p2pChannel.setPendingRemoteMedia(e, t);
              }
              this.store.subscribe(e.uid, t, void 0, Date.now()),
                this._p2pChannel.reportSubscribeEvent(!0, null, e, t);
            } catch (i) {
              throw (this._p2pChannel.reportSubscribeEvent(
                !1,
                null == i ? void 0 : i.code,
                e,
                t
              ),
              i);
            }
          EU.info(
            "["
              .concat(this._clientId, "] subscribe success user ")
              .concat(e.uid, ", mediaType: ")
              .concat(t)
          ),
            this._defaultStreamFallbackType &&
              this.setStreamFallbackOption(
                e.uid,
                this._defaultStreamFallbackType
              ).catch(e => {
                EU.warning(
                  "[".concat(this._clientId, "] auto set fallback failed"),
                  e
                );
              });
          const i = "audio" === t ? e._audioTrack : e._videoTrack;
          if (!i)
            throw new AU(
              zP.UNEXPECTED_ERROR,
              "can not find remote track in user object"
            );
          return i;
        } catch (t) {
          throw (EU.error(
            "["
              .concat(this._clientId, "] subscribe user ")
              .concat(e.uid, " error"),
            t
          ),
          t);
        } finally {
          c();
        }
      }
      async massSubscribe(e) {
        if ((sk(e, "subscribeList"), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe stream, not joined"
          );
        if (
          "CONNECTED" !== this.connectionState &&
          "RECONNECTING" !== this.connectionState
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't subscribe stream in ".concat(this.connectionState, " state")
          );
        const t = Date.now(),
          i = new Map(),
          s = await this._subscribeMutex.lock();
        EU.info(
          "[".concat(this._clientId, "]start massSubscribe user ").concat(
            e
              .map(e => {
                let { user: t, mediaType: i } = e;
                return "user: "
                  .concat(null == t ? void 0 : t.uid, ", mediaType: ")
                  .concat(i);
              })
              .join("; ")
          )
        );
        const r = (e = [...e]).map(e => {
            let { user: t, mediaType: i } = e;
            return { user: t, mediaType: i };
          }),
          n = await this._p2pChannel.globalLock();
        try {
          for (let t = e.length - 1; t >= 0; t--) {
            const s = e[t],
              { user: n, mediaType: a } = s;
            if ((ZP(a, "mediaType", ["audio", "video"]), !n)) {
              const e = new AU(
                zP.INVALID_PARAMS,
                "user property does not exist in subscribeList item"
              );
              throw (EU.error(
                "[".concat(
                  this._clientId,
                  "] user property does not exist in subscribeList item"
                )
              ),
              e);
            }
            const o = this._users.find(e => e === n);
            if (!o) {
              const i = new AU(
                zP.INVALID_REMOTE_USER,
                "user is not in the channel"
              );
              EU.error(
                "["
                  .concat(this._clientId, "] can not massSubscribe ")
                  .concat(n.uid, ", this user is not in the channel")
              ),
                (r[t].error = i),
                e.splice(t, 1);
              continue;
            }
            if (
              ("audio" === a && (!n.hasAudio || void 0 === n._audioSSRC)) ||
              ("video" === a && (!n.hasVideo || void 0 === n._videoSSRC))
            ) {
              const i = new AU(zP.REMOTE_USER_IS_NOT_PUBLISHED);
              EU.error(
                "["
                  .concat(this._clientId, "] can not subscribe ")
                  .concat(n.uid, " with mediaType ")
                  .concat(a, ", remote user is not published")
              ),
                (r[t].error = i),
                e.splice(t, 1);
              continue;
            }
            const c = OG.Video | OG.LwoVideo,
              d = i.get(n);
            if (d) {
              if ("video" === a ? d & c : d & OG.Audio) {
                e.splice(t, 1),
                  EU.warning(
                    "["
                      .concat(this._clientId, "] repeat massSubscribe user:")
                      .concat(n.uid, ", mediaType:")
                      .concat(a, " twice")
                  );
                continue;
              }
              i.set(n, d | ("video" === a ? c : OG.Audio));
            } else i.set(n, "video" === a ? c : OG.Audio);
          }
          for (let t = e.length - 1; t >= 0; t--) {
            const s = e[t],
              { user: r, mediaType: n } = s,
              a = OG.Video | OG.LwoVideo;
            if (this._p2pChannel.hasRemoteMedia(r, n)) {
              await this._p2pChannel.unmuteRemoteNoLock(r, n);
              const s = i.get(r);
              i.set(r, "video" === n ? s ^ a : s ^ OG.Audio), e.splice(t, 1);
            }
          }
          this.store.massSubscribe(
            e.map(e => ({ userId: e.user.uid, type: e.mediaType })),
            t
          );
          let a = Array.from(i.entries()).reduce((e, t) => {
            let [i, s] = t;
            if (0 === s) return e;
            const r = { stream_id: i.uid, stream_type: s };
            return (
              s & OG.Audio && (r.audio_ssrc = i._audioSSRC),
              s & OG.Video && (r.video_ssrc = i._videoSSRC),
              e.push(r),
              e
            );
          }, []);
          try {
            e.length > 0 &&
              (await this._p2pChannel.massSubscribeNoLock(
                e.map(e => {
                  let { user: t, mediaType: i } = e;
                  return {
                    user: t,
                    mediaType: i,
                    ssrcId: i === xG.VIDEO ? t._videoSSRC : t._audioSSRC,
                    rtxSsrcId: i === xG.VIDEO ? t._rtxSsrcId : void 0
                  };
                })
              ));
            const i = new Map();
            if (
              ((a = a.filter(
                e =>
                  (e.video_ssrc &&
                    !this._p2pChannel.isPreSubScribe(e.video_ssrc)) ||
                  (e.audio_ssrc &&
                    !this._p2pChannel.isPreSubScribe(e.audio_ssrc)) ||
                  (!e.video_ssrc && !e.audio_ssrc)
              )),
              a.length > 0)
            ) {
              const e = await this._gateway.subscribeAll(a, !0);
              ((null == e ? void 0 : e.users) || []).forEach(e => {
                let {
                  stream_id: t,
                  video_error_code: s,
                  audio_error_code: r,
                  error_code: n
                } = e;
                (s || r || n) &&
                  i.set(t, {
                    video_error_code: s,
                    audio_error_code: r,
                    error_code: n
                  });
              });
            }
            if (Array.from(i.entries()).length > 0) {
              const e = [];
              Array.from(i.entries()).forEach(t => {
                let [i, s] = t;
                const r = this.remoteUsers.find(e => e.uid === i);
                if (r) {
                  let t;
                  s.error_code || (s.video_error_code && s.audio_error_code)
                    ? (t = void 0)
                    : s.video_error_code
                    ? (t = xG.VIDEO)
                    : s.audio_error_code && (t = xG.AUDIO),
                    e.push({ user: r, mediaType: t });
                }
              }),
                e.length > 0 &&
                  (await this._p2pChannel.massUnsubscribeNoLock(e));
            }
            for (const e of r) {
              const t = i.get(e.user.uid);
              if (t) {
                const i =
                  t.error_code ||
                  ("audio" === e.mediaType && t.audio_error_code) ||
                  ("video" === e.mediaType && t.video_error_code);
                if (i) {
                  const t = tj(i);
                  EU.error(
                    "user:"
                      .concat(e.user.uid, " mediaType:")
                      .concat(e.mediaType, " has massSubscribe error ")
                      .concat(t.desc)
                  ),
                    (e.error = new AU(
                      zP.SUBSCRIBE_FAILED,
                      "code ".concat(i, ": ").concat(t.desc)
                    ));
                }
              }
              e.error ||
                ("video" === e.mediaType
                  ? (e.track = e.user.videoTrack)
                  : (e.track = e.user.audioTrack));
            }
            return (
              this.store.massSubscribe(
                r
                  .filter(e => !e.error)
                  .map(e => ({ userId: e.user.uid, type: e.mediaType })),
                void 0,
                Date.now()
              ),
              r.forEach(e => {
                var i;
                yU.subscribe(
                  this.store.sessionId,
                  {
                    succ: !!e.error,
                    ec:
                      (null === (i = e.error) || void 0 === i
                        ? void 0
                        : i.code) || null,
                    video: e.mediaType === xG.VIDEO,
                    audio: e.mediaType === xG.AUDIO,
                    peerid: e.user.uid,
                    subscribeRequestid:
                      e.mediaType === xG.VIDEO
                        ? e.user._videoSSRC
                        : e.user._audioSSRC,
                    p2pid: this.store.p2pId,
                    eventElapse: Math.floor(performance.now() - t),
                    preSsrc: this._p2pChannel.isPreSubScribe(e.user._videoSSRC)
                  },
                  !0
                );
              }),
              EU.info(
                "[".concat(this._clientId, "] massSubscribe success ").concat(
                  e
                    .map(e => {
                      let { user: t, mediaType: i } = e;
                      return "user: "
                        .concat(null == t ? void 0 : t.uid, ", mediaType: ")
                        .concat(i);
                    })
                    .join("; ")
                )
              ),
              r
            );
          } catch (t) {
            throw (await this._p2pChannel.massUnsubscribeNoLock(e), t);
          }
        } finally {
          n(), s();
        }
      }
      async unsubscribe(e, t, i) {
        if (!(e instanceof BH)) {
          const t = this.remoteUsers.find(t => t.uid === e);
          if (!t)
            throw new AU(zP.INVALID_REMOTE_USER, "user is not in the channel");
          e = t;
        }
        if (t || this.store.useP2P) {
          if ("datachannel" === t) return this._unsubscribeDataChannel(e, i);
        } else await this._unsubscribeDataChannel(e, i);
        if ((t && ZP(t, "mediaType", ["audio", "video"]), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't unsubscribe stream, haven't joined yet!"
          );
        const s = this._users.find(t => t === e);
        if (!s) {
          const t = new AU(
            zP.INVALID_REMOTE_USER,
            "user is not in the channel"
          );
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not unsubscribe ")
              .concat(e.uid, ", user is not in the channel")
          ),
          t);
        }
        EU.info(
          "["
            .concat(this._clientId, "] unsubscribe uid: ")
            .concat(e.uid, ", mediaType: ")
            .concat(t)
        );
        const r = await this._subscribeMutex.lock();
        try {
          if (this.store.useP2P) await this._p2pChannel.unsubscribe(e, t);
          else {
            const i = await this._p2pChannel.unsubscribe(e, t);
            i && (await this._gateway.unsubscribe(i, e.uid)),
              (t && "audio" !== t) || (e._audio_pre_subscribed = !1),
              (t && "video" !== t) || (e._video_pre_subscribed = !1),
              e._is_pre_created && Lk(this._users, e),
              EU.info(
                "["
                  .concat(this._clientId, "] unsubscribe success uid: ")
                  .concat(e.uid, ", mediaType: ")
                  .concat(t)
              );
          }
        } catch (t) {
          if (t.code === zP.DISCONNECT_P2P)
            return void EU.warning(
              "disconnecting p2p, abort unsubscribe request."
            );
          throw (EU.error(
            "["
              .concat(this._clientId, "] unsubscribe user ")
              .concat(e.uid, " error"),
            t.toString()
          ),
          t);
        } finally {
          r();
        }
      }
      async _unsubscribeDataChannel(e, t) {
        if ((t && ek(t, "id", 0, 65535, !0), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't unsubscribe datachannel, haven't joined yet!"
          );
        const i = this._users.find(t => t === e);
        if (!i) {
          const t = new AU(
            zP.INVALID_REMOTE_USER,
            "user is not in the channel"
          );
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not unsubscribe ")
              .concat(e.uid, ", user is not in the channel")
          ),
          t);
        }
        let s;
        if ("number" == typeof t) {
          const i = e._dataChannels.find(e => e.id === t);
          i && (s = [i]);
        } else s = e._dataChannels;
        if (void 0 === s) {
          const i = new AU(zP.REMOTE_USER_IS_NOT_PUBLISHED);
          throw (EU.error(
            "["
              .concat(this._clientId, "] can not unsubscribe ")
              .concat(e.uid, " with channelId ")
              .concat(t, ", remote datachannel is not published")
          ),
          i);
        }
        EU.info(
          "["
            .concat(this._clientId, "] unsubscribe uid: ")
            .concat(e.uid, ", mediaType: datachannel, ids: ")
            .concat(s.map(e => e.id))
        );
        try {
          const t = await this._p2pChannel.unsubscribeDataChannel(e, s);
          t && (await this._gateway.unsubscribeDataChannel(t, e.uid)),
            EU.info(
              "["
                .concat(
                  this._clientId,
                  "] unsubscribe datachannel success uid: "
                )
                .concat(e.uid, ", mediaType: datachannel, ids: ")
                .concat(t)
            );
        } catch (t) {
          if (t.code === zP.DISCONNECT_P2P)
            return void EU.warning(
              "disconnecting p2p, abort unsubscribe request."
            );
          throw (EU.error(
            "["
              .concat(this._clientId, "] unsubscribe user ")
              .concat(e.uid, " error"),
            t.toString()
          ),
          t);
        }
      }
      async massUnsubscribe(e) {
        if ((sk(e, "unsubscribeList"), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't unsubscribeAll stream, haven't joined yet!"
          );
        EU.info(
          "[".concat(this._clientId, "] start massUnsubscribe ").concat(
            e
              .map(e => {
                let { user: t, mediaType: i } = e;
                return "user: "
                  .concat(null == t ? void 0 : t.uid, ", mediaType: ")
                  .concat(i, ";");
              })
              .join()
          )
        ),
          (e = [...e]);
        const t = new Map();
        for (let i = e.length - 1; i >= 0; i--) {
          const { user: s, mediaType: r } = e[i];
          if (!s) {
            const e = new AU(
              zP.INVALID_PARAMS,
              "user property does not exist in unsubscribeList item"
            );
            throw (EU.error(
              "[".concat(
                this._clientId,
                "] user property does not exist in unsubscribeList item"
              )
            ),
            e);
          }
          ZP(r, "mediaType", ["video", "audio", void 0]);
          const n = this._users.find(e => e === s);
          if (!n) {
            EU.warning(
              "["
                .concat(this._clientId, "] can not unsubscribe ")
                .concat(s.uid, ", user is not in the channel")
            ),
              e.splice(i, 1);
            continue;
          }
          const a = OG.Video | OG.LwoVideo;
          if (t.has(s)) {
            const n = t.get(s);
            let o;
            switch (r) {
              case "video":
                o = n & a;
                break;
              case "audio":
                o = n & OG.Audio;
                break;
              default:
                o = n & (OG.Audio | a);
            }
            if (o) {
              EU.warning(
                "["
                  .concat(this._clientId, "] repeat massUnsubscribe user:")
                  .concat(s.uid, ",mediaType:")
                  .concat(r, " twice.")
              ),
                e.splice(i, 1);
              continue;
            }
            r
              ? "audio" === r
                ? t.set(s, n | OG.Audio)
                : "video" === r && t.set(s, n | a)
              : t.set(s, n | OG.Audio | a);
          } else
            r
              ? "audio" === r
                ? t.set(s, OG.Audio)
                : "video" === r && t.set(s, a)
              : t.set(s, OG.Audio | a);
        }
        try {
          const t = await this._p2pChannel.massUnsubscribe(e);
          t && (await this._gateway.massUnsubscribe(t)),
            EU.info(
              "[".concat(this._clientId, "] massUnsubscribe success ").concat(
                e
                  .map(e => {
                    let { user: t, mediaType: i } = e;
                    return "user: "
                      .concat(null == t ? void 0 : t.uid, ", mediaType: ")
                      .concat(i, ";");
                  })
                  .join()
              )
            );
        } catch (e) {
          if (e.code === zP.DISCONNECT_P2P)
            return void EU.warning(
              "[".concat(
                this._clientId,
                "] disconnecting p2p, abort unsubscribe request."
              )
            );
          throw (EU.error(
            "[".concat(this._clientId, "] massUnsubscribe error"),
            e.toString()
          ),
          e);
        }
      }
      async setLowStreamParameter(e) {
        !(function(e) {
          if (!e) throw new JP(zP.INVALID_PARAMS);
          rk(e.width) || tk(e.width, "streamParameter.width"),
            rk(e.height) || tk(e.height, "streamParameter.height"),
            rk(e.framerate) || tk(e.framerate, "streamParameter.framerate"),
            rk(e.bitrate) || ek(e.bitrate, "streamParameter.bitrate");
        })(e),
          ((!e.width && e.height) || (e.width && !e.height)) &&
            EU.warning(
              "[".concat(
                this._clientId,
                "] The width and height parameters take effect only when both are set"
              )
            ),
          EU.info(
            "[".concat(this._clientId, "] set low stream parameter to"),
            JSON.stringify(e)
          );
        const t = this._configDistribute.getLowStreamConfigDistribute();
        if (
          (t &&
            t.bitrate &&
            e.bitrate &&
            t.bitrate < e.bitrate &&
            (e.bitrate = t.bitrate),
          (this._lowStreamParameter = e),
          this._isDualStreamEnabled)
        )
          return this._p2pChannel.updateVideoStreamParameter(
            e,
            GG.LocalVideoLowTrack
          );
      }
      async enableDualStream() {
        if (!Lx().supportDualStream)
          throw (yU.streamSwitch(this._sessionId, {
            lts: Date.now(),
            isdual: !0,
            succ: !1
          }),
          new AU(zP.NOT_SUPPORTED, "Your browser is not support dual stream"));
        if (this._isDualStreamEnabled)
          throw new AU(zP.INVALID_OPERATION, "Dual stream is already enabled");
        if (this._p2pChannel.canPublishLowStream())
          try {
            await this._publishLowStream();
          } catch (e) {
            throw (yU.streamSwitch(this._sessionId, {
              lts: Date.now(),
              isdual: !0,
              succ: !1
            }),
            e);
          }
        (this._isDualStreamEnabled = !0),
          yU.streamSwitch(this._sessionId, {
            lts: Date.now(),
            isdual: !0,
            succ: !0
          }),
          EU.info("[".concat(this._clientId, "] enable dual stream"));
      }
      async disableDualStream() {
        if (this._isDualStreamEnabled) {
          if (!this._joinInfo)
            throw new AU(
              zP.INVALID_OPERATION,
              "Can't publish stream, haven't joined yet!"
            );
          if (this._p2pChannel.getLocalMedia(GG.LocalVideoLowTrack))
            try {
              const e = await this._p2pChannel.unpublishLowStream();
              e &&
                (await this._gateway.unpublish(
                  e,
                  this._joinInfo.stringUid || this._joinInfo.uid
                ));
            } catch (e) {
              throw (yU.streamSwitch(this._sessionId, {
                lts: Date.now(),
                isdual: !1,
                succ: !1
              }),
              e);
            }
          (this._isDualStreamEnabled = !1),
            yU.streamSwitch(this._sessionId, {
              lts: Date.now(),
              isdual: !1,
              succ: !0
            }),
            EU.info("[".concat(this._clientId, "] disable dual stream"));
        }
      }
      async setClientRole(e, t) {
        if (
          ((function(e) {
            ZP(e, "role", ["audience", "host"]);
          })(e),
          t && vk(t),
          "rtc" === this.mode || "p2p" === this.mode)
        )
          throw (EU.warning(
            "["
              .concat(this._clientId, "]")
              .concat(this.mode, " mode can not use setClientRole")
          ),
          new AU(
            zP.INVALID_OPERATION,
            "".concat(this.mode, " mode can not use setClientRole")
          ));
        if (t && t.level && "host" === e)
          throw new AU(
            zP.INVALID_OPERATION,
            "host mode can not set audience latency level"
          );
        if ("audience" === e && this._p2pChannel.hasLocalMedia())
          throw new AU(
            zP.INVALID_OPERATION,
            "can not set client role to audience when publishing stream"
          );
        const i = this._config.role;
        this._joinInfo && (this._joinInfo.role = e),
          e !== i && WM("ENABLE_ROLE_SELECT_EDGE")
            ? (this._gateway.updateClientRole(e, t),
              (this._config.role = e),
              this._gateway.reconnect("recover", yk.REGIONAL_DISTRIBUTION))
            : (await this._gateway.setClientRole(e, t),
              (this._config.role = e)),
          EU.info(
            "["
              .concat(this._clientId, "] set client role to ")
              .concat(e, ", level: ")
              .concat(t && t.level)
          );
      }
      async _setClientRoleOptions(e) {
        if ("rtc" === this.mode || "p2p" === this.mode) return;
        if (
          "audience" !== this._config.role ||
          this._p2pChannel.hasLocalMedia()
        )
          return;
        let t = !1;
        try {
          e && vk(e),
            await this._gateway.setClientRole(this._config.role, e),
            (t = !0);
        } catch (e) {
        } finally {
          EU.info(
            "["
              .concat(this._clientId, "] set client role options ")
              .concat(t ? "succeed" : "failed", ", options is ")
              .concat(e)
          );
        }
      }
      getRemoteInboundOffset() {
        var e;
        const t =
          null === (e = this._p2pChannel.getStats()) || void 0 === e
            ? void 0
            : e.audioSend[0];
        if (!t || !t.timestamp) return 0;
        const i = t.timestamp - Date.now();
        return (
          Math.abs(i) > 1e3 + t.rttMs + 100
            ? (this.ntpAlignErrorCount += 1)
            : (this.ntpAlignErrorCount = 0),
          this.ntpAlignErrorCount >= 3 ? i : 0
        );
      }
      getNtpWallTimeInMs() {
        return (
          "visible" === document.visibilityState &&
            (this.remoteInboundOffset = this.getRemoteInboundOffset()),
          this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset
        );
      }
      setProxyServer(e, t) {
        if ((ik(e, "proxyServer"), !t)) {
          if ("DISCONNECTED" !== this.connectionState)
            throw new AU(
              zP.INVALID_OPERATION,
              "Set proxy server before join channel"
            );
          if (
            "disabled" !== this._cloudProxyServerMode ||
            this._useLocalAccessPoint
          )
            throw new AU(
              zP.INVALID_OPERATION,
              "You have already set the proxy"
            );
        }
        (this._proxyServer = e),
          yU.setProxyServer(this._proxyServer),
          EU.setProxyServer(this._proxyServer),
          EU.info(
            "["
              .concat(this._clientId, "] Set proxy server ")
              .concat(t ? "by initialize call" : "", " success.")
          );
      }
      setTurnServer(e, t) {
        if ((Array.isArray(e) || (e = [e]), !t)) {
          if ("DISCONNECTED" !== this.connectionState)
            throw new AU(
              zP.INVALID_OPERATION,
              "Set turn server before join channel"
            );
          if (
            "disabled" !== this._cloudProxyServerMode ||
            this._useLocalAccessPoint
          )
            throw new AU(
              zP.INVALID_OPERATION,
              "You have already set the proxy"
            );
        }
        if (Tk(e))
          return (
            (this._turnServer = { servers: e, mode: "original-manual" }),
            void EU.info(
              "["
                .concat(this._clientId, "] Set original turnserver ")
                .concat(t ? "by initialize call" : "", " success: ")
                .concat(e.map(e => e.urls).join(","), ".")
            )
          );
        e.forEach(e => Sk(e)),
          (this._turnServer = { servers: e, mode: "manual" }),
          EU.info(
            "["
              .concat(this._clientId, "] Set turnserver ")
              .concat(t ? "by initialize call" : "", " success.")
          );
      }
      setLicense(e) {
        if ("DISCONNECTED" !== this.connectionState) {
          throw new AU(
            zP.INVALID_OPERATION,
            "you should set license before join channel"
          );
        }
        if ((ik(e, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e)))
          throw new AU(
            zP.INVALID_PARAMS,
            "license should only contains characters from A-Z a-z 0-9"
          );
        (this._license = e),
          EU.info("[".concat(this._clientId, "] set license success"), e);
      }
      startProxyServer(e) {
        if ("DISCONNECTED" !== this.connectionState)
          throw new AU(
            zP.INVALID_OPERATION,
            "Start proxy server before join channel"
          );
        if (
          this._proxyServer ||
          "manual" === this._turnServer.mode ||
          this._useLocalAccessPoint
        )
          throw new AU(zP.INVALID_OPERATION, "You have already set the proxy");
        const t = [3, 4, 5];
        let i;
        switch ((void 0 === e && (e = 3), e)) {
          case 1:
          case 2:
            throw new AU(
              zP.NOT_SUPPORTED,
              "proxy mode 1/2 has been deprecated and not supported."
            );
          case 3:
            i = "proxy3";
            break;
          case 4:
            i = "proxy4";
            break;
          case 5:
            i = "proxy5";
            break;
          default:
            throw new AU(
              zP.INVALID_PARAMS,
              "proxy server mode must be ".concat(t.join("|"))
            );
        }
        (this._cloudProxyServerMode = i),
          (this.store.cloudProxyServerMode = i),
          EU.info(
            "[".concat(this._clientId, "] set cloud proxy server mode to"),
            this._cloudProxyServerMode
          );
      }
      stopProxyServer() {
        if ("DISCONNECTED" !== this.connectionState)
          throw new AU(
            zP.INVALID_OPERATION,
            "Stop proxy server after leave channel"
          );
        yU.setProxyServer(),
          EU.setProxyServer(),
          (this._cloudProxyServerMode = "disabled"),
          (this.store.cloudProxyServerMode = "disabled"),
          EU.info(
            "[".concat(this._clientId, "] set cloud proxy server mode to"),
            this._cloudProxyServerMode
          ),
          (this._proxyServer = void 0),
          (this._turnServer = { mode: "auto", servers: [] });
      }
      setLocalAccessPointsV2(e) {
        if (!e.accessPoints)
          throw new AU(zP.INVALID_PARAMS, "accessPoints is required.");
        sk(e.accessPoints.serverList, "accessPoints.serverList"),
          ik(e.accessPoints.domain, "accessPoints.domain");
        const t = (e, t) => {
          ek(e, t, 0, 65535, !0);
        };
        let i = 443;
        if (
          (e.accessPoints.port &&
            (t(e.accessPoints.port, "accessPoints.port"),
            (i = e.accessPoints.port)),
          this._proxyServer || "disabled" !== this._cloudProxyServerMode)
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "set local access point failed, You have already set the cloud proxy"
          );
        WM("CLOSE_AFB_FOR_LOCAL_AP") &&
          (KM("JOIN_WITH_FALLBACK_SIGNAL_PROXY", !1),
          KM("JOIN_WITH_FALLBACK_MEDIA_PROXY", !1));
        const s = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,
          r = e.accessPoints.domain,
          n = e.accessPoints.serverList.map(e =>
            s.test(e) ? "".concat(e.replace(/\./g, "-"), ".").concat(r) : e
          ),
          a = n.map(e => "".concat(e, ":").concat(i));
        (this._useLocalAccessPoint = !0),
          (this._setLocalAPVersion = 2),
          KM("WEBCS_DOMAIN", a),
          KM("WEBCS_DOMAIN_BACKUP_LIST", a),
          KM("GATEWAY_DOMAINS", [r]),
          e.report &&
          e.report.hostname &&
          Array.isArray(e.report.hostname) &&
          e.report.hostname.length
            ? (sk(e.report.hostname, "report.hostname"),
              KM("EVENT_REPORT_DOMAIN", e.report.hostname[0]),
              KM(
                "EVENT_REPORT_BACKUP_DOMAIN",
                e.report.hostname[1] || e.report.hostname[0]
              ))
            : (KM("EVENT_REPORT_DOMAIN", n[0]),
              KM("EVENT_REPORT_BACKUP_DOMAIN", n[1] || n[0]));
        let o = 6443;
        e.report &&
          e.report.port &&
          (t(e.report.port, "report.port"), (o = e.report.port)),
          KM("STATS_COLLECTOR_PORT", o),
          e.report
            ? KM("ENABLE_EVENT_REPORT", !0)
            : KM("ENABLE_EVENT_REPORT", !1);
        let c = "";
        e.log &&
        e.log.hostname &&
        Array.isArray(e.log.hostname) &&
        e.log.hostname.length
          ? (sk(e.log.hostname, "log.hostname"), (c = e.log.hostname[0]))
          : (c = n[0]);
        let d = 6444;
        e.log && e.log.port && (t(e.log.port, "log.port"), (d = e.log.port)),
          KM("LOG_UPLOAD_SERVER", "".concat(c, ":").concat(d));
        let l = [];
        e.cds &&
        e.cds.hostname &&
        Array.isArray(e.cds.hostname) &&
        e.cds.hostname.length
          ? (sk(e.cds.hostname, "cds.hostname"), (l = e.cds.hostname))
          : (l = n);
        let h = 443;
        e.cds && e.cds.port && (t(e.cds.port, "cds.port"), (h = e.cds.port)),
          KM(
            "CDS_AP",
            l.map(e => "".concat(e, ":").concat(h))
          ),
          e.cds
            ? KM("ENABLE_CONFIG_DISTRIBUTE", !0)
            : KM("ENABLE_CONFIG_DISTRIBUTE", !1),
          EU.info("set local access point v2 success");
      }
      setLocalAccessPoints(e, t) {
        if (
          (sk(e, "serverList"),
          ik(t, "domain"),
          this._proxyServer || "disabled" !== this._cloudProxyServerMode)
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "set local access point failed, You have already set the cloud proxy"
          );
        const i = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
        (e = e.map(e =>
          i.test(e) ? "".concat(e.replace(/\./g, "-"), ".").concat(t) : e
        )),
          (this._useLocalAccessPoint = !0),
          (this._setLocalAPVersion = 1),
          KM("WEBCS_DOMAIN", e),
          KM("WEBCS_DOMAIN_BACKUP_LIST", e),
          KM("GATEWAY_DOMAINS", [t]),
          KM("EVENT_REPORT_DOMAIN", e[0]),
          KM("EVENT_REPORT_BACKUP_DOMAIN", e[1] || e[0]),
          KM("LOG_UPLOAD_SERVER", "".concat(e[0], ":6444")),
          EU.info(
            "[".concat(this._clientId, "] set local access point success")
          );
      }
      async setRemoteDefaultVideoStreamType(e) {
        if (
          (ZP(e, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]),
          (this._remoteDefaultVideoStreamType = e),
          this._joinInfo)
        )
          try {
            await this._gateway.setDefaultRemoteVideoStreamType(e),
              (this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType);
          } catch (e) {
            throw (EU.error(
              "[".concat(
                this._clientId,
                "] set default remote video stream type error"
              ),
              e.toString()
            ),
            e);
          }
        else
          EU.debug(
            "["
              .concat(
                this._clientId,
                "] haven't joined yet, cache remoteDefaultVideoStreamType "
              )
              .concat(e)
          );
      }
      async setRemoteVideoStreamType(e, t) {
        ZP(t, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]);
        try {
          await this._gateway.setRemoteVideoStreamType(e, t),
            setTimeout(() => {
              const t = this._users.find(t => t.uid === e);
              t &&
                t.videoTrack &&
                t.videoTrack.updateMediaStreamTrackResolution();
            }, 2e3);
        } catch (e) {
          throw (EU.error(
            "[".concat(this._clientId, "] set remote video stream type error"),
            e.toString()
          ),
          e);
        }
        EU.info(
          "["
            .concat(this._clientId, "] set remote ")
            .concat(e, " video stream type to ")
            .concat(t)
        ),
          this._remoteStreamTypeCacheMap.set(e, t);
      }
      async setStreamFallbackOption(e, t) {
        ZP(t, "fallbackType", [0, 1, 2, 3, 4, 5, 6, 7, 8]);
        try {
          await this._gateway.setStreamFallbackOption(e, t);
        } catch (e) {
          throw (EU.error(
            "[".concat(this._clientId, "] set stream fallback option"),
            e.toString()
          ),
          e);
        }
        EU.info(
          "["
            .concat(this._clientId, "] set remote ")
            .concat(e, " stream fallback type to ")
            .concat(t)
        ),
          this._streamFallbackTypeCacheMap.set(e, t);
      }
      setEncryptionConfig(e, t, i, s) {
        !(function(e) {
          ZP(e, "encryptionMode", [
            "aes-128-xts",
            "aes-256-xts",
            "aes-128-ecb",
            "sm4-128-ecb",
            "aes-128-gcm",
            "aes-256-gcm",
            "aes-128-gcm2",
            "aes-256-gcm2",
            "none"
          ]);
        })(e),
          ik(t, "secret");
        const r = ["aes-128-gcm2", "aes-256-gcm2"];
        if (r.includes(e)) {
          if (!i || !(i instanceof Uint8Array && 32 === i.length))
            throw new AU(
              zP.INVALID_PARAMS,
              "salt must be an Uint8Array and exactly equal to 32 bytes"
            );
        } else if (i)
          throw new AU(
            zP.INVALID_PARAMS,
            "current encrypt mode does not need salt"
          );
        if (s) {
          if ((QP(s, "encryptDataStream"), !r.includes(e)))
            throw new AU(
              zP.INVALID_PARAMS,
              "current encrypt mode does not support data stream"
            );
          this._encryptDataStream = !0;
        }
        new RegExp(
          "^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\"|{}\\[\\]])(?=.{8,})"
        ).test(t) ||
          EU.warning(
            "The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "
          ),
          (this._encryptionMode = e),
          (this._encryptionSecret = t),
          i && (this._encryptionSalt = Bk(i));
      }
      async renewToken(e) {
        if ((ik(e, "token", 1, 2047), !this._key || !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "renewToken should not be called before user join"
          );
        const t = this._key;
        (this._key = e), this._joinInfo && (this._joinInfo.token = e);
        const i = await this._renewTokenMutex.lock();
        try {
          if (WM("USE_NEW_TOKEN")) {
            EU.debug(
              "[".concat(
                this._clientId,
                "] start renew token with ticket from unilbs"
              )
            );
            const t = await LH(
              this._joinInfo,
              this._axiosCancelSource.token,
              this._config.httpRetryConfig || nM
            );
            EU.debug(
              "[".concat(this._clientId, "] get ticket from unilbs success")
            ),
              await this._gateway.renewToken({ token: e, ticket: t });
          } else
            EU.debug(
              "[".concat(this._clientId, "] start renew token without ticket")
            ),
              await this._gateway.renewToken({ token: e });
          EU.debug("[".concat(this._clientId, "] renewToken success"));
        } catch (e) {
          throw ((this._key = t),
          (this._joinInfo.token = t),
          EU.error(
            "[".concat(this._clientId, "] renewToken failed"),
            e.toString()
          ),
          e);
        } finally {
          i();
        }
      }
      enableAudioVolumeIndicator() {
        this._audioVolumeIndicationInterval
          ? EU.warning("you have already enabled audio volume indicator!")
          : (this._audioVolumeIndicationInterval = window.setInterval(() => {
              const e = this._p2pChannel.getAudioLevels();
              this.safeEmit(Rk.VOLUME_INDICATOR, e);
            }, WM("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3));
      }
      getRTCStats() {
        const e = this._statsCollector.getRTCStats(),
          t = this._gateway.getInChannelInfo();
        return (e.Duration = Math.round(t.duration / 1e3)), e;
      }
      async startLiveStreaming(e, t) {
        if (!t) {
          if ("h264" !== this.codec)
            throw new AU(
              zP.LIVE_STREAMING_INVALID_RAW_STREAM,
              "raw streaming is only support h264"
            );
          if (!this._p2pChannel.hasLocalMedia())
            throw new AU(
              zP.LIVE_STREAMING_INVALID_RAW_STREAM,
              "can not find stream to raw streaming"
            );
        }
        if (
          (this._liveRawStreamingClient &&
            this._liveRawStreamingClient.hasUrl(e)) ||
          (this._liveTranscodeStreamingClient &&
            this._liveTranscodeStreamingClient.hasUrl(e))
        )
          throw new AU(zP.LIVE_STREAMING_TASK_CONFLICT);
        const i = t ? vG.TRANSCODE : vG.RAW;
        return this._createLiveStreamingClient(i).startLiveStreamingTask(e, i);
      }
      setLiveTranscoding(e) {
        return this._createLiveStreamingClient(
          vG.TRANSCODE
        ).setTranscodingConfig(e);
      }
      async stopLiveStreaming(e) {
        const t = [
          this._liveRawStreamingClient,
          this._liveTranscodeStreamingClient
        ].filter(t => t && t.hasUrl(e));
        if (!t.length)
          throw new AU(
            zP.INVALID_PARAMS,
            "can not find live streaming url to stop"
          );
        await Promise.all(t.map(t => t && t.stopLiveStreamingTask(e)));
      }
      async startChannelMediaRelay(e) {
        FH(e);
        const t = this._createChannelMediaRelayClient();
        await t.startChannelMediaRelay(e);
      }
      async updateChannelMediaRelay(e) {
        FH(e);
        const t = this._createChannelMediaRelayClient();
        await t.updateChannelMediaRelay(e);
      }
      async stopChannelMediaRelay() {
        const e = this._createChannelMediaRelayClient();
        await e.stopChannelMediaRelay(),
          this._statsCollector.onStatsChanged &&
            (this._statsCollector.onStatsChanged = void 0);
      }
      sendAudioMetadata(e) {
        this._p2pChannel instanceof MK && this._p2pChannel.addAudioMetadata(e);
      }
      async sendStreamMessage(e) {
        let t =
          !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (!this._joinInfo)
          throw new AU(
            zP.INVALID_OPERATION,
            "can not send data stream, not joined"
          );
        if (
          (("string" == typeof e || e instanceof Uint8Array) &&
            (e = { payload: e }),
          "string" == typeof e.payload)
        ) {
          const t = new TextEncoder();
          e.payload = t.encode(e.payload);
        }
        let i = !1;
        this._encryptDataStream &&
          this._encryptDataStreamIv &&
          this._encryptDataStreamKey &&
          window.crypto.subtle &&
          ["aes-128-gcm2", "aes-256-gcm2"].includes(this._encryptionMode) &&
          ((i = !0),
          (e.payload = await (async function(e, t, i) {
            const s = Array.from(i).reduce((e, t) => e + t, 0),
              r = { serverTs: 0, seq: tU++, length: i.length, checkSum: s },
              n = new Uint8Array(Zk(s, 2)),
              a = new ArrayBuffer(eU),
              o = new DataView(a);
            o.setUint32(0, r.serverTs),
              o.setUint16(4, r.seq),
              o.setUint16(6, r.length),
              o.setUint16(8, r.checkSum);
            const c = 16 - (i.length % 16);
            i = Gk(i, new Uint8Array(c));
            const d = await window.crypto.subtle.encrypt(
              { name: "AES-GCM", iv: e, tagLength: JM, additionalData: n },
              t,
              i
            );
            return Gk(new Uint8Array(a), new Uint8Array(d));
          })(
            this._encryptDataStreamIv,
            this._encryptDataStreamKey,
            e.payload
          )));
        if (new Blob([e.payload]).size > 1024)
          throw new AU(
            zP.INVALID_PARAMS,
            i
              ? "encrypted stream message out of range."
              : "stream message out of range."
          );
        return this._gateway.signal.request(
          fG.DATA_STREAM,
          {
            payload: Bk(e.payload),
            syncWithAudio: e.syncWithAudio,
            sendTs: Date.now() - xK
          },
          !t
        );
      }
      sendMetadata(e) {
        if (!this._joinInfo)
          throw new AU(
            zP.INVALID_OPERATION,
            "can not send metadata, not joined"
          );
        if (new Blob([e]).size > 1024) throw new AU(zP.METADATA_OUT_OF_RANGE);
        return this._gateway.signal.request(fG.SEND_METADATA, {
          session_id: this._joinInfo.sid,
          metadata: Bk(e)
        });
      }
      async sendCustomReportMessage(e) {
        if ((Array.isArray(e) || (e = [e]), e.forEach(gU), !this._joinInfo))
          throw new AU(
            zP.INVALID_OPERATION,
            "can not send custom report, not joined"
          );
        await yU.sendCustomReportMessage(this._joinInfo.sid, e);
      }
      getLocalAudioStats() {
        return this._statsCollector.getLocalAudioTrackStats();
      }
      getRemoteAudioStats() {
        return this._statsCollector.getRemoteAudioTrackStats();
      }
      getLocalVideoStats() {
        return this._statsCollector.getLocalVideoTrackStats();
      }
      getRemoteVideoStats() {
        return this._statsCollector.getRemoteVideoTrackStats();
      }
      getRemoteNetworkQuality() {
        return this._statsCollector.getRemoteNetworkQualityStats();
      }
      getNetworkQuality() {
        return this._statsCollector.getNetworkQuality();
      }
      async pickSVCLayer(e, t) {
        ZP(t.spatialLayer, "spatialLayer", [0, 1, 2, 3]),
          ZP(t.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
        try {
          await this._gateway.pickSVCLayer(e, t);
        } catch (e) {
          throw (EU.error(
            "[".concat(this._clientId, "] pick SVC layer failed"),
            e.toString()
          ),
          e);
        }
      }
      async setRTMConfig(e) {
        const { apRTM: t = !1, rtmFlag: i } = e;
        if (
          (QP(t, "apRTM"),
          ek(i, "rtmFlag", 0),
          (this._rtmConfig.apRTM = t),
          (this._rtmConfig.rtmFlag = i),
          EU.debug(
            "["
              .concat(this._clientId, "] setRTMconfig ")
              .concat(JSON.stringify(e), " in ")
              .concat(this.connectionState, " state")
          ),
          ("CONNECTED" === this.connectionState ||
            "RECONNECTING" === this.connectionState) &&
            this._joinInfo)
        )
          return (
            (this._joinInfo.apRTM = t),
            (this._joinInfo.rtmFlag = i),
            this._gateway.setRTM2Flag(i)
          );
      }
      _reset() {
        if (
          (EU.debug("[".concat(this._clientId, "] reset client")),
          (function(e) {
            const t = $V.indexOf(e);
            -1 !== t && $V.splice(t, 1);
          })(this._clientId),
          (this.store.hasStartJoinChannel = !1),
          (this.store.isABTestSuccess = !1),
          this._axiosCancelSource.cancel(),
          (this._axiosCancelSource = lP.CancelToken.source()),
          (this._streamFallbackTypeCacheMap = new Map()),
          (this._remoteStreamTypeCacheMap = new Map()),
          this._configDistribute.stopGetConfigDistribute(),
          this._joinInfo && rW(this._joinInfo),
          (this._joinInfo = void 0),
          (this._proxyServer = void 0),
          (this._defaultStreamFallbackType = void 0),
          this._sessionId && yU.removeSid(this._sessionId),
          (this._sessionId = null),
          (this.store.sessionId = null),
          this._statsCollector.reset(),
          (this._key = void 0),
          (this._appId = void 0),
          (this._uid = void 0),
          (this.store.uid = void 0),
          (this._channelName = void 0),
          (this._encryptionMode = "none"),
          (this._encryptionSecret = null),
          (this._encryptionSalt = null),
          (this._encryptDataStreamKey = null),
          (this._encryptDataStreamIv = null),
          (this._pendingPublishedUsers = []),
          this._users.forEach(e => {
            e._audioTrack && e._audioTrack._destroy(),
              e._videoTrack && e._videoTrack._destroy(),
              e._dataChannels &&
                (e._dataChannels.forEach(e => e._close()),
                (e._dataChannels.length = 0));
          }),
          (this._users = []),
          this._audioVolumeIndicationInterval &&
            (window.clearInterval(this._audioVolumeIndicationInterval),
            (this._audioVolumeIndicationInterval = void 0)),
          "fallback" === this._cloudProxyServerMode &&
            ((this._cloudProxyServerMode = "disabled"),
            (this.store.cloudProxyServerMode = "disabled")),
          this._p2pChannel.reset(),
          (this._publishMutex = new sM("client-publish", this._clientId)),
          (this._subscribeMutex = new sM("client-subscribe", this._clientId)),
          this._networkQualityInterval &&
            (window.clearInterval(this._networkQualityInterval),
            (this._networkQualityInterval = void 0)),
          this._liveRawStreamingClient &&
            (this._liveRawStreamingClient.terminate(),
            this._liveRawStreamingClient.removeAllListeners(),
            (this._liveRawStreamingClient = void 0)),
          this._liveTranscodeStreamingClient &&
            (this._liveTranscodeStreamingClient.terminate(),
            this._liveTranscodeStreamingClient.removeAllListeners(),
            (this._liveTranscodeStreamingClient = void 0)),
          this._channelMediaRelayClient &&
            (this._channelMediaRelayClient.dispose(),
            (this._channelMediaRelayClient = void 0)),
          this._inspect)
        )
          try {
            this._inspect.close(), (this._inspect = void 0);
          } catch (e) {}
        if (this._moderation)
          try {
            this.setImageModeration(!1);
          } catch (e) {}
      }
      _startSession(e, t) {
        var i;
        const s = e || $k();
        e
          ? EU.debug("[".concat(this._clientId, "] new Session ").concat(s))
          : EU.debug(
              "["
                .concat(this._clientId, "] renewSession ")
                .concat(this._sessionId, " => ")
                .concat(s)
            );
        const r = e ? "" : this._sessionId || "";
        (this._sessionId = s), (this.store.sessionId = s), yU.addSid(s);
        const n = {
          lts: new Date().getTime(),
          mode: this.mode,
          buildFormat: 3,
          stringUid:
            (null == t ? void 0 : t.stringUid) ||
            (null === (i = this._joinInfo) || void 0 === i
              ? void 0
              : i.stringUid),
          channelProfile: "live" === this.mode ? 1 : 0,
          channelMode: 0,
          isABTestSuccess: Number(this._configDistribute.isSuccess),
          lsid: r,
          clientRole: "audience" === this.role ? 2 : 1
        };
        yU.sessionInit(
          this._sessionId,
          rG({ cname: t.channel, appid: t.appId }, n)
        ),
          this._joinInfo && (this._joinInfo.sid = s),
          this._gateway.joinInfo && (this._gateway.joinInfo.sid = s);
      }
      async _publishHighStream(e) {
        if (!this._joinInfo || void 0 === this._uid)
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't publish stream, haven't joined yet!"
          );
        if (
          "CONNECTED" !== this.connectionState &&
          "RECONNECTING" !== this.connectionState
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "can not publish stream in ".concat(this.connectionState, " state")
          );
        if (
          "auto" === this._turnServer.mode &&
          WM("FORCE_TURN") &&
          !WM("TURN_ENABLE_TCP") &&
          !WM("TURN_ENABLE_UDP")
        )
          throw new AU(
            zP.UNEXPECTED_ERROR,
            "force TURN With No TURN Configuration"
          );
        EU.debug("[".concat(this._clientId, "] publish high stream"));
        try {
          const i = await this._p2pChannel.publish(
            e,
            this._isDualStreamEnabled,
            this._lowStreamParameter
          );
          if (this.store.useP2P) {
            const e = (await i.next()).value;
            if (e) {
              try {
                await this._gateway.sendExtensionMessage(zG.PUBLISH, e, !0);
              } catch (e) {
                throw (i.throw(e), e);
              }
              await i.next();
            }
            this._p2pChannel.reportPublishEvent(!0, null);
          } else {
            const s = (await i.next()).value;
            if (s) {
              var t;
              let e;
              try {
                e = await this._gateway.publish(this._uid, s, !0);
              } catch (e) {
                if (e.code !== zP.DISCONNECT_P2P) throw (i.throw(e), e);
              }
              await i.next(
                (null === (t = e) || void 0 === t ? void 0 : t.ortc) || []
              );
            }
            this._p2pChannel.reportPublishEvent(!0, null);
            for (const t of e)
              t instanceof AV &&
                t._encoderConfig &&
                this._gateway.setVideoProfile(t._encoderConfig).catch(e => {
                  EU.debug(
                    "[".concat(
                      this._clientId,
                      "] stop setVideoProfile, because websocket is closed"
                    )
                  );
                }),
                (!t.muted && t.enabled) ||
                  (await this._p2pChannel.muteLocalTrack(t));
          }
        } catch (t) {
          if (
            (this._p2pChannel.reportPublishEvent(
              !1,
              null == t ? void 0 : t.code,
              e
            ),
            (null == t ? void 0 : t.code) === zP.WS_ABORT)
          )
            return;
          throw t;
        }
      }
      async _publishLowStream() {
        if (!this._joinInfo || void 0 === this._uid)
          throw new AU(
            zP.INVALID_OPERATION,
            "Can't publish stream, haven't joined yet!"
          );
        if (
          "CONNECTED" !== this.connectionState &&
          "RECONNECTING" !== this.connectionState
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "can not publish stream in ".concat(this.connectionState, " state")
          );
        EU.debug("[".concat(this._clientId, "] publish low stream"));
        const e = this._configDistribute.getLowStreamConfigDistribute();
        e &&
          e.bitrate &&
          (this._lowStreamParameter ||
            (this._lowStreamParameter = {
              width: 160,
              height: 120,
              framerate: 15,
              bitrate: 50
            }),
          this._lowStreamParameter &&
            this._lowStreamParameter.bitrate &&
            e.bitrate < this._lowStreamParameter.bitrate &&
            (this._lowStreamParameter.bitrate = e.bitrate));
        try {
          const e = await this._p2pChannel.publishLowStream(
              this._lowStreamParameter
            ),
            i = (await e.next()).value;
          if (i) {
            var t;
            let s;
            try {
              s = await this._gateway.publish(this._uid, i, !0);
            } catch (t) {
              if (t.code !== zP.DISCONNECT_P2P) throw (e.throw(t), t);
            }
            e.next((null === (t = s) || void 0 === t ? void 0 : t.ortc) || []),
              this._p2pChannel.reportPublishEvent(!0, null, void 0, !0);
          }
        } catch (e) {
          if (
            (this._p2pChannel.reportPublishEvent(
              !1,
              null == e ? void 0 : e.code,
              void 0,
              !0
            ),
            (null == e ? void 0 : e.code) === zP.WS_ABORT)
          )
            return;
          throw e;
        }
      }
      _createLiveStreamingClient(e) {
        const t = () => {
          if (!this._joinInfo || !this._appId) {
            return new AU(
              zP.INVALID_OPERATION,
              "can not create live streaming client, please join channel first"
            ).throw();
          }
          const e =
            ((t = {
              joinInfo: this._joinInfo,
              appId: this._appId,
              websocketRetryConfig: this._config.websocketRetryConfig,
              httpRetryConfig: this._config.httpRetryConfig
            }),
            Xj("LiveStreaming").create(t));
          var t;
          return (
            (e.onLiveStreamError = (e, t) => {
              yU
                .reportApiInvoke(this._sessionId, {
                  name: Ek.ON_LIVE_STREAM_ERROR,
                  options: [e, t],
                  tag: mk.TRACER
                })
                .onSuccess(),
                this.safeEmit(Rk.LIVE_STREAMING_ERROR, e, t);
            }),
            (e.onLiveStreamWarning = (e, t) => {
              yU
                .reportApiInvoke(this._sessionId, {
                  name: Ek.ON_LIVE_STREAM_WARNING,
                  options: [e, t],
                  tag: mk.TRACER
                })
                .onSuccess(),
                this.safeEmit(Rk.LIVE_STREAMING_WARNING, e, t);
            }),
            e.on(RG.REQUEST_WORKER_MANAGER_LIST, (e, t, i) => {
              if (!this._joinInfo)
                return i(
                  new AU(
                    zP.INVALID_OPERATION,
                    "can not find join info to get worker manager"
                  )
                );
              (async function(e, t, i, s) {
                const r = WM("UAP_AP")
                  .slice(0, WM("AJAX_REQUEST_CONCURRENT"))
                  .map(e =>
                    t.proxyServer
                      ? "https://"
                          .concat(t.proxyServer, "/ap/?url=")
                          .concat(e + "/api/v1?action=uap")
                      : "https://".concat(e, "/api/v1?action=uap")
                  );
                return await pH(r, e, t, i, s);
              })(e, this._joinInfo, this._axiosCancelSource.token, nM)
                .then(t)
                .catch(i);
            }),
            e
          );
        };
        return e === vG.RAW
          ? ((this._liveRawStreamingClient =
              this._liveRawStreamingClient || t()),
            this._liveRawStreamingClient)
          : ((this._liveTranscodeStreamingClient =
              this._liveTranscodeStreamingClient || t()),
            this._liveTranscodeStreamingClient);
      }
      _createChannelMediaRelayClient() {
        if (!this._joinInfo) {
          return new AU(
            zP.INVALID_OPERATION,
            "can not create channel media relay client, please join channel first"
          ).throw();
        }
        if (!this._channelMediaRelayClient) {
          const {
              sendResolutionWidth: t,
              sendResolutionHeight: i
            } = this.getLocalVideoStats(),
            s =
              ((e = {
                joinInfo: this._joinInfo,
                clientId: this._clientId,
                websocketRetryConfig: this._config.websocketRetryConfig,
                httpRetryConfig: this._config.httpRetryConfig,
                resolution: { width: t, height: i }
              }),
              Xj("ChannelMediaRelay").create(e));
          s.on("state", e => {
            e === AG.RELAY_STATE_FAILURE && s && s.dispose(),
              this.safeEmit(Rk.CHANNEL_MEDIA_RELAY_STATE, e);
          }),
            s.on("event", e => {
              this.safeEmit(Rk.CHANNEL_MEDIA_RELAY_EVENT, e);
            }),
            (this._channelMediaRelayClient = s),
            (this._statsCollector.onStatsChanged = (e, t) => {
              var i;
              "resolution" === e &&
                (null === (i = this._channelMediaRelayClient) ||
                  void 0 === i ||
                  i.setVideoProfile(t));
            });
        }
        var e;
        return this._channelMediaRelayClient;
      }
      _handleUpdateDataChannel(e, t) {
        const { added: i, deleted: s } = e;
        if (t) {
          const e = [];
          this._users.forEach(t => {
            t._dataChannels.forEach(s => {
              i.every(e => e.uid !== t._uintid || e.stream_id !== s.id) &&
                e.push({
                  uid: t._uintid,
                  stream_id: s.id,
                  ordered: s.ordered,
                  max_retrans_times: s.maxRetransmits,
                  metadata: s.metadata
                });
            });
          }),
            e.length > 0 &&
              this._handleUpdateDataChannel({ added: [], deleted: e });
        }
        Array.isArray(i) &&
          i.length > 0 &&
          i.forEach(e => {
            const {
                uid: i,
                stream_id: s,
                ordered: r,
                max_retrans_times: n,
                metadata: a
              } = e,
              o = this._users.find(e => e._uintid === i);
            if (!o)
              return void EU.error(
                "[".concat(
                  this._clientId,
                  "] can not find target user!(on_add_data_channel)"
                )
              );
            EU.debug(
              "["
                .concat(this._clientId, "] data_channel added with uid ")
                .concat(i)
            ),
              o._uintid || (o._uintid = i);
            if (
              !(-1 !== o._dataChannels.findIndex(t => t.id === e.stream_id))
            ) {
              const e = { id: s, ordered: !!r, maxRetransmits: n, metadata: a },
                i = (function(e) {
                  return zj(e, !0);
                })(e);
              o._dataChannels.push(i),
                EU.info(
                  "["
                    .concat(this._clientId, "] remote user ")
                    .concat(o.uid, " published datachannel")
                ),
                t || this.safeEmit(Rk.USER_PUBLISHED, o, "datachannel", e);
            }
            this._p2pChannel.hasPendingRemoteDataChannel(o, e.stream_id) &&
              (EU.debug(
                "["
                  .concat(this._clientId, "] resubscribe datachannel for user ")
                  .concat(o.uid, " after reconnect.")
              ),
              this._subscribeDataChannel(o, e.stream_id).catch(e => {
                EU.error(
                  "[".concat(this._clientId, "] resubscribe datachannel error"),
                  e.toString()
                );
              }));
          }),
          t &&
            (this.safeEmit(Rk.PUBLISHED_USER_LIST, this._pendingPublishedUsers),
            (this._pendingPublishedUsers = [])),
          Array.isArray(s) &&
            s.length > 0 &&
            s.forEach(e => {
              const { uid: t, stream_id: i } = e,
                s = this._users.find(e => e._uintid === t);
              if (!s)
                return void EU.error(
                  "[".concat(
                    this._clientId,
                    "] can not find target user!(on_delete_data_channel)"
                  )
                );
              const r = s._dataChannels.find(t => t.id === e.stream_id);
              r &&
                (EU.debug(
                  "["
                    .concat(this._clientId, "] data_stream delete with uid ")
                    .concat(t)
                ),
                this._p2pChannel.unsubscribeDataChannel(s, [r]).then(e => {
                  if (
                    ((s._dataChannels = s._dataChannels.filter(e => e !== r)),
                    e)
                  )
                    return this._gateway.unsubscribeDataChannel(e, s.uid);
                }),
                EU.info(
                  "["
                    .concat(this._clientId, "] remote user ")
                    .concat(t, " unpublished datachannel ,id:")
                    .concat(r.id)
                ),
                this.safeEmit(
                  Rk.USER_UNPUBLISHED,
                  s,
                  "datachannel",
                  r._config
                ));
            });
      }
      _handleRemoveDataChannels(e) {
        const t = this._users.find(t => t.uid === e.uid);
        if (t) {
          if (void 0 !== t._dataChannels && t._dataChannels.length > 0) {
            EU.debug(
              "["
                .concat(this._clientId, "] datachannel removed with uid ")
                .concat(e.uid)
            );
            const i = () => {
              EU.info(
                "["
                  .concat(this._clientId, "] remote user ")
                  .concat(t.uid, " unpublished datachannel")
              ),
                t._dataChannels.forEach(e => {
                  this.safeEmit(
                    Rk.USER_UNPUBLISHED,
                    t,
                    "datachannel",
                    e._config
                  );
                });
            };
            this._p2pChannel
              .unsubscribeDataChannel(t, t._dataChannels)
              .then(e => {
                if (e) return this._gateway.unsubscribeDataChannel(e, t.uid);
              }),
              i();
          }
        } else
          EU.warning(
            "[".concat(
              this._clientId,
              "] can not find target user!(on_remove_datachannel)"
            )
          );
      }
      _handleGatewayEvents() {
        this._gateway.on(CG.UPDATE_GATEWAY_CONFIG, () => {
          !(function() {
            let e;
            try {
              e = window.localStorage.getItem("websdk_ng_global_parameter");
            } catch (e) {
              return void EU.error("Error loading sdk config", e.message);
            }
            if (e)
              try {
                const t = JSON.parse(window.atob(e)),
                  i = Date.now();
                Object.keys(t).forEach(e => {
                  const { value: s, type: r, expires: n } = t[e];
                  (n && n <= i) ||
                    r ||
                    XV() ||
                    !Object.prototype.hasOwnProperty.call(BM, e) ||
                    (($M[e] = s),
                    (HM[e] = s),
                    EU.debug(
                      "Update gateway parameters from config distribute",
                      e,
                      s
                    ));
                });
              } catch (e) {
                EU.error("Error update config from local cache", e.message);
              }
          })();
        }),
          this._gateway.on(CG.DISCONNECT_P2P, async () => {
            await this._p2pChannel.disconnectForReconnect();
          }),
          this._gateway.on(CG.CONNECTION_STATE_CHANGE, (e, t, i) => {
            var s;
            if (i === _k.FALLBACK) return;
            const r = () => {
              this.safeEmit(Rk.CONNECTION_STATE_CHANGE, e, t, i);
            };
            if (
              (yU
                .reportApiInvoke(
                  this._sessionId ||
                    (null === (s = this._gateway.joinInfo) || void 0 === s
                      ? void 0
                      : s.sid) ||
                    null,
                  {
                    name: Ek.CONNECTION_STATE_CHANGE,
                    options: [e, t, i],
                    tag: mk.TRACER
                  }
                )
                .onSuccess(JSON.stringify({ cur: e, prev: t, reason: i })),
              EU.info(
                "["
                  .concat(this._clientId, "] signal connection state change: ")
                  .concat(t, " -> ")
                  .concat(e)
              ),
              "DISCONNECTED" === e)
            )
              return this._reset(), void r();
            if ("RECONNECTING" === e)
              this._users.forEach(e => {
                (e._trust_in_room_ = !1),
                  (e._trust_audio_enabled_state_ = !1),
                  (e._trust_video_enabled_state_ = !1),
                  (e._trust_audio_mute_state_ = !1),
                  (e._trust_video_mute_state_ = !1),
                  (e._trust_audio_stream_added_state_ = !1),
                  (e._trust_video_stream_added_state_ = !1),
                  e._is_pre_created ||
                    (e._audio_pre_subscribed ||
                      ((e._audioSSRC = void 0), (e._audioOrtc = void 0)),
                    e._video_pre_subscribed ||
                      ((e._videoSSRC = void 0),
                      (e._videoOrtc = void 0),
                      (e._rtxSsrcId = void 0)),
                    (e._cname = void 0));
              }),
                this._userOfflineTimeout &&
                  window.clearTimeout(this._userOfflineTimeout),
                this._streamRemovedTimeout &&
                  window.clearTimeout(this._streamRemovedTimeout),
                (this._userOfflineTimeout = void 0),
                (this._streamRemovedTimeout = void 0);
            else if ("CONNECTED" === e) {
              var n;
              this._streamFallbackTypeCacheMap.forEach((e, t) => {
                this._gateway.setStreamFallbackOption(t, e).catch(e => {
                  EU.warning(
                    "[".concat(
                      this._clientId,
                      "] auto set stream fallback option failed"
                    ),
                    e
                  );
                });
              }),
                this._remoteStreamTypeCacheMap.forEach((e, t) => {
                  this._gateway.setRemoteVideoStreamType(t, e).catch(e => {
                    EU.warning(
                      "[".concat(
                        this._clientId,
                        "] auto set remote stream type failed"
                      ),
                      e
                    );
                  });
                }),
                void 0 !== this._remoteDefaultVideoStreamType &&
                  void 0 ===
                    (null === (n = this._joinInfo) || void 0 === n
                      ? void 0
                      : n.defaultVideoStream) &&
                  this.setRemoteDefaultVideoStreamType(
                    this._remoteDefaultVideoStreamType
                  )
                    .then(() => {
                      EU.debug(
                        "[".concat(
                          this._clientId,
                          "] setRemoteDefaultVideoStreamType after gateway connected"
                        )
                      );
                    })
                    .catch(e => {
                      EU.error(
                        "["
                          .concat(
                            this._clientId,
                            "] setRemoteDefaultVideoStreamType after gateway failed, "
                          )
                          .concat(e)
                      );
                    }),
                this.store.useP2P ||
                  (this._p2pChannel.republish(),
                  (this._userOfflineTimeout = window.setTimeout(() => {
                    if ("CONNECTED" !== this.connectionState) return;
                    this._userOfflineTimeout = void 0;
                    this._users
                      .filter(e => !e._trust_in_room_)
                      .forEach(e => {
                        EU.debug(
                          "["
                            .concat(
                              this._clientId,
                              "] user offline timeout, emit user offline "
                            )
                            .concat(e.uid)
                        ),
                          this._handleUserOffline({ uid: e.uid });
                      });
                  }, 3e3)),
                  (this._streamRemovedTimeout = window.setTimeout(() => {
                    "CONNECTED" === this.connectionState &&
                      ((this._streamRemovedTimeout = void 0),
                      this._users.forEach(e => {
                        e._trust_audio_mute_state_ ||
                          (EU.debug(
                            "["
                              .concat(
                                this._clientId,
                                "] auto dispatch audio unmute event "
                              )
                              .concat(e.uid)
                          ),
                          this._handleMuteStream(e.uid, xG.AUDIO, !1)),
                          e._trust_video_mute_state_ ||
                            (EU.debug(
                              "["
                                .concat(
                                  this._clientId,
                                  "] auto dispatch video unmute event "
                                )
                                .concat(e.uid)
                            ),
                            this._handleMuteStream(e.uid, xG.VIDEO, !1)),
                          e._trust_audio_enabled_state_ ||
                            (EU.debug(
                              "["
                                .concat(
                                  this._clientId,
                                  "] auto dispatch enable local audio "
                                )
                                .concat(e.uid)
                            ),
                            this._handleSetStreamLocalEnable(
                              "audio",
                              e.uid,
                              !0
                            )),
                          e._trust_video_enabled_state_ ||
                            (EU.debug(
                              "["
                                .concat(
                                  this._clientId,
                                  "] auto dispatch enable local video "
                                )
                                .concat(e.uid)
                            ),
                            this._handleSetStreamLocalEnable(
                              "video",
                              e.uid,
                              !0
                            )),
                          e._trust_video_stream_added_state_ ||
                            (EU.debug(
                              "["
                                .concat(
                                  this._clientId,
                                  "] auto dispatch reset video stream added "
                                )
                                .concat(e.uid)
                            ),
                            this._handleResetAddStream(e, "video")),
                          e._trust_audio_stream_added_state_ ||
                            (EU.debug(
                              "["
                                .concat(
                                  this._clientId,
                                  "] auto dispatch reset audio stream added "
                                )
                                .concat(e.uid)
                            ),
                            this._handleResetAddStream(e, "audio")),
                          e._video_added_ ||
                            e._audio_added_ ||
                            (EU.debug(
                              "["
                                .concat(
                                  this._clientId,
                                  "] auto dispatch stream remove "
                                )
                                .concat(e.uid)
                            ),
                            this._handleRemoveStream({
                              uid: e.uid,
                              uint_id: e._uintid
                            }));
                      }));
                  }, 1e3)));
            }
            r();
          }),
          this._gateway.on(CG.REQUEST_NEW_GATEWAY_LIST, async (e, t) => {
            if (!this._joinInfo)
              return t(
                new AU(zP.UNEXPECTED_ERROR, "can not recover, no join info")
              );
            try {
              let t;
              const i = await tW(
                rG(
                  rG({}, this._joinInfo),
                  {},
                  { uid: this._joinInfo.uid, stringUid: void 0 }
                )
              );
              i
                ? ((t = i.ap), nW(i), (this._joinInfo.preload = !0))
                : ((t = await AH(
                    this._joinInfo,
                    this._axiosCancelSource.token,
                    this._config.httpRetryConfig || nM,
                    this.store
                  )),
                  (this._joinInfo.preload = !1)),
                this._joinInfo &&
                  ((this._joinInfo.apResponse = t.gatewayInfo.res),
                  (this._joinInfo.gatewayAddrs = t.gatewayInfo.gatewayAddrs),
                  (this._joinInfo.uni_lbs_ip = t.gatewayInfo.uni_lbs_ip));
              const s = [];
              t.gatewayInfo.gatewayAddrs.forEach(e => {
                let { address: t } = e;
                const [i, r] = t.split(":");
                this._joinInfo && this._joinInfo.proxyServer
                  ? s.push({
                      proxy: this._joinInfo.proxyServer,
                      host: i,
                      port: r
                    })
                  : s.push({ host: i, port: r });
              }),
                e(s);
            } catch (e) {
              t(e);
            }
          }),
          this._gateway.on(CG.NETWORK_QUALITY, e => {
            "normal" === this._networkQualitySensitivity &&
              this.safeEmit(Rk.NETWORK_QUALITY, e);
          }),
          this._gateway.on(CG.STREAM_TYPE_CHANGE, (e, t) => {
            this.safeEmit(Rk.STREAM_TYPE_CHANGED, e, t);
            yU.reportApiInvoke(this._sessionId, {
              name: Ek.STREAM_TYPE_CHANGE,
              options: [e, t],
              tag: mk.TRACER
            }).onSuccess(JSON.stringify({ uid: e, streamType: t }));
          }),
          this._gateway.on(CG.IS_P2P_DISCONNECTED, e => {
            this._p2pChannel.isP2PDisconnected()
              ? e(!0)
              : this._p2pChannel.hasLocalMedia() ||
                this._p2pChannel.hasRemoteMedia()
              ? e(!1)
              : e(!0);
          }),
          this._gateway.on(
            CG.REQUEST_P2P_CONNECTION_PARAMS,
            async (e, t, i) => {
              try {
                let i = await this._p2pChannel.getEstablishParams();
                (WM("ENABLE_PREALLOC_PC") && i) ||
                  (i = await this._p2pChannel.startP2PConnection(e)),
                  t(i);
              } catch (e) {
                i(e);
              }
            }
          ),
          this._gateway.on(CG.JOIN_RESPONSE, (e, t) => {
            if (this.store.useP2P) return;
            let i;
            e.attributes
              ? (i = e.attributes.userAttributes.preSubSsrcs)
              : EU.debug("no attributes in joinResponse");
            const s = Lj(e.ortc, t, i);
            this._p2pChannel.connect(s);
          }),
          this._gateway.on(CG.PRE_CONNECT_PC, async e => {
            const { candidates: t, fingerprint: i } = e;
            if (this._joinInfo && t.length > 0 && !this._p2pChannel.isPlanB) {
              var s;
              await this._p2pChannel.startP2PConnection({
                turnServer: this._joinInfo.turnServer
              });
              const { cert: e, cid: r } = this._joinInfo.apResponse;
              await this._p2pChannel.connect({
                iceParameters: {
                  iceUfrag: "".concat(r, "_").concat(e),
                  icePwd: "".concat(r, "_").concat(e)
                },
                dtlsParameters: {
                  fingerprints: [
                    {
                      hashFunction: "sha-256",
                      fingerprint:
                        null !== (s = WM("FINGERPRINT")) && void 0 !== s ? s : i
                    }
                  ]
                },
                candidates: t,
                rtpCapabilities: {
                  send: {
                    audioCodecs: [],
                    videoCodecs: [],
                    audioExtensions: [],
                    videoExtensions: []
                  },
                  recv: {
                    audioCodecs: [],
                    videoCodecs: [],
                    audioExtensions: [],
                    videoExtensions: []
                  }
                },
                setup: "active",
                cname: "o/i14u9pJrxRKAsu",
                preallocation: !0
              });
            }
          });
      }
      _handleGatewaySignalEvents() {
        this._gateway.signal.on(mG.ON_USER_ONLINE, this._handleUserOnline),
          this._gateway.signal.on(mG.ON_USER_OFFLINE, this._handleUserOffline),
          this._gateway.signal.on(mG.ON_ADD_AUDIO_STREAM, e =>
            this._handleAddAudioOrVideoStream(
              "audio",
              e.uid,
              e.ssrcId,
              e.cname,
              e.uint_id,
              e.ortc
            )
          ),
          this._gateway.signal.on(mG.ON_ADD_VIDEO_STREAM, e =>
            this._handleAddAudioOrVideoStream(
              "video",
              e.uid,
              e.ssrcId,
              e.cname,
              e.uint_id,
              e.ortc,
              e.rtxSsrcId
            )
          ),
          this._gateway.signal.on(mG.ON_REMOTE_DATASTREAM_UPDATE, e => {
            this._handleUpdateDataChannel(e);
          }),
          this._gateway.signal.on(mG.ON_REMOTE_FULL_DATASTREAM_INFO, e => {
            this._handleUpdateDataChannel(
              { added: e.datastreams || [], deleted: [] },
              !0
            );
          }),
          this._gateway.signal.on(
            mG.ON_REMOVE_STREAM,
            this._handleRemoveStream
          ),
          this._gateway.signal.on(mG.ON_P2P_LOST, this._handleP2PLost),
          this._gateway.signal.on(mG.MUTE_AUDIO, e =>
            this._handleMuteStream(e.uid, xG.AUDIO, !0)
          ),
          this._gateway.signal.on(mG.UNMUTE_AUDIO, e =>
            this._handleMuteStream(e.uid, xG.AUDIO, !1)
          ),
          this._gateway.signal.on(mG.MUTE_VIDEO, e =>
            this._handleMuteStream(e.uid, xG.VIDEO, !0)
          ),
          this._gateway.signal.on(mG.UNMUTE_VIDEO, e =>
            this._handleMuteStream(e.uid, xG.VIDEO, !1)
          ),
          this._gateway.signal.on(mG.RECEIVE_METADATA, e => {
            const t = Fk(e.metadata);
            this.safeEmit(Rk.RECEIVE_METADATA, e.uid, t);
          }),
          this._gateway.signal.on(mG.ON_DATA_STREAM, async e => {
            if (!e) return;
            let t = Fk(e.payload);
            if (
              this._encryptDataStream &&
              this._encryptDataStreamIv &&
              this._encryptDataStreamKey &&
              window.crypto.subtle &&
              ["aes-128-gcm2", "aes-256-gcm2"].includes(this._encryptionMode)
            ) {
              if (e.payload.length < eU)
                throw new AU(
                  zP.UNEXPECTED_RESPONSE,
                  "payload length "
                    .concat(e.payload.length, " is less than header length ")
                    .concat(eU)
                );
              const i = await (async function(e, t, i) {
                const s = i.subarray(0, eU),
                  r = s.slice(8, eU),
                  n = (r[0] << 8) + r[1],
                  a = (s[6] << 8) + s[7],
                  o = await window.crypto.subtle.decrypt(
                    {
                      name: "AES-GCM",
                      iv: e,
                      tagLength: JM,
                      additionalData: new Uint8Array(Zk(n, 2))
                    },
                    t,
                    i.subarray(eU)
                  );
                return new Uint8Array(o).subarray(0, a);
              })(this._encryptDataStreamIv, this._encryptDataStreamKey, t);
              t = i;
            }
            let i = 0;
            if (e.ordered || e.syncWithAudio) {
              const t = this._p2pChannel.getStats(),
                s = this.remoteUsers.find(t => t.uid === e.uid),
                r =
                  null == t
                    ? void 0
                    : t.audioRecv.find(
                        e => e.ssrc === (null == s ? void 0 : s._audioSSRC)
                      );
              i = null == r ? void 0 : r.jitterBufferMs;
            }
            (null == i || Number.isNaN(i)) && (i = 0),
              HK(rG(rG({}, e), {}, { payload: t }), i, {
                id: this._clientId,
                onStreamMessage:
                  "function" == typeof this.onStreamMessage
                    ? this.onStreamMessage.bind(this)
                    : void 0,
                safeEmit: this.safeEmit.bind(this)
              });
          }),
          this._gateway.signal.on(mG.ON_CRYPT_ERROR, () => {
            xk(() => {
              EU.warning("[".concat(this._clientId, "] on crypt error")),
                this.safeEmit(Rk.CRYPT_ERROR);
            }, this._sessionId);
          }),
          this._gateway.signal.on(
            mG.ON_TOKEN_PRIVILEGE_WILL_EXPIRE,
            this._handleTokenWillExpire
          ),
          this._gateway.signal.on(mG.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            EU.warning(
              "[".concat(
                this._clientId,
                "] received message onTokenPrivilegeDidExpire, please get new token and join again"
              )
            ),
              this._gateway.leave(!0, _k.TOKEN_EXPIRE),
              this.safeEmit(Rk.ON_TOKEN_PRIVILEGE_DID_EXPIRE),
              this._reset();
          }),
          this._gateway.signal.on(mG.ON_STREAM_FALLBACK_UPDATE, e => {
            EU.debug(
              "["
                .concat(this._clientId, "] stream fallback peerId: ")
                .concat(e.stream_id, ", attr: ")
                .concat(e.stream_type)
            ),
              this.safeEmit(
                Rk.STREAM_FALLBACK,
                e.stream_id,
                1 === e.stream_type ? "fallback" : "recover"
              );
          }),
          this._gateway.signal.on(mG.ON_PUBLISH_STREAM, e => {
            this.uid === this._uid &&
              (this._p2pChannel.reportPublishEvent(
                !0,
                null,
                void 0,
                !1,
                JSON.stringify({ proxy: e.proxy })
              ),
              EU.info(
                "["
                  .concat(this._clientId, "] on publish stream, ")
                  .concat(JSON.stringify(e))
              ));
          }),
          this._gateway.signal.on(mG.ENABLE_LOCAL_VIDEO, e => {
            this._handleSetStreamLocalEnable("video", e.uid, !0);
          }),
          this._gateway.signal.on(mG.DISABLE_LOCAL_VIDEO, e => {
            this._handleSetStreamLocalEnable("video", e.uid, !1);
          }),
          this._gateway.signal.on(pG.REQUEST_TIMEOUT, (e, t) => {
            if (this._joinInfo)
              switch (e) {
                case fG.PUBLISH: {
                  if (!t) return;
                  const e = t.ortc;
                  if (e) {
                    var i, s;
                    const r = e.some(e => {
                        let { stream_type: t } = e;
                        return t === IG.Audio;
                      }),
                      n = e.some(e => {
                        let { stream_type: t } = e;
                        return t !== IG.Audio;
                      }),
                      a = e.some(e => {
                        let { stream_type: t } = e;
                        return t === IG.Screen || t === IG.ScreenLow;
                      });
                    "offer" === t.state &&
                      yU.publish(this._joinInfo.sid, {
                        eventElapse: MH.measureFromPublishStart(
                          this.store.clientId,
                          this.store.pubId
                        ),
                        succ: !1,
                        ec: zP.TIMEOUT,
                        audio: r,
                        video: n,
                        p2pid: t.p2p_id,
                        publishRequestid: this.store.pubId,
                        screenshare: a,
                        audioName: r
                          ? null ===
                              (i = e.find(e => {
                                let { stream_type: t } = e;
                                return t === IG.Audio;
                              })) ||
                            void 0 === i ||
                            null === (i = i.ssrcs[0]) ||
                            void 0 === i
                            ? void 0
                            : i.ssrcId.toString()
                          : void 0,
                        videoName: n
                          ? null ===
                              (s = e.find(e => {
                                let { stream_type: t } = e;
                                return t !== IG.Audio;
                              })) ||
                            void 0 === s ||
                            null === (s = s.ssrcs[0]) ||
                            void 0 === s
                            ? void 0
                            : s.ssrcId.toString()
                          : void 0
                      });
                  }
                  break;
                }
                case fG.SUBSCRIBE:
                  t &&
                    yU.subscribe(this._joinInfo.sid, {
                      succ: !1,
                      ec: zP.TIMEOUT,
                      audio: t.stream_type === xG.AUDIO,
                      video: t.stream_type === xG.VIDEO,
                      peerid: t.stream_id,
                      subscribeRequestid: t.ssrcId,
                      p2pid: this.store.p2pId,
                      eventElapse: MH.measureFromSubscribeStart(
                        this.store.clientId,
                        t.ssrcId
                      ),
                      preSsrc: this._p2pChannel.isPreSubScribe(t.ssrcId)
                    });
              }
          }),
          this._gateway.signal.on(mG.ON_P2P_OK, e => {
            this.uid, this._uid;
          }),
          this._gateway.signal.on(mG.ON_PUBLISHED_USER_LIST, e => {
            if (null == e || !e.users) return;
            WM("BLOCK_LOCAL_CLIENT") &&
              (e.users = e.users.filter(
                e => !qV(e.string_id || e.stream_id, this.channelName)
              ));
            const t = [],
              i = [];
            for (const s of e.users) {
              let e = this._users.find(e => e._uintid === s.stream_id);
              e
                ? (e._trust_in_room_ = !0)
                : ((e = new BH(s.string_id || s.stream_id, s.stream_id)),
                  this._users.push(e),
                  0 === this.getListeners(Rk.PUBLISHED_USER_LIST).length &&
                    (EU.debug(
                      "[".concat(this._clientId, "] user online"),
                      s.stream_id
                    ),
                    this.safeEmit(Rk.USER_JOINED, e)));
              const r = OG.Audio & s.stream_type,
                n = (OG.Video | OG.LwoVideo) & s.stream_type,
                a = 0 != (65280 & s.stream_type),
                o = r && e.hasAudio,
                c = n && e.hasVideo;
              n &&
                ((e._trust_video_stream_added_state_ = !0),
                (e._video_added_ = !0),
                (e._videoSSRC = s.video_ssrc),
                (e._rtxSsrcId = s.video_rtx)),
                r &&
                  ((e._trust_audio_stream_added_state_ = !0),
                  (e._audio_added_ = !0),
                  (e._audioSSRC = s.audio_ssrc)),
                r &&
                  !o &&
                  0 === this.getListeners(Rk.PUBLISHED_USER_LIST).length &&
                  (EU.info(
                    "["
                      .concat(this._clientId, "] remote user ")
                      .concat(e.uid, " published audio")
                  ),
                  this.safeEmit(Rk.USER_PUBLISHED, e, "audio")),
                n &&
                  !c &&
                  0 === this.getListeners(Rk.PUBLISHED_USER_LIST).length &&
                  (EU.info(
                    "["
                      .concat(this._clientId, "] remote user ")
                      .concat(e.uid, " published video")
                  ),
                  this.safeEmit(Rk.USER_PUBLISHED, e, "video")),
                ((r && !o) || (n && !c) || a) && t.push(e),
                n &&
                  this._p2pChannel.hasPendingRemoteMedia(e, "video") &&
                  i.push({ user: e, mediaType: "video" }),
                r &&
                  this._p2pChannel.hasPendingRemoteMedia(e, "audio") &&
                  i.push({ user: e, mediaType: "audio" });
            }
            i.length > 0 &&
              (EU.debug(
                "["
                  .concat(this._clientId, "] RE massSubscribe after reconnect ")
                  .concat(
                    i
                      .map(e =>
                        "user: "
                          .concat(e.user.uid, ", mediaType: ")
                          .concat(e.mediaType)
                      )
                      .join("; "),
                    " "
                  )
              ),
              this.massSubscribe(i).catch(e => {
                EU.error(
                  "[".concat(this._clientId, "] mass resubscribe error"),
                  e.toString()
                );
              })),
              this.getListeners(Rk.PUBLISHED_USER_LIST).length > 0
                ? WM("ENABLE_DATASTREAM_2")
                  ? (this._pendingPublishedUsers = t)
                  : (EU.info(
                      "["
                        .concat(
                          this._clientId,
                          "] client emit user-list event, users: "
                        )
                        .concat(t.map(e => e.uid).join(", "))
                    ),
                    this.safeEmit(Rk.PUBLISHED_USER_LIST, t))
                : EU.info(
                    "["
                      .concat(
                        this._clientId,
                        "] client not emit user-list event case there is no user-list listener, users: "
                      )
                      .concat(t.map(e => e.uid).join(", "))
                  );
          }),
          this._gateway.signal.on(mG.ON_RTP_CAPABILITY_CHANGE, e => {
            const { video_codec: t } = e;
            this._p2pChannel instanceof MK &&
              this._p2pChannel.updateRemoteRTPCapabilities(
                t
                  .map(e => e.toLowerCase())
                  .filter(e => Object.keys(zM).includes(e))
              );
          });
      }
      _handleP2PEvents() {
        this._gateway.signal.on(mG.ON_USER_OFFLINE, () => {
          this._p2pChannel.disconnectForReconnect();
        }),
          this._gateway.signal.on(zG.PUBLISH, (e, t, i) => {
            const { uid: s } = e;
            e.forEach(e => {
              const { kind: r, ssrcs: n, mid: a, isMuted: o } = e;
              this._handleP2PAddAudioOrVideoStream(r, s, n[0].ssrcId, a);
              const c = this._users.find(e => e.uid === s);
              return (
                c && this.store.useP2P
                  ? this._p2pChannel
                      .mockSubscribe(c, r, n[0].ssrcId, a)
                      .then(() => {
                        t();
                      })
                      .catch(i)
                  : t(),
                this._handleMuteStream(s, r, !!o)
              );
            });
          }),
          this._gateway.signal.on(zG.CALL, async (e, t, i) => {
            if (this.store.useP2P)
              try {
                var s;
                t(
                  await this._p2pChannel.startP2P(
                    {
                      turnServer:
                        null === (s = this._joinInfo) || void 0 === s
                          ? void 0
                          : s.turnServer
                    },
                    e
                  )
                );
              } catch (e) {
                i(e);
              }
          }),
          this._gateway.signal.on(pG.P2P_CONNECTION, async e => {
            this.store.useP2P && (await this._p2pChannel).p2pConnect(e);
          }),
          this._gateway.signal.on(zG.UNPUBLISH, async (e, t, i) => {
            if (this.store.useP2P) {
              const { unpubMsg: s, uid: r } = e,
                n = this._users.find(e => e.uid === r);
              if (!n)
                return (
                  EU.warning(
                    "["
                      .concat(
                        this._clientId,
                        "] can not find remote user, ignore mute event, uid: "
                      )
                      .concat(r)
                  ),
                  void t()
                );
              try {
                s.forEach(async e => {
                  let { stream_type: t } = e;
                  const i = t === IG.Audio ? xG.AUDIO : xG.VIDEO;
                  await this._p2pChannel.unsubscribe(n, i),
                    this._handleMuteStream(r, i, !0);
                }),
                  t();
              } catch (e) {
                i(e);
              }
            }
          }),
          this._gateway.signal.on(zG.CONTROL, async (e, t) => {
            const { action: i } = e;
            switch (i) {
              case JG.MUTE_LOCAL_VIDEO:
                this._handleMuteStream(t, xG.VIDEO, !0);
                break;
              case JG.MUTE_LOCAL_AUDIO:
                this._handleMuteStream(t, xG.AUDIO, !0);
                break;
              case JG.UNMUTE_LOCAL_VIDEO:
                this._handleP2PAddAudioOrVideoStream("video", t),
                  this._handleMuteStream(t, xG.VIDEO, !1);
                break;
              case JG.UNMUTE_LOCAL_AUDIO:
                this._handleP2PAddAudioOrVideoStream("audio", t),
                  this._handleMuteStream(t, xG.AUDIO, !1);
            }
          }),
          this._gateway.signal.on(zG.RESTART_ICE, async (e, t, i) => {
            if (this.store.useP2P)
              try {
                const { direction: i, iceParameter: s } = e;
                if (i !== gG.SEND_ONLY || s) {
                  t(await this._p2pChannel.restartICE(i, s));
                } else this._p2pChannel.handleDisconnect(i), t();
              } catch (e) {
                i(e);
              }
          }),
          this._gateway.signal.on(zG.CANDIDATE, e => {
            if (this.store.useP2P) {
              const { candidate: t, direction: i } = e;
              this._p2pChannel.addRemoteCandidate(t, i);
            }
          }),
          this._p2pChannel.on(HG.RequestP2PRestartICE, async (e, t, i) => {
            try {
              const { direction: i } = e;
              t(
                await this._gateway.sendExtensionMessage(
                  zG.RESTART_ICE,
                  e,
                  i === gG.SEND_ONLY
                )
              );
            } catch (e) {
              i(e);
            }
          }),
          this._p2pChannel.on(HG.LocalCandidate, e => {
            this._gateway.sendExtensionMessage(
              zG.CANDIDATE,
              JSON.stringify(e),
              !0
            );
          }),
          this._p2pChannel.on(HG.RequestP2PMuteLocal, async (e, t, i) => {
            try {
              await this._gateway.sendExtensionMessage(zG.CONTROL, e, !0), t();
            } catch (e) {
              i(e);
            }
          }),
          this._p2pChannel.on(HG.RequestP2PUnmuteRemote, async (e, t, i) => {
            if (this._joinInfo)
              try {
                await this._gateway.unmuteRemote(
                  e,
                  this._joinInfo.stringUid || this._joinInfo.uid
                ),
                  t();
              } catch (e) {
                e.code === zP.DISCONNECT_P2P ? t() : i(e);
              }
            else t();
          }),
          this._p2pChannel.on(HG.RequestP2PMuteRemote, async (e, t, i) => {
            if (this._joinInfo)
              try {
                await this._gateway.muteRemote(
                  e,
                  this._joinInfo.stringUid || this._joinInfo.uid
                ),
                  t();
              } catch (e) {
                e.code === zP.DISCONNECT_P2P ? t() : i(e);
              }
            else t();
          }),
          this._p2pChannel.on(HG.StateChange, (e, t) => {
            t === jG.Connected && this._p2pChannel.republish();
          });
      }
      _handleP2PChannelEvents() {
        this._p2pChannel.on(HG.PeerConnectionStateChange, e => {
          const t = this._peerConnectionState;
          e !== t &&
            (this.safeEmit(Rk.PEERCONNECTION_STATE_CHANGE, e, t),
            (this._peerConnectionState = e));
        }),
          this._p2pChannel.on(HG.RequestMuteLocal, async (e, t, i) => {
            if (this._joinInfo)
              try {
                await this._gateway.muteLocal(
                  e,
                  this._joinInfo.stringUid || this._joinInfo.uid
                ),
                  t();
              } catch (e) {
                e.code === zP.DISCONNECT_P2P ? t() : i(e);
              }
            else t();
          }),
          this._p2pChannel.on(HG.RequestUnmuteLocal, async (e, t, i) => {
            if (this._joinInfo)
              try {
                await this._gateway.unmuteLocal(
                  e,
                  this._joinInfo.stringUid || this._joinInfo.uid
                ),
                  t();
              } catch (e) {
                e.code === zP.DISCONNECT_P2P ? t() : i(e);
              }
            else t();
          }),
          this._p2pChannel.on(HG.RequestRePublish, (e, t, i) => {
            this.publish(e, !1)
              .then(t)
              .catch(i);
          }),
          this._p2pChannel.on(HG.RequestRePublishDataChannel, (e, t, i) => {
            Promise.all(
              e.map(async e => {
                const t = await this._p2pChannel.publishDataChannel([e]);
                try {
                  t.forEach(e => {
                    this._uid &&
                      this._gateway.publishDataChannel(this._uid, e, !0);
                  });
                } catch (e) {
                  if (e.code !== zP.DISCONNECT_P2P) throw e;
                }
              })
            )
              .then(t)
              .catch(i);
          }),
          this._p2pChannel.on(HG.RequestReSubscribe, async (e, t, i) => {
            try {
              for (const { user: t, kind: i } of e)
                i === xG.VIDEO
                  ? await this.subscribe(t, "video")
                  : await this.subscribe(t, "audio");
              t();
            } catch (e) {
              i(e);
            }
          }),
          this._p2pChannel.on(HG.RequestUpload, (e, t) => {
            this._gateway.upload(e, t);
          }),
          this._p2pChannel.on(HG.RequestUploadStats, e => {
            this._gateway.uploadWRTCStats(e);
          }),
          this._p2pChannel.on(HG.MediaReconnectStart, e => {
            this.safeEmit(Rk.MEDIA_RECONNECT_START, e);
          }),
          this._p2pChannel.on(HG.MediaReconnectEnd, e => {
            this.safeEmit(Rk.MEDIA_RECONNECT_END, e);
          }),
          this._p2pChannel.on(HG.NeedSignalRTT, e => {
            e(this._gateway.getSignalRTT());
          }),
          this._p2pChannel.on(HG.RequestRestartICE, async e => {
            if (this.store.useP2P) return;
            const t = await this._p2pChannel.restartICE(e),
              i = await t.next();
            if (i.done) return;
            const s = i.value;
            let r;
            try {
              r = await this._gateway.restartICE({ iceParameters: s });
            } catch (e) {
              return void t.throw(e);
            }
            const { iceParameters: n } = (function(e) {
              const t = e.iceParameters;
              return {
                iceParameters: { iceUfrag: t.iceUfrag, icePwd: t.icePwd }
              };
            })(r);
            await t.next({ remoteIceParameters: n });
          }),
          this._p2pChannel.on(HG.RequestReconnect, async () => {
            this._gateway.reconnect();
          }),
          this._p2pChannel.on(HG.RequestReconnectPC, async () => {
            var e;
            const {
                iceParameters: t,
                dtlsParameters: i,
                rtpCapabilities: s
              } = await this._p2pChannel.startP2PConnection({
                turnServer:
                  null === (e = this._joinInfo) || void 0 === e
                    ? void 0
                    : e.turnServer
              }),
              {
                gatewayEstablishParams: r,
                gatewayAddress: n
              } = await this._gateway.reconnectPC({
                iceParameters: t,
                dtlsParameters: i,
                rtpCapabilities: s
              }),
              a = Lj(r, n);
            await this._p2pChannel.connect(a),
              await this._p2pChannel.republish(),
              await this._p2pChannel.reSubscribe();
          }),
          this._p2pChannel.on(
            HG.RequestUnpublishForReconnectPC,
            async (e, t, i) => {
              this._joinInfo && void 0 !== this._uid
                ? (await this._gateway.unpublish(e, this._uid), t())
                : i();
            }
          ),
          this._p2pChannel.on(HG.P2PLost, () => {
            this.safeEmit(Rk.P2P_LOST, this.store.uid);
          }),
          this._p2pChannel.on(HG.UpdateVideoEncoder, e => {
            e._encoderConfig && this._gateway.setVideoProfile(e._encoderConfig);
          }),
          this._p2pChannel.on(HG.ConnectionTypeChange, e => {
            this.safeEmit(Rk.IS_USING_CLOUD_PROXY, e);
          }),
          this._p2pChannel.on(HG.RequestLowStreamParameter, e => {
            e(
              this._lowStreamParameter || {
                width: 160,
                height: 120,
                framerate: 15,
                bitrate: 50
              }
            );
          }),
          this._p2pChannel.on(HG.QueryClientConnectionState, e => {
            e(this.connectionState);
          }),
          this._p2pChannel.on(HG.AudioMetadata, e => {
            this.safeEmit(Rk.AUDIO_METADATA, e);
          });
      }
      getKeyMetrics() {
        return this.store.keyMetrics;
      }
      async enableContentInspect(e) {
        if (!this._joinInfo || "CONNECTED" !== this.connectionState)
          throw new AU(
            zP.INVALID_OPERATION,
            "[".concat(
              this._clientId,
              "] can not create content inspect, please join channel first"
            )
          );
        if (this._inspect)
          throw new AU(
            zP.INVALID_OPERATION,
            "[".concat(
              this._clientId,
              "] Inspect content service already in connecting/connected state"
            )
          );
        try {
          const i = ((t = { config: e }), Xj("ContentInspect").create(t));
          (this._inspect = i), this.handleVideoInspectEvents(i);
          const {
            appId: s,
            cname: r,
            sid: n,
            token: a,
            uid: o,
            cid: c,
            vid: d
          } = this._joinInfo;
          await i.init(
            {
              appId: s,
              areaCode: "",
              cname: r,
              sid: n,
              token: a,
              uid: o,
              cid: c,
              vid: d ? Number(d) : 0
            },
            nM
          );
        } catch (e) {
          throw Array.isArray(e) ? e[0] : e;
        }
        var t;
      }
      handleVideoInspectEvents(e) {
        e.on(WG.CONNECTION_STATE_CHANGE, (t, i) => {
          if (
            (this.safeEmit(Rk.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t, i),
            i === KG.CONNECTED)
          ) {
            if ("CONNECTED" !== this.connectionState)
              return void this.safeEmit(
                Rk.CONTENT_INSPECT_ERROR,
                new AU(
                  zP.OPERATION_ABORTED,
                  "Content inspect was cancelled because it left the channel"
                )
              );
            e.inspectImage();
          }
        }),
          e.on(WG.INSPECT_RESULT, (e, t) => {
            var i;
            if (
              (null == t ? void 0 : t.code) === zP.INVALID_OPERATION &&
              "DISCONNECTED" === this.connectionState
            )
              return (
                EU.debug("Stop inspect content because that has left channel"),
                null == this ||
                  null === (i = this._inspect) ||
                  void 0 === i ||
                  i.close(),
                void (this._inspect = void 0)
              );
            this.safeEmit(Rk.CONTENT_INSPECT_RESULT, e, t);
          }),
          e.on(WG.CLIENT_LOCAL_VIDEO_TRACK, e => {
            e(this.localTracks.filter(e => "video" === e.trackMediaType)[0]);
          });
      }
      async disableContentInspect() {
        if (!this._inspect)
          throw new AU(
            zP.INVALID_OPERATION,
            "[".concat(this._clientId, "] inspectVideoContent not started")
          );
        try {
          this._inspect.close(), (this._inspect = void 0);
        } catch (e) {
          throw Array.isArray(e) ? e[0] : e;
        }
      }
      async setImageModeration(e, t) {
        if ((QP(e, "enabled"), e)) {
          if (!t) throw new AU(zP.INVALID_PARAMS, "config is required");
          if (
            ((function(e) {
              if (
                (ek(e.interval, "interval", 1e3, 1 / 0),
                e && e.extraInfo && e.extraInfo.length > 1024)
              )
                throw new AU(
                  zP.INVALID_PARAMS,
                  "config.extraInfo length cannot exceed 1024 bytes"
                );
              if (e && e.vendor && e.vendor.length > 1024)
                throw new AU(
                  zP.INVALID_PARAMS,
                  "config.vendor length cannot exceed 1024 bytes"
                );
            })(t),
            !this._joinInfo)
          )
            throw new AU(
              zP.INVALID_OPERATION,
              "can not create image moderation, please join channel first"
            );
          try {
            if (this._moderation) this._moderation.updateConfig(t);
            else {
              const e = ((i = { config: t }), Xj("ImageModeration").create(i));
              (this._moderation = e), this.handleImageModerationEvents(e);
              const {
                appId: s,
                cname: r,
                sid: n,
                token: a,
                uid: o,
                cid: c,
                vid: d
              } = this._joinInfo;
              await e.init(
                {
                  appId: s,
                  areaCode: "",
                  cname: r,
                  sid: n,
                  token: a,
                  uid: o,
                  cid: c,
                  vid: d ? Number(d) : 0
                },
                nM
              );
            }
          } catch (e) {
            throw Array.isArray(e) ? e[0] : e;
          }
        } else {
          var i;
          if (!this._moderation)
            throw new AU(
              zP.INVALID_OPERATION,
              "[".concat(this._clientId, "] image moderation not started")
            );
          try {
            this._moderation.close(),
              this._moderation.removeAllListeners(),
              (this._moderation = void 0);
          } catch (e) {
            throw Array.isArray(e) ? e[0] : e;
          }
        }
      }
      handleImageModerationEvents(e) {
        e.on(XG.CONNECTION_STATE_CHANGE, (t, i) => {
          if (
            (this.safeEmit(Rk.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t, i),
            t === qG.CONNECTED)
          ) {
            if ("CONNECTED" !== this.connectionState)
              throw (this.setImageModeration(!1),
              new AU(
                zP.OPERATION_ABORTED,
                "Image moderation was cancelled because it left the channel"
              ));
            e.inspectImage();
          }
        }),
          e.on(XG.CLIENT_LOCAL_VIDEO_TRACK, e => {
            e(this.localTracks.filter(e => "video" === e.trackMediaType)[0]);
          });
      }
      setP2PTransport(e) {
        if (
          ((function(e) {
            ZP(e, "transport", ["default", "auto", "relay", "sd-rtn"]);
          })(e),
          "p2p" !== this.mode)
        )
          throw new AU(
            zP.INVALID_OPERATION,
            "only p2p mode can set p2pTransport"
          );
        (this.store.p2pTransport = e),
          EU.info(
            "["
              .concat(this._clientId, "] set client p2pTransport to ")
              .concat(e)
          );
      }
      getJoinChannelServiceRecords() {
        return (
          EU.debug("getJoinChannelServiceRecords"),
          this.store.joinChannelServiceRecords
        );
      }
      async setPublishAudioFilterEnabled(e) {
        QP(e, "enabled"),
          KM("ENABLE_PUBLISH_AUDIO_FILTER", e),
          this._joinInfo &&
            (await this._gateway.setPublishAudioFilterEnabled(e));
      }
      _handleResetAddStream(e, t) {
        switch (t) {
          case "audio":
            (e._audio_added_ = !1), (e._trust_audio_stream_added_state_ = !0);
            break;
          case "video":
            (e._video_added_ = !1), (e._trust_video_stream_added_state_ = !0);
        }
      }
    }),
    JV(
      eY.prototype,
      "leave",
      [pW],
      Object.getOwnPropertyDescriptor(eY.prototype, "leave"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "publish",
      [fW],
      Object.getOwnPropertyDescriptor(eY.prototype, "publish"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "unpublish",
      [EW],
      Object.getOwnPropertyDescriptor(eY.prototype, "unpublish"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "subscribe",
      [mW],
      Object.getOwnPropertyDescriptor(eY.prototype, "subscribe"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "presubscribe",
      [gW],
      Object.getOwnPropertyDescriptor(eY.prototype, "presubscribe"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "massSubscribe",
      [_W],
      Object.getOwnPropertyDescriptor(eY.prototype, "massSubscribe"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "unsubscribe",
      [TW],
      Object.getOwnPropertyDescriptor(eY.prototype, "unsubscribe"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "massUnsubscribe",
      [SW],
      Object.getOwnPropertyDescriptor(eY.prototype, "massUnsubscribe"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setLowStreamParameter",
      [vW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setLowStreamParameter"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "enableDualStream",
      [RW],
      Object.getOwnPropertyDescriptor(eY.prototype, "enableDualStream"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "disableDualStream",
      [yW],
      Object.getOwnPropertyDescriptor(eY.prototype, "disableDualStream"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setClientRole",
      [AW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setClientRole"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "_setClientRoleOptions",
      [IW],
      Object.getOwnPropertyDescriptor(eY.prototype, "_setClientRoleOptions"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setProxyServer",
      [CW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setProxyServer"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setTurnServer",
      [bW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setTurnServer"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setLicense",
      [OW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setLicense"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "startProxyServer",
      [DW],
      Object.getOwnPropertyDescriptor(eY.prototype, "startProxyServer"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "stopProxyServer",
      [wW],
      Object.getOwnPropertyDescriptor(eY.prototype, "stopProxyServer"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setLocalAccessPointsV2",
      [LW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setLocalAccessPointsV2"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setLocalAccessPoints",
      [NW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setLocalAccessPoints"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setRemoteDefaultVideoStreamType",
      [PW],
      Object.getOwnPropertyDescriptor(
        eY.prototype,
        "setRemoteDefaultVideoStreamType"
      ),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setRemoteVideoStreamType",
      [kW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setRemoteVideoStreamType"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setStreamFallbackOption",
      [MW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setStreamFallbackOption"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setEncryptionConfig",
      [UW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setEncryptionConfig"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "renewToken",
      [xW],
      Object.getOwnPropertyDescriptor(eY.prototype, "renewToken"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "enableAudioVolumeIndicator",
      [FW],
      Object.getOwnPropertyDescriptor(
        eY.prototype,
        "enableAudioVolumeIndicator"
      ),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "startLiveStreaming",
      [BW],
      Object.getOwnPropertyDescriptor(eY.prototype, "startLiveStreaming"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setLiveTranscoding",
      [VW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setLiveTranscoding"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "stopLiveStreaming",
      [GW],
      Object.getOwnPropertyDescriptor(eY.prototype, "stopLiveStreaming"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "startChannelMediaRelay",
      [jW],
      Object.getOwnPropertyDescriptor(eY.prototype, "startChannelMediaRelay"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "updateChannelMediaRelay",
      [HW],
      Object.getOwnPropertyDescriptor(eY.prototype, "updateChannelMediaRelay"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "stopChannelMediaRelay",
      [KW],
      Object.getOwnPropertyDescriptor(eY.prototype, "stopChannelMediaRelay"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "sendCustomReportMessage",
      [WW],
      Object.getOwnPropertyDescriptor(eY.prototype, "sendCustomReportMessage"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "pickSVCLayer",
      [YW],
      Object.getOwnPropertyDescriptor(eY.prototype, "pickSVCLayer"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setRTMConfig",
      [$W],
      Object.getOwnPropertyDescriptor(eY.prototype, "setRTMConfig"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "enableContentInspect",
      [qW],
      Object.getOwnPropertyDescriptor(eY.prototype, "enableContentInspect"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "disableContentInspect",
      [XW],
      Object.getOwnPropertyDescriptor(eY.prototype, "disableContentInspect"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setImageModeration",
      [zW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setImageModeration"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setP2PTransport",
      [JW],
      Object.getOwnPropertyDescriptor(eY.prototype, "setP2PTransport"),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "getJoinChannelServiceRecords",
      [QW],
      Object.getOwnPropertyDescriptor(
        eY.prototype,
        "getJoinChannelServiceRecords"
      ),
      eY.prototype
    ),
    JV(
      eY.prototype,
      "setPublishAudioFilterEnabled",
      [ZW],
      Object.getOwnPropertyDescriptor(
        eY.prototype,
        "setPublishAudioFilterEnabled"
      ),
      eY.prototype
    ),
    eY);
  function iY() {
    let e =
      arguments.length > 0 && void 0 !== arguments[0]
        ? arguments[0]
        : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
    const t = Yk(5, "client-"),
      i = yU.reportApiInvoke(null, {
        id: t,
        name: Ek.CREATE_CLIENT,
        options: [e],
        tag: mk.TRACER
      });
    try {
      !(function(e) {
        ZP(e.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]),
          ZP(e.mode, "config.mode", ["rtc", "live", "p2p"]),
          void 0 !== e.audioCodec &&
            ZP(e.audioCodec, "config.audioCodec", [
              "opus",
              "pcmu",
              "pcma",
              "g722"
            ]),
          void 0 !== e.proxyServer &&
            ik(e.proxyServer, "config.proxyServer", 1, 1e4),
          void 0 !== e.turnServer && Sk(e.turnServer),
          void 0 !== e.httpRetryConfig && gk(e.httpRetryConfig),
          void 0 !== e.websocketRetryConfig && gk(e.websocketRetryConfig);
      })(e);
    } catch (e) {
      throw (i.onError(e), e);
    }
    return (
      (MP(16, 0, !0) || UP(16, 0, !0)) &&
        ("vp9" === e.codec &&
          ((e.codec = "vp8"),
          EU.debug("browser not support vp9, force use vp8")),
        KM("UNSUPPORTED_VIDEO_CODEC", ["vp9"])),
      void 0 === e.audioCodec && (e.audioCodec = "opus"),
      i.onSuccess(),
      new tY(
        rG(
          rG({ forceWaitGatewayResponse: !0 }, e),
          {},
          {
            role: ["rtc", "p2p"].includes(e.mode)
              ? "host"
              : e.role || "audience"
          }
        ),
        t
      )
    );
  }
  function sY() {
    let e = !1;
    const t = vP();
    return (
      ((t.name === gP.CHROME &&
        Number(t.version) >= 58 &&
        ("WebKit" !== TP.engine.name ||
          (function() {
            const e = vP();
            if (IP()) {
              if (e.os === mP.MAC_OS) return !0;
              if (e.os === mP.IOS) {
                const e = TP.os.version && TP.os.version.split(".");
                if (e && 14 === Number(e[0]) && e[1] && Number(e[1]) >= 3)
                  return !0;
                if (e && Number(e[0]) > 14) return !0;
              }
            }
            return !1;
          })())) ||
        (t.name === gP.FIREFOX && Number(t.version) >= 56) ||
        (t.name === gP.OPERA && Number(t.version) >= 45) ||
        (t.name === gP.SAFARI && Number(t.version) >= 11) ||
        ("WebKit" === t.name &&
          (wP() || GP()) &&
          t.osVersion &&
          Number(t.osVersion.split(".")[0]) >= 11) ||
        jP() ||
        vP().name === gP.QQ) &&
        (e = !0),
      e
    );
  }
  function rY() {
    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    const t = yU.reportApiInvoke(null, {
        name: Ek.CHECK_SYSTEM_REQUIREMENTS,
        options: [],
        tag: mk.TRACER
      }),
      i = (function() {
        let e =
            !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
          t = !1;
        try {
          const i = window.RTCPeerConnection,
            s = navigator.mediaDevices && navigator.mediaDevices.getUserMedia,
            r = window.WebSocket;
          (t = !(!i || !r)),
            e && !s && (t = !1),
            t && WP() && NP(75) && new i().close();
        } catch (e) {
          EU.error("check system requirement failed: ", e), (t = !1);
        }
        return t;
      })(e),
      s = sY();
    EU.debug("checkSystemRequirements, api:", i, "browser", s);
    const r = i && s;
    return t.onSuccess(r), r;
  }
  class nY {
    constructor(e, t) {
      (this.id = 0),
        (this.element = void 0),
        (this.peerPair = void 0),
        (this.context = void 0),
        (this.audioPlayerElement = void 0),
        (this.audioTrack = void 0),
        (nY.count += 1),
        (this.id = nY.count),
        (this.element = e),
        (this.context = t);
    }
    initPeers() {
      (this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()]),
        (this.peerPair[1].ontrack = e => {
          const t = document.createElement("audio");
          (t.srcObject = new MediaStream([e.track])),
            t.play(),
            (this.audioPlayerElement = t);
        });
    }
    async switchSdp() {
      if (!this.peerPair) return;
      const e = async (e, t) => {
          const i =
            "offer" === t ? await e.createOffer() : await e.createAnswer();
          return (
            await e.setLocalDescription(i),
            "complete" === e.iceGatheringState
              ? e.localDescription
              : new Promise(t => {
                  e.onicegatheringstatechange = () => {
                    "complete" === e.iceGatheringState && t(e.localDescription);
                  };
                })
          );
        },
        t = async (e, t) => await e.setRemoteDescription(t);
      try {
        const i = await e(this.peerPair[0], "offer");
        await t(this.peerPair[1], i);
        const s = await e(this.peerPair[1], "answer");
        await t(this.peerPair[0], s);
      } catch (e) {
        throw new AU(zP.LOCAL_AEC_ERROR, e.toString()).print();
      }
    }
    async getTracksFromMediaElement(e) {
      if (this.audioTrack) return this.audioTrack;
      let t;
      try {
        e instanceof HTMLVideoElement &&
          (e.captureStream ? e.captureStream() : e.mozCaptureStream()),
          (t = this.context.createMediaStreamDestination());
        this.context.createMediaElementSource(e).connect(t);
      } catch (e) {
        throw new AU(zP.LOCAL_AEC_ERROR, e.toString()).print();
      }
      if (!t) {
        throw new AU(zP.LOCAL_AEC_ERROR, "no dest node when local aec").print();
      }
      const i = t.stream.getAudioTracks()[0];
      return (this.audioTrack = i), i;
    }
    getElement() {
      return this.element;
    }
    async startEchoCancellation() {
      this.context.resume(), this.peerPair && this.close(), this.initPeers();
      const e = this.element,
        t = await this.getTracksFromMediaElement(e);
      this.peerPair && this.peerPair[0].addTrack(t), await this.switchSdp();
    }
    close() {
      EU.debug("close echo cancellation unit, id is", this.id),
        this.audioPlayerElement && this.audioPlayerElement.pause(),
        this.peerPair &&
          this.peerPair.forEach(e => {
            e.close();
          }),
        (this.peerPair = void 0),
        (this.audioPlayerElement = void 0);
    }
  }
  var aY, oY;
  nY.count = 0;
  const cY = window.AudioContext || window.webkitAudioContext;
  new ((aY = RU({ report: yU })),
  JV(
    (oY = class {
      constructor() {
        (this.units = []), (this.context = void 0);
      }
      processExternalMediaAEC(e) {
        if (!this._doesEnvironmentNeedAEC())
          return EU.debug("the system does not need to process local aec"), -1;
        this.context || (this.context = new cY());
        let t = this.units.find(t => t && t.getElement() === e);
        return (
          t || ((t = new nY(e, this.context)), this.units.push(t)),
          t.startEchoCancellation(),
          EU.debug(
            "start processing local audio echo cancellation, id is",
            t.id
          ),
          t.id
        );
      }
      _doesEnvironmentNeedAEC() {
        return vP().name !== gP.SAFARI;
      }
    }).prototype,
    "processExternalMediaAEC",
    [aY],
    Object.getOwnPropertyDescriptor(oY.prototype, "processExternalMediaAEC"),
    oY.prototype
  ),
  oY)();
  const dY = window || document;
  function lY(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (!dY) return;
    const i = hY._cspEventHandlerPointer;
    if (i && t) return void console.error(i, t);
    const s = e => {
      if (
        !(
          e &&
          e.blockedURI &&
          (hY.onSecurityPolicyViolation ||
            hY.getListeners($G.SECURITY_POLICY_VIOLATION).length > 0)
        )
      )
        return;
      const t = e.blockedURI;
      WM("CSP_DETECTED_HOSTNAME_LIST").some(e => t.includes(e)) &&
        (hY.onSecurityPolicyViolation &&
          "function" == typeof hY.onSecurityPolicyViolation &&
          hY.onSecurityPolicyViolation(e),
        hY.getListeners($G.SECURITY_POLICY_VIOLATION).length > 0 &&
          hY.safeEmit($G.SECURITY_POLICY_VIOLATION, e));
    };
    i && dY.removeEventListener("securitypolicyviolation", i),
      (t ||
        (e && "function" == typeof e) ||
        hY.getListeners($G.SECURITY_POLICY_VIOLATION).length > 0) &&
        dY.addEventListener("securitypolicyviolation", s),
      (hY._cspEventHandlerPointer = s);
  }
  kM(),
    KM(
      "PROCESS_ID",
      "process-"
        .concat(Yk(8, ""), "-")
        .concat(Yk(4, ""), "-")
        .concat(Yk(4, ""), "-")
        .concat(Yk(4, ""), "-")
        .concat(Yk(12, ""))
    ),
    (function() {
      let e;
      try {
        e = window.localStorage.getItem("websdk_ng_global_parameter");
      } catch (e) {
        return void EU.error("Error loading sdk config", e.message);
      }
      if (e)
        try {
          const t = JSON.parse(window.atob(e)),
            i = Date.now();
          EU.debug("Loading global parameters from cache", t),
            Object.keys(t).forEach(e => {
              if (Object.prototype.hasOwnProperty.call(HM, e)) {
                const { value: s, expires: r } = t[e];
                if (r && r <= i) return;
                ($M[e] = s), (HM[e] = s);
              }
            });
        } catch (t) {
          EU.error("Error loading mutableParamsCache: ".concat(e), t.message);
        }
    })(),
    Array.isArray($M.AREAS) && $M.AREAS.length > 0 && hH($M.AREAS, !0);
  const hY = (function(e) {
    const t = new uk(),
      i = e,
      s = {
        getListeners: t.getListeners.bind(t),
        on: (e, i) => (
          (function(e, t) {
            e === $G.SECURITY_POLICY_VIOLATION && lY(t, !0);
          })(e, i),
          t.on.bind(t)(e, i)
        ),
        addListener: t.addListener.bind(t),
        once: t.once.bind(t),
        off: t.off.bind(t),
        removeAllListeners: t.removeAllListeners.bind(t),
        emit: t.emit.bind(t),
        safeEmit: t.safeEmit.bind(t)
      };
    return rG(rG({}, i), s);
  })({});
  Object.defineProperties(hY, {
    onAudioAutoplayFailed: {
      get: () => MF.onAudioAutoplayFailed,
      set: function(e) {
        MF.onAudioAutoplayFailed = e;
      }
    },
    onAutoplayFailed: {
      get: () => MF.onAutoplayFailed,
      set: function(e) {
        MF.onAutoplayFailed = e;
      }
    },
    _onSecurityPolicyViolation: { value: void 0, writable: !0 },
    _cspEventHandlerPointer: { value: void 0, writable: !0 },
    onSecurityPolicyViolation: {
      get: () => hY._onSecurityPolicyViolation,
      set(e) {
        (hY._onSecurityPolicyViolation = e), lY(e);
      }
    },
    __CLIENT_LIST__: { get: () => (WM("SHOW_GLOBAL_CLIENT_LIST") ? YV : []) }
  }),
    (hY.use = e => (
      (function(e) {
        (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) &&
          EU.debug("install service ".concat(e.name)),
          (qj[e.name] = e);
      })(e),
      hY
    )),
    PF.on(rF.CAMERA_DEVICE_CHANGED, e => {
      EU.info("camera device changed", JSON.stringify(e)),
        hY.onCameraChanged && hY.onCameraChanged(e),
        hY.safeEmit($G.CAMERA_CHANGED, e);
    }),
    PF.on(rF.RECORDING_DEVICE_CHANGED, e => {
      EU.info("microphone device changed", JSON.stringify(e)),
        hY.onMicrophoneChanged && hY.onMicrophoneChanged(e),
        hY.safeEmit($G.MICROPHONE_CHANGED, e);
    }),
    PF.on(rF.PLAYOUT_DEVICE_CHANGED, e => {
      EU.debug("playout device changed", JSON.stringify(e)),
        hY.onPlaybackDeviceChanged && hY.onPlaybackDeviceChanged(e),
        hY.safeEmit($G.PLAYBACK_DEVICE_CHANGED, e);
    }),
    (BF.onAutoplayFailed = () => {
      EU.info("detect audio element autoplay failed"),
        MF.onAudioAutoplayFailed && MF.onAudioAutoplayFailed();
    }),
    mF.on("autoplay-failed", () => {
      EU.info("detect webaudio autoplay failed"),
        MF.onAudioAutoplayFailed && MF.onAudioAutoplayFailed(),
        hY.safeEmit($G.AUTOPLAY_FAILED);
    }),
    mF.on(kx.STATE_CHANGE, (e, t) => {
      EU.info("audio context state changed: ".concat(t, " => ").concat(e)),
        hY.onAudioContextStateChanged && hY.onAudioContextStateChanged(e, t),
        hY.safeEmit($G.AUDIO_CONTEXT_STATE_CHANGED, e, t);
    }),
    window &&
      (window.__ARTC__ = {
        ESM_BUNDLER: true,
        ESM: false,
        UMD: false,
        DEV: false,
        AgoraRTC: hY,
        __TRACK_LIST__: Vx
      }),
    wk.on(Ik.NETWORK_STATE_CHANGE, (e, t) => {
      EU.info(
        "[network-indicator] network state changed, "
          .concat(t, " => ")
          .concat(e)
      );
    });
  const uY = (function(e) {
    const t = e ? [e] : [];
    return {
      debug: function() {
        for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++)
          i[s] = arguments[s];
        return EU.debug(...t, ...i);
      },
      info: function() {
        for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++)
          i[s] = arguments[s];
        return EU.info(...t, ...i);
      },
      warning: function() {
        for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++)
          i[s] = arguments[s];
        return EU.warn(...t, ...i);
      },
      warn: function() {
        for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++)
          i[s] = arguments[s];
        return EU.warn(...t, ...i);
      },
      error: function() {
        for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++)
          i[s] = arguments[s];
        return EU.error(...t, ...i);
      },
      log: function(e) {
        for (
          var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), r = 1;
          r < i;
          r++
        )
          s[r - 1] = arguments[r];
        return EU[e](...t, ...s);
      }
    };
  })("LivePlayer");
  uY.info("current fls.js: ", "v0.0.8-1(2025/3/28 15:40:54)");
  var pY = nr.includes;
  wi(
    {
      target: "Array",
      proto: !0,
      forced: r(function() {
        return !Array(1).includes();
      })
    },
    {
      includes: function(e) {
        return pY(this, e, arguments.length > 1 ? arguments[1] : void 0);
      }
    }
  );
  var fY = ls("Array", "includes"),
    EY = aO,
    mY = TypeError,
    gY = ft("match"),
    _Y = wi,
    TY = function(e) {
      if (EY(e)) throw new mY("The method doesn't accept regular expressions");
      return e;
    },
    SY = q,
    vY = ji,
    RY = function(e) {
      var t = /./;
      try {
        "/./"[e](t);
      } catch (i) {
        try {
          return (t[gY] = !1), "/./"[e](t);
        } catch (e) {}
      }
      return !1;
    },
    yY = l("".indexOf);
  _Y(
    { target: "String", proto: !0, forced: !RY("includes") },
    {
      includes: function(e) {
        return !!~yY(
          vY(SY(this)),
          vY(TY(e)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    }
  );
  var AY = ls("String", "includes"),
    IY = h,
    CY = fY,
    bY = AY,
    OY = Array.prototype,
    DY = String.prototype,
    wY = function(e) {
      var t = e.includes;
      return e === OY || (IY(OY, e) && t === OY.includes)
        ? CY
        : "string" == typeof e || e === DY || (IY(DY, e) && t === DY.includes)
        ? bY
        : t;
    },
    LY = s(wY);
  function NY() {
    return !!document
      .createElement("video")
      .canPlayType("application/vnd.apple.mpegurl");
  }
  let PY, kY, MY;
  function UY() {
    return vA.isSupported();
  }
  function xY() {
    return void 0 === PY && (PY = UY() || NY()), PY;
  }
  async function FY() {
    if (!BY()) return !1;
    if (void 0 === MY)
      try {
        const e = (
          await (async function() {
            let e = { audio: [], video: [] };
            try {
              let t = new RTCPeerConnection();
              const i = await (async function(e) {
                let t;
                return (
                  e.addTransceiver
                    ? (e.addTransceiver("video", { direction: "recvonly" }),
                      e.addTransceiver("audio", { direction: "recvonly" }),
                      (t = (await e.createOffer()).sdp))
                    : (t = (
                        await e.createOffer({
                          offerToReceiveAudio: !0,
                          offerToReceiveVideo: !0
                        })
                      ).sdp),
                  t
                );
              })(t);
              if (!i) return e;
              t.close(),
                (t = null),
                (e = (function(e) {
                  const t = { video: [], audio: [] };
                  return (
                    e.match(/ VP8/i) && t.video.push("VP8"),
                    e.match(/ VP9/i) && t.video.push("VP9"),
                    e.match(/ AV1/i) && t.video.push("AV1"),
                    e.match(/ H264/i) && t.video.push("H264"),
                    e.match(/ H265/i) && t.video.push("H265"),
                    e.match(/ opus/i) && t.audio.push("OPUS"),
                    e.match(/ PCMU/i) && t.audio.push("PCMU"),
                    e.match(/ PCMA/i) && t.audio.push("PCMA"),
                    e.match(/ G722/i) && t.audio.push("G722"),
                    t
                  );
                })(i));
            } catch (e) {
              throw new AU(
                zP.CREATE_OFFER_FAILED,
                e.toString && e.toString()
              ).print();
            }
            return e;
          })()
        ).video;
        uY.info("supported video codecs: ".concat(e.join(","))),
          (MY = LY(e).call(e, "H264"));
      } catch (e) {
        MY = !1;
      }
    return MY;
  }
  function BY() {
    return void 0 === kY && (kY = rY(!1)), kY;
  }
  function VY() {
    return navigator && void 0 !== navigator.onLine && !navigator.onLine;
  }
  function GY(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  const jY = vA.Events,
    HY = vA.ErrorTypes;
  class KY extends _m {
    constructor(t, i, s) {
      if (
        (super(),
        (this.mode = e.MediaSource.HLS),
        (this.url = void 0),
        (this.element = void 0),
        (this.hls = void 0),
        (this.recoverTimes = 0),
        (this.url = t),
        (this.element = i),
        (this.element.muted = !1),
        NY() && !UY())
      )
        return (this.element.src = t), void this.bindElementEvents();
      (s = s || {}),
        (this.hls = new vA(
          (function(e) {
            for (var t = 1; t < arguments.length; t++) {
              var i = null != arguments[t] ? arguments[t] : {};
              t % 2
                ? GY(Object(i), !0).forEach(function(t) {
                    gm(e, t, i[t]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(i)
                  )
                : GY(Object(i)).forEach(function(t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(i, t)
                    );
                  });
            }
            return e;
          })({}, s)
        )),
        this.bindEvents(),
        xY()
          ? (this.hls.loadSource(t), this.hls.attachMedia(i))
          : (this.destroy(),
            setTimeout(() => {
              this.safeEmit(RA.UNRECOVERABLE_ERROR, "not supported");
            }));
    }
    bindElementEvents() {
      (this.element.onsuspend = () => this.safeEmit(RA.READY_FOR_PLAY)),
        (this.element.oncanplay = () => this.safeEmit(RA.READY_FOR_PLAY)),
        (this.element.onerror = () => this.safeEmit(RA.ERROR));
    }
    unBindElementEvents() {
      (this.element.onsuspend = null),
        (this.element.oncanplay = null),
        (this.element.onerror = null);
    }
    bindEvents() {
      this.hls &&
        (this.hls.on(jY.MEDIA_ATTACHED, () => {
          (this.recoverTimes = 0),
            uY.debug("media attached"),
            (this.element.muted = !1);
        }),
        this.hls.on(jY.MANIFEST_PARSED, (e, t) => {
          uY.debug("manifest parsed");
        }),
        this.hls.on(jY.MANIFEST_LOADED, (e, t) => {
          uY.debug("manifest loaded, quality level: ".concat(t.levels.length)),
            this.safeEmit(RA.READY_FOR_PLAY);
        }),
        this.hls.on(jY.ERROR, (e, t) => {
          if (t.fatal)
            switch (
              (uY.warn(
                "hls media source error: ".concat(t.type, " ").concat(t.details)
              ),
              t.type)
            ) {
              case HY.MEDIA_ERROR:
                if (2 === this.recoverTimes) {
                  this.destroy(), this.safeEmit(RA.UNRECOVERABLE_ERROR, t);
                  break;
                }
                1 === this.recoverTimes &&
                  this.hls &&
                  this.hls.swapAudioCodec(),
                  this.hls && this.hls.recoverMediaError(),
                  this.recoverTimes++;
                break;
              case HY.NETWORK_ERROR:
                this.safeEmit(RA.ERROR, t);
                break;
              default:
                this.destroy(), this.safeEmit(RA.UNRECOVERABLE_ERROR, t);
            }
        }));
    }
    unBindEvents() {
      this.hls &&
        (this.hls.off(jY.MEDIA_ATTACHED),
        this.hls.off(jY.MANIFEST_PARSED),
        this.hls.off(jY.ERROR));
    }
    async play() {
      this.hls &&
        (this.hls.started || this.hls.startLoad(), this.hls.resumeBuffering());
      try {
        await this.element.play();
      } catch (e) {
        uY.warn("play error: ".concat(e.name, " ").concat(e.message)),
          "NotAllowedError" === e.name && this.safeEmit(RA.AUTOPLAY_PREVENTED);
      }
    }
    async pause(e) {
      this.element.pause(),
        this.hls && (e ? this.hls.stopLoad() : this.hls.pauseBuffering());
    }
    async retry() {
      this.switch(this.url);
    }
    async switch(e) {
      (this.url = e),
        this.hls
          ? this.hls.loadSource(e)
          : ((this.element.src = e), DP() && this.element.load());
    }
    setVolume(e) {
      (this.element.muted = e <= 0), (this.element.volume = e);
    }
    getVolume() {
      return this.element.volume;
    }
    async destroy() {
      this.hls
        ? ((this.recoverTimes = 0), this.hls.destroy(), this.unBindEvents())
        : ((this.element.src = ""), this.unBindElementEvents());
    }
  }
  const WY = () => {};
  function YY() {
    const e = {
      promise: void 0,
      isResolved: !1,
      isRejected: !1,
      isFinished: !1,
      resolve: void 0,
      reject: void 0,
      cancel: WY
    };
    return (
      (e.promise = new Ru((t, i) => {
        (e.resolve = i => {
          e.isFinished ||
            ((e.isResolved = !0), (e.isFinished = !0), t(i), (e.value = i));
        }),
          (e.reject = t => {
            e.isFinished || ((e.isRejected = !0), (e.isFinished = !0), i(t));
          });
      })),
      e
    );
  }
  function $Y(e) {
    const t = YY();
    return t.resolve(e), t;
  }
  const qY = {
    CDN_DOMAIN: "agorartcfob.sd-rtn.com",
    CDN_BACKUP_DOMAIN: "agorartcfoa.agoraio.cn",
    ENABLE_RTC_H264_CHECK: !0,
    NETWORK_POINTS: 3,
    VIDEO_DECODE_POINTS: 5,
    VIDEO_FROZEN_POINTS: 3,
    VIDEO_FROZEN_THRESHOLD: 0.6,
    VIDEO_FROZEN_RECOVERED_THRESHOLD: 0.2
  };
  function XY(e) {
    return qY[e];
  }
  const zY = /^rte:\/\/([^\/^\?]+)\/([^\/^\?]+)\/([^\/\?]+)(\?[^\?]+)?/,
    JY = /^rte:\/\/([^\/^\?]+)\/([^\/\?]+)(\?[^\?]+)?/,
    QY = /^https?:\/\/([^\/^\?]+)\/([^\/^\?]+)\/([^\/\|\?]+)\|([^\/]+)\.m3u8(\?[^\?]+)?/,
    ZY = /^https?:\/\/([^\/^\?]+)\/([^\/^\?]+)\/([^\/\|\?]+)\.m3u8(\?[^\?]+)?/;
  function e$(e) {
    if (n$(e)) return i$(e);
    if (a$(e)) return s$(e);
    throw new Error("unknown url: ".concat(e));
  }
  function t$(e) {
    const t = { token: null, uid: null };
    if (!e) return t;
    return (
      Array.from(e.match(/([^\/\?&]+)=([^\?&]+)/g) || []).forEach(e => {
        if (e.startsWith("token=")) return (t.token = e.split("token=")[1]);
        const i = e.startsWith("streamid=")
          ? Number(e.split("streamid=")[1])
          : e.startsWith("remoteUid=")
          ? Number(e.split("remoteUid=")[1])
          : void 0;
        if (null != i) return (t.streamid = isNaN(i) ? void 0 : i);
        const s = e.startsWith("uid=")
          ? e.split("uid=")[1]
          : e.startsWith("userUid=")
          ? e.split("userUid=")[1]
          : null;
        return s
          ? (t.uid = Number.isSafeInteger(Number(s)) ? Number(s) : s)
          : void 0;
      }),
      "null" === t.token && (t.token = null),
      "null" === t.uid && (t.uid = null),
      t
    );
  }
  function i$(e) {
    let t, i, s, r;
    if (
      (zY.test(e)
        ? ([, t, i, s, r] = Array.from(e.match(zY) || []))
        : ([, t, s, r] = Array.from(e.match(JY) || [])),
      !t || (!i && !s))
    )
      throw new Error("Invalid rtc url: ".concat(e));
    const n = {
        appid: t,
        appname: i,
        steamname: s,
        token: null,
        uid: null,
        cdnDomain: qY.CDN_DOMAIN
      },
      a = t$(r);
    return (n.token = a.token), (n.uid = a.uid), (n.streamid = a.streamid), n;
  }
  function s$(e) {
    let t, i, s, r, n;
    QY.test(e)
      ? ([, t, i, s, r, n] = Array.from(e.match(QY) || []))
      : ([, t, i, r, n] = Array.from(e.match(ZY) || [])),
      (r = decodeURIComponent(r)),
      !s && LY(r).call(r, "|") && ([s, r] = r.split("|"));
    const a = !(!t || !i || (!s && !r)),
      o = {
        cdnDomain: t || qY.CDN_DOMAIN,
        appid: i,
        appname: s,
        steamname: decodeURIComponent(r),
        token: null,
        uid: null,
        nonRteHlsURL: a ? void 0 : e
      };
    if (!a) return o;
    const c = t$(n);
    return (
      (o.token =
        "string" == typeof c.token ? decodeURIComponent(c.token) : c.token),
      (o.uid = c.uid),
      (o.streamid = c.streamid),
      o.uid || (o.nonRteHlsURL = e),
      o
    );
  }
  function r$(e) {
    if ("string" == typeof e) {
      if (n$(e)) return e;
      e = s$(e);
    }
    const t = e.appname
        ? "".concat(e.appname, "/").concat(e.steamname)
        : e.steamname,
      i = null != e.streamid ? "&streamid=".concat(e.streamid) : "";
    return "rte://"
      .concat(e.appid, "/")
      .concat(t, "?token=")
      .concat(e.token, "&uid=")
      .concat(e.uid)
      .concat(i);
  }
  function n$(e) {
    return /^rte:\/\//.test(e);
  }
  function a$(e) {
    return /^https?:\/\/.+\.m3u8/.test(e);
  }
  function o$(e) {
    if (e.nonRteHlsURL) return e.nonRteHlsURL;
    e.cdnDomain || (e.cdnDomain = qY.CDN_DOMAIN);
    const t = e.appname
        ? "".concat(e.appname, "|").concat(e.steamname)
        : e.steamname,
      i = encodeURIComponent(e.token || e.appid),
      s = null != e.streamid ? "&remoteUid=".concat(e.streamid) : "";
    return "https://"
      .concat(e.cdnDomain, "/")
      .concat(e.appid, "/")
      .concat(t, ".m3u8?token=")
      .concat(i, "&userUid=")
      .concat(e.uid)
      .concat(s);
  }
  class c$ extends _m {
    constructor(t, i, s) {
      super(),
        (this.mode = e.MediaSource.RTC),
        (this.url = void 0),
        (this.element = void 0),
        (this.rtcConfig = {
          mode: "live",
          codec: "h264",
          clientRoleOptions: { level: 1 }
        }),
        (this.rtc = void 0),
        (this.host = void 0),
        (this.channel = void 0),
        (this.streamid = void 0),
        (this.uid = void 0),
        (this.state = e.RtcSourceState.CREATING),
        (this.videoState = e.RtcMediaState.EMPTY),
        (this.audioState = e.RtcMediaState.EMPTY),
        (this.pendingRemoteUsers = []),
        (this.videoTrack = void 0),
        (this.audioTrack = void 0),
        (this.audioDefer = void 0),
        (this.videoDefer = void 0),
        (this.tryAutoRecover = !1),
        (this.onAutoplayFailed = async () => {
          if (!jP() || !window.WeixinJSBridge)
            return this.safeEmit(RA.AUTOPLAY_PREVENTED);
          window.WeixinJSBridge.invoke("getNetworkType", {}, async () => {
            try {
              uY.debug("resume autoplay-failed at wechat"),
                BF.autoResumeAfterInterruption(!0),
                await this.element.play();
            } catch (e) {
              uY.debug("resume autoplay-failed error: ", e && e.message),
                e &&
                  "NotAllowedError" === e.name &&
                  this.safeEmit(RA.AUTOPLAY_PREVENTED);
            }
          });
        }),
        (this.onUserJoined = async t => {
          !this.host && this.isStreamingHost(t)
            ? await this.playRemoteUser(t)
            : this.pendingRemoteUsers.push(t),
            this.safeEmit(e.RtcSourceEvent.USER_STATE_CHANGED, {
              state: e.RtcUserState.JOINED,
              user: t,
              isHost: this.host && this.host.uid === t.uid
            });
        }),
        (this.onUserLeft = async t => {
          this.safeEmit(e.RtcSourceEvent.USER_STATE_CHANGED, {
            state: e.RtcUserState.LEFT,
            user: t,
            isHost: this.host && this.host.uid === t.uid
          });
          const i = this.pendingRemoteUsers.findIndex(e => e.uid === t.uid);
          if (-1 !== i) return this.pendingRemoteUsers.splice(i, 1);
          let s;
          if (
            (this.host &&
              this.host.uid === t.uid &&
              (this.audioDefer && this.audioDefer.reject("user left"),
              this.videoDefer && this.videoDefer.reject("user left")),
            this.pendingRemoteUsers.length > 0)
          ) {
            const e =
              this.pendingRemoteUsers.findIndex(e => e.hasVideo) ||
              this.pendingRemoteUsers.findIndex(e => e.hasVideo) ||
              0;
            (s = this.pendingRemoteUsers[e]),
              this.pendingRemoteUsers.splice(e, 1);
          }
          s && !this.isStreamingHost(s) && (s = void 0), this.playRemoteUser(s);
        }),
        (this.onUserUnpublished = async (t, i) => {
          const s = this.host && this.host.uid === t.uid;
          this.safeEmit(e.RtcSourceEvent.USER_STATE_CHANGED, {
            state: e.RtcUserState.UNPUBLISHED,
            user: t,
            mediaType: i,
            isHost: s
          }),
            "video" === i &&
              s &&
              ((this.videoTrack = void 0),
              this.setVideoState(e.RtcMediaState.STOPPED),
              (this.videoDefer = YY()),
              this.playVideo().catch(() => {})),
            "audio" === i &&
              s &&
              ((this.audioTrack = void 0),
              this.setAudioState(e.RtcMediaState.STOPPED),
              (this.audioDefer = YY()),
              this.playAudio().catch(() => {}));
        }),
        (this.onUserPublished = async (t, i) => {
          const s = this.host && this.host.uid === t.uid;
          this.safeEmit(e.RtcSourceEvent.USER_STATE_CHANGED, {
            state: e.RtcUserState.PUBLISHED,
            user: t,
            mediaType: i,
            isHost: s
          }),
            s &&
              ("video" === i && this.videoDefer && this.videoDefer.resolve(),
              "audio" === i && this.audioDefer && this.audioDefer.resolve());
        }),
        null != s && (this.rtcConfig = s),
        (this.url = t),
        (this.element = i),
        this.create(),
        (hY.onAutoplayFailed = this.onAutoplayFailed),
        BY()
          ? qY.ENABLE_RTC_H264_CHECK &&
            FY().then(e => {
              e ||
                (this.destroy(),
                this.safeEmit(RA.UNRECOVERABLE_ERROR, "h264 not supported"));
            })
          : (this.destroy(),
            setTimeout(() => {
              this.safeEmit(RA.UNRECOVERABLE_ERROR, "not supported");
            }));
    }
    isStreamingHost(e) {
      return null == this.streamid || this.streamid === e.uid;
    }
    setState(t) {
      this.state !== t &&
        ((this.state = t), this.safeEmit(e.RtcSourceEvent.STATE_CHANGED, t));
    }
    setVideoState(t) {
      this.videoState !== t &&
        ((this.videoState = t),
        this.safeEmit(e.RtcSourceEvent.VIDEO_STATE_CHANGED, t));
    }
    setAudioState(t) {
      this.audioState !== t &&
        ((this.audioState = t),
        this.safeEmit(e.RtcSourceEvent.AUDIO_STATE_CHANGED, t));
    }
    async join() {
      this.setState(e.RtcSourceState.CONNECTING);
      const t = i$(this.url);
      (this.channel = t.appname
        ? "".concat(t.appname, "|").concat(t.steamname)
        : t.steamname),
        (this.streamid = t.streamid);
      try {
        const i = await this.rtc.join(t.appid, this.channel, t.token, t.uid);
        (this.uid = "number" == typeof i ? i : this.rtc.store.intUid),
          this.setState(e.RtcSourceState.CONNECTED);
      } catch (t) {
        this.setState(e.RtcSourceState.CONNECT_FAILED);
        if (!this.onRtcError(t)) throw t;
      }
      return (
        this.state === e.RtcSourceState.CONNECTED && this.bindEvents(),
        this.state === e.RtcSourceState.CONNECTED
      );
    }
    reset(t) {
      uY.debug("reset rtc for ".concat(t)),
        this.audioDefer &&
          !this.audioDefer.isFinished &&
          (this.audioDefer.reject(t), (this.audioDefer = void 0)),
        this.videoDefer &&
          !this.videoDefer.isFinished &&
          (this.videoDefer.reject(t), (this.videoDefer = void 0)),
        this.videoTrack &&
          (this.videoTrack.stop(),
          (this.videoTrack = void 0),
          this.host && this.rtc.unsubscribe(this.host, "video"),
          this.setVideoState(e.RtcMediaState.EMPTY)),
        this.audioTrack &&
          (this.audioTrack.stop(),
          (this.audioTrack = void 0),
          this.host && this.rtc.unsubscribe(this.host, "audio"),
          this.setAudioState(e.RtcMediaState.EMPTY)),
        (this.host = void 0),
        (this.pendingRemoteUsers = []),
        this.unbindEvent();
    }
    async recreate() {
      return (
        this.reset("switch url"), this.rtc && this.rtc.leave(), this.create()
      );
    }
    setVolume(e) {
      return (
        (e = Math.min(e, 1)),
        this.audioTrack ? (this.audioTrack.setVolume(100 * e), e) : -1
      );
    }
    getVolume() {
      return this.audioTrack ? this.audioTrack.getVolumeLevel() : -1;
    }
    async playAudio() {
      if (
        (this.host &&
          !this.host.hasAudio &&
          ((this.audioDefer && !this.audioDefer.isFinished) ||
            (this.audioDefer = YY()),
          await this.audioDefer.promise),
        this.host)
      )
        try {
          const t = await this.rtc.subscribe(this.host, "audio");
          this.host &&
            this.host.hasAudio &&
            ((this.audioTrack = t),
            this.audioTrack.play(),
            this.setAudioState(e.RtcMediaState.PLAYING));
        } catch (e) {
          if (!this.onRtcError(e)) throw e;
        }
    }
    async playVideo() {
      if (
        (this.host &&
          !this.host.hasVideo &&
          ((this.videoDefer && !this.videoDefer.isFinished) ||
            (this.videoDefer = YY()),
          await this.videoDefer.promise),
        this.host)
      )
        try {
          const t = await this.rtc.subscribe(this.host, "video");
          this.host &&
            this.host.hasVideo &&
            ((this.videoTrack = t),
            this.videoTrack.play(this.element, {
              fit: this.element.style.objectFit
            }),
            this.setVideoState(e.RtcMediaState.PLAYING));
        } catch (e) {
          if (!this.onRtcError(e)) throw e;
        }
    }
    async pauseAudio(t) {
      const i = this.audioState === e.RtcMediaState.PLAYING,
        s = this.audioState === e.RtcMediaState.PAUSED;
      if (this.audioTrack && this.host && (i || s))
        return (
          i && this.audioTrack.stop(),
          t
            ? (await this.rtc.unsubscribe(this.host, "audio"),
              this.setAudioState(e.RtcMediaState.STOPPED))
            : this.setAudioState(e.RtcMediaState.PAUSED)
        );
    }
    async pauseVideo(t) {
      const i = this.videoState === e.RtcMediaState.PLAYING,
        s = this.videoState === e.RtcMediaState.PAUSED;
      if (this.videoTrack && this.host && (i || s))
        return (
          i && this.videoTrack.stop(),
          t
            ? (await this.rtc.unsubscribe(this.host, "video"),
              this.setVideoState(e.RtcMediaState.STOPPED))
            : this.setVideoState(e.RtcMediaState.PAUSED)
        );
    }
    async playRemoteUser(t) {
      (!this.host || !t || this.host.uid !== t.uid) &&
        this.safeEmit(e.RtcSourceEvent.HOST_CHANGED, this.host, t),
        (this.host = t),
        this.host && this.safeEmit(RA.READY_FOR_PLAY);
    }
    onNetworkQuality(t) {
      this.safeEmit(e.RtcSourceEvent.NETWORK_QUALITY, t.downlinkNetworkQuality);
    }
    getNetworkQuality() {
      return VY()
        ? 6
        : this.state !== e.RtcSourceState.CONNECTED
        ? 0
        : this.rtc.getNetworkQuality().downlinkNetworkQuality;
    }
    bindEvents() {
      this.rtc.on("user-published", this.onUserPublished),
        this.rtc.on("user-unpublished", this.onUserUnpublished),
        this.rtc.on("user-joined", this.onUserJoined),
        this.rtc.on("user-left", this.onUserLeft),
        this.rtc.on("network-quality", this.onNetworkQuality);
    }
    unbindEvent() {
      this.rtc.off("user-published", this.onUserPublished),
        this.rtc.off("user-unpublished", this.onUserUnpublished),
        this.rtc.off("user-joined", this.onUserJoined),
        this.rtc.off("user-left", this.onUserLeft),
        this.rtc.off("network-quality", this.onNetworkQuality);
    }
    onRtcError(e) {
      var t;
      let i =
        e &&
        LY(
          (t = [
            "INVALID_OPERATION",
            "UNEXPECTED_ERROR",
            "NO_ACTIVE_STATUS",
            "INVALID_UINT_UID_FROM_STRING_UID",
            "CAN_NOT_GET_GATEWAY_SERVER",
            "UNEXPECTED_RESPONSE"
          ])
        ).call(t, e.code);
      return (
        "UNEXPECTED_ERROR" === e.code &&
          "can not find remote track in user object" === e.message &&
          (i = !1),
        i && this.safeEmit(RA.UNRECOVERABLE_ERROR, e),
        i
      );
    }
    async retry() {
      return this.reset("retry"), this.rtc.leave(), this.join();
    }
    async pause(e) {
      await Ru.all([this.pauseAudio(e), this.pauseVideo(e)]);
    }
    async play() {
      let t = !1;
      if (
        (this.videoTrack &&
          this.videoState === e.RtcMediaState.PAUSED &&
          (this.videoTrack.play(this.element, {
            fit: this.element.style.objectFit
          }),
          this.setVideoState(e.RtcMediaState.PLAYING)),
        this.audioTrack &&
          this.audioState === e.RtcMediaState.PAUSED &&
          (this.audioTrack.play(), this.setAudioState(e.RtcMediaState.PLAYING)),
        (t =
          this.videoState === e.RtcMediaState.PLAYING ||
          this.audioState === e.RtcMediaState.PLAYING),
        !t)
      ) {
        if (
          (this.state === e.RtcSourceState.CONNECT_FAILED &&
            (await this.join()),
          this.state === e.RtcSourceState.CONNECT_FAILED)
        ) {
          const e = "play failed: ".concat(
            this.host ? "join failed" : "no host"
          );
          uY.warn(e);
          const t = new Error(e);
          throw (this.safeEmit(RA.ERROR, t), t);
        }
        this.host && (await this.playRemoteUser(this.host));
      }
    }
    async switch(e) {
      e !== this.url && ((this.url = e), await this.recreate());
    }
    async create() {
      this.setState(e.RtcSourceState.CREATING),
        this.setAudioState(e.RtcMediaState.EMPTY),
        this.setVideoState(e.RtcMediaState.EMPTY),
        (this.rtc = iY(this.rtcConfig)),
        this.setState(e.RtcSourceState.CREATED),
        await this.join();
    }
    getStats() {
      if (this.rtc && this.host)
        return {
          audio: this.rtc.getRemoteAudioStats()[this.host.uid],
          video: this.rtc.getRemoteVideoStats()[this.host.uid]
        };
    }
    async destroy() {
      hY.off("autoplay-failed", this.onAutoplayFailed),
        this.reset("destroy"),
        this.setState(e.RtcSourceState.DESTROYED),
        this.rtc &&
          (await this.rtc.leave().catch(e => {
            uY.warn("leave rtc failed: ".concat(e));
          }));
    }
  }
  function d$(e, t) {
    return { source: e, error: t };
  }
  var l$ = Le,
    h$ = Je,
    u$ = K,
    p$ = er,
    f$ = TypeError,
    E$ = "Reduce of empty array with no initial value",
    m$ = function(e) {
      return function(t, i, s, r) {
        var n = h$(t),
          a = u$(n),
          o = p$(n);
        if ((l$(i), 0 === o && s < 2)) throw new f$(E$);
        var c = e ? o - 1 : 0,
          d = e ? -1 : 1;
        if (s < 2)
          for (;;) {
            if (c in a) {
              (r = a[c]), (c += d);
              break;
            }
            if (((c += d), e ? c < 0 : o <= c)) throw new f$(E$);
          }
        for (; e ? c >= 0 : o > c; c += d) c in a && (r = i(r, a[c], c, n));
        return r;
      };
    },
    g$ = { left: m$(!1), right: m$(!0) },
    _$ = r,
    T$ = g$.left,
    S$ = function(e, t) {
      var i = [][e];
      return (
        !!i &&
        _$(function() {
          i.call(
            null,
            t ||
              function() {
                return 1;
              },
            1
          );
        })
      );
    };
  wi(
    {
      target: "Array",
      proto: !0,
      forced: (!Go && Ee > 79 && Ee < 83) || !S$("reduce")
    },
    {
      reduce: function(e) {
        var t = arguments.length;
        return T$(this, e, t, t > 1 ? arguments[1] : void 0);
      }
    }
  );
  var v$,
    R$,
    y$,
    A$,
    I$ = ls("Array", "reduce"),
    C$ = h,
    b$ = I$,
    O$ = Array.prototype,
    D$ = function(e) {
      var t = e.reduce;
      return e === O$ || (C$(O$, e) && t === O$.reduce) ? b$ : t;
    },
    w$ = s(D$);
  function L$(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t &&
        (s = s.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  (e.MediaPlayState = void 0),
    ((v$ = e.MediaPlayState || (e.MediaPlayState = {})).PENDING = "pending"),
    (v$.PLAYING = "playing"),
    (v$.PAUSED = "paused"),
    (v$.STOPPED = "stopped"),
    (e.PlayerEvent = void 0),
    ((R$ = e.PlayerEvent || (e.PlayerEvent = {})).RTC_USER_STATE_CHANGED =
      "rtc-user-state-changed"),
    (R$.RTC_SOURCE_STATE_CHANGED = "rtc-source-state-changed"),
    (R$.RTC_HOST_CHANGED = "rtc-host-changed"),
    (R$.RTC_MEDIA_CHANGED = "rtc-media-changed"),
    (R$.RTC_EVENTS = "rtc-events"),
    (R$.PLAY_STATE_CHANGED = "play-state-changed"),
    (R$.BEFORE_MEDIA_SOURCE_CHANGE = "before-media-source-change"),
    (R$.MEDIA_SOURCE_CHANGED = "media-source-changed"),
    (R$.AUTOPLAY_PREVENTED = "autoplay-prevented"),
    (R$.NETWORK_QUALITY = "network-quality"),
    (R$.VIDEO_EVENTS = "video-events"),
    (R$.ERROR = "error"),
    (R$.REQUEST_SWITCH_MEDIA_SOURCE = "request-switch-media-source"),
    (e.RtcEvent = void 0),
    ((y$ = e.RtcEvent || (e.RtcEvent = {}))[(y$.NETWORK_EXCEPTION = 1001)] =
      "NETWORK_EXCEPTION"),
    (y$[(y$.NETWORK_EXCEPTION_RECOVERED = 1002)] =
      "NETWORK_EXCEPTION_RECOVERED"),
    (y$[(y$.VIDEO_DECODED_FAILED = 1003)] = "VIDEO_DECODED_FAILED"),
    (y$[(y$.VIDEO_DECODED_RECOVERED = 1004)] = "VIDEO_DECODED_RECOVERED"),
    (y$[(y$.VIDEO_FROZEN = 1005)] = "VIDEO_FROZEN"),
    (y$[(y$.VIDEO_FROZEN_RECOVERED = 1006)] = "VIDEO_FROZEN_RECOVERED"),
    (e.PlayerErrorCode = void 0),
    ((e.PlayerErrorCode || (e.PlayerErrorCode = {})).TIMEOUT = "TIMEOUT"),
    (function(e) {
      e.EXCEPTION_EVENTS = "exception-events";
    })(A$ || (A$ = {}));
  class N$ extends _m {
    constructor() {
      super(...arguments),
        (this.result = {}),
        (this.prevResult = {}),
        (this.networkStateList = []),
        (this.videoDecodeStateList = []),
        (this.videoFrozenStateList = []),
        (this.isFirstFrameDecoded = !1);
    }
    record(e) {
      (this.prevResult = (function(e) {
        for (var t = 1; t < arguments.length; t++) {
          var i = null != arguments[t] ? arguments[t] : {};
          t % 2
            ? L$(Object(i), !0).forEach(function(t) {
                gm(e, t, i[t]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i))
            : L$(Object(i)).forEach(function(t) {
                Object.defineProperty(
                  e,
                  t,
                  Object.getOwnPropertyDescriptor(i, t)
                );
              });
        }
        return e;
      })({}, this.result)),
        this.checkException(e);
    }
    checkException(t) {
      if (VY())
        return (
          (this.networkStateList.length = 0),
          (this.videoDecodeStateList.length = 0),
          (this.videoFrozenStateList.length = 0),
          (this.isFirstFrameDecoded = !1),
          void (
            this.prevResult.isNetworkException ||
            (uY.debug("network exception: offline"),
            (this.result.isNetworkException = !0),
            this.safeEmit(A$.EXCEPTION_EVENTS, e.RtcEvent.NETWORK_EXCEPTION))
          )
        );
      const {
        downlinkNetwork: i,
        decodeFrameRate: s,
        receiveBitrate: r,
        receiveFrameRate: n
      } = t;
      (s || 0) > 0 &&
        !this.isFirstFrameDecoded &&
        ((this.isFirstFrameDecoded = !0), uY.debug("first frame decoded"));
      const a = null == i ? -1 : this.checkNetworkException(i);
      if (1 === a)
        return this.safeEmit(A$.EXCEPTION_EVENTS, e.RtcEvent.NETWORK_EXCEPTION);
      if (0 === a)
        return this.safeEmit(
          A$.EXCEPTION_EVENTS,
          e.RtcEvent.NETWORK_EXCEPTION_RECOVERED
        );
      const o =
        null == r || null == s
          ? -1
          : this.checkVideoDecodeFailedException(r, s);
      if (1 === o)
        return this.safeEmit(
          A$.EXCEPTION_EVENTS,
          e.RtcEvent.VIDEO_DECODED_FAILED
        );
      if (0 === o)
        return this.safeEmit(
          A$.EXCEPTION_EVENTS,
          e.RtcEvent.VIDEO_DECODED_RECOVERED
        );
      const c =
        this.isFirstFrameDecoded && null != n && null != s
          ? this.checkVideoFrozenException(n, s)
          : -1;
      return 1 === c
        ? this.safeEmit(A$.EXCEPTION_EVENTS, e.RtcEvent.VIDEO_FROZEN)
        : 0 === c
        ? this.safeEmit(A$.EXCEPTION_EVENTS, e.RtcEvent.VIDEO_FROZEN_RECOVERED)
        : void 0;
    }
    checkNetworkException(e) {
      const t = XY("NETWORK_POINTS");
      this.networkStateList.length >= t && this.networkStateList.pop();
      const i = this.prevResult.isNetworkException,
        s = 5 === e || 6 === e;
      if (
        (this.networkStateList.unshift(s), this.networkStateList.length >= t)
      ) {
        const e = this.networkStateList.every(e => e);
        if (((this.result.isNetworkException = e), !i && e))
          return uY.debug("network exception"), 1;
        if (i && !e) return uY.debug("network exception recovered"), 0;
      }
      return -1;
    }
    checkVideoDecodeFailedException(e, t) {
      const i = XY("VIDEO_DECODE_POINTS");
      this.videoDecodeStateList.length >= i && this.videoDecodeStateList.pop();
      const s = this.prevResult.isVideoDecodeFailed,
        r = e > 0 && 0 === t;
      if (
        (this.videoDecodeStateList.unshift(r),
        this.videoDecodeStateList.length >= i)
      ) {
        const e = this.videoDecodeStateList.every(e => e);
        if (((this.result.isVideoDecodeFailed = e), !s && e))
          return uY.debug("video decode failed"), 1;
        if (s && !e) return uY.debug("video decode failed recovered"), 0;
      }
      return -1;
    }
    checkVideoFrozenException(e, t) {
      const i = XY("VIDEO_FROZEN_POINTS");
      this.videoFrozenStateList.length >= i && this.videoFrozenStateList.pop();
      const s = this.prevResult.isVideoFrozen,
        r = e <= 5 || t <= 5;
      if (
        (this.videoFrozenStateList.unshift(r),
        this.videoFrozenStateList.length >= i)
      ) {
        var n;
        const e = 1 === i ? 1 : 1 / (2 * i),
          t = 1 === i ? 0 : 1 / (i * (i - 1)),
          r = w$((n = this.videoFrozenStateList)).call(
            n,
            (s, r, n) => s + (r ? 1 : 0) * (e + t * (i - 1 - n)),
            0
          );
        let a = s;
        if (
          (s && r <= XY("VIDEO_FROZEN_RECOVERED_THRESHOLD") && (a = !1),
          !s && r >= XY("VIDEO_FROZEN_THRESHOLD") && (a = !0),
          (this.result.isVideoFrozen = a),
          !s && a)
        )
          return uY.debug("video frozen, videoFrozenRate:", r), 1;
        if (s && !a)
          return uY.debug("video frozen recovered, videoFrozenRate:", r), 0;
      }
      return -1;
    }
    clear() {
      uY.debug("clear exception manager data"),
        (this.isFirstFrameDecoded = !1),
        (this.result = {}),
        (this.networkStateList = []),
        (this.videoDecodeStateList = []),
        (this.videoFrozenStateList = []);
    }
  }
  function P$(e) {
    let { el: t, width: i, height: s, aspectRatio: r, objectFit: n } = e;
    const a =
      "string" == typeof t
        ? document.getElementById(t)
        : t || document.createElement("video");
    if (!a || "VIDEO" !== a.tagName)
      throw new Error("Invalid video element: ".concat(t));
    return (
      (a.style.width = null == i ? "" : "".concat(i, "px")),
      (a.style.height = null == i ? "" : "".concat(s, "px")),
      (a.style.aspectRatio = null == r ? "" : "".concat(r)),
      a.setAttribute("playsinline", "true"),
      a.setAttribute("webkit-playsinline", "true"),
      a.setAttribute("x5-playsinline", "true"),
      a.setAttribute("mediatype", "video"),
      (a.style.objectFit = n || "cover"),
      a
    );
  }
  class k$ extends _m {
    get codec() {
      const e = this.getStats();
      return {
        video: e && e.video && e.video.codecType,
        audio: e && e.audio && e.audio.codecType
      };
    }
    set playState(t) {
      t !== this._playState &&
        (uY.debug(
          "play state change: ".concat(this._playState, " => ").concat(t)
        ),
        this.safeEmit(e.PlayerEvent.PLAY_STATE_CHANGED, t, this._playState),
        (this._playState = t));
    }
    get playState() {
      return this._playState;
    }
    get isPlaying() {
      return this.playState === e.MediaPlayState.PLAYING;
    }
    get isPaused() {
      return this.playState === e.MediaPlayState.PAUSED;
    }
    get isStopped() {
      return this.playState === e.MediaPlayState.STOPPED;
    }
    constructor(t) {
      var i;
      if (
        (super(),
        (this.source = void 0),
        (this.element = void 0),
        (this.options = void 0),
        (this.urlInfo = void 0),
        (this.autoSwitchHLS = !0),
        (this.isMirror = !1),
        (this.volume = void 0),
        (this.timeout = void 0),
        (this.timeoutTrigger = void 0),
        (this.playDefer = $Y(!1)),
        (this.pauseDefer = $Y(!1)),
        (this.retryDefer = $Y(!1)),
        (this.switchUrlDefer = $Y(!1)),
        (this.switchSourceDefer = $Y(!1)),
        (this._playState = e.MediaPlayState.STOPPED),
        (this._userIntent = { isPausing: !1, isStopping: !1, isPlaying: !1 }),
        (this.exceptionManager = new N$()),
        (this.exceptionTimer = void 0),
        (this.lastTimeUpdate = 0),
        (this.handleVideoEvents = t => {
          const i = t.type;
          switch (i) {
            case "playing":
              (this.playState = e.MediaPlayState.PLAYING),
                this.playDefer.isFinished || this.playDefer.resolve(!0),
                (this._userIntent = {
                  isPausing: !1,
                  isStopping: !1,
                  isPlaying: !0
                }),
                (this.lastTimeUpdate = this.element.currentTime);
              break;
            case "pause":
              this.playState !== e.MediaPlayState.STOPPED &&
                (this._userIntent.isPausing
                  ? (this.playState = e.MediaPlayState.PAUSED)
                  : this._userIntent.isPlaying);
              break;
            case "ended":
              this._userIntent.isStopping
                ? (this.playState = e.MediaPlayState.STOPPED)
                : this._userIntent.isPausing &&
                  (this.playState = e.MediaPlayState.PAUSED);
              break;
            case "timeupdate":
              if (this.playState === e.MediaPlayState.PLAYING) {
                const e = this.element.currentTime;
                e !== this.lastTimeUpdate &&
                  ((this.lastTimeUpdate = e),
                  this.clearTimeoutTrigger(),
                  this.setupTimeoutTrigger());
              }
          }
          this.emit(e.PlayerEvent.VIDEO_EVENTS, i, t);
        }),
        uY.info("compatibility: rtc ".concat(BY(), ", hls: ").concat(xY())),
        !BY() && !xY())
      )
        throw new Error("Not support RTC and HLS!");
      !BY() &&
        t.autoSwitchHLS &&
        (uY.warn("Not support RTC, auto fallback to HLS."),
        (t.defaultUseHLS = !0)),
        (this.options = t),
        null != t.autoSwitchHLS && (this.autoSwitchHLS = !!t.autoSwitchHLS),
        t.autoplay && (this.playState = e.MediaPlayState.PENDING),
        (this.element = P$(t)),
        this.bindVideoEvents();
      const s = ms((i = t.url)).call(i);
      if (
        ((this.urlInfo = e$(s)),
        t.defaultUseHLS && !this.urlInfo.nonRteHlsURL && !this.urlInfo.uid)
      )
        throw new Error(
          "Invalid url: uid is required when use hls as default."
        );
      this.urlInfo.nonRteHlsURL &&
        uY.info("non standard rte hls url: ".concat(this.urlInfo.nonRteHlsURL)),
        "number" == typeof t.timeout &&
          ((this.timeout = t.timeout),
          this.on(e.PlayerEvent.PLAY_STATE_CHANGED, t => {
            t === e.MediaPlayState.PENDING
              ? this.setupTimeoutTrigger()
              : (t !== e.MediaPlayState.PLAYING &&
                  t !== e.MediaPlayState.PAUSED &&
                  t !== e.MediaPlayState.STOPPED) ||
                this.clearTimeoutTrigger();
          }),
          this._playState === e.MediaPlayState.PENDING &&
            this.setupTimeoutTrigger()),
        (this.source =
          t.defaultUseHLS || a$(s)
            ? new KY(o$(this.urlInfo), this.element, t.hlsConfig)
            : new c$(r$(this.urlInfo), this.element, t.rtcConfig)),
        this.mirror(!!t.mirror),
        this.bindMediaEvents(),
        this.bindEvents();
    }
    bindMediaEvents() {
      "rtc" === this.source.mode &&
        (this.source.on(e.RtcSourceEvent.AUDIO_STATE_CHANGED, t => {
          this.safeEmit(e.PlayerEvent.RTC_MEDIA_CHANGED, {
            type: "audio",
            state: t
          });
        }),
        this.source.on(e.RtcSourceEvent.VIDEO_STATE_CHANGED, t => {
          this.safeEmit(e.PlayerEvent.RTC_MEDIA_CHANGED, {
            type: "video",
            state: t
          }),
            t === e.RtcMediaState.PLAYING && this.startMonitorException(),
            (t !== e.RtcMediaState.STOPPED && t !== e.RtcMediaState.EMPTY) ||
              this.stopMonitorException();
        }),
        this.source.on(e.RtcSourceEvent.STATE_CHANGED, t => {
          t === e.RtcSourceState.CONNECTED &&
            (this.urlInfo.uid = this.source.uid || this.urlInfo.uid),
            this.safeEmit(e.PlayerEvent.RTC_SOURCE_STATE_CHANGED, t);
        }),
        this.source.on(e.RtcSourceEvent.HOST_CHANGED, (t, i) => {
          this.safeEmit(e.PlayerEvent.RTC_HOST_CHANGED, i, t);
        }),
        this.source.on(e.RtcSourceEvent.USER_STATE_CHANGED, t => {
          this.safeEmit(e.PlayerEvent.RTC_USER_STATE_CHANGED, t);
        }),
        this.source.rtc.on(e.RtcSourceEvent.NETWORK_QUALITY, t => {
          this.safeEmit(e.PlayerEvent.NETWORK_QUALITY, t);
        })),
        this.source.mode,
        this.source.on(RA.AUTOPLAY_PREVENTED, () => {
          this.safeEmit(e.PlayerEvent.AUTOPLAY_PREVENTED);
        }),
        this.source.on(RA.ERROR, t => {
          if (
            (uY.warning(
              "error: "
                .concat(t.message || t.details, " at ")
                .concat(this.source.mode, " mode.")
            ),
            "hls" === this.source.mode)
          ) {
            const e = this.urlInfo.cdnDomain;
            if (e !== qY.CDN_BACKUP_DOMAIN) {
              const t =
                e === qY.CDN_DOMAIN ? qY.CDN_BACKUP_DOMAIN : qY.CDN_DOMAIN;
              return (
                (this.urlInfo.cdnDomain = t), this.switchURL(o$(this.urlInfo))
              );
            }
          }
          this.safeEmit(e.PlayerEvent.ERROR, d$(this.source.mode, t));
        }),
        this.source.on(RA.READY_FOR_PLAY, async () => {
          uY.info(
            "ready for play, current play state: ".concat(this._playState)
          ),
            this.isPaused || this.isStopped
              ? "hls" === this.source.mode && this.source.pause(this.isStopped)
              : ("rtc" === this.source.mode
                  ? await Ru.all([
                      this.source.playAudio(),
                      this.source.playVideo()
                    ])
                      .then(() => {})
                      .catch(e => {
                        uY.warning("play abort: ".concat(e, " at rtc mode."));
                      })
                  : await this.source.play(),
                null != this.volume && this.source.setVolume(this.volume));
        }),
        this.source.on(RA.UNRECOVERABLE_ERROR, t => {
          uY.warning(
            "unrecoverable error: "
              .concat(t.message || t.details || t, " at ")
              .concat(this.source.mode, " mode.")
          );
          const i = "rtc" === this.source.mode,
            s = "hls" === this.source.mode,
            r = i ? e.MediaSource.HLS : e.MediaSource.RTC;
          i && this.autoSwitchHLS && xY()
            ? this.switchMediaSource(r)
            : s && this.urlInfo.cdnDomain !== qY.CDN_BACKUP_DOMAIN && xY()
            ? ((this.urlInfo.cdnDomain = qY.CDN_BACKUP_DOMAIN),
              this.unbindMediaEvents(),
              (this.source = new KY(
                o$(this.urlInfo),
                this.element,
                this.options.hlsConfig
              )),
              this.bindMediaEvents())
            : this.safeEmit(e.PlayerEvent.REQUEST_SWITCH_MEDIA_SOURCE, r);
        });
    }
    bindVideoEvents() {
      M$.forEach(e => {
        this.element.addEventListener(e, this.handleVideoEvents);
      });
    }
    unbindVideoEvents() {
      M$.forEach(e => {
        this.element.removeEventListener(e, this.handleVideoEvents);
      });
    }
    unbindMediaEvents() {
      "rtc" === this.source.mode &&
        (this.source.removeAllListeners(e.RtcSourceEvent.AUDIO_STATE_CHANGED),
        this.source.removeAllListeners(e.RtcSourceEvent.VIDEO_STATE_CHANGED),
        this.source.removeAllListeners(e.RtcSourceEvent.STATE_CHANGED),
        this.source.removeAllListeners(e.RtcSourceEvent.HOST_CHANGED),
        this.source.removeAllListeners(e.RtcSourceEvent.USER_STATE_CHANGED),
        this.source.removeAllListeners(e.RtcSourceEvent.NETWORK_QUALITY)),
        this.source.mode,
        this.source.removeAllListeners(RA.AUTOPLAY_PREVENTED),
        this.source.removeAllListeners(RA.ERROR),
        this.source.removeAllListeners(RA.READY_FOR_PLAY),
        this.source.removeAllListeners(RA.UNRECOVERABLE_ERROR);
    }
    bindEvents() {
      this.exceptionManager.on(A$.EXCEPTION_EVENTS, t => {
        this.safeEmit(e.PlayerEvent.RTC_EVENTS, t);
      });
    }
    unbindEvents() {
      this.exceptionManager.removeAllListeners(A$.EXCEPTION_EVENTS);
    }
    async play() {
      if (
        (await Ru.all([
          this.playDefer.promise,
          this.switchUrlDefer.promise,
          this.pauseDefer.promise
        ]),
        this.playState === e.MediaPlayState.PLAYING)
      )
        return;
      this.playDefer = YY();
      const t = this.playState;
      try {
        return (
          (this._userIntent.isPlaying = !0),
          (this._userIntent.isPausing = !1),
          (this._userIntent.isStopping = !1),
          this.playState !== e.MediaPlayState.PENDING &&
            (this.playState = e.MediaPlayState.PENDING),
          await this.source.play(),
          this.playDefer.promise
        );
      } catch (e) {
        throw (uY.warn("play error: ".concat(e)),
        (this.playState = t),
        this.playDefer.reject(e),
        e);
      }
    }
    async pause(t) {
      if (
        (await Ru.all([
          this.switchUrlDefer.promise,
          this.pauseDefer.promise,
          this.playDefer.promise
        ]),
        !((this.isPaused && !t) || this.isStopped))
      ) {
        this.pauseDefer = YY();
        try {
          (this._userIntent.isPausing = !t),
            (this._userIntent.isStopping = !!t),
            (this._userIntent.isPlaying = !1),
            await this.source.pause(t),
            t
              ? (this.playState = e.MediaPlayState.STOPPED)
              : this.playState !== e.MediaPlayState.STOPPED &&
                (this.playState = e.MediaPlayState.PAUSED);
        } catch (e) {
          uY.warn("pause error: ".concat(e));
        } finally {
          this.pauseDefer.resolve(!0);
        }
      }
    }
    async retry() {
      await Ru.all([
        this.playDefer.promise,
        this.pauseDefer.promise,
        this.switchUrlDefer.promise,
        this.retryDefer.promise
      ]),
        (this.retryDefer = YY());
      try {
        this.playState === e.MediaPlayState.PLAYING &&
          (this.playState = e.MediaPlayState.PENDING),
          uY.info("retry at ".concat(this.source.mode, " mode")),
          await this.source.retry();
      } catch (e) {
        uY.warn("retry error: ".concat(e));
      } finally {
        this.retryDefer.resolve(!0);
      }
    }
    async switchURL(t) {
      if (
        (await this.switchUrlDefer.promise,
        (t = ms(t).call(t)) !== this.options.url)
      ) {
        this.switchUrlDefer = YY();
        try {
          uY.info("switch url to ".concat(t)),
            (this.options.url = t),
            (this.urlInfo = e$(t));
          const i = this.playState === e.MediaPlayState.PLAYING;
          this.playState === e.MediaPlayState.PLAYING &&
            (this.playState = e.MediaPlayState.PENDING),
            "rtc" === this.source.mode && n$(t)
              ? await this.source.switch(r$(this.urlInfo))
              : "hls" === this.source.mode && a$(t)
              ? await this.source.switch(o$(this.urlInfo))
              : n$(t)
              ? await this.switchMediaSource(e.MediaSource.RTC)
              : a$(t)
              ? await this.switchMediaSource(e.MediaSource.HLS)
              : uY.warn("unknown url: ".concat(t)),
            i && (await this.play());
        } catch (e) {
          uY.warn("switchURL error: ".concat(e, ", url: ").concat(t));
        } finally {
          this.switchUrlDefer.resolve(!0);
        }
      }
    }
    async switchMediaSource(t) {
      const i = this.source.mode;
      i !== t &&
        (i !== e.MediaSource.RTC || "VP8" !== this.codec.video
          ? this.urlInfo.nonRteHlsURL
            ? uY.warn("can't switch to rtc when hls is not rte standard")
            : (this.safeEmit(e.PlayerEvent.BEFORE_MEDIA_SOURCE_CHANGE, t),
              this.playState === e.MediaPlayState.PLAYING &&
                (this.playState = e.MediaPlayState.PENDING),
              await this.source.destroy(),
              this.unbindMediaEvents(),
              "hls" === t
                ? (MP(14, 6, !0) && this.replaceNewVideoElement(),
                  (this.source = new KY(
                    o$(this.urlInfo),
                    this.element,
                    this.options.hlsConfig
                  )))
                : (this.source = new c$(
                    r$(this.urlInfo),
                    this.element,
                    this.options.rtcConfig
                  )),
              this.bindMediaEvents(),
              uY.debug("media source change to ".concat(this.source.mode)),
              this.safeEmit(
                e.PlayerEvent.MEDIA_SOURCE_CHANGED,
                this.source.mode
              ))
          : uY.warn("can't switch to hls when codec is VP8"));
    }
    mirror(e) {
      (this.isMirror = null != e ? e : !this.isMirror),
        (this.element.style.transform = "rotateY(".concat(
          this.isMirror ? 180 : 0,
          "deg)"
        ));
    }
    async destroy() {
      await this.source.destroy(),
        this.unbindMediaEvents(),
        this.unbindEvents(),
        (this.playState = e.MediaPlayState.STOPPED),
        !this.playDefer.isFinished && this.playDefer.reject(!1),
        !this.pauseDefer.isFinished && this.pauseDefer.reject(!1),
        !this.retryDefer.isFinished && this.retryDefer.reject(!1),
        !this.switchUrlDefer.isFinished && this.switchUrlDefer.reject(!1),
        !this.switchSourceDefer.isFinished && this.switchSourceDefer.reject(!1),
        (this.pauseDefer = $Y(!1)),
        (this.retryDefer = $Y(!1)),
        (this.playDefer = $Y(!1)),
        (this.switchUrlDefer = $Y(!1));
    }
    setVolume(e) {
      e > 1 && (e = 1),
        e < 0 && (e = 0),
        (this.volume = e),
        this.source.setVolume(e);
    }
    getVolume() {
      return this.source.getVolume();
    }
    getNetworkQuality() {
      return this.source.mode !== e.MediaSource.RTC
        ? 0
        : this.source.getNetworkQuality();
    }
    startMonitorException() {
      if (this.exceptionTimer) return;
      const e = () => {
        const e = this.getStats(),
          t = this.getNetworkQuality();
        e &&
          this.exceptionManager.record({
            downlinkNetwork: t,
            receiveBitrate: e.video && e.video.receiveBitrate,
            receiveFrameRate: e.video && e.video.receiveFrameRate,
            decodeFrameRate: e.video && e.video.decodeFrameRate
          });
      };
      e(), (this.exceptionTimer = window.setInterval(e, 1e3));
    }
    stopMonitorException() {
      this.exceptionTimer &&
        (window.clearInterval(this.exceptionTimer),
        (this.exceptionTimer = void 0),
        this.exceptionManager.clear());
    }
    getStats() {
      if (this.source.mode === e.MediaSource.RTC && this.source.host) {
        const e = this.source.host,
          t = this.source.rtc.getRemoteAudioStats(),
          i = this.source.rtc.getRemoteVideoStats();
        return { audio: t[e.uid], video: i[e.uid] };
      }
    }
    replaceNewVideoElement() {
      uY.info("replace video element");
      const e = document.createElement("video");
      (this.options.el = e),
        this.element.replaceWith(e),
        this.unbindVideoEvents(),
        (this.element = P$(this.options)),
        this.bindVideoEvents();
    }
    setupTimeoutTrigger() {
      this.timeout &&
        void 0 === this.timeoutTrigger &&
        (this.timeoutTrigger = window.setTimeout(() => {
          this.playState !== e.MediaPlayState.PAUSED &&
            this.playState !== e.MediaPlayState.STOPPED &&
            (uY.warn(
              "æ­æ¾å è½½æ¶é´è¶è¿é¢æ: ".concat(
                this.timeout,
                "msï¼ä½å°ç»§ç»­å°è¯å è½½"
              )
            ),
            this.safeEmit(
              e.PlayerEvent.ERROR,
              d$(this.source.mode, {
                code: e.PlayerErrorCode.TIMEOUT,
                message: "è§é¢å è½½è¶æ¶: ".concat(
                  this.timeout,
                  "msï¼æ­æ¾å¨å°ç»§ç»­å°è¯å è½½"
                )
              })
            ),
            (this.timeoutTrigger = void 0));
        }, this.timeout));
    }
    clearTimeoutTrigger() {
      this.timeoutTrigger &&
        (window.clearTimeout(this.timeoutTrigger),
        (this.timeoutTrigger = void 0));
    }
  }
  (k$.isHlsSupported = xY), (k$.isRtcSupported = BY);
  const M$ = ["playing", "pause", "waiting", "canplay", "timeupdate"];
  (e.LivePlayer = k$),
    (e.disableLogUpload = function() {
      WM("USE_NEW_LOG") ? KM("UPLOAD_LOG", !1) : EU.disableLogUpload();
    }),
    (e.enableLogUpload = function() {
      WM("USE_NEW_LOG") ? KM("UPLOAD_LOG", !0) : EU.enableLogUpload();
    }),
    (e.enableNewNetworkConfig = function() {
      EU.info("enable new network config"),
        KM("WEBCS_DOMAIN", ["webrtc2-2.ap.sd-rtn.com"]),
        KM("WEBCS_DOMAIN_BACKUP_LIST", ["webrtc2-4.ap.sd-rtn.com"]),
        KM("CDS_AP", ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"]),
        KM("ACCOUNT_REGISTER", [
          "sua-web-2.ap.sd-rtn.com",
          "sua-web-4.ap.sd-rtn.com"
        ]),
        KM("EVENT_REPORT_DOMAIN", "web-2.statscollector.sd-rtn.com"),
        KM("EVENT_REPORT_BACKUP_DOMAIN", "statscollector-1.agora.io"),
        KM("GATEWAY_DOMAINS", ["edge.sd-rtn.com"]);
    }),
    (e.getParameter = XY),
    (e.isHlsSupported = xY),
    (e.isRtcSupported = BY),
    (e.setLogLevel = function(e) {
      return (function(e) {
        EU.setLogLevel(e);
      })(e);
    }),
    (e.setParameter = function(e, t) {
      EU.info("set ".concat(e, " to ").concat(t)), (qY[e] = t);
    }),
    (e.setRTCParameter = function(e, t) {
      KM(e, t);
    });
});
